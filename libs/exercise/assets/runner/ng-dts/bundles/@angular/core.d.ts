declare module '@angular/core' {
// Generated by dts-bundle v0.7.3
// Dependencies for this module:
//   rxjs

/**
  * @license
  * Copyright Google Inc. All Rights Reserved.
  *
  * Use of this source code is governed by an MIT-style license that can be
  * found in the LICENSE file at https://angular.io/license
  */
export * from '@angular/core/--/--/--/--/--/node_modules/@angular/core/public_api';

/**
    * @module
    * @description
    * Entry point for all public APIs of this package.
    */
export * from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/core';

/**
    * @module
    * @description
    * Entry point from which you should import all public core APIs.
    */
export * from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/metadata';
export * from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/version';
export { TypeDecorator } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/util/decorators';
export * from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/di';
export { createPlatform, assertPlatform, destroyPlatform, getPlatform, PlatformRef, ApplicationRef, createPlatformFactory, NgProbeToken } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/application_ref';
export { enableProdMode, isDevMode } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/is_dev_mode';
export { APP_ID, PACKAGE_ROOT_URL, PLATFORM_INITIALIZER, PLATFORM_ID, APP_BOOTSTRAP_LISTENER } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/application_tokens';
export { APP_INITIALIZER, ApplicationInitStatus } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/application_init';
export * from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/zone';
export * from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/render';
export * from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/linker';
export { DebugElement, DebugNode, asNativeElements, getDebugNode, Predicate } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/debug/debug_node';
export { GetTestability, Testability, TestabilityRegistry, setTestabilityGetter } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/testability/testability';
export * from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/change_detection';
export * from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/platform_core_providers';
export { TRANSLATIONS, TRANSLATIONS_FORMAT, LOCALE_ID, MissingTranslationStrategy } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/i18n/tokens';
export { ApplicationModule } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/application_module';
export { wtfCreateScope, wtfLeave, wtfStartTimeRange, wtfEndTimeRange, WtfScopeFn } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/profile/profile';
export { Type } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/type';
export { EventEmitter } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/event_emitter';
export { ErrorHandler } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/error_handler';
export * from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/core_private_export';
export * from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/core_render3_private_export';
export { Sanitizer, SecurityContext } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/sanitization/security';
export * from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/codegen_private_exports';

/**
  * @license
  * Copyright Google Inc. All Rights Reserved.
  *
  * Use of this source code is governed by an MIT-style license that can be
  * found in the LICENSE file at https://angular.io/license
  */
export { ANALYZE_FOR_ENTRY_COMPONENTS, Attribute, ContentChild, ContentChildDecorator, ContentChildren, ContentChildrenDecorator, Query, ViewChild, ViewChildDecorator, ViewChildren, ViewChildrenDecorator } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/metadata/di';
export { Component, ComponentDecorator, Directive, DirectiveDecorator, HostBinding, HostListener, Input, Output, Pipe } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/metadata/directives';
export { AfterContentChecked, AfterContentInit, AfterViewChecked, AfterViewInit, DoCheck, OnChanges, OnDestroy, OnInit } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/metadata/lifecycle_hooks';
export { CUSTOM_ELEMENTS_SCHEMA, DoBootstrap, ModuleWithProviders, NO_ERRORS_SCHEMA, NgModule, SchemaMetadata } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/metadata/ng_module';
export { ViewEncapsulation } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/metadata/view';

/**
    * @description Represents the version of Angular
    *
    * @publicApi
    */
export declare class Version {
        full: string;
        readonly major: string;
        readonly minor: string;
        readonly patch: string;
        constructor(full: string);
}
/**
    * @publicApi
    */
export declare const VERSION: Version;

/**
    * @license
    * Copyright Google Inc. All Rights Reserved.
    *
    * Use of this source code is governed by an MIT-style license that can be
    * found in the LICENSE file at https://angular.io/license
    */
import { Type } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/type';
/**
    * An interface implemented by all Angular type decorators, which allows them to be used as ES7
    * decorators as well as
    * Angular DSL syntax.
    *
    * ES7 syntax:
    *
    * ```
    * @ng.Component({...})
    * class MyClass {...}
    * ```
    *
    * @publicApi
    */
export interface TypeDecorator {
        /**
            * Invoke as ES7 decorator.
            */
        <T extends Type<any>>(type: T): T;
        (target: Object, propertyKey?: string | symbol, parameterIndex?: number): void;
}
export declare const ANNOTATIONS = "__annotations__";
export declare const PARAMETERS = "__parameters__";
export declare const PROP_METADATA = "__prop__metadata__";
/**
    * @suppress {globalThis}
    */
export declare function makeDecorator<T>(name: string, props?: (...args: any[]) => any, parentClass?: any, additionalProcessing?: (type: Type<T>) => void, typeFn?: (type: Type<T>, ...args: any[]) => void): {
        new (...args: any[]): any;
        (...args: any[]): any;
        (...args: any[]): (cls: any) => any;
};
export declare function makeParamDecorator(name: string, props?: (...args: any[]) => any, parentClass?: any): any;
export declare function makePropDecorator(name: string, props?: (...args: any[]) => any, parentClass?: any, additionalProcessing?: (target: any, name: string, ...args: any[]) => void): any;

/**
    * @module
    * @description
    * The `di` module provides dependency injection container services.
    */
export * from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/di/metadata';
export { InjectableType, InjectorType, defineInjectable, defineInjector } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/di/defs';
export { forwardRef, resolveForwardRef, ForwardRefFn } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/di/forward_ref';
export { Injectable, InjectableDecorator, InjectableProvider } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/di/injectable';
export { INJECTOR, Injector } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/di/injector';
export { inject, InjectFlags } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/di/injector_compatibility';
export { ReflectiveInjector } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/di/reflective_injector';
export { StaticProvider, ValueProvider, ConstructorSansProvider, ExistingProvider, FactoryProvider, Provider, TypeProvider, ClassProvider } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/di/provider';
export { createInjector } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/di/r3_injector';
export { ResolvedReflectiveFactory, ResolvedReflectiveProvider } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/di/reflective_provider';
export { ReflectiveKey } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/di/reflective_key';
export { InjectionToken } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/di/injection_token';

/**
    * @license
    * Copyright Google Inc. All Rights Reserved.
    *
    * Use of this source code is governed by an MIT-style license that can be
    * found in the LICENSE file at https://angular.io/license
    */
import { Observable } from 'rxjs';
import { InjectionToken, Injector, StaticProvider } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/di';
import { CompilerOptions } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/linker/compiler';
import { ComponentFactory, ComponentRef } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/linker/component_factory';
import { NgModuleFactory, NgModuleRef } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/linker/ng_module_factory';
import { ViewRef } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/linker/view_ref';
import { Type } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/type';
import { NgZone } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/zone/ng_zone';
export declare function compileNgModuleFactory__POST_R3__<M>(injector: Injector, options: CompilerOptions, moduleType: Type<M>): Promise<NgModuleFactory<M>>;
export declare const ALLOW_MULTIPLE_PLATFORMS: InjectionToken<boolean>;
/**
    * A token for third-party components that can register themselves with NgProbe.
    *
    * @publicApi
    */
export declare class NgProbeToken {
        name: string;
        token: any;
        constructor(name: string, token: any);
}
/**
    * Creates a platform.
    * Platforms have to be eagerly created via this function.
    *
    * @publicApi
    */
export declare function createPlatform(injector: Injector): PlatformRef;
/**
    * Creates a factory for a platform
    *
    * @publicApi
    */
export declare function createPlatformFactory(parentPlatformFactory: ((extraProviders?: StaticProvider[]) => PlatformRef) | null, name: string, providers?: StaticProvider[]): (extraProviders?: StaticProvider[]) => PlatformRef;
/**
    * Checks that there currently is a platform which contains the given token as a provider.
    *
    * @publicApi
    */
export declare function assertPlatform(requiredToken: any): PlatformRef;
/**
    * Destroy the existing platform.
    *
    * @publicApi
    */
export declare function destroyPlatform(): void;
/**
    * Returns the current platform.
    *
    * @publicApi
    */
export declare function getPlatform(): PlatformRef | null;
/**
    * Provides additional options to the bootstraping process.
    *
    *
    */
export interface BootstrapOptions {
        /**
            * Optionally specify which `NgZone` should be used.
            *
            * - Provide your own `NgZone` instance.
            * - `zone.js` - Use default `NgZone` which requires `Zone.js`.
            * - `noop` - Use `NoopNgZone` which does nothing.
            */
        ngZone?: NgZone | 'zone.js' | 'noop';
}
/**
    * The Angular platform is the entry point for Angular on a web page. Each page
    * has exactly one platform, and services (such as reflection) which are common
    * to every Angular application running on the page are bound in its scope.
    *
    * A page's platform is initialized implicitly when a platform is created via a platform factory
    * (e.g. {@link platformBrowser}), or explicitly by calling the {@link createPlatform} function.
    *
    * @publicApi
    */
export declare class PlatformRef {
        /**
            * Creates an instance of an `@NgModule` for the given platform
            * for offline compilation.
            *
            * @usageNotes
            * ### Simple Example
            *
            * ```typescript
            * my_module.ts:
            *
            * @NgModule({
            *   imports: [BrowserModule]
            * })
            * class MyModule {}
            *
            * main.ts:
            * import {MyModuleNgFactory} from './my_module.ngfactory';
            * import {platformBrowser} from '@angular/platform-browser';
            *
            * let moduleRef = platformBrowser().bootstrapModuleFactory(MyModuleNgFactory);
            * ```
            */
        bootstrapModuleFactory<M>(moduleFactory: NgModuleFactory<M>, options?: BootstrapOptions): Promise<NgModuleRef<M>>;
        /**
            * Creates an instance of an `@NgModule` for a given platform using the given runtime compiler.
            *
            * @usageNotes
            * ### Simple Example
            *
            * ```typescript
            * @NgModule({
            *   imports: [BrowserModule]
            * })
            * class MyModule {}
            *
            * let moduleRef = platformBrowser().bootstrapModule(MyModule);
            * ```
            *
            */
        bootstrapModule<M>(moduleType: Type<M>, compilerOptions?: (CompilerOptions & BootstrapOptions) | Array<CompilerOptions & BootstrapOptions>): Promise<NgModuleRef<M>>;
        /**
            * Register a listener to be called when the platform is disposed.
            */
        onDestroy(callback: () => void): void;
        /**
            * Retrieve the platform {@link Injector}, which is the parent injector for
            * every Angular application on the page and provides singleton providers.
            */
        readonly injector: Injector;
        /**
            * Destroy the Angular platform and all Angular applications on the page.
            */
        destroy(): void;
        readonly destroyed: boolean;
}
/**
    * A reference to an Angular application running on a page.
    *
    * @publicApi
    */
export declare class ApplicationRef {
        /**
            * Get a list of component types registered to this application.
            * This list is populated even before the component is created.
            */
        readonly componentTypes: Type<any>[];
        /**
            * Get a list of components registered to this application.
            */
        readonly components: ComponentRef<any>[];
        /**
            * Returns an Observable that indicates when the application is stable or unstable.
            */
        readonly isStable: Observable<boolean>;
        /**
            * Bootstrap a new component at the root level of the application.
            *
            * @usageNotes
            * ### Bootstrap process
            *
            * When bootstrapping a new root component into an application, Angular mounts the
            * specified application component onto DOM elements identified by the componentType's
            * selector and kicks off automatic change detection to finish initializing the component.
            *
            * Optionally, a component can be mounted onto a DOM element that does not match the
            * componentType's selector.
            *
            * ### Example
            * {@example core/ts/platform/platform.ts region='longform'}
            */
        bootstrap<C>(componentOrFactory: ComponentFactory<C> | Type<C>, rootSelectorOrNode?: string | any): ComponentRef<C>;
        /**
            * Invoke this method to explicitly process change detection and its side-effects.
            *
            * In development mode, `tick()` also performs a second change detection cycle to ensure that no
            * further changes are detected. If additional changes are picked up during this second cycle,
            * bindings in the app have side-effects that cannot be resolved in a single change detection
            * pass.
            * In this case, Angular throws an error, since an Angular application can only have one change
            * detection pass during which all change detection must complete.
            */
        tick(): void;
        /**
            * Attaches a view so that it will be dirty checked.
            * The view will be automatically detached when it is destroyed.
            * This will throw if the view is already attached to a ViewContainer.
            */
        attachView(viewRef: ViewRef): void;
        /**
            * Detaches a view from dirty checking again.
            */
        detachView(viewRef: ViewRef): void;
        /**
            * Returns the number of attached views.
            */
        readonly viewCount: number;
}

/**
    * Returns whether Angular is in development mode. After called once,
    * the value is locked and won't change any more.
    *
    * By default, this is true, unless a user calls `enableProdMode` before calling this.
    *
    * @publicApi
    */
export declare function isDevMode(): boolean;
/**
    * Disable Angular's development mode, which turns off assertions and other
    * checks within the framework.
    *
    * One important assertion this disables verifies that a change detection pass
    * does not result in additional changes to any bindings (also known as
    * unidirectional data flow).
    *
    * @publicApi
    */
export declare function enableProdMode(): void;

/**
    * @license
    * Copyright Google Inc. All Rights Reserved.
    *
    * Use of this source code is governed by an MIT-style license that can be
    * found in the LICENSE file at https://angular.io/license
    */
import { InjectionToken } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/di';
import { ComponentRef } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/linker/component_factory';
/**
    * A DI Token representing a unique string id assigned to the application by Angular and used
    * primarily for prefixing application attributes and CSS styles when
    * {@link ViewEncapsulation#Emulated ViewEncapsulation.Emulated} is being used.
    *
    * If you need to avoid randomly generated value to be used as an application id, you can provide
    * a custom value via a DI provider <!-- TODO: provider --> configuring the root {@link Injector}
    * using this token.
    * @publicApi
    */
export declare const APP_ID: InjectionToken<string>;
export declare function _appIdRandomProviderFactory(): string;
/**
    * Providers that will generate a random APP_ID_TOKEN.
    * @publicApi
    */
export declare const APP_ID_RANDOM_PROVIDER: {
        provide: InjectionToken<string>;
        useFactory: typeof _appIdRandomProviderFactory;
        deps: any[];
};
/**
    * A function that will be executed when a platform is initialized.
    * @publicApi
    */
export declare const PLATFORM_INITIALIZER: InjectionToken<(() => void)[]>;
/**
    * A token that indicates an opaque platform id.
    * @publicApi
    */
export declare const PLATFORM_ID: InjectionToken<Object>;
/**
    * All callbacks provided via this token will be called for every component that is bootstrapped.
    * Signature of the callback:
    *
    * `(componentRef: ComponentRef) => void`.
    *
    * @publicApi
    */
export declare const APP_BOOTSTRAP_LISTENER: InjectionToken<((compRef: ComponentRef<any>) => void)[]>;
/**
    * A token which indicates the root directory of the application
    * @publicApi
    */
export declare const PACKAGE_ROOT_URL: InjectionToken<string>;

/**
    * @license
    * Copyright Google Inc. All Rights Reserved.
    *
    * Use of this source code is governed by an MIT-style license that can be
    * found in the LICENSE file at https://angular.io/license
    */
import { InjectionToken } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/di';
/**
    * A function that will be executed when an application is initialized.
    *
    * @publicApi
    */
export declare const APP_INITIALIZER: InjectionToken<(() => void)[]>;
/**
    * A class that reflects the state of running {@link APP_INITIALIZER}s.
    *
    * @publicApi
    */
export declare class ApplicationInitStatus {
        readonly donePromise: Promise<any>;
        readonly done = false;
        constructor(appInits: (() => any)[]);
}

/**
  * @license
  * Copyright Google Inc. All Rights Reserved.
  *
  * Use of this source code is governed by an MIT-style license that can be
  * found in the LICENSE file at https://angular.io/license
  */
export { NgZone, NoopNgZone as ɵNoopNgZone } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/zone/ng_zone';

/**
  * @license
  * Copyright Google Inc. All Rights Reserved.
  *
  * Use of this source code is governed by an MIT-style license that can be
  * found in the LICENSE file at https://angular.io/license
  */
export { RenderComponentType, Renderer, Renderer2, RendererFactory2, RendererStyleFlags2, RendererType2, RootRenderer } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/render/api';

/**
  * @license
  * Copyright Google Inc. All Rights Reserved.
  *
  * Use of this source code is governed by an MIT-style license that can be
  * found in the LICENSE file at https://angular.io/license
  */
export { COMPILER_OPTIONS, Compiler, CompilerFactory, CompilerOptions, ModuleWithComponentFactories } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/linker/compiler';
export { ComponentFactory, ComponentRef } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/linker/component_factory';
export { ComponentFactoryResolver } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/linker/component_factory_resolver';
export { ElementRef } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/linker/element_ref';
export { NgModuleFactory, NgModuleRef } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/linker/ng_module_factory';
export { NgModuleFactoryLoader, getModuleFactory } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/linker/ng_module_factory_loader';
export { QueryList } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/linker/query_list';
export { SystemJsNgModuleLoader, SystemJsNgModuleLoaderConfig } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/linker/system_js_ng_module_factory_loader';
export { TemplateRef } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/linker/template_ref';
export { ViewContainerRef } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/linker/view_container_ref';
export { EmbeddedViewRef, ViewRef } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/linker/view_ref';

/**
    * @license
    * Copyright Google Inc. All Rights Reserved.
    *
    * Use of this source code is governed by an MIT-style license that can be
    * found in the LICENSE file at https://angular.io/license
    */
import { Injector } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/di';
import { DebugContext } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/view/index';
export declare class EventListener {
        name: string;
        callback: Function;
        constructor(name: string, callback: Function);
}
/**
    * @publicApi
    */
export declare class DebugNode {
        nativeNode: any;
        listeners: EventListener[];
        parent: DebugElement | null;
        constructor(nativeNode: any, parent: DebugNode | null, _debugContext: DebugContext);
        readonly injector: Injector;
        readonly componentInstance: any;
        readonly context: any;
        readonly references: {
                [key: string]: any;
        };
        readonly providerTokens: any[];
}
/**
    * @publicApi
    */
export declare class DebugElement extends DebugNode {
        name: string;
        properties: {
                [key: string]: any;
        };
        attributes: {
                [key: string]: string | null;
        };
        classes: {
                [key: string]: boolean;
        };
        styles: {
                [key: string]: string | null;
        };
        childNodes: DebugNode[];
        nativeElement: any;
        constructor(nativeNode: any, parent: any, _debugContext: DebugContext);
        addChild(child: DebugNode): void;
        removeChild(child: DebugNode): void;
        insertChildrenAfter(child: DebugNode, newChildren: DebugNode[]): void;
        insertBefore(refChild: DebugNode, newChild: DebugNode): void;
        query(predicate: Predicate<DebugElement>): DebugElement;
        queryAll(predicate: Predicate<DebugElement>): DebugElement[];
        queryAllNodes(predicate: Predicate<DebugNode>): DebugNode[];
        readonly children: DebugElement[];
        triggerEventHandler(eventName: string, eventObj: any): void;
}
/**
    * @publicApi
    */
export declare function asNativeElements(debugEls: DebugElement[]): any;
/**
    * @publicApi
    */
export declare function getDebugNode(nativeNode: any): DebugNode | null;
export declare function getAllDebugNodes(): DebugNode[];
export declare function indexDebugNode(node: DebugNode): void;
export declare function removeDebugNodeFromIndex(node: DebugNode): void;
/**
    * A boolean-valued function over a value, possibly including context information
    * regarding that value's position in an array.
    *
    * @publicApi
    */
export interface Predicate<T> {
        (value: T): boolean;
}

/**
    * @license
    * Copyright Google Inc. All Rights Reserved.
    *
    * Use of this source code is governed by an MIT-style license that can be
    * found in the LICENSE file at https://angular.io/license
    */
import { NgZone } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/zone/ng_zone';
/**
    * Testability API.
    * `declare` keyword causes tsickle to generate externs, so these methods are
    * not renamed by Closure Compiler.
    * @publicApi
    */
export declare interface PublicTestability {
        isStable(): boolean;
        whenStable(callback: Function, timeout?: number, updateCallback?: Function): void;
        findProviders(using: any, provider: string, exactMatch: boolean): any[];
}
export interface PendingMacrotask {
        source: string;
        creationLocation: Error;
        runCount?: number;
        data: TaskData;
}
export interface TaskData {
        target?: XMLHttpRequest;
        delay?: number;
        isPeriodic?: boolean;
}
export declare type DoneCallback = (didWork: boolean, tasks?: PendingMacrotask[]) => void;
export declare type UpdateCallback = (tasks: PendingMacrotask[]) => boolean;
/**
    * The Testability service provides testing hooks that can be accessed from
    * the browser and by services such as Protractor. Each bootstrapped Angular
    * application on the page will have an instance of Testability.
    * @publicApi
    */
export declare class Testability implements PublicTestability {
        constructor(_ngZone: NgZone);
        /**
            * Increases the number of pending request
            * @deprecated pending requests are now tracked with zones.
            */
        increasePendingRequestCount(): number;
        /**
            * Decreases the number of pending request
            * @deprecated pending requests are now tracked with zones
            */
        decreasePendingRequestCount(): number;
        /**
            * Whether an associated application is stable
            */
        isStable(): boolean;
        /**
            * Wait for the application to be stable with a timeout. If the timeout is reached before that
            * happens, the callback receives a list of the macro tasks that were pending, otherwise null.
            *
            * @param doneCb The callback to invoke when Angular is stable or the timeout expires
            *    whichever comes first.
            * @param timeout Optional. The maximum time to wait for Angular to become stable. If not
            *    specified, whenStable() will wait forever.
            * @param updateCb Optional. If specified, this callback will be invoked whenever the set of
            *    pending macrotasks changes. If this callback returns true doneCb will not be invoked
            *    and no further updates will be issued.
            */
        whenStable(doneCb: Function, timeout?: number, updateCb?: Function): void;
        /**
            * Get the number of pending requests
            * @deprecated pending requests are now tracked with zones
            */
        getPendingRequestCount(): number;
        /**
            * Find providers by name
            * @param using The root element to search from
            * @param provider The name of binding variable
            * @param exactMatch Whether using exactMatch
            */
        findProviders(using: any, provider: string, exactMatch: boolean): any[];
}
/**
    * A global registry of {@link Testability} instances for specific elements.
    * @publicApi
    */
export declare class TestabilityRegistry {
        constructor();
        /**
            * Registers an application with a testability hook so that it can be tracked
            * @param token token of application, root element
            * @param testability Testability hook
            */
        registerApplication(token: any, testability: Testability): void;
        /**
            * Unregisters an application.
            * @param token token of application, root element
            */
        unregisterApplication(token: any): void;
        /**
            * Unregisters all applications
            */
        unregisterAllApplications(): void;
        /**
            * Get a testability hook associated with the application
            * @param elem root element
            */
        getTestability(elem: any): Testability | null;
        /**
            * Get all registered testabilities
            */
        getAllTestabilities(): Testability[];
        /**
            * Get all registered applications(root elements)
            */
        getAllRootElements(): any[];
        /**
            * Find testability of a node in the Tree
            * @param elem node
            * @param findInAncestors whether finding testability in ancestors if testability was not found in
            * current node
            */
        findTestabilityInTree(elem: Node, findInAncestors?: boolean): Testability | null;
}
/**
    * Adapter interface for retrieving the `Testability` service associated for a
    * particular context.
    *
    * @publicApi
    */
export interface GetTestability {
        addToWindow(registry: TestabilityRegistry): void;
        findTestabilityInTree(registry: TestabilityRegistry, elem: any, findInAncestors: boolean): Testability | null;
}
/**
    * Set the {@link GetTestability} implementation used by the Angular testing framework.
    * @publicApi
    */
export declare function setTestabilityGetter(getter: GetTestability): void;

/**
    * @module
    * @description
    * Change detection enables data binding in Angular.
    */
export { ChangeDetectionStrategy, ChangeDetectorRef, CollectionChangeRecord, DefaultIterableDiffer, IterableChangeRecord, IterableChanges, IterableDiffer, IterableDifferFactory, IterableDiffers, KeyValueChangeRecord, KeyValueChanges, KeyValueDiffer, KeyValueDifferFactory, KeyValueDiffers, NgIterable, PipeTransform, SimpleChange, SimpleChanges, TrackByFunction, WrappedValue } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/change_detection/change_detection';

/**
    * @license
    * Copyright Google Inc. All Rights Reserved.
    *
    * Use of this source code is governed by an MIT-style license that can be
    * found in the LICENSE file at https://angular.io/license
    */
import { PlatformRef } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/application_ref';
import { StaticProvider } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/di';
/**
    * This platform has to be included in any other platform
    *
    * @publicApi
    */
export declare const platformCore: (extraProviders?: StaticProvider[] | undefined) => PlatformRef;

/**
    * @license
    * Copyright Google Inc. All Rights Reserved.
    *
    * Use of this source code is governed by an MIT-style license that can be
    * found in the LICENSE file at https://angular.io/license
    */
import { InjectionToken } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/di/injection_token';
/**
    * Provide this token to set the locale of your application.
    * It is used for i18n extraction, by i18n pipes (DatePipe, I18nPluralPipe, CurrencyPipe,
    * DecimalPipe and PercentPipe) and by ICU expressions.
    *
    * See the [i18n guide](guide/i18n#setting-up-locale) for more information.
    *
    * @usageNotes
    * ### Example
    *
    * ```typescript
    * import { LOCALE_ID } from '@angular/core';
    * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';
    * import { AppModule } from './app/app.module';
    *
    * platformBrowserDynamic().bootstrapModule(AppModule, {
    *   providers: [{provide: LOCALE_ID, useValue: 'en-US' }]
    * });
    * ```
    *
    * @publicApi
    */
export declare const LOCALE_ID: InjectionToken<string>;
/**
    * Use this token at bootstrap to provide the content of your translation file (`xtb`,
    * `xlf` or `xlf2`) when you want to translate your application in another language.
    *
    * See the [i18n guide](guide/i18n#merge) for more information.
    *
    * @usageNotes
    * ### Example
    *
    * ```typescript
    * import { TRANSLATIONS } from '@angular/core';
    * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';
    * import { AppModule } from './app/app.module';
    *
    * // content of your translation file
    * const translations = '....';
    *
    * platformBrowserDynamic().bootstrapModule(AppModule, {
    *   providers: [{provide: TRANSLATIONS, useValue: translations }]
    * });
    * ```
    *
    * @publicApi
    */
export declare const TRANSLATIONS: InjectionToken<string>;
/**
    * Provide this token at bootstrap to set the format of your {@link TRANSLATIONS}: `xtb`,
    * `xlf` or `xlf2`.
    *
    * See the [i18n guide](guide/i18n#merge) for more information.
    *
    * @usageNotes
    * ### Example
    *
    * ```typescript
    * import { TRANSLATIONS_FORMAT } from '@angular/core';
    * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';
    * import { AppModule } from './app/app.module';
    *
    * platformBrowserDynamic().bootstrapModule(AppModule, {
    *   providers: [{provide: TRANSLATIONS_FORMAT, useValue: 'xlf' }]
    * });
    * ```
    *
    * @publicApi
    */
export declare const TRANSLATIONS_FORMAT: InjectionToken<string>;
/**
    * Use this enum at bootstrap as an option of `bootstrapModule` to define the strategy
    * that the compiler should use in case of missing translations:
    * - Error: throw if you have missing translations.
    * - Warning (default): show a warning in the console and/or shell.
    * - Ignore: do nothing.
    *
    * See the [i18n guide](guide/i18n#missing-translation) for more information.
    *
    * @usageNotes
    * ### Example
    * ```typescript
    * import { MissingTranslationStrategy } from '@angular/core';
    * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';
    * import { AppModule } from './app/app.module';
    *
    * platformBrowserDynamic().bootstrapModule(AppModule, {
    *   missingTranslation: MissingTranslationStrategy.Error
    * });
    * ```
    *
    * @publicApi
    */
export declare enum MissingTranslationStrategy {
        Error = 0,
        Warning = 1,
        Ignore = 2
}

/**
    * @license
    * Copyright Google Inc. All Rights Reserved.
    *
    * Use of this source code is governed by an MIT-style license that can be
    * found in the LICENSE file at https://angular.io/license
    */
import { ApplicationRef } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/application_ref';
import { IterableDiffers, KeyValueDiffers } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/change_detection/change_detection';
import { StaticProvider } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/di';
export declare function _iterableDiffersFactory(): IterableDiffers;
export declare function _keyValueDiffersFactory(): KeyValueDiffers;
export declare function _localeFactory(locale?: string): string;
/**
    * A built-in [dependency injection token](guide/glossary#di-token)
    * that is used to configure the root injector for bootstrapping.
    */
export declare const APPLICATION_MODULE_PROVIDERS: StaticProvider[];
/**
    * Configures the root injector for an app with
    * providers of `@angular/core` dependencies that `ApplicationRef` needs
    * to bootstrap components.
    *
    * Re-exported by `BrowserModule`, which is included automatically in the root
    * `AppModule` when you create a new app with the CLI `new` command.
    *
    * @publicApi
    */
export declare class ApplicationModule {
        constructor(appRef: ApplicationRef);
}

/**
    * @license
    * Copyright Google Inc. All Rights Reserved.
    *
    * Use of this source code is governed by an MIT-style license that can be
    * found in the LICENSE file at https://angular.io/license
    */
import { WtfScopeFn } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/profile/wtf_impl';
export { WtfScopeFn } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/profile/wtf_impl';
/**
    * True if WTF is enabled.
    */
export declare const wtfEnabled: boolean;
/**
    * Create trace scope.
    *
    * Scopes must be strictly nested and are analogous to stack frames, but
    * do not have to follow the stack frames. Instead it is recommended that they follow logical
    * nesting. You may want to use
    * [Event
    * Signatures](http://google.github.io/tracing-framework/instrumenting-code.html#custom-events)
    * as they are defined in WTF.
    *
    * Used to mark scope entry. The return value is used to leave the scope.
    *
    *     var myScope = wtfCreateScope('MyClass#myMethod(ascii someVal)');
    *
    *     someMethod() {
    *        var s = myScope('Foo'); // 'Foo' gets stored in tracing UI
    *        // DO SOME WORK HERE
    *        return wtfLeave(s, 123); // Return value 123
    *     }
    *
    * Note, adding try-finally block around the work to ensure that `wtfLeave` gets called can
    * negatively impact the performance of your application. For this reason we recommend that
    * you don't add them to ensure that `wtfLeave` gets called. In production `wtfLeave` is a noop and
    * so try-finally block has no value. When debugging perf issues, skipping `wtfLeave`, do to
    * exception, will produce incorrect trace, but presence of exception signifies logic error which
    * needs to be fixed before the app should be profiled. Add try-finally only when you expect that
    * an exception is expected during normal execution while profiling.
    *
    * @publicApi
    */
export declare const wtfCreateScope: (signature: string, flags?: any) => WtfScopeFn;
/**
    * Used to mark end of Scope.
    *
    * - `scope` to end.
    * - `returnValue` (optional) to be passed to the WTF.
    *
    * Returns the `returnValue for easy chaining.
    * @publicApi
    */
export declare const wtfLeave: <T>(scope: any, returnValue?: T) => T;
/**
    * Used to mark Async start. Async are similar to scope but they don't have to be strictly nested.
    * The return value is used in the call to [endAsync]. Async ranges only work if WTF has been
    * enabled.
    *
    *     someMethod() {
    *        var s = wtfStartTimeRange('HTTP:GET', 'some.url');
    *        var future = new Future.delay(5).then((_) {
    *          wtfEndTimeRange(s);
    *        });
    *     }
    * @publicApi
    */
export declare const wtfStartTimeRange: (rangeType: string, action: string) => any;
/**
    * Ends a async time range operation.
    * [range] is the return value from [wtfStartTimeRange] Async ranges only work if WTF has been
    * enabled.
    * @publicApi
    */
export declare const wtfEndTimeRange: (range: any) => void;

/**
    * @description
    *
    * Represents a type that a Component or other object is instances of.
    *
    * An example of a `Type` is `MyCustomComponent` class, which in JavaScript is be represented by
    * the `MyCustomComponent` constructor function.
    *
    * @publicApi
    */
export declare const Type: FunctionConstructor;
export declare function isType(v: any): v is Type<any>;
export interface Type<T> extends Function {
        new (...args: any[]): T;
}
export declare type Mutable<T extends {
        [x: string]: any;
}, K extends string> = {
        [P in K]: T[P];
};

/**
    * @license
    * Copyright Google Inc. All Rights Reserved.
    *
    * Use of this source code is governed by an MIT-style license that can be
    * found in the LICENSE file at https://angular.io/license
    */
import { Subject } from 'rxjs';
/**
    * Use in directives and components to emit custom events synchronously
    * or asynchronously, and register handlers for those events by subscribing
    * to an instance.
    *
    * @usageNotes
    *
    * In the following example, a component defines two output properties
    * that create event emitters. When the title is clicked, the emitter
    * emits an open or close event to toggle the current visibility state.
    *
    * ```
    * @Component({
    *   selector: 'zippy',
    *   template: `
    *   <div class="zippy">
    *     <div (click)="toggle()">Toggle</div>
    *     <div [hidden]="!visible">
    *       <ng-content></ng-content>
    *     </div>
    *  </div>`})
    * export class Zippy {
    *   visible: boolean = true;
    *   @Output() open: EventEmitter<any> = new EventEmitter();
    *   @Output() close: EventEmitter<any> = new EventEmitter();
    *
    *   toggle() {
    *     this.visible = !this.visible;
    *     if (this.visible) {
    *       this.open.emit(null);
    *     } else {
    *       this.close.emit(null);
    *     }
    *   }
    * }
    * ```
    *
    * Access the event object with the `$event` argument passed to the output event
    * handler:
    *
    * ```
    * <zippy (open)="onOpen($event)" (close)="onClose($event)"></zippy>
    * ```
    *
    * ### Notes
    *
    * Uses Rx.Observable but provides an adapter to make it work as specified here:
    * https://github.com/jhusain/observable-spec
    *
    * Once a reference implementation of the spec is available, switch to it.
    *
    * @publicApi
    */
export declare class EventEmitter<T> extends Subject<T> {
        /**
            * Internal
            */
        __isAsync: boolean;
        /**
            * Creates an instance of this class that can
            * deliver events synchronously or asynchronously.
            *
            * @param isAsync When true, deliver events asynchronously.
            *
            */
        constructor(isAsync?: boolean);
        /**
            * Emits an event containing a given value.
            * @param value The value to emit.
            */
        emit(value?: T): void;
        /**
            * Registers handlers for events emitted by this instance.
            * @param generatorOrNext When supplied, a custom handler for emitted events.
            * @param error When supplied, a custom handler for an error notification
            * from this emitter.
            * @param complete When supplied, a custom handler for a completion
            * notification from this emitter.
            */
        subscribe(generatorOrNext?: any, error?: any, complete?: any): any;
}

/**
    * Provides a hook for centralized exception handling.
    *
    * The default implementation of `ErrorHandler` prints error messages to the `console`. To
    * intercept error handling, write a custom exception handler that replaces this default as
    * appropriate for your app.
    *
    * @usageNotes
    * ### Example
    *
    * ```
    * class MyErrorHandler implements ErrorHandler {
    *   handleError(error) {
    *     // do something with the exception
    *   }
    * }
    *
    * @NgModule({
    *   providers: [{provide: ErrorHandler, useClass: MyErrorHandler}]
    * })
    * class MyModule {}
    * ```
    *
    * @publicApi
    */
export declare class ErrorHandler {
        handleError(error: any): void;
}
export declare function wrappedError(message: string, originalError: any): Error;

/**
  * @license
  * Copyright Google Inc. All Rights Reserved.
  *
  * Use of this source code is governed by an MIT-style license that can be
  * found in the LICENSE file at https://angular.io/license
  */
export { ALLOW_MULTIPLE_PLATFORMS as ɵALLOW_MULTIPLE_PLATFORMS } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/application_ref';
export { APP_ID_RANDOM_PROVIDER as ɵAPP_ID_RANDOM_PROVIDER } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/application_tokens';
export { defaultIterableDiffers as ɵdefaultIterableDiffers, defaultKeyValueDiffers as ɵdefaultKeyValueDiffers } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/change_detection/change_detection';
export { devModeEqual as ɵdevModeEqual } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/change_detection/change_detection_util';
export { isListLikeIterable as ɵisListLikeIterable } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/change_detection/change_detection_util';
export { ChangeDetectorStatus as ɵChangeDetectorStatus, isDefaultChangeDetectionStrategy as ɵisDefaultChangeDetectionStrategy } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/change_detection/constants';
export { Console as ɵConsole } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/console';
export { InjectableDef as ɵInjectableDef, InjectorDef as ɵInjectorDef, getInjectableDef as ɵgetInjectableDef } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/di/defs';
export { inject as ɵinject, setCurrentInjector as ɵsetCurrentInjector } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/di/injector_compatibility';
export { APP_ROOT as ɵAPP_ROOT } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/di/scope';
export { ivyEnabled as ɵivyEnabled } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/ivy_switch';
export { ComponentFactory as ɵComponentFactory } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/linker/component_factory';
export { CodegenComponentFactoryResolver as ɵCodegenComponentFactoryResolver } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/linker/component_factory_resolver';
export { resolveComponentResources as ɵresolveComponentResources } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/metadata/resource_loading';
export { ReflectionCapabilities as ɵReflectionCapabilities } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/reflection/reflection_capabilities';
export { GetterFn as ɵGetterFn, MethodFn as ɵMethodFn, SetterFn as ɵSetterFn } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/reflection/types';
export { DirectRenderer as ɵDirectRenderer, RenderDebugInfo as ɵRenderDebugInfo } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/render/api';
export { _sanitizeHtml as ɵ_sanitizeHtml } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/sanitization/html_sanitizer';
export { _sanitizeStyle as ɵ_sanitizeStyle } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/sanitization/style_sanitizer';
export { _sanitizeUrl as ɵ_sanitizeUrl } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/sanitization/url_sanitizer';
export { global as ɵglobal, looseIdentical as ɵlooseIdentical, stringify as ɵstringify } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/util';
export { makeDecorator as ɵmakeDecorator } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/util/decorators';
export { isObservable as ɵisObservable, isPromise as ɵisPromise } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/util/lang';
export { clearOverrides as ɵclearOverrides, initServicesIfNeeded as ɵinitServicesIfNeeded, overrideComponentView as ɵoverrideComponentView, overrideProvider as ɵoverrideProvider } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/view/index';
export { NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR as ɵNOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/view/provider';

/**
  * @license
  * Copyright Google Inc. All Rights Reserved.
  *
  * Use of this source code is governed by an MIT-style license that can be
  * found in the LICENSE file at https://angular.io/license
  */
export { defineBase as ɵdefineBase, defineComponent as ɵdefineComponent, defineDirective as ɵdefineDirective, definePipe as ɵdefinePipe, defineNgModule as ɵdefineNgModule, detectChanges as ɵdetectChanges, renderComponent as ɵrenderComponent, ComponentType as ɵComponentType, ComponentFactory as ɵRender3ComponentFactory, ComponentRef as ɵRender3ComponentRef, DirectiveType as ɵDirectiveType, RenderFlags as ɵRenderFlags, directiveInject as ɵdirectiveInject, injectAttribute as ɵinjectAttribute, getFactoryOf as ɵgetFactoryOf, getInheritedFactory as ɵgetInheritedFactory, templateRefExtractor as ɵtemplateRefExtractor, ProvidersFeature as ɵProvidersFeature, InheritDefinitionFeature as ɵInheritDefinitionFeature, NgOnChangesFeature as ɵNgOnChangesFeature, LifecycleHooksFeature as ɵLifecycleHooksFeature, NgModuleType as ɵNgModuleType, NgModuleRef as ɵRender3NgModuleRef, CssSelectorList as ɵCssSelectorList, markDirty as ɵmarkDirty, NgModuleFactory as ɵNgModuleFactory, NO_CHANGE as ɵNO_CHANGE, container as ɵcontainer, nextContext as ɵnextContext, elementStart as ɵelementStart, namespaceHTML as ɵnamespaceHTML, namespaceMathML as ɵnamespaceMathML, namespaceSVG as ɵnamespaceSVG, element as ɵelement, listener as ɵlistener, text as ɵtext, embeddedViewStart as ɵembeddedViewStart, query as ɵquery, registerContentQuery as ɵregisterContentQuery, projection as ɵprojection, bind as ɵbind, interpolation1 as ɵinterpolation1, interpolation2 as ɵinterpolation2, interpolation3 as ɵinterpolation3, interpolation4 as ɵinterpolation4, interpolation5 as ɵinterpolation5, interpolation6 as ɵinterpolation6, interpolation7 as ɵinterpolation7, interpolation8 as ɵinterpolation8, interpolationV as ɵinterpolationV, pipeBind1 as ɵpipeBind1, pipeBind2 as ɵpipeBind2, pipeBind3 as ɵpipeBind3, pipeBind4 as ɵpipeBind4, pipeBindV as ɵpipeBindV, pureFunction0 as ɵpureFunction0, pureFunction1 as ɵpureFunction1, pureFunction2 as ɵpureFunction2, pureFunction3 as ɵpureFunction3, pureFunction4 as ɵpureFunction4, pureFunction5 as ɵpureFunction5, pureFunction6 as ɵpureFunction6, pureFunction7 as ɵpureFunction7, pureFunction8 as ɵpureFunction8, pureFunctionV as ɵpureFunctionV, getCurrentView as ɵgetCurrentView, restoreView as ɵrestoreView, containerRefreshStart as ɵcontainerRefreshStart, containerRefreshEnd as ɵcontainerRefreshEnd, queryRefresh as ɵqueryRefresh, loadQueryList as ɵloadQueryList, elementEnd as ɵelementEnd, elementProperty as ɵelementProperty, projectionDef as ɵprojectionDef, reference as ɵreference, enableBindings as ɵenableBindings, disableBindings as ɵdisableBindings, elementAttribute as ɵelementAttribute, elementContainerStart as ɵelementContainerStart, elementContainerEnd as ɵelementContainerEnd, elementStyling as ɵelementStyling, elementStylingMap as ɵelementStylingMap, elementStyleProp as ɵelementStyleProp, elementStylingApply as ɵelementStylingApply, elementClassProp as ɵelementClassProp, textBinding as ɵtextBinding, template as ɵtemplate, embeddedViewEnd as ɵembeddedViewEnd, store as ɵstore, load as ɵload, pipe as ɵpipe, BaseDef as ɵBaseDef, ComponentDef as ɵComponentDef, ComponentDefWithMeta as ɵComponentDefWithMeta, DirectiveDef as ɵDirectiveDef, DirectiveDefWithMeta as ɵDirectiveDefWithMeta, PipeDef as ɵPipeDef, PipeDefWithMeta as ɵPipeDefWithMeta, whenRendered as ɵwhenRendered, i18n as ɵi18n, i18nAttributes as ɵi18nAttributes, i18nExp as ɵi18nExp, i18nStart as ɵi18nStart, i18nEnd as ɵi18nEnd, i18nApply as ɵi18nApply, i18nPostprocess as ɵi18nPostprocess, WRAP_RENDERER_FACTORY2 as ɵWRAP_RENDERER_FACTORY2, setClassMetadata as ɵsetClassMetadata, } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/render3/index';
export { Render3DebugRendererFactory2 as ɵRender3DebugRendererFactory2 } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/render3/debug';
export { compileComponent as ɵcompileComponent, compileDirective as ɵcompileDirective, } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/render3/jit/directive';
export { compileNgModule as ɵcompileNgModule, compileNgModuleDefs as ɵcompileNgModuleDefs, patchComponentDefWithScope as ɵpatchComponentDefWithScope, } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/render3/jit/module';
export { compilePipe as ɵcompilePipe, } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/render3/jit/pipe';
export { NgModuleDef as ɵNgModuleDef, NgModuleDefWithMeta as ɵNgModuleDefWithMeta, NgModuleTransitiveScopes as ɵNgModuleTransitiveScopes, } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/metadata/ng_module';
export { sanitizeHtml as ɵsanitizeHtml, sanitizeStyle as ɵsanitizeStyle, sanitizeUrl as ɵsanitizeUrl, sanitizeResourceUrl as ɵsanitizeResourceUrl, } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/sanitization/sanitization';
export { bypassSanitizationTrustHtml as ɵbypassSanitizationTrustHtml, bypassSanitizationTrustStyle as ɵbypassSanitizationTrustStyle, bypassSanitizationTrustScript as ɵbypassSanitizationTrustScript, bypassSanitizationTrustUrl as ɵbypassSanitizationTrustUrl, bypassSanitizationTrustResourceUrl as ɵbypassSanitizationTrustResourceUrl, } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/sanitization/bypass';
export { getContext as ɵgetContext } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/render3/context_discovery';
export { Player as ɵPlayer, PlayerFactory as ɵPlayerFactory, PlayState as ɵPlayState, PlayerHandler as ɵPlayerHandler, } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/render3/interfaces/player';
export { LContext as ɵLContext, } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/render3/interfaces/context';
export { bindPlayerFactory as ɵbindPlayerFactory, } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/render3/styling/player_factory';
export { addPlayer as ɵaddPlayer, getPlayers as ɵgetPlayers, } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/render3/players';
export { compileNgModuleFactory__POST_R3__ as ɵcompileNgModuleFactory__POST_R3__ } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/application_ref';
export { SWITCH_COMPILE_COMPONENT__POST_R3__ as ɵSWITCH_COMPILE_COMPONENT__POST_R3__, SWITCH_COMPILE_DIRECTIVE__POST_R3__ as ɵSWITCH_COMPILE_DIRECTIVE__POST_R3__, SWITCH_COMPILE_PIPE__POST_R3__ as ɵSWITCH_COMPILE_PIPE__POST_R3__, } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/metadata/directives';
export { SWITCH_COMPILE_NGMODULE__POST_R3__ as ɵSWITCH_COMPILE_NGMODULE__POST_R3__, } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/metadata/ng_module';
export { SWITCH_COMPILE_INJECTABLE__POST_R3__ as ɵSWITCH_COMPILE_INJECTABLE__POST_R3__, } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/di/injectable';
export { SWITCH_IVY_ENABLED__POST_R3__ as ɵSWITCH_IVY_ENABLED__POST_R3__, } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/ivy_switch';
export { SWITCH_CHANGE_DETECTOR_REF_FACTORY__POST_R3__ as ɵSWITCH_CHANGE_DETECTOR_REF_FACTORY__POST_R3__, } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/change_detection/change_detector_ref';
export { SWITCH_ELEMENT_REF_FACTORY__POST_R3__ as ɵSWITCH_ELEMENT_REF_FACTORY__POST_R3__, } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/linker/element_ref';
export { SWITCH_TEMPLATE_REF_FACTORY__POST_R3__ as ɵSWITCH_TEMPLATE_REF_FACTORY__POST_R3__, } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/linker/template_ref';
export { SWITCH_VIEW_CONTAINER_REF_FACTORY__POST_R3__ as ɵSWITCH_VIEW_CONTAINER_REF_FACTORY__POST_R3__, } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/linker/view_container_ref';
export { SWITCH_RENDERER2_FACTORY__POST_R3__ as ɵSWITCH_RENDERER2_FACTORY__POST_R3__, } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/render/api';
export { publishGlobalUtil as ɵpublishGlobalUtil, publishDefaultGlobalUtils as ɵpublishDefaultGlobalUtils } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/render3/global_utils';
export { SWITCH_INJECTOR_FACTORY__POST_R3__ as ɵSWITCH_INJECTOR_FACTORY__POST_R3__, } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/di/injector';

/**
    * A SecurityContext marks a location that has dangerous security implications, e.g. a DOM property
    * like `innerHTML` that could cause Cross Site Scripting (XSS) security bugs when improperly
    * handled.
    *
    * See DomSanitizer for more details on security in Angular applications.
    *
    * @publicApi
    */
export declare enum SecurityContext {
        NONE = 0,
        HTML = 1,
        STYLE = 2,
        SCRIPT = 3,
        URL = 4,
        RESOURCE_URL = 5
}
/**
    * Sanitizer is used by the views to sanitize potentially dangerous values.
    *
    * @publicApi
    */
export declare abstract class Sanitizer {
        abstract sanitize(context: SecurityContext, value: {} | string | null): string | null;
}

/**
  * @license
  * Copyright Google Inc. All Rights Reserved.
  *
  * Use of this source code is governed by an MIT-style license that can be
  * found in the LICENSE file at https://angular.io/license
  */
export { CodegenComponentFactoryResolver as ɵCodegenComponentFactoryResolver } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/linker/component_factory_resolver';
export { registerModuleFactory as ɵregisterModuleFactory } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/linker/ng_module_factory_loader';
export { ArgumentType as ɵArgumentType, BindingFlags as ɵBindingFlags, DepFlags as ɵDepFlags, EMPTY_ARRAY as ɵEMPTY_ARRAY, EMPTY_MAP as ɵEMPTY_MAP, NodeFlags as ɵNodeFlags, QueryBindingType as ɵQueryBindingType, QueryValueType as ɵQueryValueType, ViewDefinition as ɵViewDefinition, ViewFlags as ɵViewFlags, anchorDef as ɵand, createComponentFactory as ɵccf, createNgModuleFactory as ɵcmf, createRendererType2 as ɵcrt, directiveDef as ɵdid, elementDef as ɵeld, elementEventFullName as ɵelementEventFullName, getComponentViewDefinitionFactory as ɵgetComponentViewDefinitionFactory, inlineInterpolate as ɵinlineInterpolate, interpolate as ɵinterpolate, moduleDef as ɵmod, moduleProvideDef as ɵmpd, ngContentDef as ɵncd, nodeValue as ɵnov, pipeDef as ɵpid, providerDef as ɵprd, pureArrayDef as ɵpad, pureObjectDef as ɵpod, purePipeDef as ɵppd, queryDef as ɵqud, textDef as ɵted, unwrapValue as ɵunv, viewDef as ɵvid } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/view/index';

/**
    * @license
    * Copyright Google Inc. All Rights Reserved.
    *
    * Use of this source code is governed by an MIT-style license that can be
    * found in the LICENSE file at https://angular.io/license
    */
import { InjectionToken } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/di/injection_token';
import { Type } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/type';
/**
    * This token can be used to create a virtual provider that will populate the
    * `entryComponents` fields of components and ng modules based on its `useValue`.
    * All components that are referenced in the `useValue` value (either directly
    * or in a nested array or map) will be added to the `entryComponents` property.
    *
    * @usageNotes
    * ### Example
    * The following example shows how the router can populate the `entryComponents`
    * field of an NgModule based on the router configuration which refers
    * to components.
    *
    * ```typescript
    * // helper function inside the router
    * function provideRoutes(routes) {
    *   return [
    *     {provide: ROUTES, useValue: routes},
    *     {provide: ANALYZE_FOR_ENTRY_COMPONENTS, useValue: routes, multi: true}
    *   ];
    * }
    *
    * // user code
    * let routes = [
    *   {path: '/root', component: RootComp},
    *   {path: '/teams', component: TeamsComp}
    * ];
    *
    * @NgModule({
    *   providers: [provideRoutes(routes)]
    * })
    * class ModuleWithRoutes {}
    * ```
    *
    * @publicApi
    */
export declare const ANALYZE_FOR_ENTRY_COMPONENTS: InjectionToken<any>;
/**
    * Type of the Attribute decorator / constructor function.
    *
    *
    */
export interface AttributeDecorator {
        /**
            * Specifies that a constant attribute value should be injected.
            *
            * The directive can inject constant string literals of host element attributes.
            *
            * @usageNotes
            * ### Example
            *
            * Suppose we have an `<input>` element and want to know its `type`.
            *
            * ```html
            * <input type="text">
            * ```
            *
            * A decorator can inject string literal `text` like so:
            *
            * {@example core/ts/metadata/metadata.ts region='attributeMetadata'}
            *
            * ### Example as TypeScript Decorator
            *
            * {@example core/ts/metadata/metadata.ts region='attributeFactory'}
            *
            * ### Example as ES5 annotation
            *
            * ```
            * var MyComponent = function(title) {
            *   ...
            * };
            *
            * MyComponent.annotations = [
            *   new ng.Component({...})
            * ]
            * MyComponent.parameters = [
            *   [new ng.Attribute('title')]
            * ]
            * ```
            *
            *
            */
        (name: string): any;
        new (name: string): Attribute;
}
/**
    * Type of the Attribute metadata.
    */
export interface Attribute {
        attributeName?: string;
}
/**
    * Attribute decorator and metadata.
    *
    * @Annotation
    * @publicApi
    */
export declare const Attribute: AttributeDecorator;
/**
    * Type of the Query metadata.
    */
export interface Query {
        descendants: boolean;
        first: boolean;
        read: any;
        isViewQuery: boolean;
        selector: any;
}
/**
    * Base class for query metadata.
    *
    * @see `ContentChildren`.
    * @see `ContentChild`.
    * @see `ViewChildren`.
    * @see `ViewChild`.
    *
    * @publicApi
    */
export declare abstract class Query {
}
/**
    * Type of the ContentChildren decorator / constructor function.
    *
    * @see `ContentChildren`.
    * @publicApi
    */
export interface ContentChildrenDecorator {
        /**
            * Configures a content query.
            *
            * You can use ContentChildren to get the `QueryList` of elements or directives from the
            * content DOM. Any time a child element is added, removed, or moved, the query list will be
            * updated, and the changes observable of the query list will emit a new value.
            *
            * Content queries are set before the `ngAfterContentInit` callback is called.
            *
            * **Metadata Properties**:
            *
            * * **selector** - the directive type or the name used for querying.
            * * **descendants** - include only direct children or all descendants.
            * * **read** - read a different token from the queried elements.
            *
            * @usageNotes
            * ### Basic Example
            *
            * Here is a simple demonstration of how the `ContentChildren` decorator can be used.
            *
            * {@example core/di/ts/contentChildren/content_children_howto.ts region='HowTo'}
            *
            * ### Tab-pane Example
            *
            * Here is a slightly more realistic example that shows how `ContentChildren` decorators
            * can be used to implement a tab pane component.
            *
            * {@example core/di/ts/contentChildren/content_children_example.ts region='Component'}
            *
            * @Annotation
            */
        (selector: Type<any> | Function | string, opts?: {
                descendants?: boolean;
                read?: any;
        }): any;
        new (selector: Type<any> | Function | string, opts?: {
                descendants?: boolean;
                read?: any;
        }): Query;
}
/**
    * Type of the ContentChildren metadata.
    *
    *
    * @Annotation
    */
export declare type ContentChildren = Query;
/**
    * ContentChildren decorator and metadata.
    *
    *
    * @Annotation
    * @publicApi
    */
export declare const ContentChildren: ContentChildrenDecorator;
/**
    * Type of the ContentChild decorator / constructor function.
    *
    * @publicApi
    */
export interface ContentChildDecorator {
        /**
            * Configures a content query.
            *
            * You can use ContentChild to get the first element or the directive matching the selector from
            * the content DOM. If the content DOM changes, and a new child matches the selector,
            * the property will be updated.
            *
            * Content queries are set before the `ngAfterContentInit` callback is called.
            *
            * **Metadata Properties**:
            *
            * * **selector** - the directive type or the name used for querying.
            * * **read** - read a different token from the queried element.
            *
            * @usageNotes
            * ### Example
            *
            * {@example core/di/ts/contentChild/content_child_howto.ts region='HowTo'}
            *
            * ### Example
            *
            * {@example core/di/ts/contentChild/content_child_example.ts region='Component'}
            *
            * @Annotation
            */
        (selector: Type<any> | Function | string, opts?: {
                read?: any;
        }): any;
        new (selector: Type<any> | Function | string, opts?: {
                read?: any;
        }): ContentChild;
}
/**
    * Type of the ContentChild metadata.
    *
    * @see `ContentChild`.
    *
    *
    */
export declare type ContentChild = Query;
/**
    * ContentChild decorator and metadata.
    *
    *
    * @Annotation
    * @publicApi
    */
export declare const ContentChild: ContentChildDecorator;
/**
    * Type of the ViewChildren decorator / constructor function.
    *
    * @see `ViewChildren`.
    *
    * @publicApi
    */
export interface ViewChildrenDecorator {
        /**
            * Configures a view query.
            *
            * You can use ViewChildren to get the `QueryList` of elements or directives from the
            * view DOM. Any time a child element is added, removed, or moved, the query list will be updated,
            * and the changes observable of the query list will emit a new value.
            *
            * View queries are set before the `ngAfterViewInit` callback is called.
            *
            * **Metadata Properties**:
            *
            * * **selector** - the directive type or the name used for querying.
            * * **read** - read a different token from the queried elements.
            *
            * @usageNotes
            *
            * ### Example
            *
            * {@example core/di/ts/viewChildren/view_children_howto.ts region='HowTo'}
            *
            * ### Example
            *
            * {@example core/di/ts/viewChildren/view_children_example.ts region='Component'}
            *
            * @Annotation
            */
        (selector: Type<any> | Function | string, opts?: {
                read?: any;
        }): any;
        new (selector: Type<any> | Function | string, opts?: {
                read?: any;
        }): ViewChildren;
}
/**
    * Type of the ViewChildren metadata.
    */
export declare type ViewChildren = Query;
/**
    * ViewChildren decorator and metadata.
    *
    * @Annotation
    * @publicApi
    */
export declare const ViewChildren: ViewChildrenDecorator;
/**
    * Type of the ViewChild decorator / constructor function.
    *
    * @see `ViewChild`.
    * @publicApi
    */
export interface ViewChildDecorator {
        /**
            * @description
            * Property decorator that configures a view query.
            * The change detector looks for the first element or the directive matching the selector
            * in the view DOM. If the view DOM changes, and a new child matches the selector,
            * the property is updated.
            *
            * View queries are set before the `ngAfterViewInit` callback is called.
            *
            * **Metadata Properties**:
            *
            * * **selector** - the directive type or the name used for querying.
            * * **read** - read a different token from the queried elements.
            *
            * Supported selectors include:
            *   * any class with the `@Component` or `@Directive` decorator
            *   * a template reference variable as a string (e.g. query `<my-component #cmp></my-component>
            * with `@ViewChild('cmp')`)
            *   * any provider defined in the child component tree of the current component (e.g.
            * `@ViewChild(SomeService) someService: SomeService`)
            *   * any provider defined through a string token (e.g. `@ViewChild('someToken') someTokenVal:
            * any`)
            *   * a `TemplateRef` (e.g. query `<ng-template></ng-template>` with `@ViewChild(TemplateRef)
            * template;`)
            *
            * @usageNotes
            *
            * {@example core/di/ts/viewChild/view_child_example.ts region='Component'}
            *
            * ### Example
            *
            * {@example core/di/ts/viewChild/view_child_howto.ts region='HowTo'}
            *
            * ### Example
            *
            * {@example core/di/ts/viewChild/view_child_example.ts region='Component'}
            *
            * @Annotation
            */
        (selector: Type<any> | Function | string, opts?: {
                read?: any;
        }): any;
        new (selector: Type<any> | Function | string, opts?: {
                read?: any;
        }): ViewChild;
}
/**
    * Type of the ViewChild metadata.
    */
export declare type ViewChild = Query;
/**
    * ViewChild decorator and metadata.
    *
    * @Annotation
    * @publicApi
    */
export declare const ViewChild: ViewChildDecorator;

/**
    * @license
    * Copyright Google Inc. All Rights Reserved.
    *
    * Use of this source code is governed by an MIT-style license that can be
    * found in the LICENSE file at https://angular.io/license
    */
import { ChangeDetectionStrategy } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/change_detection/constants';
import { Provider } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/di';
import { compileComponent as render3CompileComponent, compileDirective as render3CompileDirective } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/render3/jit/directive';
import { compilePipe as render3CompilePipe } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/render3/jit/pipe';
import { Type } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/type';
import { TypeDecorator } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/util/decorators';
import { ViewEncapsulation } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/metadata/view';
/**
    * Type of the Directive decorator / constructor function.
    * @publicApi
    */
export interface DirectiveDecorator {
        /**
            * Marks a class as an Angular directive. You can define your own
            * directives to attach custom behavior to elements in the DOM.
            * The options provide configuration metadata that determines
            * how the directive should be processed, instantiated and used at
            * runtime.
            *
            * Directive classes, like component classes, can implement
            * [life-cycle hooks](guide/lifecycle-hooks) to influence their configuration and behavior.
            *
            *
            * @usageNotes
            * To define a directive, mark the class with the decorator and provide metadata.
            *
            * ```
            * import {Directive} from '@angular/core';
            *
            * @Directive({
            *   selector: 'my-directive',
            * })
            * export class MyDirective {
            * ...
            * }
            * ```
            *
            * ### Declaring directives
            *
            * Directives are [declarables](guide/glossary#declarable).
            * They must be declared by an NgModule
            * in order to be usable in an app.
            *
            * A directive must belong to exactly one NgModule. Do not re-declare
            * a directive imported from another module.
            * List the directive class in the `declarations` field of an NgModule.
            *
            * ```
            * declarations: [
            *  AppComponent,
            *  MyDirective
            * ],
            * ```
            *
            * @Annotation
            */
        (obj: Directive): TypeDecorator;
        /**
            * See the `Directive` decorator.
            */
        new (obj: Directive): Directive;
}
export interface Directive {
        /**
            * The CSS selector that triggers the instantiation of a directive.
            *
            * Declare as one of the following:
            *
            * - `element-name`: select by element name.
            * - `.class`: select by class name.
            * - `[attribute]`: select by attribute name.
            * - `[attribute=value]`: select by attribute name and value.
            * - `:not(sub_selector)`: select only if the element does not match the `sub_selector`.
            * - `selector1, selector2`: select if either `selector1` or `selector2` matches.
            *
            * Angular only allows directives to trigger on CSS selectors that do not cross element
            * boundaries. For example, consider a directive with an `input[type=text]` selector.
            * For the following HTML, the directive is instantiated only on the
            * `<input type="text">` element.
            *
            * ```html
            * <form>
            *   <input type="text">
            *   <input type="radio">
            * <form>
            * ```
            *
            */
        selector?: string;
        /**
            * Enumerates the set of data-bound input properties for a directive
            *
            * Angular automatically updates input properties during change detection.
            * The `inputs` property defines a set of `directiveProperty` to `bindingProperty`
            * configuration:
            *
            * - `directiveProperty` specifies the component property where the value is written.
            * - `bindingProperty` specifies the DOM property where the value is read from.
            *
            * When `bindingProperty` is not provided, it is assumed to be equal to `directiveProperty`.
            * @usageNotes
            *
            * ### Example
            *
            * The following example creates a component with two data-bound properties.
            *
            * ```typescript
            * @Component({
            *   selector: 'bank-account',
            *   inputs: ['bankName', 'id: account-id'],
            *   template: `
            *     Bank Name: {{bankName}}
            *     Account Id: {{id}}
            *   `
            * })
            * class BankAccount {
            *   bankName: string;
            *   id: string;
            *
            * ```
            *
            */
        inputs?: string[];
        /**
            * Enumerates the set of event-bound output properties.
            *
            * When an output property emits an event, an event handler attached to that event
            * in the template is invoked.
            *
            * The `outputs` property defines a set of `directiveProperty` to `bindingProperty`
            * configuration:
            *
            * - `directiveProperty` specifies the component property that emits events.
            * - `bindingProperty` specifies the DOM property the event handler is attached to.
            *
            * @usageNotes
            *
            * ### Example
            *
            * ```typescript
            * @Directive({
            *   selector: 'child-dir',
            *   exportAs: 'child'
            * })
            * class ChildDir {
            * }
            *
            * @Component({
            *   selector: 'main',
            *   template: `<child-dir #c="child"></child-dir>`
            * })
            * class MainComponent {
            * }
            * ```
            *
            */
        outputs?: string[];
        /**
            * A set of injection tokens that allow the DI system to
            * provide a dependency to this directive or component.
            */
        providers?: Provider[];
        /**
            * Defines the name that can be used in the template to assign this directive to a variable.
            *
            * @usageNotes
            *
            * ### Simple Example
            *
            * ```
            * @Directive({
            *   selector: 'child-dir',
            *   exportAs: 'child'
            * })
            * class ChildDir {
            * }
            *
            * @Component({
            *   selector: 'main',
            *   template: `<child-dir #c="child"></child-dir>`
            * })
            * class MainComponent {
            * }
            * ```
            *
            */
        exportAs?: string;
        /**
            * Configures the queries that will be injected into the directive.
            *
            * Content queries are set before the `ngAfterContentInit` callback is called.
            * View queries are set before the `ngAfterViewInit` callback is called.
            *
            * @usageNotes
            *
            * ### Example
            *
            * The following example shows how queries are defined
            * and when their results are available in lifecycle hooks:
            *
            * ```
            * @Component({
            *   selector: 'someDir',
            *   queries: {
            *     contentChildren: new ContentChildren(ChildDirective),
            *     viewChildren: new ViewChildren(ChildDirective)
            *   },
            *   template: '<child-directive></child-directive>'
            * })
            * class SomeDir {
            *   contentChildren: QueryList<ChildDirective>,
            *   viewChildren: QueryList<ChildDirective>
            *
            *   ngAfterContentInit() {
            *     // contentChildren is set
            *   }
            *
            *   ngAfterViewInit() {
            *     // viewChildren is set
            *   }
            * }
            * ```
            *
            * @Annotation
            */
        queries?: {
                [key: string]: any;
        };
        /**
            * If true, this directive/component will be skipped by the AOT compiler and so will always be
            * compiled using JIT.
            *
            * This exists to support future Ivy work and has no effect currently.
            */
        jit?: true;
}
/**
    * Directive decorator and metadata.
    *
    * @Annotation
    */
export interface Directive {
        /**
            * The CSS selector that identifies this directive in a template
            * and triggers instantiation of the directive.
            *
            * Declare as one of the following:
            *
            * - `element-name`: Select by element name.
            * - `.class`: Select by class name.
            * - `[attribute]`: Select by attribute name.
            * - `[attribute=value]`: Select by attribute name and value.
            * - `:not(sub_selector)`: Select only if the element does not match the `sub_selector`.
            * - `selector1, selector2`: Select if either `selector1` or `selector2` matches.
            *
            * Angular only allows directives to apply on CSS selectors that do not cross
            * element boundaries.
            *
            * For the following template HTML, a directive with an `input[type=text]` selector,
            * would be instantiated only on the `<input type="text">` element.
            *
            * ```html
            * <form>
            *   <input type="text">
            *   <input type="radio">
            * <form>
            * ```
            *
            */
        selector?: string;
        /**
            * The set of event-bound output properties.
            * When an output property emits an event, an event handler attached
            * to that event in the template is invoked.
            *
            * Each output property maps a `directiveProperty` to a `bindingProperty`:
            * - `directiveProperty` specifies the component property that emits events.
            * - `bindingProperty` specifies the HTML attribute the event handler is attached to.
            *
            */
        outputs?: string[];
        /**
            * Maps class properties to host element bindings for properties,
            * attributes, and events, using a set of key-value pairs.
            *
            * Angular automatically checks host property bindings during change detection.
            * If a binding changes, Angular updates the directive's host element.
            *
            * When the key is a property of the host element, the property value is
            * the propagated to the specified DOM property.
            *
            * When the key is a static attribute in the DOM, the attribute value
            * is propagated to the specified property in the host element.
            *
            * For event handling:
            * - The key is the DOM event that the directive listens to.
            * To listen to global events, add the target to the event name.
            * The target can be `window`, `document` or `body`.
            * - The value is the statement to execute when the event occurs. If the
            * statement evalueates to `false`, then `preventDefault` is applied on the DOM
            * event. A handler method can refer to the `$event` local variable.
            *
            */
        host?: {
                [key: string]: string;
        };
        /**
            * Configures the [injector](guide/glossary#injector) of this
            * directive or component with a [token](guide/glossary#di-token)
            * that maps to a [provider](guide/glossary#provider) of a dependency.
            */
        providers?: Provider[];
        /**
            * The name or names that can be used in the template to assign this directive to a variable.
            * For multiple names, use a comma-separated string.
            *
            */
        exportAs?: string;
        /**
            * Configures the queries that will be injected into the directive.
            *
            * Content queries are set before the `ngAfterContentInit` callback is called.
            * View queries are set before the `ngAfterViewInit` callback is called.
            *
            */
        queries?: {
                [key: string]: any;
        };
}
/**
    * Type of the Directive metadata.
    *
    * @publicApi
    */
export declare const Directive: DirectiveDecorator;
/**
    * Component decorator interface
    *
    * @publicApi
    */
export interface ComponentDecorator {
        /**
            * Decorator that marks a class as an Angular component and provides configuration
            * metadata that determines how the component should be processed,
            * instantiated, and used at runtime.
            *
            * Components are the most basic UI building block of an Angular app.
            * An Angular app contains a tree of Angular components.
            *
            * Angular components are a subset of directives, always associated with a template.
            * Unlike other directives, only one component can be instantiated per an element in a template.
            *
            * A component must belong to an NgModule in order for it to be available
            * to another component or application. To make it a member of an NgModule,
            * list it in the `declarations` field of the `@NgModule` metadata.
            *
            * Note that, in addition to these options for configuring a directive,
            * you can control a component's runtime behavior by implementing
            * life-cycle hooks. For more information, see the
            * [Lifecycle Hooks](guide/lifecycle-hooks) guide.
            *
            * @usageNotes
            *
            * ### Setting component inputs
            *
            * The following example creates a component with two data-bound properties,
            * specified by the `inputs` value.
            *
            * <code-example path="core/ts/metadata/directives.ts" region="component-input">
            * </code-example>
            *
            *
            * ### Setting component outputs
            *
            * The following example shows two event emitters that emit on an interval. One
            * emits an output every second, while the other emits every five seconds.
            *
            * {@example core/ts/metadata/directives.ts region='component-output-interval'}
            *
            * ### Injecting a class with a view provider
            *
            * The following simple example injects a class into a component
            * using the view provider specified in component metadata:
            *
            * ```
            * class Greeter {
            *    greet(name:string) {
            *      return 'Hello ' + name + '!';
            *    }
            * }
            *
            * @Directive({
            *   selector: 'needs-greeter'
            * })
            * class NeedsGreeter {
            *   greeter:Greeter;
            *
            *   constructor(greeter:Greeter) {
            *     this.greeter = greeter;
            *   }
            * }
            *
            * @Component({
            *   selector: 'greet',
            *   viewProviders: [
            *     Greeter
            *   ],
            *   template: `<needs-greeter></needs-greeter>`
            * })
            * class HelloWorld {
            * }
            *
            * ```
            *
            * ### Preserving whitespace
            *
            * Removing whitespace can greatly reduce AOT-generated code size and speed up view creation.
            * As of Angular 6, the default for `preserveWhitespaces` is false (whitespace is removed).
            * To change the default setting for all components in your application, set
            * the `preserveWhitespaces` option of the AOT compiler.
            *
            * By default, the AOT compiler removes whitespace characters as follows:
            * * Trims all whitespaces at the beginning and the end of a template.
            * * Removes whitespace-only text nodes. For example,
            *
            * ```
            * <button>Action 1</button>  <button>Action 2</button>
            * ```
            *
            * becomes:
            *
            * ```
            * <button>Action 1</button><button>Action 2</button>
            * ```
            *
            * * Replaces a series of whitespace characters in text nodes with a single space.
            * For example, `<span>\n some text\n</span>` becomes `<span> some text </span>`.
            * * Does NOT alter text nodes inside HTML tags such as `<pre>` or `<textarea>`,
            * where whitespace characters are significant.
            *
            * Note that these transformations can influence DOM nodes layout, although impact
            * should be minimal.
            *
            * You can override the default behavior to preserve whitespace characters
            * in certain fragments of a template. For example, you can exclude an entire
            * DOM sub-tree by using the `ngPreserveWhitespaces` attribute:
            *
            * ```html
            * <div ngPreserveWhitespaces>
            *     whitespaces are preserved here
            *     <span>    and here </span>
            * </div>
            * ```
            *
            * You can force a single space to be preserved in a text node by using `&ngsp;`,
            * which is replaced with a space character by Angular's template
            * compiler:
            *
            * ```html
            * <a>Spaces</a>&ngsp;<a>between</a>&ngsp;<a>links.</a>
            * <!-->compiled to be equivalent to:</>
            *  <a>Spaces</a> <a>between</a> <a>links.</a>
            * ```
            *
            * Note that sequences of `&ngsp;` are still collapsed to just one space character when
            * the `preserveWhitespaces` option is set to `false`.
            *
            * ```html
            * <a>before</a>&ngsp;&ngsp;&ngsp;<a>after</a>
            * <!-->compiled to be equivalent to:</>
            *  <a>Spaces</a> <a>between</a> <a>links.</a>
            * ```
            *
            * To preserve sequences of whitespace characters, use the
            * `ngPreserveWhitespaces` attribute.
            *
            * @Annotation
            */
        (obj: Component): TypeDecorator;
        /**
            * See the `@Component` decorator.
            */
        new (obj: Component): Component;
}
/**
    * Supplies configuration metadata for an Angular component.
    */
export interface Component extends Directive {
        /**
            * The change-detection strategy to use for this component.
            *
            * When a component is instantiated, Angular creates a change detector,
            * which is responsible for propagating the component's bindings.
            * The strategy is one of:
            * - `ChangeDetectionStrategy#OnPush` sets the strategy to `CheckOnce` (on demand).
            * - `ChangeDetectionStrategy#Default` sets the strategy to `CheckAlways`.
            */
        changeDetection?: ChangeDetectionStrategy;
        /**
            * Defines the set of injectable objects that are visible to its view DOM children.
            * See [example](#injecting-a-class-with-a-view-provider).
            *
            */
        viewProviders?: Provider[];
        /**
            * The module ID of the module that contains the component.
            * The component must be able to resolve relative URLs for templates and styles.
            * SystemJS exposes the `__moduleName` variable within each module.
            * In CommonJS, this can  be set to `module.id`.
            *
            */
        moduleId?: string;
        /**
            * The URL of a template file for an Angular component. If provided,
            * do not supply an inline template using `template`.
            *
            */
        templateUrl?: string;
        /**
            * An inline template for an Angular component. If provided,
            * do not supply a template file using `templateUrl`.
            *
            */
        template?: string;
        /**
            * One or more URLs for files containing CSS stylesheets to use
            * in this component.
            */
        styleUrls?: string[];
        /**
            * One or more inline CSS stylesheets to use
            * in this component.
            */
        styles?: string[];
        /**
            * One or more animation `trigger()` calls, containing
            * `state()` and `transition()` definitions.
            * See the [Animations guide](/guide/animations) and animations API documentation.
            *
            */
        animations?: any[];
        /**
            * An encapsulation policy for the template and CSS styles. One of:
            * - `ViewEncapsulation.Native`: Use shadow roots. This works
            * only if natively available on the platform.
            * - `ViewEncapsulation.Emulated`: Use shimmed CSS that
            * emulates the native behavior.
            * - `ViewEncapsulation.None`: Use global CSS without any
            * encapsulation.
            *
            * If not supplied, the value is taken from `CompilerOptions`. The default compiler option is
            * `ViewEncapsulation.Emulated`.
            *
            * If the policy is set to `ViewEncapsulation.Emulated` and the component has no `styles`
            * or `styleUrls` specified, the policy is automatically switched to `ViewEncapsulation.None`.
            */
        encapsulation?: ViewEncapsulation;
        /**
            * Overrides the default encapsulation start and end delimiters (`{{` and `}}`)
            */
        interpolation?: [string, string];
        /**
            * A set of components that should be compiled along with
            * this component. For each component listed here,
            * Angular creates a {@link ComponentFactory} and stores it in the
            * {@link ComponentFactoryResolver}.
            */
        entryComponents?: Array<Type<any> | any[]>;
        /**
            * True to preserve or false to remove potentially superfluous whitespace characters
            * from the compiled template. Whitespace characters are those matching the `\s`
            * character class in JavaScript regular expressions. Default is false, unless
            * overridden in compiler options.
            */
        preserveWhitespaces?: boolean;
}
/**
    * Component decorator and metadata.
    *
    * @Annotation
    * @publicApi
    */
export declare const Component: ComponentDecorator;
/**
    * Type of the Pipe decorator / constructor function.
    *
    * @publicApi
    */
export interface PipeDecorator {
        /**
            * Declares a reusable pipe function, and supplies configuration metadata.
            *
            */
        (obj: Pipe): TypeDecorator;
        /**
            * See the `Pipe` decorator.
            */
        new (obj: Pipe): Pipe;
}
/**
    * Type of the Pipe metadata.
    */
export interface Pipe {
        /**
            * The pipe name to use in template bindings.
            *
            */
        name: string;
        /**
            * When true, the pipe is pure, meaning that the
            * `transform()` method is invoked only when its input arguments
            * change. Pipes are pure by default.
            *
            * If the pipe has internal state (that is, the result
            * depends on state other than its arguments), set `pure` to false.
            * In this case, the pipe is invoked on each change-detection cycle,
            * even if the arguments have not changed.
            */
        pure?: boolean;
}
/**
    * @Annotation
    * @publicApi
    */
export declare const Pipe: PipeDecorator;
/**
    * @publicApi
    */
export interface InputDecorator {
        /**
            * Decorator that marks a class as pipe and supplies configuration metadata.
            *
            * A pipe class must implement the `PipeTransform` interface.
            * For example, if the name is "myPipe", use a template binding expression
            * such as the following:
            *
            * ```
            * {{ exp | myPipe }}
            * ```
            *
            * The result of the expression is passed to the pipe's `transform()` method.
            *
            * A pipe must belong to an NgModule in order for it to be available
            * to a template. To make it a member of an NgModule,
            * list it in the `declarations` field of the `@NgModule` metadata.
            *
            */
        (bindingPropertyName?: string): any;
        new (bindingPropertyName?: string): any;
}
/**
    * Type of metadata for an `Input` property.
    *
    *
    */
export interface Input {
        /**
            * Decorator that marks a class field as an input property and supplies configuration metadata.
            * Declares a data-bound input property, which Angular automatically updates
            * during change detection.
            *
            * @usageNotes
            *
            * You can supply an optional name to use in templates when the
            * component is instantiated, that maps to the
            * name of the bound property. By default, the original
            * name of the bound property is used for input binding.
            *
            * The following example creates a component with two input properties,
            * one of which is given a special binding name.
            *
            * ```typescript
            * @Component({
            *   selector: 'bank-account',
            *   template: `
            *     Bank Name: {{bankName}}
            *     Account Id: {{id}}
            *   `
            * })
            * class BankAccount {
            *   // This property is bound using its original name.
            *   @Input() bankName: string;
            *   // this property value is bound to a different property name
            *   // when this component is instantiated in a template.
            *   @Input('account-id') id: string;
            *
            *   // this property is not bound, and is not automatically updated by Angular
            *   normalizedBankName: string;
            * }
            *
            * @Component({
            *   selector: 'app',
            *   template: `
            *     <bank-account bankName="RBC" account-id="4747"></bank-account>
            *   `
            * })
            *
            * class App {}
            * ```
            *
            */
        bindingPropertyName?: string;
}
/**
    * @Annotation
    * @publicApi
    */
export declare const Input: InputDecorator;
/**
    * Type of the Output decorator / constructor function.
    *
    * @publicApi
    */
export interface OutputDecorator {
        /**
         * Decorator that marks a class field as an output property and supplies configuration metadata.
         * Declares a data-bound output property, which Angular automatically updates
         * during change detection.
         *
         * @usageNotes
         *
         * You can supply an optional name to use in templates when the
         * component is instantiated, that maps to the
         * name of the bound property. By default, the original
         * name of the bound property is used for output binding.
         *
         * See `@Input` decorator for an example of providing a binding name.
         *
         */
        (bindingPropertyName?: string): any;
        new (bindingPropertyName?: string): any;
}
/**
    * Type of the Output metadata.
    */
export interface Output {
        bindingPropertyName?: string;
}
/**
    * @Annotation
    * @publicApi
    */
export declare const Output: OutputDecorator;
/**
    * Type of the HostBinding decorator / constructor function.
    *
    * @publicApi
    */
export interface HostBindingDecorator {
        /**
            * Decorator that marks a DOM property as a host-binding property and supplies configuration
            * metadata.
            * Angular automatically checks host property bindings during change detection, and
            * if a binding changes it updates the host element of the directive.
            *
            * @usageNotes
            *
            * The following example creates a directive that sets the `valid` and `invalid`
            * properties on the DOM element that has an `ngModel` directive on it.
            *
            * ```typescript
            * @Directive({selector: '[ngModel]'})
            * class NgModelStatus {
            *   constructor(public control: NgModel) {}
            *   @HostBinding('class.valid') get valid() { return this.control.valid; }
            *   @HostBinding('class.invalid') get invalid() { return this.control.invalid; }
            * }
            *
            * @Component({
            *   selector: 'app',
            *   template: `<input [(ngModel)]="prop">`,
            * })
            * class App {
            *   prop;
            * }
            * ```
            *
            */
        (hostPropertyName?: string): any;
        new (hostPropertyName?: string): any;
}
/**
    * Type of the HostBinding metadata.
    *
    */
export interface HostBinding {
        hostPropertyName?: string;
}
/**
    * @Annotation
    * @publicApi
    */
export declare const HostBinding: HostBindingDecorator;
/**
    * Type of the HostListener decorator / constructor function.
    *
    * @publicApi
    */
export interface HostListenerDecorator {
        (eventName: string, args?: string[]): any;
        new (eventName: string, args?: string[]): any;
}
/**
    * Type of the HostListener metadata.
    */
export interface HostListener {
        /**
            * The CSS event to listen for.
            */
        eventName?: string;
        /**
            * A set of arguments to pass to the handler method when the event occurs.
            */
        args?: string[];
}
/**
    * Binds a CSS event to a host listener and supplies configuration metadata.
    * Angular invokes the supplied handler method when the host element emits the specified event,
    * and updates the bound element with the result.
    * If the handler method returns false, applies `preventDefault` on the bound element.
    *
    * @usageNotes
    *
    * The following example declares a directive
    * that attaches a click listener to a button and counts clicks.
    *
    * ```
    * @Directive({selector: 'button[counting]'})
    * class CountClicks {
    *   numberOfClicks = 0;
    *
    *   @HostListener('click', ['$event.target'])
    *   onClick(btn) {
    *     console.log('button', btn, 'number of clicks:', this.numberOfClicks++);
    *  }
    * }
    *
    * @Component({
    *   selector: 'app',
    *   template: '<button counting>Increment</button>',
    * })
    * class App {}
    * ```
    *
    * @Annotation
    * @publicApi
    */
export declare const HostListener: HostListenerDecorator;
export declare const SWITCH_COMPILE_COMPONENT__POST_R3__: typeof render3CompileComponent;
export declare const SWITCH_COMPILE_DIRECTIVE__POST_R3__: typeof render3CompileDirective;
export declare const SWITCH_COMPILE_PIPE__POST_R3__: typeof render3CompilePipe;

/**
    * @license
    * Copyright Google Inc. All Rights Reserved.
    *
    * Use of this source code is governed by an MIT-style license that can be
    * found in the LICENSE file at https://angular.io/license
    */
import { SimpleChange } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/change_detection/change_detection_util';
/**
    * Defines an object that associates properties with
    * instances of `SimpleChange`.
    *
    * @see `OnChanges`
    *
    * @publicApi
    */
export interface SimpleChanges {
        [propName: string]: SimpleChange;
}
/**
    * @description
    * A lifecycle hook that is called when any data-bound property of a directive changes.
    * Define an `ngOnChanges()` method to handle the changes.
    *
    * @see `DoCheck`
    * @see `OnInit`
    * @see [Lifecycle Hooks](guide/lifecycle-hooks#onchanges) guide
    *
    * @usageNotes
    * The following snippet shows how a component can implement this interface to
    * define an on-changes handler for an input property.
    *
    * {@example core/ts/metadata/lifecycle_hooks_spec.ts region='OnChanges'}
    *
    * @publicApi
    */
export interface OnChanges {
        /**
            * A callback method that is invoked immediately after the
            * default change detector has checked data-bound properties
            * if at least one has changed, and before the view and content
            * children are checked.
            * @param changes The changed properties.
            */
        ngOnChanges(changes: SimpleChanges): void;
}
/**
    * @description
    * A lifecycle hook that is called after Angular has initialized
    * all data-bound properties of a directive.
    * Define an `ngOnInit()` method to handle any additional initialization tasks.
    *
    * @see `AfterContentInit`
    * @see [Lifecycle Hooks](guide/lifecycle-hooks#onchanges) guide
    *
    * @usageNotes
    * The following snippet shows how a component can implement this interface to
    * define its own initialization method.
    *
    * {@example core/ts/metadata/lifecycle_hooks_spec.ts region='OnInit'}
    *
    * @publicApi
    */
export interface OnInit {
        /**
            * A callback method that is invoked immediately after the
            * default change detector has checked the directive's
            * data-bound properties for the first time,
            * and before any of the view or content children have been checked.
            * It is invoked only once when the directive is instantiated.
            */
        ngOnInit(): void;
}
/**
    * A lifecycle hook that invokes a custom change-detection function for a directive,
    * in addition to the check performed by the default change-detector.
    *
    * The default change-detection algorithm looks for differences by comparing
    * bound-property values by reference across change detection runs. You can use this
    * hook to check for and respond to changes by some other means.
    *
    * When the default change detector detects changes, it invokes `ngOnChanges()` if supplied,
    * regardless of whether you perform additional change detection.
    * Typically, you should not use both `DoCheck` and `OnChanges` to respond to
    * changes on the same input.
    *
    * @see `OnChanges`
    * @see [Lifecycle Hooks](guide/lifecycle-hooks#onchanges) guide
    *
    * @usageNotes
    * The following snippet shows how a component can implement this interface
    * to invoke it own change-detection cycle.
    *
    * {@example core/ts/metadata/lifecycle_hooks_spec.ts region='DoCheck'}
    *
    * @publicApi
    */
export interface DoCheck {
        /**
                * A callback method that performs change-detection, invoked
                * after the default change-detector runs.
                * See `KeyValueDiffers` and `IterableDiffers` for implementing
                * custom change checking for collections.
                *
                */
        ngDoCheck(): void;
}
/**
    * A lifecycle hook that is called when a directive, pipe, or service is destroyed.
    * Use for any custom cleanup that needs to occur when the
    * instance is destroyed.
    * @see [Lifecycle Hooks](guide/lifecycle-hooks#onchanges) guide
    *
    * @usageNotes
    * The following snippet shows how a component can implement this interface
    * to define its own custom clean-up method.
    *
    * {@example core/ts/metadata/lifecycle_hooks_spec.ts region='OnDestroy'}
    *
    * @publicApi
    */
export interface OnDestroy {
        /**
            * A callback method that performs custom clean-up, invoked immediately
            * after a directive, pipe, or service instance is destroyed.
            */
        ngOnDestroy(): void;
}
/**
    * @description
    * A lifecycle hook that is called after Angular has fully initialized
    * all content of a directive.
    * Define an `ngAfterContentInit()` method to handle any additional initialization tasks.
    *
    * @see `OnInit`
    * @see `AfterViewInit`
    * @see [Lifecycle Hooks](guide/lifecycle-hooks#onchanges) guide
    *
    * @usageNotes
    * The following snippet shows how a component can implement this interface to
    * define its own content initialization method.
    *
    * {@example core/ts/metadata/lifecycle_hooks_spec.ts region='AfterContentInit'}
    *
    * @publicApi
    */
export interface AfterContentInit {
        /**
            * A callback method that is invoked immediately after
            * Angular has completed initialization of all of the directive's
            * content.
            * It is invoked only once when the directive is instantiated.
            */
        ngAfterContentInit(): void;
}
/**
    * @description
    * A lifecycle hook that is called after the default change detector has
    * completed checking all content of a directive.
    *
    * @see `AfterViewChecked`
    * @see [Lifecycle Hooks](guide/lifecycle-hooks#onchanges) guide
    *
    * @usageNotes
    * The following snippet shows how a component can implement this interface to
    * define its own after-check functionality.
    *
    * {@example core/ts/metadata/lifecycle_hooks_spec.ts region='AfterContentChecked'}
    *
    * @publicApi
    */
export interface AfterContentChecked {
        /**
            * A callback method that is invoked immediately after the
            * default change detector has completed checking all of the directive's
            * content.
            */
        ngAfterContentChecked(): void;
}
/**
    * @description
    * A lifecycle hook that is called after Angular has fully initialized
    * a component's view.
    * Define an `ngAfterViewInit()` method to handle any additional initialization tasks.
    *
    * @see `OnInit`
    * @see `AfterContentInit`
    * @see [Lifecycle Hooks](guide/lifecycle-hooks#onchanges) guide
    *
    * @usageNotes
    * The following snippet shows how a component can implement this interface to
    * define its own view initialization method.
    *
    * {@example core/ts/metadata/lifecycle_hooks_spec.ts region='AfterViewInit'}
    *
    * @publicApi
    */
export interface AfterViewInit {
        /**
            * A callback method that is invoked immediately after
            * Angular has completed initialization of a component's view.
            * It is invoked only once when the view is instantiated.
            *
            */
        ngAfterViewInit(): void;
}
/**
    * @description
    * A lifecycle hook that is called after the default change detector has
    * completed checking a component's view for changes.
    *
    * @see `AfterContentChecked`
    * @see [Lifecycle Hooks](guide/lifecycle-hooks#onchanges) guide
    *
    * @usageNotes
    * The following snippet shows how a component can implement this interface to
    * define its own after-check functionality.
    *
    * {@example core/ts/metadata/lifecycle_hooks_spec.ts region='AfterViewChecked'}
    *
    * @publicApi
    */
export interface AfterViewChecked {
        /**
            * A callback method that is invoked immediately after the
            * default change detector has completed one change-check cycle
            * for a component's view.
            */
        ngAfterViewChecked(): void;
}

/**
    * @license
    * Copyright Google Inc. All Rights Reserved.
    *
    * Use of this source code is governed by an MIT-style license that can be
    * found in the LICENSE file at https://angular.io/license
    */
import { ApplicationRef } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/application_ref';
import { Provider } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/di/provider';
import { compileNgModule as render3CompileNgModule } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/render3/jit/module';
import { Type } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/type';
import { TypeDecorator } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/util/decorators';
/**
    * Represents the expansion of an `NgModule` into its scopes.
    *
    * A scope is a set of directives and pipes that are visible in a particular context. Each
    * `NgModule` has two scopes. The `compilation` scope is the set of directives and pipes that will
    * be recognized in the templates of components declared by the module. The `exported` scope is the
    * set of directives and pipes exported by a module (that is, module B's exported scope gets added
    * to module A's compilation scope when module A imports B).
    */
export interface NgModuleTransitiveScopes {
        compilation: {
                directives: Set<any>;
                pipes: Set<any>;
        };
        exported: {
                directives: Set<any>;
                pipes: Set<any>;
        };
}
export declare type NgModuleDefWithMeta<T, Declarations, Imports, Exports> = NgModuleDef<T>;
/**
    * Runtime link information for NgModules.
    *
    * This is the internal data structure used by the runtime to assemble components, directives,
    * pipes, and injectors.
    *
    * NOTE: Always use `defineNgModule` function to create this object,
    * never create the object directly since the shape of this object
    * can change between versions.
    */
export interface NgModuleDef<T> {
        /** Token representing the module. Used by DI. */
        type: T;
        /** List of components to bootstrap. */
        bootstrap: Type<any>[];
        /** List of components, directives, and pipes declared by this module. */
        declarations: Type<any>[];
        /** List of modules or `ModuleWithProviders` imported by this module. */
        imports: Type<any>[];
        /**
            * List of modules, `ModuleWithProviders`, components, directives, or pipes exported by this
            * module.
            */
        exports: Type<any>[];
        /**
            * Cached value of computed `transitiveCompileScopes` for this module.
            *
            * This should never be read directly, but accessed via `transitiveScopesFor`.
            */
        transitiveCompileScopes: NgModuleTransitiveScopes | null;
}
/**
    * A wrapper around an NgModule that associates it with the providers.
    *
    * @param T the module type. In Ivy applications, this must be explicitly
    * provided.
    *
    * @publicApi
    */
export interface ModuleWithProviders<T = any /** TODO(alxhub): remove default when callers pass explicit type param */> {
        ngModule: Type<T>;
        providers?: Provider[];
}
/**
    * A schema definition associated with an NgModule.
    *
    * @see `@NgModule`, `CUSTOM_ELEMENTS_SCHEMA`, `NO_ERRORS_SCHEMA`
    *
    * @param name The name of a defined schema.
    *
    * @publicApi
    */
export interface SchemaMetadata {
        name: string;
}
/**
    * Defines a schema that allows an NgModule to contain the following:
    * - Non-Angular elements named with dash case (`-`).
    * - Element properties named with dash case (`-`).
    * Dash case is the naming convention for custom elements.
    *
    * @publicApi
    */
export declare const CUSTOM_ELEMENTS_SCHEMA: SchemaMetadata;
/**
    * Defines a schema that allows any property on any element.
    *
    * @publicApi
    */
export declare const NO_ERRORS_SCHEMA: SchemaMetadata;
/**
    * Type of the NgModule decorator / constructor function.
    */
export interface NgModuleDecorator {
        /**
            * Marks a class as an NgModule and supplies configuration metadata.
            */
        (obj?: NgModule): TypeDecorator;
        new (obj?: NgModule): NgModule;
}
/**
    * Type of the NgModule metadata.
    */
export interface NgModule {
        /**
            * The set of injectable objects that are available in the injector
            * of this module.
            *
            * @see [Dependency Injection guide](guide/dependency-injection)
            * @see [NgModule guide](guide/providers)
            *
            * @usageNotes
            *
            * Dependencies whose providers are listed here become available for injection
            * into any component, directive, pipe or service that is a child of this injector.
            * The NgModule used for bootstrapping uses the root injector, and can provide dependencies
            * to any part of the app.
            *
            * A lazy-loaded module has its own injector, typically a child of the app root injector.
            * Lazy-loaded services are scoped to the lazy-loaded module's injector.
            * If a lazy-loaded module also provides the `UserService`, any component created
            * within that module's context (such as by router navigation) gets the local instance
            * of the service, not the instance in the root injector.
            * Components in external modules continue to receive the instance provided by their injectors.
            *
            * ### Example
            *
            * The following example defines a class that is injected in
            * the HelloWorld NgModule:
            *
            * ```
            * class Greeter {
            *    greet(name:string) {
            *      return 'Hello ' + name + '!';
            *    }
            * }
            *
            * @NgModule({
            *   providers: [
            *     Greeter
            *   ]
            * })
            * class HelloWorld {
            *   greeter:Greeter;
            *
            *   constructor(greeter:Greeter) {
            *     this.greeter = greeter;
            *   }
            * }
            * ```
            */
        providers?: Provider[];
        /**
            * The set of components, directives, and pipes ([declarables](guide/glossary#declarable))
            * that belong to this module.
            *
            * @usageNotes
            *
            * The set of selectors that are available to a template include those declared here, and
            * those that are exported from imported NgModules.
            *
            * Declarables must belong to exactly one module.
            * The compiler emits an error if you try to declare the same class in more than one module.
            * Be careful not to declare a class that is imported from another module.
            *
            * ### Example
            *
            * The following example allows the CommonModule to use the `NgFor`
            * directive.
            *
            * ```javascript
            * @NgModule({
            *   declarations: [NgFor]
            * })
            * class CommonModule {
            * }
            * ```
            */
        declarations?: Array<Type<any> | any[]>;
        /**
            * The set of NgModules whose exported [declarables](guide/glossary#declarable)
            * are available to templates in this module.
            *
            * @usageNotes
            *
            * A template can use exported declarables from any
            * imported module, including those from modules that are imported indirectly
            * and re-exported.
            * For example, `ModuleA` imports `ModuleB`, and also exports
            * it, which makes the declarables from `ModuleB` available
            * wherever `ModuleA` is imported.
            *
            * ### Example
            *
            * The following example allows MainModule to use anthing exported by
            * `CommonModule`:
            *
            * ```javascript
            * @NgModule({
            *   imports: [CommonModule]
            * })
            * class MainModule {
            * }
            * ```
            *
            */
        imports?: Array<Type<any> | ModuleWithProviders<{}> | any[]>;
        /**
            * The set of components, directives, and pipes declared in this
            * NgModule that can be used in the template of any component that is part of an
            * NgModule that imports this NgModule. Exported declarations are the module's public API.
            *
            * A declarable belongs to one and only one NgModule.
            * A module can list another module among its exports, in which case all of that module's
            * public declaration are exported.
            *
            * @usageNotes
            *
            * Declarations are private by default.
            * If this ModuleA does not export UserComponent, then only the components within this
            * ModuleA can use UserComponent.
            *
            * ModuleA can import ModuleB and also export it, making exports from ModuleB
            * available to an NgModule that imports ModuleA.
            *
            * ### Example
            *
            * The following example exports the `NgFor` directive from CommonModule.
            *
            * ```javascript
            * @NgModule({
            *   exports: [NgFor]
            * })
            * class CommonModule {
            * }
            * ```
            */
        exports?: Array<Type<any> | any[]>;
        /**
            * The set of components to compile when this NgModule is defined,
            * so that they can be dynamically loaded into the view.
            *
            * For each component listed here, Angular creates a `ComponentFactory`
            * and stores it in the `ComponentFactoryResolver`.
            *
            * Angular automatically adds components in the module's bootstrap
            * and route definitions into the `entryComponents` list. Use this
            * option to add components that are bootstrapped
            * using one of the imperative techniques, such as `ViewContainerRef.createComponent()`.
            *
            * @see [Entry Components](guide/entry-components)
            */
        entryComponents?: Array<Type<any> | any[]>;
        /**
            * The set of components that are bootstrapped when
            * this module is bootstrapped. The components listed here
            * are automatically added to `entryComponents`.
            */
        bootstrap?: Array<Type<any> | any[]>;
        /**
            * The set of schemas that declare elements to be allowed in the NgModule.
            * Elements and properties that are neither Angular components nor directives
            * must be declared in a schema.
            *
            * Allowed value are `NO_ERRORS_SCHEMA` and `CUSTOM_ELEMENTS_SCHEMA`.
            *
            * @security When using one of `NO_ERRORS_SCHEMA` or `CUSTOM_ELEMENTS_SCHEMA`
            * you must ensure that allowed elements and properties securely escape inputs.
            */
        schemas?: Array<SchemaMetadata | any[]>;
        /**
            * A name or path that uniquely identifies this NgModule in `getModuleFactory`.
            * If left `undefined`, the NgModule is not registered with
            * `getModuleFactory`.
            */
        id?: string;
        /**
            * If true, this module will be skipped by the AOT compiler and so will always be compiled
            * using JIT.
            *
            * This exists to support future Ivy work and has no effect currently.
            */
        jit?: true;
}
/**
    * @Annotation
    * @publicApi
    */
export declare const NgModule: NgModuleDecorator;
/**
    * @description
    * Hook for manual bootstrapping of the application instead of using bootstrap array in @NgModule
    * annotation.
    *
    * Reference to the current application is provided as a parameter.
    *
    * See ["Bootstrapping"](guide/bootstrapping) and ["Entry components"](guide/entry-components).
    *
    * @usageNotes
    * ```typescript
    * class AppModule implements DoBootstrap {
    *   ngDoBootstrap(appRef: ApplicationRef) {
    *     appRef.bootstrap(AppComponent); // Or some other component
    *   }
    * }
    * ```
    *
    * @publicApi
    */
export interface DoBootstrap {
        ngDoBootstrap(appRef: ApplicationRef): void;
}
export declare const SWITCH_COMPILE_NGMODULE__POST_R3__: typeof render3CompileNgModule;

/**
    * Defines template and style encapsulation options available for Component's {@link Component}.
    *
    * See {@link Component#encapsulation encapsulation}.
    *
    * @usageNotes
    * ### Example
    *
    * {@example core/ts/metadata/encapsulation.ts region='longform'}
    *
    * @publicApi
    */
export declare enum ViewEncapsulation {
        /**
            * Emulate `Native` scoping of styles by adding an attribute containing surrogate id to the Host
            * Element and pre-processing the style rules provided via {@link Component#styles styles} or
            * {@link Component#styleUrls styleUrls}, and adding the new Host Element attribute to all
            * selectors.
            *
            * This is the default option.
            */
        Emulated = 0,
        /**
            * @deprecated v6.1.0 - use {ViewEncapsulation.ShadowDom} instead.
            * Use the native encapsulation mechanism of the renderer.
            *
            * For the DOM this means using the deprecated [Shadow DOM
            * v0](https://w3c.github.io/webcomponents/spec/shadow/) and
            * creating a ShadowRoot for Component's Host Element.
            */
        Native = 1,
        /**
            * Don't provide any template or style encapsulation.
            */
        None = 2,
        /**
            * Use Shadow DOM to encapsulate styles.
            *
            * For the DOM this means using modern [Shadow
            * DOM](https://w3c.github.io/webcomponents/spec/shadow/) and
            * creating a ShadowRoot for Component's Host Element.
            */
        ShadowDom = 3
}

/**
    * Type of the Inject decorator / constructor function.
    *
    * @publicApi
    */
export interface InjectDecorator {
        /**
            * A constructor parameter decorator that specifies a
            * custom provider of a dependency.
            *
            * @see ["Dependency Injection Guide"](guide/dependency-injection).
            *
            * @usageNotes
            * The following example shows a class constructor that specifies a
            * custom provider of a dependency using the parameter decorator.
            *
            * {@example core/di/ts/metadata_spec.ts region='Inject'}
            *
            * When `@Inject()` is not present, the `Injector` uses the type annotation of the
            * parameter as the provider.
            *
            * {@example core/di/ts/metadata_spec.ts region='InjectWithoutDecorator'}
            */
        (token: any): any;
        new (token: any): Inject;
}
/**
    * Type of the Inject metadata.
    *
    * @publicApi
    */
export interface Inject {
        /**
            * Injector token that maps to the dependency to be injected.
            */
        token: any;
}
/**
    * Inject decorator and metadata.
    *
    * @Annotation
    * @publicApi
    */
export declare const Inject: InjectDecorator;
/**
    * Type of the Optional decorator / constructor function.
    *
    * @publicApi
    */
export interface OptionalDecorator {
        /**
            * A constructor parameter decorator that marks a dependency as optional.
            *
            * The DI framework provides null if the dependency is not found.
            * For example, the following code allows the possibility of a null result:
            *
            * {@example core/di/ts/metadata_spec.ts region='Optional'}
            *
            * @see ["Dependency Injection Guide"](guide/dependency-injection).
            */
        (): any;
        new (): Optional;
}
/**
    * Type of the Optional metadata.
    *
    * @publicApi
    */
export interface Optional {
}
/**
    * Optional decorator and metadata.
    *
    * @Annotation
    * @publicApi
    */
export declare const Optional: OptionalDecorator;
/**
    * Type of the Self decorator / constructor function.
    *
    * @publicApi
    */
export interface SelfDecorator {
        /**
            * A constructor parameter decorator that tells the DI framework
            * to retrieve a dependency only from the local injector.
            *
            * In the following example, the dependency can be resolved
            * by the local injector when instantiating the class itself, but not
            * when instantiating a child.
            *
            * {@example core/di/ts/metadata_spec.ts region='Self'}
            *
            * @see ["Dependency Injection Guide"](guide/dependency-injection).
            *
            *
            */
        (): any;
        new (): Self;
}
/**
    * Type of the Self metadata.
    *
    * @publicApi
    */
export interface Self {
}
/**
    * Self decorator and metadata.
    *
    * @Annotation
    * @publicApi
    */
export declare const Self: SelfDecorator;
/**
    * Type of the SkipSelf decorator / constructor function.
    *
    * @publicApi
    */
export interface SkipSelfDecorator {
        /**
            * A constructor parameter decorator that tells the DI framework
            * that dependency resolution should start from the parent injector.
            *
            * In the following example, the dependency can be resolved when
            * instantiating a child, but not when instantiating the class itself.
            *
            * {@example core/di/ts/metadata_spec.ts region='SkipSelf'}
            *
            * @see ["Dependency Injection Guide"](guide/dependency-injection).
            *
            *
            */
        (): any;
        new (): SkipSelf;
}
/**
    * Type of the SkipSelf metadata.
    *
    * @publicApi
    */
export interface SkipSelf {
}
/**
    * SkipSelf decorator and metadata.
    *
    * @Annotation
    * @publicApi
    */
export declare const SkipSelf: SkipSelfDecorator;
/**
    * Type of the Host decorator / constructor function.
    *
    * @publicApi
    */
export interface HostDecorator {
        /**
            * A constructor parameter decorator that tells the DI framework
            * to retrieve a dependency from any injector until
            * reaching the host element of the current component.
            *
            * @see ["Dependency Injection Guide"](guide/dependency-injection).
            *
            * @usageNotes
            *
            * {@example core/di/ts/metadata_spec.ts region='Host'}
            */
        (): any;
        new (): Host;
}
/**
    * Type of the Host metadata.
    *
    * @publicApi
    */
export interface Host {
}
/**
    * Host decorator and metadata.
    *
    * @Annotation
    * @publicApi
    */
export declare const Host: HostDecorator;

/**
    * @license
    * Copyright Google Inc. All Rights Reserved.
    *
    * Use of this source code is governed by an MIT-style license that can be
    * found in the LICENSE file at https://angular.io/license
    */
import { Type } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/type';
import { ClassProvider, ConstructorProvider, ExistingProvider, FactoryProvider, StaticClassProvider, ValueProvider } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/di/provider';
/**
    * Information about how a type or `InjectionToken` interfaces with the DI system.
    *
    * At a minimum, this includes a `factory` which defines how to create the given type `T`, possibly
    * requesting injection of other types if necessary.
    *
    * Optionally, a `providedIn` parameter specifies that the given type belongs to a particular
    * `InjectorDef`, `NgModule`, or a special scope (e.g. `'root'`). A value of `null` indicates
    * that the injectable does not belong to any scope.
    *
    * NOTE: This is a private type and should not be exported
    */
export interface InjectableDef<T> {
        /**
            * Specifies that the given type belongs to a particular injector:
            * - `InjectorType` such as `NgModule`,
            * - `'root'` the root injector
            * - `'any'` all injectors.
            * - `null`, does not belong to any injector. Must be explicitly listed in the injector
            *   `providers`.
            */
        providedIn: InjectorType<any> | 'root' | 'any' | null;
        /**
            * Factory method to execute to create an instance of the injectable.
            */
        factory: () => T;
        /**
            * In a case of no explicit injector, a location where the instance of the injectable is stored.
            */
        value: T | undefined;
}
/**
    * Information about the providers to be included in an `Injector` as well as how the given type
    * which carries the information should be created by the DI system.
    *
    * An `InjectorDef` can import other types which have `InjectorDefs`, forming a deep nested
    * structure of providers with a defined priority (identically to how `NgModule`s also have
    * an import/dependency structure).
    *
    * NOTE: This is a private type and should not be exported
    */
export interface InjectorDef<T> {
        factory: () => T;
        providers: (Type<any> | ValueProvider | ExistingProvider | FactoryProvider | ConstructorProvider | StaticClassProvider | ClassProvider | any[])[];
        imports: (InjectorType<any> | InjectorTypeWithProviders<any>)[];
}
/**
    * A `Type` which has an `InjectableDef` static field.
    *
    * `InjectableDefType`s contain their own Dependency Injection metadata and are usable in an
    * `InjectorDef`-based `StaticInjector.
    *
    * @publicApi
    */
export interface InjectableType<T> extends Type<T> {
        /**
            * Opaque type whose structure is highly version dependent. Do not rely on any properties.
            */
        ngInjectableDef: never;
}
/**
    * A type which has an `InjectorDef` static field.
    *
    * `InjectorDefTypes` can be used to configure a `StaticInjector`.
    *
    * @publicApi
    */
export interface InjectorType<T> extends Type<T> {
        /**
            * Opaque type whose structure is highly version dependent. Do not rely on any properties.
            */
        ngInjectorDef: never;
}
/**
    * Describes the `InjectorDef` equivalent of a `ModuleWithProviders`, an `InjectorDefType` with an
    * associated array of providers.
    *
    * Objects of this type can be listed in the imports section of an `InjectorDef`.
    *
    * NOTE: This is a private type and should not be exported
    */
export interface InjectorTypeWithProviders<T> {
        ngModule: InjectorType<T>;
        providers?: (Type<any> | ValueProvider | ExistingProvider | FactoryProvider | ConstructorProvider | StaticClassProvider | ClassProvider | any[])[];
}
/**
    * Construct an `InjectableDef` which defines how a token will be constructed by the DI system, and
    * in which injectors (if any) it will be available.
    *
    * This should be assigned to a static `ngInjectableDef` field on a type, which will then be an
    * `InjectableType`.
    *
    * Options:
    * * `providedIn` determines which injectors will include the injectable, by either associating it
    *   with an `@NgModule` or other `InjectorType`, or by specifying that this injectable should be
    *   provided in the `'root'` injector, which will be the application-level injector in most apps.
    * * `factory` gives the zero argument function which will create an instance of the injectable.
    *   The factory can call `inject` to access the `Injector` and request injection of dependencies.
    *
    * @publicApi
    */
export declare function defineInjectable<T>(opts: {
        providedIn?: Type<any> | 'root' | 'any' | null;
        factory: () => T;
}): never;
/**
    * Construct an `InjectorDef` which configures an injector.
    *
    * This should be assigned to a static `ngInjectorDef` field on a type, which will then be an
    * `InjectorType`.
    *
    * Options:
    *
    * * `factory`: an `InjectorType` is an instantiable type, so a zero argument `factory` function to
    *   create the type must be provided. If that factory function needs to inject arguments, it can
    *   use the `inject` function.
    * * `providers`: an optional array of providers to add to the injector. Each provider must
    *   either have a factory or point to a type which has an `ngInjectableDef` static property (the
    *   type must be an `InjectableType`).
    * * `imports`: an optional array of imports of other `InjectorType`s or `InjectorTypeWithModule`s
    *   whose providers will also be added to the injector. Locally provided types will override
    *   providers from imports.
    *
    * @publicApi
    */
export declare function defineInjector(options: {
        factory: () => any;
        providers?: any[];
        imports?: any[];
}): never;
/**
    * Read the `ngInjectableDef` type in a way which is immune to accidentally reading inherited value.
    *
    * @param type type which may have `ngInjectableDef`
    */
export declare function getInjectableDef<T>(type: any): InjectableDef<T> | null;
/**
    * Read the `ngInjectorDef` type in a way which is immune to accidentally reading inherited value.
    *
    * @param type type which may have `ngInjectorDef`
    */
export declare function getInjectorDef<T>(type: any): InjectorDef<T> | null;

/**
    * @license
    * Copyright Google Inc. All Rights Reserved.
    *
    * Use of this source code is governed by an MIT-style license that can be
    * found in the LICENSE file at https://angular.io/license
    */
import { Type } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/type';
/**
    * An interface that a function passed into {@link forwardRef} has to implement.
    *
    * @usageNotes
    * ### Example
    *
    * {@example core/di/ts/forward_ref/forward_ref_spec.ts region='forward_ref_fn'}
    * @publicApi
    */
export interface ForwardRefFn {
        (): any;
}
/**
    * Allows to refer to references which are not yet defined.
    *
    * For instance, `forwardRef` is used when the `token` which we need to refer to for the purposes of
    * DI is declared, but not yet defined. It is also used when the `token` which we use when creating
    * a query is not yet defined.
    *
    * @usageNotes
    * ### Example
    * {@example core/di/ts/forward_ref/forward_ref_spec.ts region='forward_ref'}
    * @publicApi
    */
export declare function forwardRef(forwardRefFn: ForwardRefFn): Type<any>;
/**
    * Lazily retrieves the reference value from a forwardRef.
    *
    * Acts as the identity function when given a non-forward-ref value.
    *
    * @usageNotes
    * ### Example
    *
    * {@example core/di/ts/forward_ref/forward_ref_spec.ts region='resolve_forward_ref'}
    *
    * @see `forwardRef`
    * @publicApi
    */
export declare function resolveForwardRef<T>(type: T): T;

/**
    * @license
    * Copyright Google Inc. All Rights Reserved.
    *
    * Use of this source code is governed by an MIT-style license that can be
    * found in the LICENSE file at https://angular.io/license
    */
import { compileInjectable as render3CompileInjectable } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/render3/jit/injectable';
import { Type } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/type';
import { InjectableDef } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/di/defs';
import { ClassSansProvider, ConstructorSansProvider, ExistingSansProvider, FactorySansProvider, StaticClassSansProvider, ValueSansProvider } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/di/provider';
/**
    * Injectable providers used in `@Injectable` decorator.
    *
    * @publicApi
    */
export declare type InjectableProvider = ValueSansProvider | ExistingSansProvider | StaticClassSansProvider | ConstructorSansProvider | FactorySansProvider | ClassSansProvider;
/**
    * Type of the Injectable decorator / constructor function.
    *
    * @publicApi
    */
export interface InjectableDecorator {
        /**
            * A marker metadata that marks a class as available to `Injector` for creation.
            *
            * For more details, see the ["Dependency Injection Guide"](guide/dependency-injection).
            *
            * @usageNotes
            * ### Example
            *
            * {@example core/di/ts/metadata_spec.ts region='Injectable'}
            *
            * `Injector` will throw an error when trying to instantiate a class that
            * does not have `@Injectable` marker, as shown in the example below.
            *
            * {@example core/di/ts/metadata_spec.ts region='InjectableThrows'}
            *
            */
        (): any;
        (options?: {
                providedIn: Type<any> | 'root' | null;
        } & InjectableProvider): any;
        new (): Injectable;
        new (options?: {
                providedIn: Type<any> | 'root' | null;
        } & InjectableProvider): Injectable;
}
/**
    * Type of the Injectable metadata.
    *
    * @publicApi
    */
export interface Injectable {
        providedIn?: Type<any> | 'root' | null;
}
/**
    * Injectable decorator and metadata.
    *
    * @Annotation
    * @publicApi
    */
export declare const Injectable: InjectableDecorator;
/**
    * Type representing injectable service.
    *
    * @publicApi
    */
export interface InjectableType<T> extends Type<T> {
        ngInjectableDef: InjectableDef<T>;
}
export declare const SWITCH_COMPILE_INJECTABLE__POST_R3__: typeof render3CompileInjectable;

/**
    * @license
    * Copyright Google Inc. All Rights Reserved.
    *
    * Use of this source code is governed by an MIT-style license that can be
    * found in the LICENSE file at https://angular.io/license
    */
import { Type } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/type';
import { InjectionToken } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/di/injection_token';
import { InjectFlags } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/di/injector_compatibility';
import { StaticProvider } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/di/provider';
export declare const SOURCE = "__source";
export declare const THROW_IF_NOT_FOUND: Object;
/**
    * An InjectionToken that gets the current `Injector` for `createInjector()`-style injectors.
    *
    * Requesting this token instead of `Injector` allows `StaticInjector` to be tree-shaken from a
    * project.
    *
    * @publicApi
    */
export declare const INJECTOR: InjectionToken<Injector>;
export declare class NullInjector implements Injector {
        get(token: any, notFoundValue?: any): any;
}
/**
    * Concrete injectors implement this interface.
    *
    * For more details, see the ["Dependency Injection Guide"](guide/dependency-injection).
    *
    * @usageNotes
    * ### Example
    *
    * {@example core/di/ts/injector_spec.ts region='Injector'}
    *
    * `Injector` returns itself when given `Injector` as a token:
    *
    * {@example core/di/ts/injector_spec.ts region='injectInjector'}
    *
    * @publicApi
    */
export declare abstract class Injector {
        static THROW_IF_NOT_FOUND: Object;
        static NULL: Injector;
        /**
            * Retrieves an instance from the injector based on the provided token.
            * @returns The instance from the injector if defined, otherwise the `notFoundValue`.
            * @throws When the `notFoundValue` is `undefined` or `Injector.THROW_IF_NOT_FOUND`.
            */
        abstract get<T>(token: Type<T> | InjectionToken<T>, notFoundValue?: T, flags?: InjectFlags): T;
        /**
            * @deprecated from v4.0.0 use Type<T> or InjectionToken<T>
            * @suppress {duplicate}
            */
        abstract get(token: any, notFoundValue?: any): any;
        /**
            * @deprecated from v5 use the new signature Injector.create(options)
            */
        static create(providers: StaticProvider[], parent?: Injector): Injector;
        static create(options: {
                providers: StaticProvider[];
                parent?: Injector;
                name?: string;
        }): Injector;
        /** @nocollapse */
        static ngInjectableDef: never;
}
export declare const SWITCH_INJECTOR_FACTORY__POST_R3__: () => import("@angular/core/src/render3/di").NodeInjector;
export declare const USE_VALUE: string;
export declare class StaticInjector implements Injector {
        readonly parent: Injector;
        readonly source: string | null;
        constructor(providers: StaticProvider[], parent?: Injector, source?: string | null);
        get<T>(token: Type<T> | InjectionToken<T>, notFoundValue?: T, flags?: InjectFlags): T;
        get(token: any, notFoundValue?: any): any;
        toString(): string;
}

/**
    * @license
    * Copyright Google Inc. All Rights Reserved.
    *
    * Use of this source code is governed by an MIT-style license that can be
    * found in the LICENSE file at https://angular.io/license
    */
import { Type } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/type';
import { InjectionToken } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/di/injection_token';
import { Injector } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/di/injector';
/**
    * Injection flags for DI.
    *
    * @publicApi
    */
export declare enum InjectFlags {
        Default = 0,
        /**
            * Specifies that an injector should retrieve a dependency from any injector until reaching the
            * host element of the current component. (Only used with Element Injector)
            */
        Host = 1,
        /** Don't descend into ancestors of the node requesting injection. */
        Self = 2,
        /** Skip the node that is requesting injection. */
        SkipSelf = 4,
        /** Inject `defaultValue` instead if token not found. */
        Optional = 8
}
export declare function setCurrentInjector(injector: Injector | null | undefined): Injector | undefined | null;
/**
    * Sets the current inject implementation.
    */
export declare function setInjectImplementation(impl: (<T>(token: Type<T> | InjectionToken<T>, flags?: InjectFlags) => T | null) | undefined): (<T>(token: Type<T> | InjectionToken<T>, flags?: InjectFlags) => T | null) | undefined;
export declare function injectInjectorOnly<T>(token: Type<T> | InjectionToken<T>): T;
export declare function injectInjectorOnly<T>(token: Type<T> | InjectionToken<T>, flags?: InjectFlags): T | null;
/**
    * Injects a token from the currently active injector.
    *
    * This function must be used in the context of a factory function such as one defined for an
    * `InjectionToken`, and will throw an error if not called from such a context.
    *
    * @usageNotes
    * ### Example
    *
    * {@example core/di/ts/injector_spec.ts region='ShakeableInjectionToken'}
    *
    * Within such a factory function `inject` is utilized to request injection of a dependency, instead
    * of providing an additional array of dependencies as was common to do with `useFactory` providers.
    * `inject` is faster and more type-safe.
    *
    * @publicApi
    */
export declare function inject<T>(token: Type<T> | InjectionToken<T>): T;
export declare function inject<T>(token: Type<T> | InjectionToken<T>, flags?: InjectFlags): T | null;
/**
    * Injects `root` tokens in limp mode.
    *
    * If no injector exists, we can still inject tree-shakable providers which have `providedIn` set to
    * `"root"`. This is known as the limp mode injection. In such case the value is stored in the
    * `InjectableDef`.
    */
export declare function injectRootLimpMode<T>(token: Type<T> | InjectionToken<T>, notFoundValue: T | undefined, flags: InjectFlags): T | null;
export declare function injectArgs(types: (Type<any> | InjectionToken<any> | any[])[]): any[];

/**
    * @license
    * Copyright Google Inc. All Rights Reserved.
    *
    * Use of this source code is governed by an MIT-style license that can be
    * found in the LICENSE file at https://angular.io/license
    */
import { Injector } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/di/injector';
import { Provider } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/di/provider';
import { ResolvedReflectiveProvider } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/di/reflective_provider';
/**
    * A ReflectiveDependency injection container used for instantiating objects and resolving
    * dependencies.
    *
    * An `Injector` is a replacement for a `new` operator, which can automatically resolve the
    * constructor dependencies.
    *
    * In typical use, application code asks for the dependencies in the constructor and they are
    * resolved by the `Injector`.
    *
    * @usageNotes
    * ### Example
    *
    * The following example creates an `Injector` configured to create `Engine` and `Car`.
    *
    * ```typescript
    * @Injectable()
    * class Engine {
    * }
    *
    * @Injectable()
    * class Car {
    *   constructor(public engine:Engine) {}
    * }
    *
    * var injector = ReflectiveInjector.resolveAndCreate([Car, Engine]);
    * var car = injector.get(Car);
    * expect(car instanceof Car).toBe(true);
    * expect(car.engine instanceof Engine).toBe(true);
    * ```
    *
    * Notice, we don't use the `new` operator because we explicitly want to have the `Injector`
    * resolve all of the object's dependencies automatically.
    *
    * @deprecated from v5 - slow and brings in a lot of code, Use `Injector.create` instead.
    * @publicApi
    */
export declare abstract class ReflectiveInjector implements Injector {
        /**
            * Turns an array of provider definitions into an array of resolved providers.
            *
            * A resolution is a process of flattening multiple nested arrays and converting individual
            * providers into an array of `ResolvedReflectiveProvider`s.
            *
            * @usageNotes
            * ### Example
            *
            * ```typescript
            * @Injectable()
            * class Engine {
            * }
            *
            * @Injectable()
            * class Car {
            *   constructor(public engine:Engine) {}
            * }
            *
            * var providers = ReflectiveInjector.resolve([Car, [[Engine]]]);
            *
            * expect(providers.length).toEqual(2);
            *
            * expect(providers[0] instanceof ResolvedReflectiveProvider).toBe(true);
            * expect(providers[0].key.displayName).toBe("Car");
            * expect(providers[0].dependencies.length).toEqual(1);
            * expect(providers[0].factory).toBeDefined();
            *
            * expect(providers[1].key.displayName).toBe("Engine");
            * });
            * ```
            *
            */
        static resolve(providers: Provider[]): ResolvedReflectiveProvider[];
        /**
            * Resolves an array of providers and creates an injector from those providers.
            *
            * The passed-in providers can be an array of `Type`, `Provider`,
            * or a recursive array of more providers.
            *
            * @usageNotes
            * ### Example
            *
            * ```typescript
            * @Injectable()
            * class Engine {
            * }
            *
            * @Injectable()
            * class Car {
            *   constructor(public engine:Engine) {}
            * }
            *
            * var injector = ReflectiveInjector.resolveAndCreate([Car, Engine]);
            * expect(injector.get(Car) instanceof Car).toBe(true);
            * ```
            */
        static resolveAndCreate(providers: Provider[], parent?: Injector): ReflectiveInjector;
        /**
            * Creates an injector from previously resolved providers.
            *
            * This API is the recommended way to construct injectors in performance-sensitive parts.
            *
            * @usageNotes
            * ### Example
            *
            * ```typescript
            * @Injectable()
            * class Engine {
            * }
            *
            * @Injectable()
            * class Car {
            *   constructor(public engine:Engine) {}
            * }
            *
            * var providers = ReflectiveInjector.resolve([Car, Engine]);
            * var injector = ReflectiveInjector.fromResolvedProviders(providers);
            * expect(injector.get(Car) instanceof Car).toBe(true);
            * ```
            */
        static fromResolvedProviders(providers: ResolvedReflectiveProvider[], parent?: Injector): ReflectiveInjector;
        /**
            * Parent of this injector.
            *
            * <!-- TODO: Add a link to the section of the user guide talking about hierarchical injection.
            * -->
            */
        abstract readonly parent: Injector | null;
        /**
            * Resolves an array of providers and creates a child injector from those providers.
            *
            * <!-- TODO: Add a link to the section of the user guide talking about hierarchical injection.
            * -->
            *
            * The passed-in providers can be an array of `Type`, `Provider`,
            * or a recursive array of more providers.
            *
            * @usageNotes
            * ### Example
            *
            * ```typescript
            * class ParentProvider {}
            * class ChildProvider {}
            *
            * var parent = ReflectiveInjector.resolveAndCreate([ParentProvider]);
            * var child = parent.resolveAndCreateChild([ChildProvider]);
            *
            * expect(child.get(ParentProvider) instanceof ParentProvider).toBe(true);
            * expect(child.get(ChildProvider) instanceof ChildProvider).toBe(true);
            * expect(child.get(ParentProvider)).toBe(parent.get(ParentProvider));
            * ```
            */
        abstract resolveAndCreateChild(providers: Provider[]): ReflectiveInjector;
        /**
            * Creates a child injector from previously resolved providers.
            *
            * <!-- TODO: Add a link to the section of the user guide talking about hierarchical injection.
            * -->
            *
            * This API is the recommended way to construct injectors in performance-sensitive parts.
            *
            * @usageNotes
            * ### Example
            *
            * ```typescript
            * class ParentProvider {}
            * class ChildProvider {}
            *
            * var parentProviders = ReflectiveInjector.resolve([ParentProvider]);
            * var childProviders = ReflectiveInjector.resolve([ChildProvider]);
            *
            * var parent = ReflectiveInjector.fromResolvedProviders(parentProviders);
            * var child = parent.createChildFromResolved(childProviders);
            *
            * expect(child.get(ParentProvider) instanceof ParentProvider).toBe(true);
            * expect(child.get(ChildProvider) instanceof ChildProvider).toBe(true);
            * expect(child.get(ParentProvider)).toBe(parent.get(ParentProvider));
            * ```
            */
        abstract createChildFromResolved(providers: ResolvedReflectiveProvider[]): ReflectiveInjector;
        /**
            * Resolves a provider and instantiates an object in the context of the injector.
            *
            * The created object does not get cached by the injector.
            *
            * @usageNotes
            * ### Example
            *
            * ```typescript
            * @Injectable()
            * class Engine {
            * }
            *
            * @Injectable()
            * class Car {
            *   constructor(public engine:Engine) {}
            * }
            *
            * var injector = ReflectiveInjector.resolveAndCreate([Engine]);
            *
            * var car = injector.resolveAndInstantiate(Car);
            * expect(car.engine).toBe(injector.get(Engine));
            * expect(car).not.toBe(injector.resolveAndInstantiate(Car));
            * ```
            */
        abstract resolveAndInstantiate(provider: Provider): any;
        /**
            * Instantiates an object using a resolved provider in the context of the injector.
            *
            * The created object does not get cached by the injector.
            *
            * @usageNotes
            * ### Example
            *
            * ```typescript
            * @Injectable()
            * class Engine {
            * }
            *
            * @Injectable()
            * class Car {
            *   constructor(public engine:Engine) {}
            * }
            *
            * var injector = ReflectiveInjector.resolveAndCreate([Engine]);
            * var carProvider = ReflectiveInjector.resolve([Car])[0];
            * var car = injector.instantiateResolved(carProvider);
            * expect(car.engine).toBe(injector.get(Engine));
            * expect(car).not.toBe(injector.instantiateResolved(carProvider));
            * ```
            */
        abstract instantiateResolved(provider: ResolvedReflectiveProvider): any;
        abstract get(token: any, notFoundValue?: any): any;
}
export declare class ReflectiveInjector_ implements ReflectiveInjector {
        readonly parent: Injector | null;
        keyIds: number[];
        objs: any[];
        /**
            * Private
            */
        constructor(_providers: ResolvedReflectiveProvider[], _parent?: Injector);
        get(token: any, notFoundValue?: any): any;
        resolveAndCreateChild(providers: Provider[]): ReflectiveInjector;
        createChildFromResolved(providers: ResolvedReflectiveProvider[]): ReflectiveInjector;
        resolveAndInstantiate(provider: Provider): any;
        instantiateResolved(provider: ResolvedReflectiveProvider): any;
        getProviderAtIndex(index: number): ResolvedReflectiveProvider;
        readonly displayName: string;
        toString(): string;
}

/**
    * @license
    * Copyright Google Inc. All Rights Reserved.
    *
    * Use of this source code is governed by an MIT-style license that can be
    * found in the LICENSE file at https://angular.io/license
    */
import { Type } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/type';
/**
    * Configures the `Injector` to return a value for a token.
    *
    * For more details, see the ["Dependency Injection Guide"](guide/dependency-injection).
    *
    * @usageNotes
    * ### Example
    *
    * {@example core/di/ts/provider_spec.ts region='ValueSansProvider'}
    *
    * @publicApi
    */
export interface ValueSansProvider {
        /**
            * The value to inject.
            */
        useValue: any;
}
/**
    * Configures the `Injector` to return a value for a token.
    *
    * For more details, see the ["Dependency Injection Guide"](guide/dependency-injection).
    *
    * @usageNotes
    * ### Example
    *
    * {@example core/di/ts/provider_spec.ts region='ValueProvider'}
    *
    * ### Multi-value example
    *
    * {@example core/di/ts/provider_spec.ts region='MultiProviderAspect'}
    *
    * @publicApi
    */
export interface ValueProvider extends ValueSansProvider {
        /**
            * An injection token. (Typically an instance of `Type` or `InjectionToken`, but can be `any`).
            */
        provide: any;
        /**
            * If true, then injector returns an array of instances. This is useful to allow multiple
            * providers spread across many files to provide configuration information to a common token.
            */
        multi?: boolean;
}
/**
    * Configures the `Injector` to return an instance of `useClass` for a token.
    *
    * For more details, see the ["Dependency Injection Guide"](guide/dependency-injection).
    *
    * @usageNotes
    * ### Example
    *
    * {@example core/di/ts/provider_spec.ts region='StaticClassSansProvider'}
    *
    * @publicApi
    */
export interface StaticClassSansProvider {
        /**
            * An optional class to instantiate for the `token`. (If not provided `provide` is assumed to be a
            * class to instantiate)
            */
        useClass: Type<any>;
        /**
            * A list of `token`s which need to be resolved by the injector. The list of values is then
            * used as arguments to the `useClass` constructor.
            */
        deps: any[];
}
/**
    * Configures the `Injector` to return an instance of `useClass` for a token.
    *
    * For more details, see the ["Dependency Injection Guide"](guide/dependency-injection).
    *
    * @usageNotes
    * ### Example
    *
    * {@example core/di/ts/provider_spec.ts region='StaticClassProvider'}
    *
    * Note that following two providers are not equal:
    *
    * {@example core/di/ts/provider_spec.ts region='StaticClassProviderDifference'}
    *
    * ### Multi-value example
    *
    * {@example core/di/ts/provider_spec.ts region='MultiProviderAspect'}
    */
export interface StaticClassProvider extends StaticClassSansProvider {
        /**
            * An injection token. (Typically an instance of `Type` or `InjectionToken`, but can be `any`).
            */
        provide: any;
        /**
            * If true, then injector returns an array of instances. This is useful to allow multiple
            * providers spread across many files to provide configuration information to a common token.
            */
        multi?: boolean;
}
/**
    * Configures the `Injector` to return an instance of a token.
    *
    * For more details, see the ["Dependency Injection Guide"](guide/dependency-injection).
    *
    * @usageNotes
    * ### Example
    *
    * ```
    * @Injectable(SomeModule, {deps: []})
    * class MyService {}
    * ```
    *
    * @publicApi
    */
export interface ConstructorSansProvider {
        /**
            * A list of `token`s which need to be resolved by the injector. The list of values is then
            * used as arguments to the `useClass` constructor.
            */
        deps?: any[];
}
/**
    * Configures the `Injector` to return an instance of a token.
    *
    * For more details, see the ["Dependency Injection Guide"](guide/dependency-injection).
    *
    * @usageNotes
    * ### Example
    *
    * {@example core/di/ts/provider_spec.ts region='ConstructorProvider'}
    *
    * ### Multi-value example
    *
    * {@example core/di/ts/provider_spec.ts region='MultiProviderAspect'}
    */
export interface ConstructorProvider extends ConstructorSansProvider {
        /**
            * An injection token. (Typically an instance of `Type` or `InjectionToken`, but can be `any`).
            */
        provide: Type<any>;
        /**
            * If true, then injector returns an array of instances. This is useful to allow multiple
            * providers spread across many files to provide configuration information to a common token.
            */
        multi?: boolean;
}
/**
    * Configures the `Injector` to return a value of another `useExisting` token.
    *
    * For more details, see the ["Dependency Injection Guide"](guide/dependency-injection).
    *
    * @usageNotes
    * ### Example
    *
    * {@example core/di/ts/provider_spec.ts region='ExistingSansProvider'}
    */
export interface ExistingSansProvider {
        /**
            * Existing `token` to return. (equivalent to `injector.get(useExisting)`)
            */
        useExisting: any;
}
/**
    * Configures the `Injector` to return a value of another `useExisting` token.
    *
    * For more details, see the ["Dependency Injection Guide"](guide/dependency-injection).
    *
    * @usageNotes
    * ### Example
    *
    * {@example core/di/ts/provider_spec.ts region='ExistingProvider'}
    *
    * ### Multi-value example
    *
    * {@example core/di/ts/provider_spec.ts region='MultiProviderAspect'}
    *
    * @publicApi
    */
export interface ExistingProvider extends ExistingSansProvider {
        /**
            * An injection token. (Typically an instance of `Type` or `InjectionToken`, but can be `any`).
            */
        provide: any;
        /**
            * If true, then injector returns an array of instances. This is useful to allow multiple
            * providers spread across many files to provide configuration information to a common token.
            */
        multi?: boolean;
}
/**
    * Configures the `Injector` to return a value by invoking a `useFactory` function.
    *
    * For more details, see the ["Dependency Injection Guide"](guide/dependency-injection).
    *
    * @usageNotes
    * ### Example
    *
    * {@example core/di/ts/provider_spec.ts region='FactorySansProvider'}
    *
    * @publicApi
    */
export interface FactorySansProvider {
        /**
            * A function to invoke to create a value for this `token`. The function is invoked with
            * resolved values of `token`s in the `deps` field.
            */
        useFactory: Function;
        /**
            * A list of `token`s which need to be resolved by the injector. The list of values is then
            * used as arguments to the `useFactory` function.
            */
        deps?: any[];
}
/**
    * Configures the `Injector` to return a value by invoking a `useFactory` function.
    *
    * For more details, see the ["Dependency Injection Guide"](guide/dependency-injection).
    *
    * @usageNotes
    * ### Example
    *
    * {@example core/di/ts/provider_spec.ts region='FactoryProvider'}
    *
    * Dependencies can also be marked as optional:
    *
    * {@example core/di/ts/provider_spec.ts region='FactoryProviderOptionalDeps'}
    *
    * ### Multi-value example
    *
    * {@example core/di/ts/provider_spec.ts region='MultiProviderAspect'}
    *
    * @publicApi
    */
export interface FactoryProvider extends FactorySansProvider {
        /**
            * An injection token. (Typically an instance of `Type` or `InjectionToken`, but can be `any`).
            */
        provide: any;
        /**
            * If true, then injector returns an array of instances. This is useful to allow multiple
            * providers spread across many files to provide configuration information to a common token.
            */
        multi?: boolean;
}
/**
    * Describes how the `Injector` should be configured in a static way (Without reflection).
    *
    * For more details, see the ["Dependency Injection Guide"](guide/dependency-injection).
    *
    * @see `ValueProvider`
    * @see `ExistingProvider`
    * @see `FactoryProvider`
    *
    * @publicApi
    */
export declare type StaticProvider = ValueProvider | ExistingProvider | StaticClassProvider | ConstructorProvider | FactoryProvider | any[];
/**
    * Configures the `Injector` to return an instance of `Type` when `Type' is used as the token.
    *
    * Create an instance by invoking the `new` operator and supplying additional arguments.
    * This form is a short form of `TypeProvider`;
    *
    * For more details, see the ["Dependency Injection Guide"](guide/dependency-injection).
    *
    * @usageNotes
    * ### Example
    *
    * {@example core/di/ts/provider_spec.ts region='TypeProvider'}
    *
    * @publicApi
    */
export interface TypeProvider extends Type<any> {
}
/**
    * Configures the `Injector` to return a value by invoking a `useClass` function.
    *
    * For more details, see the ["Dependency Injection Guide"](guide/dependency-injection).
    *
    * @usageNotes
    * ### Example
    *
    * {@example core/di/ts/provider_spec.ts region='ClassSansProvider'}
    *
    * @publicApi
    */
export interface ClassSansProvider {
        /**
            * Class to instantiate for the `token`.
            */
        useClass: Type<any>;
}
/**
    * Configures the `Injector` to return an instance of `useClass` for a token.
    *
    * For more details, see the ["Dependency Injection Guide"](guide/dependency-injection).
    *
    * @usageNotes
    * ### Example
    *
    * {@example core/di/ts/provider_spec.ts region='ClassProvider'}
    *
    * Note that following two providers are not equal:
    *
    * {@example core/di/ts/provider_spec.ts region='ClassProviderDifference'}
    *
    * ### Multi-value example
    *
    * {@example core/di/ts/provider_spec.ts region='MultiProviderAspect'}
    *
    * @publicApi
    */
export interface ClassProvider extends ClassSansProvider {
        /**
            * An injection token. (Typically an instance of `Type` or `InjectionToken`, but can be `any`).
            */
        provide: any;
        /**
            * If true, then injector returns an array of instances. This is useful to allow multiple
            * providers spread across many files to provide configuration information to a common token.
            */
        multi?: boolean;
}
/**
    * Describes how the `Injector` should be configured.
    *
    * For more details, see the ["Dependency Injection Guide"](guide/dependency-injection).
    *
    * @see `TypeProvider`
    * @see `ClassProvider`
    * @see `StaticProvider`
    *
    * @publicApi
    */
export declare type Provider = TypeProvider | ValueProvider | ClassProvider | ConstructorProvider | ExistingProvider | FactoryProvider | any[];

/**
    * @license
    * Copyright Google Inc. All Rights Reserved.
    *
    * Use of this source code is governed by an MIT-style license that can be
    * found in the LICENSE file at https://angular.io/license
    */
import { Type } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/type';
import { InjectorType } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/di/defs';
import { InjectionToken } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/di/injection_token';
import { Injector } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/di/injector';
import { InjectFlags } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/di/injector_compatibility';
import { ClassProvider, ConstructorProvider, ExistingProvider, FactoryProvider, StaticClassProvider, StaticProvider, TypeProvider, ValueProvider } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/di/provider';
/**
    * Internal type for a single provider in a deep provider array.
    */
declare type SingleProvider = TypeProvider | ValueProvider | ClassProvider | ConstructorProvider | ExistingProvider | FactoryProvider | StaticClassProvider;
/**
    * Create a new `Injector` which is configured using a `defType` of `InjectorType<any>`s.
    *
    * @publicApi
    */
export declare function createInjector(defType: any, parent?: Injector | null, additionalProviders?: StaticProvider[] | null): Injector;
export declare class R3Injector {
        readonly parent: Injector;
        constructor(def: InjectorType<any>, additionalProviders: StaticProvider[] | null, parent: Injector);
        /**
            * Destroy the injector and release references to every instance or provider associated with it.
            *
            * Also calls the `OnDestroy` lifecycle hooks of every instance that was created for which a
            * hook was found.
            */
        destroy(): void;
        get<T>(token: Type<T> | InjectionToken<T>, notFoundValue?: any, flags?: InjectFlags): T;
}
/**
    * Converts a `SingleProvider` into a factory function.
    *
    * @param provider provider to convert to factory
    */
export declare function providerToFactory(provider: SingleProvider): () => any;
export declare function isTypeProvider(value: SingleProvider): value is TypeProvider;
export {};

/**
    * @license
    * Copyright Google Inc. All Rights Reserved.
    *
    * Use of this source code is governed by an MIT-style license that can be
    * found in the LICENSE file at https://angular.io/license
    */
import { Self, SkipSelf } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/di/metadata';
import { Provider } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/di/provider';
import { ReflectiveKey } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/di/reflective_key';
/**
    * `Dependency` is used by the framework to extend DI.
    * This is internal to Angular and should not be used directly.
    */
export declare class ReflectiveDependency {
        key: ReflectiveKey;
        optional: boolean;
        visibility: Self | SkipSelf | null;
        constructor(key: ReflectiveKey, optional: boolean, visibility: Self | SkipSelf | null);
        static fromKey(key: ReflectiveKey): ReflectiveDependency;
}
/**
    * An internal resolved representation of a `Provider` used by the `Injector`.
    *
    * @usageNotes
    * This is usually created automatically by `Injector.resolveAndCreate`.
    *
    * It can be created manually, as follows:
    *
    * ### Example
    *
    * ```typescript
    * var resolvedProviders = Injector.resolve([{ provide: 'message', useValue: 'Hello' }]);
    * var injector = Injector.fromResolvedProviders(resolvedProviders);
    *
    * expect(injector.get('message')).toEqual('Hello');
    * ```
    *
    * @publicApi
    */
export interface ResolvedReflectiveProvider {
        /**
            * A key, usually a `Type<any>`.
            */
        key: ReflectiveKey;
        /**
            * Factory function which can return an instance of an object represented by a key.
            */
        resolvedFactories: ResolvedReflectiveFactory[];
        /**
            * Indicates if the provider is a multi-provider or a regular provider.
            */
        multiProvider: boolean;
}
export declare class ResolvedReflectiveProvider_ implements ResolvedReflectiveProvider {
        key: ReflectiveKey;
        resolvedFactories: ResolvedReflectiveFactory[];
        multiProvider: boolean;
        readonly resolvedFactory: ResolvedReflectiveFactory;
        constructor(key: ReflectiveKey, resolvedFactories: ResolvedReflectiveFactory[], multiProvider: boolean);
}
/**
    * An internal resolved representation of a factory function created by resolving `Provider`.
    * @publicApi
    */
export declare class ResolvedReflectiveFactory {
        /**
            * Factory function which can return an instance of an object represented by a key.
            */
        factory: Function;
        /**
            * Arguments (dependencies) to the `factory` function.
            */
        dependencies: ReflectiveDependency[];
        constructor(
        /**
            * Factory function which can return an instance of an object represented by a key.
            */
        factory: Function, 
        /**
            * Arguments (dependencies) to the `factory` function.
            */
        dependencies: ReflectiveDependency[]);
}
/**
    * Resolve a list of Providers.
    */
export declare function resolveReflectiveProviders(providers: Provider[]): ResolvedReflectiveProvider[];
/**
    * Merges a list of ResolvedProviders into a list where each key is contained exactly once and
    * multi providers have been merged.
    */
export declare function mergeResolvedReflectiveProviders(providers: ResolvedReflectiveProvider[], normalizedProvidersMap: Map<number, ResolvedReflectiveProvider>): Map<number, ResolvedReflectiveProvider>;
export declare function constructDependencies(typeOrFunc: any, dependencies?: any[]): ReflectiveDependency[];

/**
    * A unique object used for retrieving items from the {@link ReflectiveInjector}.
    *
    * Keys have:
    * - a system-wide unique `id`.
    * - a `token`.
    *
    * `Key` is used internally by {@link ReflectiveInjector} because its system-wide unique `id` allows
    * the
    * injector to store created objects in a more efficient way.
    *
    * `Key` should not be created directly. {@link ReflectiveInjector} creates keys automatically when
    * resolving
    * providers.
    *
    * @deprecated No replacement
    * @publicApi
    */
export declare class ReflectiveKey {
        token: Object;
        id: number;
        readonly displayName: string;
        /**
            * Private
            */
        constructor(token: Object, id: number);
        /**
            * Retrieves a `Key` for a token.
            */
        static get(token: Object): ReflectiveKey;
        /**
            * @returns the number of keys registered in the system.
            */
        static readonly numberOfKeys: number;
}
export declare class KeyRegistry {
        get(token: Object): ReflectiveKey;
        readonly numberOfKeys: number;
}

/**
    * @license
    * Copyright Google Inc. All Rights Reserved.
    *
    * Use of this source code is governed by an MIT-style license that can be
    * found in the LICENSE file at https://angular.io/license
    */
import { Type } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/type';
/**
    * Creates a token that can be used in a DI Provider.
    *
    * Use an `InjectionToken` whenever the type you are injecting is not reified (does not have a
    * runtime representation) such as when injecting an interface, callable type, array or
    * parametrized type.
    *
    * `InjectionToken` is parameterized on `T` which is the type of object which will be returned by
    * the `Injector`. This provides additional level of type safety.
    *
    * ```
    * interface MyInterface {...}
    * var myInterface = injector.get(new InjectionToken<MyInterface>('SomeToken'));
    * // myInterface is inferred to be MyInterface.
    * ```
    *
    * When creating an `InjectionToken`, you can optionally specify a factory function which returns
    * (possibly by creating) a default value of the parameterized type `T`. This sets up the
    * `InjectionToken` using this factory as a provider as if it was defined explicitly in the
    * application's root injector. If the factory function, which takes zero arguments, needs to inject
    * dependencies, it can do so using the `inject` function. See below for an example.
    *
    * Additionally, if a `factory` is specified you can also specify the `providedIn` option, which
    * overrides the above behavior and marks the token as belonging to a particular `@NgModule`. As
    * mentioned above, `'root'` is the default value for `providedIn`.
    *
    * @usageNotes
    * ### Basic Example
    *
    * ### Plain InjectionToken
    *
    * {@example core/di/ts/injector_spec.ts region='InjectionToken'}
    *
    * ### Tree-shakable InjectionToken
    *
    * {@example core/di/ts/injector_spec.ts region='ShakableInjectionToken'}
    *
    *
    * @publicApi
    */
export declare class InjectionToken<T> {
        protected _desc: string;
        readonly ngInjectableDef: never | undefined;
        constructor(_desc: string, options?: {
                providedIn?: Type<any> | 'root' | null;
                factory: () => T;
        });
        toString(): string;
}
export interface InjectableDefToken<T> extends InjectionToken<T> {
        ngInjectableDef: never;
}

/**
    * @license
    * Copyright Google Inc. All Rights Reserved.
    *
    * Use of this source code is governed by an MIT-style license that can be
    * found in the LICENSE file at https://angular.io/license
    */
import { InjectionToken } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/di/injection_token';
import { StaticProvider } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/di/provider';
import { MissingTranslationStrategy } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/i18n/tokens';
import { ViewEncapsulation } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/metadata';
import { Type } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/type';
import { ComponentFactory } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/linker/component_factory';
import { NgModuleFactory } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/linker/ng_module_factory';
/**
    * Combination of NgModuleFactory and ComponentFactorys.
    *
    * @publicApi
    */
export declare class ModuleWithComponentFactories<T> {
        ngModuleFactory: NgModuleFactory<T>;
        componentFactories: ComponentFactory<any>[];
        constructor(ngModuleFactory: NgModuleFactory<T>, componentFactories: ComponentFactory<any>[]);
}
/**
    * Low-level service for running the angular compiler during runtime
    * to create {@link ComponentFactory}s, which
    * can later be used to create and render a Component instance.
    *
    * Each `@NgModule` provides an own `Compiler` to its injector,
    * that will use the directives/pipes of the ng module for compilation
    * of components.
    *
    * @publicApi
    */
export declare class Compiler {
        /**
            * Compiles the given NgModule and all of its components. All templates of the components listed
            * in `entryComponents` have to be inlined.
            */
        compileModuleSync<T>(moduleType: Type<T>): NgModuleFactory<T>;
        /**
            * Compiles the given NgModule and all of its components
            */
        compileModuleAsync<T>(moduleType: Type<T>): Promise<NgModuleFactory<T>>;
        /**
            * Same as {@link #compileModuleSync} but also creates ComponentFactories for all components.
            */
        compileModuleAndAllComponentsSync<T>(moduleType: Type<T>): ModuleWithComponentFactories<T>;
        /**
            * Same as {@link #compileModuleAsync} but also creates ComponentFactories for all components.
            */
        compileModuleAndAllComponentsAsync<T>(moduleType: Type<T>): Promise<ModuleWithComponentFactories<T>>;
        /**
            * Clears all caches.
            */
        clearCache(): void;
        /**
            * Clears the cache for the given component/ngModule.
            */
        clearCacheFor(type: Type<any>): void;
        /**
            * Returns the id for a given NgModule, if one is defined and known to the compiler.
            */
        getModuleId(moduleType: Type<any>): string | undefined;
}
/**
    * Options for creating a compiler
    *
    * @publicApi
    */
export declare type CompilerOptions = {
        useJit?: boolean;
        defaultEncapsulation?: ViewEncapsulation;
        providers?: StaticProvider[];
        missingTranslation?: MissingTranslationStrategy;
        preserveWhitespaces?: boolean;
};
/**
    * Token to provide CompilerOptions in the platform injector.
    *
    * @publicApi
    */
export declare const COMPILER_OPTIONS: InjectionToken<CompilerOptions[]>;
/**
    * A factory for creating a Compiler
    *
    * @publicApi
    */
export declare abstract class CompilerFactory {
        abstract createCompiler(options?: CompilerOptions[]): Compiler;
}

/**
    * @license
    * Copyright Google Inc. All Rights Reserved.
    *
    * Use of this source code is governed by an MIT-style license that can be
    * found in the LICENSE file at https://angular.io/license
    */
import { ChangeDetectorRef } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/change_detection/change_detection';
import { Injector } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/di/injector';
import { Type } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/type';
import { ElementRef } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/linker/element_ref';
import { NgModuleRef } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/linker/ng_module_factory';
import { ViewRef } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/linker/view_ref';
/**
    * Represents a component created by a `ComponentFactory`.
    * Provides access to the component instance and related objects,
    * and provides the means of destroying the instance.
    *
    * @publicApi
    */
export declare abstract class ComponentRef<C> {
        /**
            * The host or anchor [element](guide/glossary#element) for this component instance.
            */
        abstract readonly location: ElementRef;
        /**
            * The [dependency injector](guide/glossary#injector) for this component instance.
            */
        abstract readonly injector: Injector;
        /**
            * This component instance.
            */
        abstract readonly instance: C;
        /**
            * The [host view](guide/glossary#view-tree) defined by the template
            * for this component instance.
            */
        abstract readonly hostView: ViewRef;
        /**
            * The change detector for this component instance.
            */
        abstract readonly changeDetectorRef: ChangeDetectorRef;
        /**
            * The component type.
            */
        abstract readonly componentType: Type<any>;
        /**
            * Destroys the component instance and all of the data structures associated with it.
            */
        abstract destroy(): void;
        /**
            * A lifecycle hook that provides additional developer-defined cleanup
            * functionality for the component.
            * @param callback A handler function that cleans up developer-defined data
            * associated with this component. Called when the `destroy()` method is invoked.
            */
        abstract onDestroy(callback: Function): void;
}
/**
    * @publicApi
    */
export declare abstract class ComponentFactory<C> {
        /**
            * The component's HTML selector.
            */
        abstract readonly selector: string;
        /**
            * The component's type
            */
        abstract readonly componentType: Type<any>;
        /**
            * Selector for all <ng-content> elements in the component.
            */
        abstract readonly ngContentSelectors: string[];
        /**
            * The inputs of the component.
            */
        abstract readonly inputs: {
                propName: string;
                templateName: string;
        }[];
        /**
            * The outputs of the component.
            */
        abstract readonly outputs: {
                propName: string;
                templateName: string;
        }[];
        /**
            * Creates a new component.
            */
        abstract create(injector: Injector, projectableNodes?: any[][], rootSelectorOrNode?: string | any, ngModule?: NgModuleRef<any>): ComponentRef<C>;
}

/**
    * @license
    * Copyright Google Inc. All Rights Reserved.
    *
    * Use of this source code is governed by an MIT-style license that can be
    * found in the LICENSE file at https://angular.io/license
    */
import { Injector } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/di/injector';
import { Type } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/type';
import { ComponentFactoryResolver } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/linker/component_factory_resolver';
/**
    * Represents an instance of an NgModule created via a {@link NgModuleFactory}.
    *
    * `NgModuleRef` provides access to the NgModule Instance as well other objects related to this
    * NgModule Instance.
    *
    * @publicApi
    */
export declare abstract class NgModuleRef<T> {
        /**
            * The injector that contains all of the providers of the NgModule.
            */
        abstract readonly injector: Injector;
        /**
            * The ComponentFactoryResolver to get hold of the ComponentFactories
            * declared in the `entryComponents` property of the module.
            */
        abstract readonly componentFactoryResolver: ComponentFactoryResolver;
        /**
            * The NgModule instance.
            */
        abstract readonly instance: T;
        /**
            * Destroys the module instance and all of the data structures associated with it.
            */
        abstract destroy(): void;
        /**
            * Allows to register a callback that will be called when the module is destroyed.
            */
        abstract onDestroy(callback: () => void): void;
}
export interface InternalNgModuleRef<T> extends NgModuleRef<T> {
        _bootstrapComponents: Type<any>[];
}
/**
    * @publicApi
    */
export declare abstract class NgModuleFactory<T> {
        abstract readonly moduleType: Type<T>;
        abstract create(parentInjector: Injector | null): NgModuleRef<T>;
}

/**
    * @license
    * Copyright Google Inc. All Rights Reserved.
    *
    * Use of this source code is governed by an MIT-style license that can be
    * found in the LICENSE file at https://angular.io/license
    */
import { ApplicationRef } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/application_ref';
import { ChangeDetectorRef } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/change_detection/change_detector_ref';
/**
    * Represents an Angular [view](guide/glossary#view),
    * specifically the [host view](guide/glossary#view-tree) that is defined by a component.
    * Also serves as the base class
    * that adds destroy methods for [embedded views](guide/glossary#view-tree).
    *
    * @see `EmbeddedViewRef`
    *
    * @publicApi
    */
export declare abstract class ViewRef extends ChangeDetectorRef {
        /**
            * Destroys this view and all of the data structures associated with it.
            */
        abstract destroy(): void;
        /**
            * Reports whether this view has been destroyed.
            * @returns True after the `destroy()` method has been called, false otherwise.
            */
        abstract readonly destroyed: boolean;
        /**
            * A lifecycle hook that provides additional developer-defined cleanup
            * functionality for views.
            * @param callback A handler function that cleans up developer-defined data
            * associated with a view. Called when the `destroy()` method is invoked.
            */
        abstract onDestroy(callback: Function): any /** TODO #9100 */;
}
/**
    * Represents an Angular [view](guide/glossary#view) in a view container.
    * An [embedded view](guide/glossary#view-tree) can be referenced from a component
    * other than the hosting component whose template defines it, or it can be defined
    * independently by a `TemplateRef`.
    *
    * Properties of elements in a view can change, but the structure (number and order) of elements in
    * a view cannot. Change the structure of elements by inserting, moving, or
    * removing nested views in a view container.
    *
    * @see `ViewContainerRef`
    *
    * @usageNotes
    *
    * The following template breaks down into two separate `TemplateRef` instances,
    * an outer one and an inner one.
    *
    * ```
    * Count: {{items.length}}
    * <ul>
    *   <li *ngFor="let  item of items">{{item}}</li>
    * </ul>
    * ```
    *
    * This is the outer `TemplateRef`:
    *
    * ```
    * Count: {{items.length}}
    * <ul>
    *   <ng-template ngFor let-item [ngForOf]="items"></ng-template>
    * </ul>
    * ```
    *
    * This is the inner `TemplateRef`:
    *
    * ```
    *   <li>{{item}}</li>
    * ```
    *
    * The outer and inner `TemplateRef` instances are assembled into views as follows:
    *
    * ```
    * <!-- ViewRef: outer-0 -->
    * Count: 2
    * <ul>
    *   <ng-template view-container-ref></ng-template>
    *   <!-- ViewRef: inner-1 --><li>first</li><!-- /ViewRef: inner-1 -->
    *   <!-- ViewRef: inner-2 --><li>second</li><!-- /ViewRef: inner-2 -->
    * </ul>
    * <!-- /ViewRef: outer-0 -->
    * ```
    * @publicApi
    */
export declare abstract class EmbeddedViewRef<C> extends ViewRef {
        /**
            * The context for this view, inherited from the anchor element.
            */
        abstract readonly context: C;
        /**
            * The root nodes for this embedded view.
            */
        abstract readonly rootNodes: any[];
}
export interface InternalViewRef extends ViewRef {
        detachFromAppRef(): void;
        attachToAppRef(appRef: ApplicationRef): void;
}

/**
    * @license
    * Copyright Google Inc. All Rights Reserved.
    *
    * Use of this source code is governed by an MIT-style license that can be
    * found in the LICENSE file at https://angular.io/license
    */
import { EventEmitter } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/event_emitter';
/**
    * An injectable service for executing work inside or outside of the Angular zone.
    *
    * The most common use of this service is to optimize performance when starting a work consisting of
    * one or more asynchronous tasks that don't require UI updates or error handling to be handled by
    * Angular. Such tasks can be kicked off via {@link #runOutsideAngular} and if needed, these tasks
    * can reenter the Angular zone via {@link #run}.
    *
    * <!-- TODO: add/fix links to:
    *   - docs explaining zones and the use of zones in Angular and change-detection
    *   - link to runOutsideAngular/run (throughout this file!)
    *   -->
    *
    * @usageNotes
    * ### Example
    *
    * ```
    * import {Component, NgZone} from '@angular/core';
    * import {NgIf} from '@angular/common';
    *
    * @Component({
    *   selector: 'ng-zone-demo',
    *   template: `
    *     <h2>Demo: NgZone</h2>
    *
    *     <p>Progress: {{progress}}%</p>
    *     <p *ngIf="progress >= 100">Done processing {{label}} of Angular zone!</p>
    *
    *     <button (click)="processWithinAngularZone()">Process within Angular zone</button>
    *     <button (click)="processOutsideOfAngularZone()">Process outside of Angular zone</button>
    *   `,
    * })
    * export class NgZoneDemo {
    *   progress: number = 0;
    *   label: string;
    *
    *   constructor(private _ngZone: NgZone) {}
    *
    *   // Loop inside the Angular zone
    *   // so the UI DOES refresh after each setTimeout cycle
    *   processWithinAngularZone() {
    *     this.label = 'inside';
    *     this.progress = 0;
    *     this._increaseProgress(() => console.log('Inside Done!'));
    *   }
    *
    *   // Loop outside of the Angular zone
    *   // so the UI DOES NOT refresh after each setTimeout cycle
    *   processOutsideOfAngularZone() {
    *     this.label = 'outside';
    *     this.progress = 0;
    *     this._ngZone.runOutsideAngular(() => {
    *       this._increaseProgress(() => {
    *         // reenter the Angular zone and display done
    *         this._ngZone.run(() => { console.log('Outside Done!'); });
    *       });
    *     });
    *   }
    *
    *   _increaseProgress(doneCallback: () => void) {
    *     this.progress += 1;
    *     console.log(`Current progress: ${this.progress}%`);
    *
    *     if (this.progress < 100) {
    *       window.setTimeout(() => this._increaseProgress(doneCallback), 10);
    *     } else {
    *       doneCallback();
    *     }
    *   }
    * }
    * ```
    *
    * @publicApi
    */
export declare class NgZone {
        readonly hasPendingMicrotasks: boolean;
        readonly hasPendingMacrotasks: boolean;
        /**
            * Whether there are no outstanding microtasks or macrotasks.
            */
        readonly isStable: boolean;
        /**
            * Notifies when code enters Angular Zone. This gets fired first on VM Turn.
            */
        readonly onUnstable: EventEmitter<any>;
        /**
            * Notifies when there is no more microtasks enqueued in the current VM Turn.
            * This is a hint for Angular to do change detection, which may enqueue more microtasks.
            * For this reason this event can fire multiple times per VM Turn.
            */
        readonly onMicrotaskEmpty: EventEmitter<any>;
        /**
            * Notifies when the last `onMicrotaskEmpty` has run and there are no more microtasks, which
            * implies we are about to relinquish VM turn.
            * This event gets called just once.
            */
        readonly onStable: EventEmitter<any>;
        /**
            * Notifies that an error has been delivered.
            */
        readonly onError: EventEmitter<any>;
        constructor({ enableLongStackTrace }: {
                enableLongStackTrace?: boolean | undefined;
        });
        static isInAngularZone(): boolean;
        static assertInAngularZone(): void;
        static assertNotInAngularZone(): void;
        /**
            * Executes the `fn` function synchronously within the Angular zone and returns value returned by
            * the function.
            *
            * Running functions via `run` allows you to reenter Angular zone from a task that was executed
            * outside of the Angular zone (typically started via {@link #runOutsideAngular}).
            *
            * Any future tasks or microtasks scheduled from within this function will continue executing from
            * within the Angular zone.
            *
            * If a synchronous error happens it will be rethrown and not reported via `onError`.
            */
        run<T>(fn: (...args: any[]) => T, applyThis?: any, applyArgs?: any[]): T;
        /**
            * Executes the `fn` function synchronously within the Angular zone as a task and returns value
            * returned by the function.
            *
            * Running functions via `run` allows you to reenter Angular zone from a task that was executed
            * outside of the Angular zone (typically started via {@link #runOutsideAngular}).
            *
            * Any future tasks or microtasks scheduled from within this function will continue executing from
            * within the Angular zone.
            *
            * If a synchronous error happens it will be rethrown and not reported via `onError`.
            */
        runTask<T>(fn: (...args: any[]) => T, applyThis?: any, applyArgs?: any[], name?: string): T;
        /**
            * Same as `run`, except that synchronous errors are caught and forwarded via `onError` and not
            * rethrown.
            */
        runGuarded<T>(fn: (...args: any[]) => T, applyThis?: any, applyArgs?: any[]): T;
        /**
            * Executes the `fn` function synchronously in Angular's parent zone and returns value returned by
            * the function.
            *
            * Running functions via {@link #runOutsideAngular} allows you to escape Angular's zone and do
            * work that
            * doesn't trigger Angular change-detection or is subject to Angular's error handling.
            *
            * Any future tasks or microtasks scheduled from within this function will continue executing from
            * outside of the Angular zone.
            *
            * Use {@link #run} to reenter the Angular zone and do work that updates the application model.
            */
        runOutsideAngular<T>(fn: (...args: any[]) => T): T;
}
/**
    * Provides a noop implementation of `NgZone` which does nothing. This zone requires explicit calls
    * to framework to perform rendering.
    */
export declare class NoopNgZone implements NgZone {
        readonly hasPendingMicrotasks: boolean;
        readonly hasPendingMacrotasks: boolean;
        readonly isStable: boolean;
        readonly onUnstable: EventEmitter<any>;
        readonly onMicrotaskEmpty: EventEmitter<any>;
        readonly onStable: EventEmitter<any>;
        readonly onError: EventEmitter<any>;
        run(fn: () => any): any;
        runGuarded(fn: () => any): any;
        runOutsideAngular(fn: () => any): any;
        runTask<T>(fn: () => any): any;
}

/**
    * @license
    * Copyright Google Inc. All Rights Reserved.
    *
    * Use of this source code is governed by an MIT-style license that can be
    * found in the LICENSE file at https://angular.io/license
    */
import { InjectionToken } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/di/injection_token';
import { Injector } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/di/injector';
import { ViewEncapsulation } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/metadata/view';
import { injectRenderer2 as render3InjectRenderer2 } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/render3/view_engine_compatibility';
/**
    * @deprecated Use `RendererType2` (and `Renderer2`) instead.
    * @publicApi
    */
export declare class RenderComponentType {
        id: string;
        templateUrl: string;
        slotCount: number;
        encapsulation: ViewEncapsulation;
        styles: Array<string | any[]>;
        animations: any;
        constructor(id: string, templateUrl: string, slotCount: number, encapsulation: ViewEncapsulation, styles: Array<string | any[]>, animations: any);
}
/**
    * @deprecated Debug info is handled internally in the view engine now.
    */
export declare abstract class RenderDebugInfo {
        abstract readonly injector: Injector;
        abstract readonly component: any;
        abstract readonly providerTokens: any[];
        abstract readonly references: {
                [key: string]: any;
        };
        abstract readonly context: any;
        abstract readonly source: string;
}
/**
    * @deprecated Use the `Renderer2` instead.
    */
export interface DirectRenderer {
        remove(node: any): void;
        appendChild(node: any, parent: any): void;
        insertBefore(node: any, refNode: any): void;
        nextSibling(node: any): any;
        parentElement(node: any): any;
}
/**
    * @deprecated Use the `Renderer2` instead.
    * @publicApi
    */
export declare abstract class Renderer {
        abstract selectRootElement(selectorOrNode: string | any, debugInfo?: RenderDebugInfo): any;
        abstract createElement(parentElement: any, name: string, debugInfo?: RenderDebugInfo): any;
        abstract createViewRoot(hostElement: any): any;
        abstract createTemplateAnchor(parentElement: any, debugInfo?: RenderDebugInfo): any;
        abstract createText(parentElement: any, value: string, debugInfo?: RenderDebugInfo): any;
        abstract projectNodes(parentElement: any, nodes: any[]): void;
        abstract attachViewAfter(node: any, viewRootNodes: any[]): void;
        abstract detachView(viewRootNodes: any[]): void;
        abstract destroyView(hostElement: any, viewAllNodes: any[]): void;
        abstract listen(renderElement: any, name: string, callback: Function): Function;
        abstract listenGlobal(target: string, name: string, callback: Function): Function;
        abstract setElementProperty(renderElement: any, propertyName: string, propertyValue: any): void;
        abstract setElementAttribute(renderElement: any, attributeName: string, attributeValue?: string): void;
        /**
            * Used only in debug mode to serialize property changes to dom nodes as attributes.
            */
        abstract setBindingDebugInfo(renderElement: any, propertyName: string, propertyValue: string): void;
        abstract setElementClass(renderElement: any, className: string, isAdd: boolean): void;
        abstract setElementStyle(renderElement: any, styleName: string, styleValue?: string): void;
        abstract invokeElementMethod(renderElement: any, methodName: string, args?: any[]): void;
        abstract setText(renderNode: any, text: string): void;
        abstract animate(element: any, startingStyles: any, keyframes: any[], duration: number, delay: number, easing: string, previousPlayers?: any[]): any;
}
export declare const Renderer2Interceptor: InjectionToken<Renderer2[]>;
/**
    * Injectable service that provides a low-level interface for modifying the UI.
    *
    * Use this service to bypass Angular's templating and make custom UI changes that can't be
    * expressed declaratively. For example if you need to set a property or an attribute whose name is
    * not statically known, use {@link Renderer#setElementProperty setElementProperty} or
    * {@link Renderer#setElementAttribute setElementAttribute} respectively.
    *
    * If you are implementing a custom renderer, you must implement this interface.
    *
    * The default Renderer implementation is `DomRenderer`. Also available is `WebWorkerRenderer`.
    *
    * @deprecated Use `RendererFactory2` instead.
    * @publicApi
    */
export declare abstract class RootRenderer {
        abstract renderComponent(componentType: RenderComponentType): Renderer;
}
/**
    * Used by `RendererFactory2` to associate custom rendering data and styles
    * with a rendering implementation.
    *  @publicApi
    */
export interface RendererType2 {
        /**
            * A unique identifying string for the new renderer, used when creating
            * unique styles for encapsulation.
            */
        id: string;
        /**
            * The view encapsulation type, which determines how styles are applied to
            * DOM elements. One of
            * - `Emulated` (default): Emulate native scoping of styles.
            * - `Native`: Use the native encapsulation mechanism of the renderer.
            * - `ShadowDom`: Use modern [Shadow
            * DOM](https://w3c.github.io/webcomponents/spec/shadow/) and
            * create a ShadowRoot for component's host element.
            * - `None`: Do not provide any template or style encapsulation.
            */
        encapsulation: ViewEncapsulation;
        /**
            * Defines CSS styles to be stored on a renderer instance.
            */
        styles: (string | any[])[];
        /**
            * Defines arbitrary developer-defined data to be stored on a renderer instance.
            * This is useful for renderers that delegate to other renderers.
            */
        data: {
                [kind: string]: any;
        };
}
/**
    * Creates and initializes a custom renderer that implements the `Renderer2` base class.
    *
    * @publicApi
    */
export declare abstract class RendererFactory2 {
        /**
            * Creates and initializes a custom renderer for a host DOM element.
            * @param hostElement The element to render.
            * @param type The base class to implement.
            * @returns The new custom renderer instance.
            */
        abstract createRenderer(hostElement: any, type: RendererType2 | null): Renderer2;
        /**
            * A callback invoked when rendering has begun.
            */
        abstract begin?(): void;
        /**
            * A callback invoked when rendering has completed.
            */
        abstract end?(): void;
        /**
            * Use with animations test-only mode. Notifies the test when rendering has completed.
            * @returns The asynchronous result of the developer-defined function.
            */
        abstract whenRenderingDone?(): Promise<any>;
}
/**
    * Flags for renderer-specific style modifiers.
    * @publicApi
    */
export declare enum RendererStyleFlags2 {
        /**
            * Marks a style as important.
            */
        Important = 1,
        /**
            * Marks a style as using dash case naming (this-is-dash-case).
            */
        DashCase = 2
}
/**
    * Extend this base class to implement custom rendering. By default, Angular
    * renders a template into DOM. You can use custom rendering to intercept
    * rendering calls, or to render to something other than DOM.
    *
    * Create your custom renderer using `RendererFactory2`.
    *
    * Use a custom renderer to bypass Angular's templating and
    * make custom UI changes that can't be expressed declaratively.
    * For example if you need to set a property or an attribute whose name is
    * not statically known, use the `setProperty()` or
    * `setAttribute()` method.
    *
    * @publicApi
    */
export declare abstract class Renderer2 {
        /**
            * Use to store arbitrary developer-defined data on a renderer instance,
            * as an object containing key-value pairs.
            * This is useful for renderers that delegate to other renderers.
            */
        abstract readonly data: {
                [key: string]: any;
        };
        /**
            * Implement this callback to destroy the renderer or the host element.
            */
        abstract destroy(): void;
        /**
            * Implement this callback to create an instance of the host element.
            * @param name An identifying name for the new element, unique within the namespace.
            * @param namespace The namespace for the new element.
            * @returns The new element.
            */
        abstract createElement(name: string, namespace?: string | null): any;
        /**
            * Implement this callback to add a comment to the DOM of the host element.
            * @param value The comment text.
            * @returns The modified element.
            */
        abstract createComment(value: string): any;
        /**
            * Implement this callback to add text to the DOM of the host element.
            * @param value The text string.
            * @returns The modified element.
            */
        abstract createText(value: string): any;
        /**
            * If null or undefined, the view engine won't call it.
            * This is used as a performance optimization for production mode.
            */
        destroyNode: ((node: any) => void) | null;
        /**
            * Appends a child to a given parent node in the host element DOM.
            * @param parent The parent node.
            * @param newChild The new child node.
            */
        abstract appendChild(parent: any, newChild: any): void;
        /**
            * Implement this callback to insert a child node at a given position in a parent node
            * in the host element DOM.
            * @param parent The parent node.
            * @param newChild The new child nodes.
            * @param refChild The existing child node that should precede the new node.
            */
        abstract insertBefore(parent: any, newChild: any, refChild: any): void;
        /**
            * Implement this callback to remove a child node from the host element's DOM.
            * @param parent The parent node.
            * @param oldChild The child node to remove.
            */
        abstract removeChild(parent: any, oldChild: any): void;
        /**
            * Implement this callback to prepare an element to be bootstrapped
            * as a root element, and return the element instance.
            * @param selectorOrNode The DOM element.
            * @param preserveContent Whether the contents of the root element
            * should be preserved, or cleared upon bootstrap (default behavior).
            * Use with `ViewEncapsulation.ShadowDom` to allow simple native
            * content projection via `<slot>` elements.
            * @returns The root element.
            */
        abstract selectRootElement(selectorOrNode: string | any, preserveContent?: boolean): any;
        /**
            * Implement this callback to get the parent of a given node
            * in the host element's DOM.
            * @param node The child node to query.
            * @returns The parent node, or null if there is no parent.
            * For WebWorkers, always returns true.
            * This is because the check is synchronous,
            * and the caller can't rely on checking for null.
            */
        abstract parentNode(node: any): any;
        /**
            * Implement this callback to get the next sibling node of a given node
            * in the host element's DOM.
            * @returns The sibling node, or null if there is no sibling.
            * For WebWorkers, always returns a value.
            * This is because the check is synchronous,
            * and the caller can't rely on checking for null.
            */
        abstract nextSibling(node: any): any;
        /**
            * Implement this callback to set an attribute value for an element in the DOM.
            * @param el The element.
            * @param name The attribute name.
            * @param value The new value.
            * @param namespace The namespace.
            */
        abstract setAttribute(el: any, name: string, value: string, namespace?: string | null): void;
        /**
            * Implement this callback to remove an attribute from an element in the DOM.
            * @param el The element.
            * @param name The attribute name.
            * @param namespace The namespace.
            */
        abstract removeAttribute(el: any, name: string, namespace?: string | null): void;
        /**
            * Implement this callback to add a class to an element in the DOM.
            * @param el The element.
            * @param name The class name.
            */
        abstract addClass(el: any, name: string): void;
        /**
            * Implement this callback to remove a class from an element in the DOM.
            * @param el The element.
            * @param name The class name.
            */
        abstract removeClass(el: any, name: string): void;
        /**
            * Implement this callback to set a CSS style for an element in the DOM.
            * @param el The element.
            * @param style The name of the style.
            * @param value The new value.
            * @param flags Flags for style variations. No flags are set by default.
            */
        abstract setStyle(el: any, style: string, value: any, flags?: RendererStyleFlags2): void;
        /**
            * Implement this callback to remove the value from a CSS style for an element in the DOM.
            * @param el The element.
            * @param style The name of the style.
            * @param flags Flags for style variations to remove, if set. ???
            */
        abstract removeStyle(el: any, style: string, flags?: RendererStyleFlags2): void;
        /**
            * Implement this callback to set the value of a property of an element in the DOM.
            * @param el The element.
            * @param name The property name.
            * @param value The new value.
            */
        abstract setProperty(el: any, name: string, value: any): void;
        /**
            * Implement this callback to set the value of a node in the host element.
            * @param node The node.
            * @param value The new value.
            */
        abstract setValue(node: any, value: string): void;
        /**
            * Implement this callback to start an event listener.
            * @param target The context in which to listen for events. Can be
            * the entire window or document, the body of the document, or a specific
            * DOM element.
            * @param eventName The event to listen for.
            * @param callback A handler function to invoke when the event occurs.
            * @returns An "unlisten" function for disposing of this handler.
            */
        abstract listen(target: 'window' | 'document' | 'body' | any, eventName: string, callback: (event: any) => boolean | void): () => void;
}
export declare const SWITCH_RENDERER2_FACTORY__POST_R3__: typeof render3InjectRenderer2;

/**
    * @license
    * Copyright Google Inc. All Rights Reserved.
    *
    * Use of this source code is governed by an MIT-style license that can be
    * found in the LICENSE file at https://angular.io/license
    */
import { Injector } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/di/injector';
import { Type } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/type';
import { ComponentFactory, ComponentRef } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/linker/component_factory';
import { NgModuleRef } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/linker/ng_module_factory';
export declare function noComponentFactoryError(component: Function): Error;
export declare function getComponent(error: Error): Type<any>;
/**
    * @publicApi
    */
export declare abstract class ComponentFactoryResolver {
        static NULL: ComponentFactoryResolver;
        abstract resolveComponentFactory<T>(component: Type<T>): ComponentFactory<T>;
}
export declare class CodegenComponentFactoryResolver implements ComponentFactoryResolver {
        constructor(factories: ComponentFactory<any>[], _parent: ComponentFactoryResolver, _ngModule: NgModuleRef<any>);
        resolveComponentFactory<T>(component: {
                new (...args: any[]): T;
        }): ComponentFactory<T>;
}
export declare class ComponentFactoryBoundToModule<C> extends ComponentFactory<C> {
        readonly selector: string;
        readonly componentType: Type<any>;
        readonly ngContentSelectors: string[];
        readonly inputs: {
                propName: string;
                templateName: string;
        }[];
        readonly outputs: {
                propName: string;
                templateName: string;
        }[];
        constructor(factory: ComponentFactory<C>, ngModule: NgModuleRef<any>);
        create(injector: Injector, projectableNodes?: any[][], rootSelectorOrNode?: string | any, ngModule?: NgModuleRef<any>): ComponentRef<C>;
}

/**
    * @license
    * Copyright Google Inc. All Rights Reserved.
    *
    * Use of this source code is governed by an MIT-style license that can be
    * found in the LICENSE file at https://angular.io/license
    */
import { injectElementRef as render3InjectElementRef } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/render3/view_engine_compatibility';
/**
    * A wrapper around a native element inside of a View.
    *
    * An `ElementRef` is backed by a render-specific element. In the browser, this is usually a DOM
    * element.
    *
    * @security Permitting direct access to the DOM can make your application more vulnerable to
    * XSS attacks. Carefully review any use of `ElementRef` in your code. For more detail, see the
    * [Security Guide](http://g.co/ng/security).
    *
    * @publicApi
    */
export declare class ElementRef<T = any> {
        /**
            * The underlying native element or `null` if direct access to native elements is not supported
            * (e.g. when the application runs in a web worker).
            *
            * <div class="callout is-critical">
            *   <header>Use with caution</header>
            *   <p>
            *    Use this API as the last resort when direct access to DOM is needed. Use templating and
            *    data-binding provided by Angular instead. Alternatively you can take a look at {@link
            * Renderer2}
            *    which provides API that can safely be used even when direct access to native elements is not
            *    supported.
            *   </p>
            *   <p>
            *    Relying on direct DOM access creates tight coupling between your application and rendering
            *    layers which will make it impossible to separate the two and deploy your application into a
            *    web worker.
            *   </p>
            * </div>
            *
            */
        nativeElement: T;
        constructor(nativeElement: T);
}
export declare const SWITCH_ELEMENT_REF_FACTORY__POST_R3__: typeof render3InjectElementRef;

/**
    * @license
    * Copyright Google Inc. All Rights Reserved.
    *
    * Use of this source code is governed by an MIT-style license that can be
    * found in the LICENSE file at https://angular.io/license
    */
import { NgModuleFactory } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/linker/ng_module_factory';
/**
    * Used to load ng module factories.
    *
    * @publicApi
    */
export declare abstract class NgModuleFactoryLoader {
        abstract load(path: string): Promise<NgModuleFactory<any>>;
}
/**
    * Registers a loaded module. Should only be called from generated NgModuleFactory code.
    * @publicApi
    */
export declare function registerModuleFactory(id: string, factory: NgModuleFactory<any>): void;
export declare function clearModulesForTest(): void;
/**
    * Returns the NgModuleFactory with the given id, if it exists and has been loaded.
    * Factories for modules that do not specify an `id` cannot be retrieved. Throws if the module
    * cannot be found.
    * @publicApi
    */
export declare function getModuleFactory(id: string): NgModuleFactory<any>;

/**
    * @license
    * Copyright Google Inc. All Rights Reserved.
    *
    * Use of this source code is governed by an MIT-style license that can be
    * found in the LICENSE file at https://angular.io/license
    */
import { Observable } from 'rxjs';
/**
    * An unmodifiable list of items that Angular keeps up to date when the state
    * of the application changes.
    *
    * The type of object that {@link ViewChildren}, {@link ContentChildren}, and {@link QueryList}
    * provide.
    *
    * Implements an iterable interface, therefore it can be used in both ES6
    * javascript `for (var i of items)` loops as well as in Angular templates with
    * `*ngFor="let i of myList"`.
    *
    * Changes can be observed by subscribing to the changes `Observable`.
    *
    * NOTE: In the future this class will implement an `Observable` interface.
    *
    * @usageNotes
    * ### Example
    * ```typescript
    * @Component({...})
    * class Container {
    *   @ViewChildren(Item) items:QueryList<Item>;
    * }
    * ```
    *
    * @publicApi
    */
export declare class QueryList<T> {
        readonly dirty = true;
        readonly changes: Observable<any>;
        readonly length: number;
        readonly first: T;
        readonly last: T;
        /**
            * See
            * [Array.map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map)
            */
        map<U>(fn: (item: T, index: number, array: T[]) => U): U[];
        /**
            * See
            * [Array.filter](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter)
            */
        filter(fn: (item: T, index: number, array: T[]) => boolean): T[];
        /**
            * See
            * [Array.find](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find)
            */
        find(fn: (item: T, index: number, array: T[]) => boolean): T | undefined;
        /**
            * See
            * [Array.reduce](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce)
            */
        reduce<U>(fn: (prevValue: U, curValue: T, curIndex: number, array: T[]) => U, init: U): U;
        /**
            * See
            * [Array.forEach](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach)
            */
        forEach(fn: (item: T, index: number, array: T[]) => void): void;
        /**
            * See
            * [Array.some](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some)
            */
        some(fn: (value: T, index: number, array: T[]) => boolean): boolean;
        toArray(): T[];
        toString(): string;
        reset(res: Array<T | any[]>): void;
        notifyOnChanges(): void;
        /** internal */
        setDirty(): void;
        /** internal */
        destroy(): void;
}

/**
    * @license
    * Copyright Google Inc. All Rights Reserved.
    *
    * Use of this source code is governed by an MIT-style license that can be
    * found in the LICENSE file at https://angular.io/license
    */
import { Compiler } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/linker/compiler';
import { NgModuleFactory } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/linker/ng_module_factory';
import { NgModuleFactoryLoader } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/linker/ng_module_factory_loader';
/**
    * Configuration for SystemJsNgModuleLoader.
    * token.
    *
    * @publicApi
    */
export declare abstract class SystemJsNgModuleLoaderConfig {
        /**
            * Prefix to add when computing the name of the factory module for a given module name.
            */
        factoryPathPrefix: string;
        /**
            * Suffix to add when computing the name of the factory module for a given module name.
            */
        factoryPathSuffix: string;
}
/**
    * NgModuleFactoryLoader that uses SystemJS to load NgModuleFactory
    * @publicApi
    */
export declare class SystemJsNgModuleLoader implements NgModuleFactoryLoader {
        constructor(_compiler: Compiler, config?: SystemJsNgModuleLoaderConfig);
        load(path: string): Promise<NgModuleFactory<any>>;
}

/**
    * @license
    * Copyright Google Inc. All Rights Reserved.
    *
    * Use of this source code is governed by an MIT-style license that can be
    * found in the LICENSE file at https://angular.io/license
    */
import { injectTemplateRef as render3InjectTemplateRef } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/render3/view_engine_compatibility';
import { ElementRef } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/linker/element_ref';
import { EmbeddedViewRef } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/linker/view_ref';
/**
    * Represents an embedded template that can be used to instantiate embedded views.
    * To instantiate embedded views based on a template, use the `ViewContainerRef`
    * method `createEmbeddedView()`.
    *
    * Access a `TemplateRef` instance by placing a directive on an `<ng-template>`
    * element (or directive prefixed with `*`). The `TemplateRef` for the embedded view
    * is injected into the constructor of the directive,
    * using the `TemplateRef` token.
    *
    * You can also use a `Query` to find a `TemplateRef` associated with
    * a component or a directive.
    *
    * @see `ViewContainerRef`
    * @see [Navigate the Component Tree with DI](guide/dependency-injection-navtree)
    *
    * @publicApi
    */
export declare abstract class TemplateRef<C> {
        /**
            * The anchor element in the parent view for this embedded view.
            *
            * The data-binding and injection contexts of embedded views created from this `TemplateRef`
            * inherit from the contexts of this location.
            *
            * Typically new embedded views are attached to the view container of this location, but in
            * advanced use-cases, the view can be attached to a different container while keeping the
            * data-binding and injection context from the original location.
            *
            */
        abstract readonly elementRef: ElementRef;
        /**
            * Creates a view object and attaches it to the view container of the parent view.
            * @param context The context for the new view, inherited from the anchor element.
            * @returns The new view object.
            */
        abstract createEmbeddedView(context: C): EmbeddedViewRef<C>;
}
export declare const SWITCH_TEMPLATE_REF_FACTORY__POST_R3__: typeof render3InjectTemplateRef;

/**
    * @license
    * Copyright Google Inc. All Rights Reserved.
    *
    * Use of this source code is governed by an MIT-style license that can be
    * found in the LICENSE file at https://angular.io/license
    */
import { Injector } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/di/injector';
import { injectViewContainerRef as render3InjectViewContainerRef } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/render3/view_engine_compatibility';
import { ComponentFactory, ComponentRef } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/linker/component_factory';
import { ElementRef } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/linker/element_ref';
import { NgModuleRef } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/linker/ng_module_factory';
import { TemplateRef } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/linker/template_ref';
import { EmbeddedViewRef, ViewRef } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/linker/view_ref';
/**
    * Represents a container where one or more views can be attached to a component.
    *
    * Can contain *host views* (created by instantiating a
    * component with the `createComponent()` method), and *embedded views*
    * (created by instantiating a `TemplateRef` with the `createEmbeddedView()` method).
    *
    * A view container instance can contain other view containers,
    * creating a [view hierarchy](guide/glossary#view-tree).
    *
    * @see `ComponentRef`
    * @see `EmbeddedViewRef`
    *
    * @publicApi
    */
export declare abstract class ViewContainerRef {
        /**
            * Anchor element that specifies the location of this container in the containing view.
            * Each view container can have only one anchor element, and each anchor element
            * can have only a single view container.
            *
            * Root elements of views attached to this container become siblings of the anchor element in
            * the rendered view.
            *
            * Access the `ViewContainerRef` of an element by placing a `Directive` injected
            * with `ViewContainerRef` on the element, or use a `ViewChild` query.
            *
            * <!-- TODO: rename to anchorElement -->
            */
        abstract readonly element: ElementRef;
        /**
            * The [dependency injector](guide/glossary#injector) for this view container.
            */
        abstract readonly injector: Injector;
        /** @deprecated No replacement */
        abstract readonly parentInjector: Injector;
        /**
            * Destroys all views in this container.
            */
        abstract clear(): void;
        /**
            * Retrieves a view from this container.
            * @param index The 0-based index of the view to retrieve.
            * @returns The `ViewRef` instance, or null if the index is out of range.
            */
        abstract get(index: number): ViewRef | null;
        /**
            * Reports how many views are currently attached to this container.
            * @returns The number of views.
            */
        abstract readonly length: number;
        /**
            * Instantiates an embedded view and inserts it
            * into this container.
            * @param templateRef The HTML template that defines the view.
            * @param index The 0-based index at which to insert the new view into this container.
            * If not specified, appends the new view as the last entry.
            *
            * @returns The `ViewRef` instance for the newly created view.
            */
        abstract createEmbeddedView<C>(templateRef: TemplateRef<C>, context?: C, index?: number): EmbeddedViewRef<C>;
        /**
            * Instantiates a single component and inserts its host view into this container.
            *
            * @param componentFactory The factory to use.
            * @param index The index at which to insert the new component's host view into this container.
            * If not specified, appends the new view as the last entry.
            * @param injector The injector to use as the parent for the new component.
            * @param projectableNodes
            * @param ngModule
            *
            * @returns The new component instance, containing the host view.
            *
            */
        abstract createComponent<C>(componentFactory: ComponentFactory<C>, index?: number, injector?: Injector, projectableNodes?: any[][], ngModule?: NgModuleRef<any>): ComponentRef<C>;
        /**
            * Inserts a view into this container.
            * @param viewRef The view to insert.
            * @param index The 0-based index at which to insert the view.
            * If not specified, appends the new view as the last entry.
            * @returns The inserted `ViewRef` instance.
            *
            */
        abstract insert(viewRef: ViewRef, index?: number): ViewRef;
        /**
            * Moves a view to a new location in this container.
            * @param viewRef The view to move.
            * @param index The 0-based index of the new location.
            * @returns The moved `ViewRef` instance.
            */
        abstract move(viewRef: ViewRef, currentIndex: number): ViewRef;
        /**
            * Returns the index of a view within the current container.
            * @param viewRef The view to query.
            * @returns The 0-based index of the view's position in this container,
            * or `-1` if this container doesn't contain the view.
            */
        abstract indexOf(viewRef: ViewRef): number;
        /**
            * Destroys a view attached to this container
            * @param index The 0-based index of the view to destroy.
            * If not specified, the last view in the container is removed.
            */
        abstract remove(index?: number): void;
        /**
            * Detaches a view from this container without destroying it.
            * Use along with `insert()` to move a view within the current container.
            * @param index The 0-based index of the view to detach.
            * If not specified, the last view in the container is detached.
            */
        abstract detach(index?: number): ViewRef | null;
}
export declare const SWITCH_VIEW_CONTAINER_REF_FACTORY__POST_R3__: typeof render3InjectViewContainerRef;

/**
  * @license
  * Copyright Google Inc. All Rights Reserved.
  *
  * Use of this source code is governed by an MIT-style license that can be
  * found in the LICENSE file at https://angular.io/license
  */
export { anchorDef, elementDef } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/view/element';
export { clearOverrides, createNgModuleFactory, overrideComponentView, overrideProvider } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/view/entrypoint';
export { ngContentDef } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/view/ng_content';
export { moduleDef, moduleProvideDef } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/view/ng_module';
export { directiveDef, pipeDef, providerDef } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/view/provider';
export { pureArrayDef, pureObjectDef, purePipeDef } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/view/pure_expression';
export { queryDef } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/view/query';
export { ViewRef_, createComponentFactory, getComponentViewDefinitionFactory, nodeValue } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/view/refs';
export { initServicesIfNeeded } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/view/services';
export { textDef } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/view/text';
export { EMPTY_ARRAY, EMPTY_MAP, createRendererType2, elementEventFullName, inlineInterpolate, interpolate, rootRenderNodes, tokenKey, unwrapValue } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/view/util';
export { viewDef } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/view/view';
export { attachEmbeddedView, detachEmbeddedView, moveEmbeddedView } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/view/view_attach';
export * from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/view/types';

/**
  * @license
  * Copyright Google Inc. All Rights Reserved.
  *
  * Use of this source code is governed by an MIT-style license that can be
  * found in the LICENSE file at https://angular.io/license
  */
import { IterableDiffers } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/change_detection/differs/iterable_differs';
import { KeyValueDiffers } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/change_detection/differs/keyvalue_differs';
export { SimpleChanges } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/metadata/lifecycle_hooks';
export { SimpleChange, WrappedValue, devModeEqual } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/change_detection/change_detection_util';
export { ChangeDetectorRef } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/change_detection/change_detector_ref';
export { ChangeDetectionStrategy, ChangeDetectorStatus, isDefaultChangeDetectionStrategy } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/change_detection/constants';
export { DefaultIterableDifferFactory } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/change_detection/differs/default_iterable_differ';
export { DefaultIterableDiffer } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/change_detection/differs/default_iterable_differ';
export { DefaultKeyValueDifferFactory } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/change_detection/differs/default_keyvalue_differ';
export { CollectionChangeRecord, IterableChangeRecord, IterableChanges, IterableDiffer, IterableDifferFactory, IterableDiffers, NgIterable, TrackByFunction } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/change_detection/differs/iterable_differs';
export { KeyValueChangeRecord, KeyValueChanges, KeyValueDiffer, KeyValueDifferFactory, KeyValueDiffers } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/change_detection/differs/keyvalue_differs';
export { PipeTransform } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/change_detection/pipe_transform';
export declare const defaultIterableDiffers: IterableDiffers;
export declare const defaultKeyValueDiffers: KeyValueDiffers;

/**
    * A scope function for the Web Tracing Framework (WTF).
    *
    * @publicApi
    */
export interface WtfScopeFn {
        (arg0?: any, arg1?: any): any;
}
export interface Range {
}
export interface Scope {
        (...args: any[] /** TODO #9100 */): any;
}
export declare function detectWTF(): boolean;
export declare function createScope(signature: string, flags?: any): any;
export declare function leave<T>(scope: Scope): void;
export declare function leave<T>(scope: Scope, returnValue?: T): T;
export declare function startTimeRange(rangeType: string, action: string): Range;
export declare function endTimeRange(range: Range): void;

/**
    * @license
    * Copyright Google Inc. All Rights Reserved.
    *
    * Use of this source code is governed by an MIT-style license that can be
    * found in the LICENSE file at https://angular.io/license
    */
export declare function devModeEqual(a: any, b: any): boolean;
/**
    * Indicates that the result of a {@link Pipe} transformation has changed even though the
    * reference has not changed.
    *
    * Wrapped values are unwrapped automatically during the change detection, and the unwrapped value
    * is stored.
    *
    * Example:
    *
    * ```
    * if (this._latestValue === this._latestReturnedValue) {
    *    return this._latestReturnedValue;
    *  } else {
    *    this._latestReturnedValue = this._latestValue;
    *    return WrappedValue.wrap(this._latestValue); // this will force update
    *  }
    * ```
    *
    * @publicApi
    */
export declare class WrappedValue {
        /** @deprecated from 5.3, use `unwrap()` instead - will switch to protected */
        wrapped: any;
        constructor(value: any);
        /** Creates a wrapped value. */
        static wrap(value: any): WrappedValue;
        /**
            * Returns the underlying value of a wrapped value.
            * Returns the given `value` when it is not wrapped.
            **/
        static unwrap(value: any): any;
        /** Returns true if `value` is a wrapped value. */
        static isWrapped(value: any): value is WrappedValue;
}
/**
    * Represents a basic change from a previous to a new value.
    *
    * @publicApi
    */
export declare class SimpleChange {
        previousValue: any;
        currentValue: any;
        firstChange: boolean;
        constructor(previousValue: any, currentValue: any, firstChange: boolean);
        /**
            * Check whether the new value is the first value assigned.
            */
        isFirstChange(): boolean;
}
export declare function isListLikeIterable(obj: any): boolean;
export declare function areIterablesEqual(a: any, b: any, comparator: (a: any, b: any) => boolean): boolean;
export declare function iterateListLike(obj: any, fn: (p: any) => any): void;
export declare function isJsObject(o: any): boolean;

/**
    * The strategy that the default change detector uses to detect changes.
    * When set, takes effect the next time change detection is triggered.
    *
    * @publicApi
    */
export declare enum ChangeDetectionStrategy {
        /**
            * Use the `CheckOnce` strategy, meaning that automatic change detection is deactivated
            * until reactivated by setting the strategy to `Default` (`CheckAlways`).
            * Change detection can still be explictly invoked.
            */
        OnPush = 0,
        /**
            * Use the default `CheckAlways` strategy, in which change detection is automatic until
            * explicitly deactivated.
            */
        Default = 1
}
/**
    * Defines the possible states of the default change detector.
    * @see `ChangeDetectorRef`
    */
export declare enum ChangeDetectorStatus {
        /**
            * A state in which, after calling `detectChanges()`, the change detector
            * state becomes `Checked`, and must be explicitly invoked or reactivated.
            */
        CheckOnce = 0,
        /**
            * A state in which change detection is skipped until the change detector mode
            * becomes `CheckOnce`.
            */
        Checked = 1,
        /**
            * A state in which change detection continues automatically until explictly
            * deactivated.
            */
        CheckAlways = 2,
        /**
            * A state in which a change detector sub tree is not a part of the main tree and
            * should be skipped.
            */
        Detached = 3,
        /**
            * Indicates that the change detector encountered an error checking a binding
            * or calling a directive lifecycle method and is now in an inconsistent state. Change
            * detectors in this state do not detect changes.
            */
        Errored = 4,
        /**
            * Indicates that the change detector has been destroyed.
            */
        Destroyed = 5
}
/**
    * Reports whether a given strategy is currently the default for change detection.
    * @param changeDetectionStrategy The strategy to check.
    * @returns True if the given strategy is the current default, false otherwise.
    * @see `ChangeDetectorStatus`
    * @see `ChangeDetectorRef`
    */
export declare function isDefaultChangeDetectionStrategy(changeDetectionStrategy: ChangeDetectionStrategy): boolean;

/**
  * @license
  * Copyright Google Inc. All Rights Reserved.
  *
  * Use of this source code is governed by an MIT-style license that can be
  * found in the LICENSE file at https://angular.io/license
  */
export declare class Console {
    log(message: string): void;
    warn(message: string): void;
}

/**
    * @license
    * Copyright Google Inc. All Rights Reserved.
    *
    * Use of this source code is governed by an MIT-style license that can be
    * found in the LICENSE file at https://angular.io/license
    */
import { InjectionToken } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/di/injection_token';
/**
    * An internal token whose presence in an injector indicates that the injector should treat itself
    * as a root scoped injector when processing requests for unknown tokens which may indicate
    * they are provided in the root scope.
    */
export declare const APP_ROOT: InjectionToken<boolean>;

/**
  * @license
  * Copyright Google Inc. All Rights Reserved.
  *
  * Use of this source code is governed by an MIT-style license that can be
  * found in the LICENSE file at https://angular.io/license
  */
export declare const SWITCH_IVY_ENABLED__POST_R3__ = true;
export declare const ivyEnabled = false;

/**
    * @license
    * Copyright Google Inc. All Rights Reserved.
    *
    * Use of this source code is governed by an MIT-style license that can be
    * found in the LICENSE file at https://angular.io/license
    */
import { Component } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/metadata/directives';
/**
    * Used to resolve resource URLs on `@Component` when used with JIT compilation.
    *
    * Example:
    * ```
    * @Component({
    *   selector: 'my-comp',
    *   templateUrl: 'my-comp.html', // This requires asynchronous resolution
    * })
    * class MyComponnent{
    * }
    *
    * // Calling `renderComponent` will fail because `MyComponent`'s `@Compenent.templateUrl`
    * // needs to be resolved because `renderComponent` is synchronous process.
    * // renderComponent(MyComponent);
    *
    * // Calling `resolveComponentResources` will resolve `@Compenent.templateUrl` into
    * // `@Compenent.template`, which would allow `renderComponent` to proceed in synchronous manner.
    * // Use browser's `fetch` function as the default resource resolution strategy.
    * resolveComponentResources(fetch).then(() => {
    *   // After resolution all URLs have been converted into strings.
    *   renderComponent(MyComponent);
    * });
    *
    * ```
    *
    * NOTE: In AOT the resolution happens during compilation, and so there should be no need
    * to call this method outside JIT mode.
    *
    * @param resourceResolver a function which is responsible to returning a `Promise` of the resolved
    * URL. Browser's `fetch` method is a good default implementation.
    */
export declare function resolveComponentResources(resourceResolver: (url: string) => (Promise<string | {
        text(): Promise<string>;
}>)): Promise<null>;
export declare function maybeQueueResolutionOfComponentResources(metadata: Component): void;
export declare function componentNeedsResolution(component: Component): string | number | undefined;
export declare function clearResolutionOfComponentResourcesQueue(): void;

/**
    * @license
    * Copyright Google Inc. All Rights Reserved.
    *
    * Use of this source code is governed by an MIT-style license that can be
    * found in the LICENSE file at https://angular.io/license
    */
import { Type } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/type';
import { PlatformReflectionCapabilities } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/reflection/platform_reflection_capabilities';
import { GetterFn, MethodFn, SetterFn } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/reflection/types';
/**
    * Attention: These regex has to hold even if the code is minified!
    */
export declare const DELEGATE_CTOR: RegExp;
export declare const INHERITED_CLASS: RegExp;
export declare const INHERITED_CLASS_WITH_CTOR: RegExp;
export declare class ReflectionCapabilities implements PlatformReflectionCapabilities {
        constructor(reflect?: any);
        isReflectionEnabled(): boolean;
        factory<T>(t: Type<T>): (args: any[]) => T;
        parameters(type: Type<any>): any[][];
        annotations(typeOrFunc: Type<any>): any[];
        propMetadata(typeOrFunc: any): {
                [key: string]: any[];
        };
        hasLifecycleHook(type: any, lcProperty: string): boolean;
        guards(type: any): {
                [key: string]: any;
        };
        getter(name: string): GetterFn;
        setter(name: string): SetterFn;
        method(name: string): MethodFn;
        importUri(type: any): string;
        resourceUri(type: any): string;
        resolveIdentifier(name: string, moduleUrl: string, members: string[], runtime: any): any;
        resolveEnum(enumIdentifier: any, name: string): any;
}

/**
  * @license
  * Copyright Google Inc. All Rights Reserved.
  *
  * Use of this source code is governed by an MIT-style license that can be
  * found in the LICENSE file at https://angular.io/license
  */
export declare type SetterFn = (obj: any, value: any) => void;
export declare type GetterFn = (obj: any) => any;
export declare type MethodFn = (obj: any, args: any[]) => any;

/**
    * @license
    * Copyright Google Inc. All Rights Reserved.
    *
    * Use of this source code is governed by an MIT-style license that can be
    * found in the LICENSE file at https://angular.io/license
    */
export declare const VALID_ELEMENTS: {
        [k: string]: boolean;
};
export declare const URI_ATTRS: {
        [k: string]: boolean;
};
export declare const SRCSET_ATTRS: {
        [k: string]: boolean;
};
export declare const VALID_ATTRS: {
        [k: string]: boolean;
};
/**
    * Sanitizes the given unsafe, untrusted HTML fragment, and returns HTML text that is safe to add to
    * the DOM in a browser environment.
    */
export declare function _sanitizeHtml(defaultDoc: any, unsafeHtmlInput: string): string;
export declare function getTemplateContent(el: Node): Node | null;

/**
    * Sanitizes the given untrusted CSS style property value (i.e. not an entire object, just a single
    * value) and returns a value that is safe to use in a browser environment.
    */
export declare function _sanitizeStyle(value: string): string;
/**
    * Used to intercept and sanitize style values before they are written to the renderer.
    *
    * This function is designed to be called in two modes. When a value is not provided
    * then the function will return a boolean whether a property will be sanitized later.
    * If a value is provided then the sanitized version of that will be returned.
    */
export interface StyleSanitizeFn {
        /** This mode is designed to instruct whether the property will be used for sanitization
            * at a later point */
        (prop: string): boolean;
        /** This mode is designed to sanitize the provided value */
        (prop: string, value: string): string;
}

/**
  * @license
  * Copyright Google Inc. All Rights Reserved.
  *
  * Use of this source code is governed by an MIT-style license that can be
  * found in the LICENSE file at https://angular.io/license
  */
export declare function _sanitizeUrl(url: string): string;
export declare function sanitizeSrcset(srcset: string): string;

/**
    * @license
    * Copyright Google Inc. All Rights Reserved.
    *
    * Use of this source code is governed by an MIT-style license that can be
    * found in the LICENSE file at https://angular.io/license
    */
declare const _global: {
        [name: string]: any;
};
/**
    * Attention: whenever providing a new value, be sure to add an
    * entry into the corresponding `....externs.js` file,
    * so that closure won't use that global for its purposes.
    */
export { _global as global };
export declare function getSymbolIterator(): string | symbol;
export declare function scheduleMicroTask(fn: Function): void;
export declare function looseIdentical(a: any, b: any): boolean;
export declare function stringify(token: any): string;
/**
    * Convince closure compiler that the wrapped function has no side-effects.
    *
    * Closure compiler always assumes that `toString` has no side-effects. We use this quirk to
    * allow us to execute a function but have closure compiler mark the call as no-side-effects.
    * It is important that the return value for the `noSideEffects` function be assigned
    * to something which is retained otherwise the call to `noSideEffects` will be removed by closure
    * compiler.
    */
export declare function noSideEffects(fn: () => void): string;

/**
    * @license
    * Copyright Google Inc. All Rights Reserved.
    *
    * Use of this source code is governed by an MIT-style license that can be
    * found in the LICENSE file at https://angular.io/license
    */
import { Observable } from 'rxjs';
/**
    * Determine if the argument is shaped like a Promise
    */
export declare function isPromise(obj: any): obj is Promise<any>;
/**
    * Determine if the argument is an Observable
    */
export declare function isObservable(obj: any | Observable<any>): obj is Observable<any>;

/**
  * @license
  * Copyright Google Inc. All Rights Reserved.
  *
  * Use of this source code is governed by an MIT-style license that can be
  * found in the LICENSE file at https://angular.io/license
  */
import { BindingDef, DepDef, DepFlags, NodeDef, NodeFlags, OutputDef, QueryValueType, ViewData } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/view/types';
export declare function directiveDef(checkIndex: number, flags: NodeFlags, matchedQueries: null | [string | number, QueryValueType][], childCount: number, ctor: any, deps: ([DepFlags, any] | any)[], props?: null | {
    [name: string]: [number, string];
}, outputs?: null | {
    [name: string]: string;
}): NodeDef;
export declare function pipeDef(flags: NodeFlags, ctor: any, deps: ([DepFlags, any] | any)[]): NodeDef;
export declare function providerDef(flags: NodeFlags, matchedQueries: null | [string | number, QueryValueType][], token: any, value: any, deps: ([DepFlags, any] | any)[]): NodeDef;
export declare function _def(checkIndex: number, flags: NodeFlags, matchedQueriesDsl: [string | number, QueryValueType][] | null, childCount: number, token: any, value: any, deps: ([DepFlags, any] | any)[], bindings?: BindingDef[], outputs?: OutputDef[]): NodeDef;
export declare function createProviderInstance(view: ViewData, def: NodeDef): any;
export declare function createPipeInstance(view: ViewData, def: NodeDef): any;
export declare function createDirectiveInstance(view: ViewData, def: NodeDef): any;
export declare function checkAndUpdateDirectiveInline(view: ViewData, def: NodeDef, v0: any, v1: any, v2: any, v3: any, v4: any, v5: any, v6: any, v7: any, v8: any, v9: any): boolean;
export declare function checkAndUpdateDirectiveDynamic(view: ViewData, def: NodeDef, values: any[]): boolean;
export declare const NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR: {};
export declare function resolveDep(view: ViewData, elDef: NodeDef, allowPrivateServices: boolean, depDef: DepDef, notFoundValue?: any): any;
export declare function callLifecycleHooksChildrenFirst(view: ViewData, lifecycles: NodeFlags): void;

/**
  * @license
  * Copyright Google Inc. All Rights Reserved.
  *
  * Use of this source code is governed by an MIT-style license that can be
  * found in the LICENSE file at https://angular.io/license
  */
import { LifecycleHooksFeature, renderComponent, whenRendered } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/render3/component';
import { defineBase, defineComponent, defineDirective, defineNgModule, definePipe } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/render3/definition';
import { getHostElement, getRenderedText } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/render3/discovery_utils';
import { InheritDefinitionFeature } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/render3/features/inherit_definition_feature';
import { NgOnChangesFeature } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/render3/features/ng_onchanges_feature';
import { ProvidersFeature } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/render3/features/providers_feature';
import { BaseDef, ComponentDef, ComponentDefWithMeta, ComponentTemplate, ComponentType, DirectiveDef, DirectiveDefFlags, DirectiveDefWithMeta, DirectiveType, PipeDef, PipeDefWithMeta } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/render3/interfaces/definition';
export { ComponentFactory, ComponentFactoryResolver, ComponentRef, WRAP_RENDERER_FACTORY2, injectComponentFactoryResolver } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/render3/component_ref';
export { getFactoryOf, getInheritedFactory } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/render3/di';
export { RenderFlags } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/render3/interfaces/definition';
export { CssSelectorList } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/render3/interfaces/projection';
export { bind, interpolation1, interpolation2, interpolation3, interpolation4, interpolation5, interpolation6, interpolation7, interpolation8, interpolationV, container, containerRefreshStart, containerRefreshEnd, nextContext, element, elementAttribute, elementClassProp, elementEnd, elementProperty, elementStart, elementContainerStart, elementContainerEnd, elementStyling, elementStylingMap, elementStyleProp, elementStylingApply, listener, store, load, namespaceHTML, namespaceMathML, namespaceSVG, projection, projectionDef, text, textBinding, template, reference, embeddedViewStart, embeddedViewEnd, detectChanges, markDirty, tick, directiveInject, injectAttribute, } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/render3/instructions';
export { getCurrentView, restoreView, enableBindings, disableBindings, } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/render3/state';
export { i18n, i18nAttributes, i18nExp, i18nStart, i18nEnd, i18nApply, i18nPostprocess } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/render3/i18n';
export { NgModuleFactory, NgModuleRef, NgModuleType } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/render3/ng_module_ref';
export { AttributeMarker } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/render3/interfaces/node';
export { setClassMetadata, } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/render3/metadata';
export { pipe, pipeBind1, pipeBind2, pipeBind3, pipeBind4, pipeBindV, } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/render3/pipe';
export { QueryList, query, queryRefresh, } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/render3/query';
export { registerContentQuery, loadQueryList, } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/render3/instructions';
export { pureFunction0, pureFunction1, pureFunction2, pureFunction3, pureFunction4, pureFunction5, pureFunction6, pureFunction7, pureFunction8, pureFunctionV, } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/render3/pure_function';
export { templateRefExtractor } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/render3/view_engine_compatibility_prebound';
export { BaseDef, ComponentDef, ComponentDefWithMeta, ComponentTemplate, ComponentType, DirectiveDef, DirectiveDefFlags, DirectiveDefWithMeta, DirectiveType, NgOnChangesFeature, InheritDefinitionFeature, ProvidersFeature, PipeDef, PipeDefWithMeta, LifecycleHooksFeature, defineComponent, defineDirective, defineNgModule, defineBase, definePipe, getHostElement, getRenderedText, renderComponent, whenRendered, };
export { NO_CHANGE } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/render3/tokens';

/**
    * @license
    * Copyright Google Inc. All Rights Reserved.
    *
    * Use of this source code is governed by an MIT-style license that can be
    * found in the LICENSE file at https://angular.io/license
    */
import { Renderer2, RendererType2 } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/render/api';
import { DebugRendererFactory2 } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/view/services';
/**
    * Adapts the DebugRendererFactory2 to create a DebugRenderer2 specific for IVY.
    *
    * The created DebugRenderer know how to create a Debug Context specific to IVY.
    */
export declare class Render3DebugRendererFactory2 extends DebugRendererFactory2 {
        createRenderer(element: any, renderData: RendererType2 | null): Renderer2;
}

/**
    * @license
    * Copyright Google Inc. All Rights Reserved.
    *
    * Use of this source code is governed by an MIT-style license that can be
    * found in the LICENSE file at https://angular.io/license
    */
import { Query } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/metadata/di';
import { Component, Directive } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/metadata/directives';
import { Type } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/type';
import { R3QueryMetadataFacade } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/render3/jit/compiler_facade_interface';
/**
    * Compile an Angular component according to its decorator metadata, and patch the resulting
    * ngComponentDef onto the component type.
    *
    * Compilation may be asynchronous (due to the need to resolve URLs for the component template or
    * other resources, for example). In the event that compilation is not immediate, `compileComponent`
    * will enqueue resource resolution into a global queue and will fail to return the `ngComponentDef`
    * until the global queue has been resolved with a call to `resolveComponentResources`.
    */
export declare function compileComponent(type: Type<any>, metadata: Component): void;
/**
    * Compile an Angular directive according to its decorator metadata, and patch the resulting
    * ngDirectiveDef onto the component type.
    *
    * In the event that compilation is not immediate, `compileDirective` will return a `Promise` which
    * will resolve when compilation completes and the directive becomes usable.
    */
export declare function compileDirective(type: Type<any>, directive: Directive): void;
export declare function extendsDirectlyFromObject(type: Type<any>): boolean;
export declare function convertToR3QueryMetadata(propertyName: string, ann: Query): R3QueryMetadataFacade;

/**
    * @license
    * Copyright Google Inc. All Rights Reserved.
    *
    * Use of this source code is governed by an MIT-style license that can be
    * found in the LICENSE file at https://angular.io/license
    */
import { NgModule, NgModuleTransitiveScopes } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/metadata/ng_module';
import { Type } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/type';
import { ComponentDef } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/render3/interfaces/definition';
/**
    * Compiles a module in JIT mode.
    *
    * This function automatically gets called when a class has a `@NgModule` decorator.
    */
export declare function compileNgModule(moduleType: Type<any>, ngModule: NgModule): void;
/**
    * Compiles and adds the `ngModuleDef` and `ngInjectorDef` properties to the module class.
    */
export declare function compileNgModuleDefs(moduleType: Type<any>, ngModule: NgModule): void;
/**
    * Patch the definition of a component with directives and pipes from the compilation scope of
    * a given module.
    */
export declare function patchComponentDefWithScope<C>(componentDef: ComponentDef<C>, transitiveScopes: NgModuleTransitiveScopes): void;
/**
    * Compute the pair of transitive scopes (compilation scope and exported scope) for a given module.
    *
    * This operation is memoized and the result is cached on the module's definition. It can be called
    * on modules with components that have not fully compiled yet, but the result should not be used
    * until they have.
    */
export declare function transitiveScopesFor<T>(moduleType: Type<T>): NgModuleTransitiveScopes;

/**
  * @license
  * Copyright Google Inc. All Rights Reserved.
  *
  * Use of this source code is governed by an MIT-style license that can be
  * found in the LICENSE file at https://angular.io/license
  */
import { Pipe } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/metadata/directives';
import { Type } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/type';
export declare function compilePipe(type: Type<any>, meta: Pipe): void;

/**
    * @license
    * Copyright Google Inc. All Rights Reserved.
    *
    * Use of this source code is governed by an MIT-style license that can be
    * found in the LICENSE file at https://angular.io/license
    */
import { StyleSanitizeFn } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/sanitization/style_sanitizer';
/**
    * An `html` sanitizer which converts untrusted `html` **string** into trusted string by removing
    * dangerous content.
    *
    * This method parses the `html` and locates potentially dangerous content (such as urls and
    * javascript) and removes it.
    *
    * It is possible to mark a string as trusted by calling {@link bypassSanitizationTrustHtml}.
    *
    * @param unsafeHtml untrusted `html`, typically from the user.
    * @returns `html` string which is safe to display to user, because all of the dangerous javascript
    * and urls have been removed.
    */
export declare function sanitizeHtml(unsafeHtml: any): string;
/**
    * A `style` sanitizer which converts untrusted `style` **string** into trusted string by removing
    * dangerous content.
    *
    * This method parses the `style` and locates potentially dangerous content (such as urls and
    * javascript) and removes it.
    *
    * It is possible to mark a string as trusted by calling {@link bypassSanitizationTrustStyle}.
    *
    * @param unsafeStyle untrusted `style`, typically from the user.
    * @returns `style` string which is safe to bind to the `style` properties, because all of the
    * dangerous javascript and urls have been removed.
    */
export declare function sanitizeStyle(unsafeStyle: any): string;
/**
    * A `url` sanitizer which converts untrusted `url` **string** into trusted string by removing
    * dangerous
    * content.
    *
    * This method parses the `url` and locates potentially dangerous content (such as javascript) and
    * removes it.
    *
    * It is possible to mark a string as trusted by calling {@link bypassSanitizationTrustUrl}.
    *
    * @param unsafeUrl untrusted `url`, typically from the user.
    * @returns `url` string which is safe to bind to the `src` properties such as `<img src>`, because
    * all of the dangerous javascript has been removed.
    */
export declare function sanitizeUrl(unsafeUrl: any): string;
/**
    * A `url` sanitizer which only lets trusted `url`s through.
    *
    * This passes only `url`s marked trusted by calling {@link bypassSanitizationTrustResourceUrl}.
    *
    * @param unsafeResourceUrl untrusted `url`, typically from the user.
    * @returns `url` string which is safe to bind to the `src` properties such as `<img src>`, because
    * only trusted `url`s have been allowed to pass.
    */
export declare function sanitizeResourceUrl(unsafeResourceUrl: any): string;
/**
    * A `script` sanitizer which only lets trusted javascript through.
    *
    * This passes only `script`s marked trusted by calling {@link bypassSanitizationTrustScript}.
    *
    * @param unsafeScript untrusted `script`, typically from the user.
    * @returns `url` string which is safe to bind to the `<script>` element such as `<img src>`,
    * because only trusted `scripts`s have been allowed to pass.
    */
export declare function sanitizeScript(unsafeScript: any): string;
/**
    * The default style sanitizer will handle sanitization for style properties by
    * sanitizing any CSS property that can include a `url` value (usually image-based properties)
    */
export declare const defaultStyleSanitizer: StyleSanitizeFn;

/**
    * @license
    * Copyright Google Inc. All Rights Reserved.
    *
    * Use of this source code is governed by an MIT-style license that can be
    * found in the LICENSE file at https://angular.io/license
    */
declare const BRAND = "__SANITIZER_TRUSTED_BRAND__";
export declare const enum BypassType {
        Url = "Url",
        Html = "Html",
        ResourceUrl = "ResourceUrl",
        Script = "Script",
        Style = "Style"
}
/**
    * A branded trusted string used with sanitization.
    *
    * See: {@link TrustedHtmlString}, {@link TrustedResourceUrlString}, {@link TrustedScriptString},
    * {@link TrustedStyleString}, {@link TrustedUrlString}
    */
export interface TrustedString extends String {
        [BRAND]: BypassType;
}
/**
    * A branded trusted string used with sanitization of `html` strings.
    *
    * See: {@link bypassSanitizationTrustHtml} and {@link htmlSanitizer}.
    */
export interface TrustedHtmlString extends TrustedString {
        [BRAND]: BypassType.Html;
}
/**
    * A branded trusted string used with sanitization of `style` strings.
    *
    * See: {@link bypassSanitizationTrustStyle} and {@link styleSanitizer}.
    */
export interface TrustedStyleString extends TrustedString {
        [BRAND]: BypassType.Style;
}
/**
    * A branded trusted string used with sanitization of `url` strings.
    *
    * See: {@link bypassSanitizationTrustScript} and {@link scriptSanitizer}.
    */
export interface TrustedScriptString extends TrustedString {
        [BRAND]: BypassType.Script;
}
/**
    * A branded trusted string used with sanitization of `url` strings.
    *
    * See: {@link bypassSanitizationTrustUrl} and {@link urlSanitizer}.
    */
export interface TrustedUrlString extends TrustedString {
        [BRAND]: BypassType.Url;
}
/**
    * A branded trusted string used with sanitization of `resourceUrl` strings.
    *
    * See: {@link bypassSanitizationTrustResourceUrl} and {@link resourceUrlSanitizer}.
    */
export interface TrustedResourceUrlString extends TrustedString {
        [BRAND]: BypassType.ResourceUrl;
}
export declare function allowSanitizationBypass(value: any, type: BypassType): boolean;
/**
    * Mark `html` string as trusted.
    *
    * This function wraps the trusted string in `String` and brands it in a way which makes it
    * recognizable to {@link htmlSanitizer} to be trusted implicitly.
    *
    * @param trustedHtml `html` string which needs to be implicitly trusted.
    * @returns a `html` `String` which has been branded to be implicitly trusted.
    */
export declare function bypassSanitizationTrustHtml(trustedHtml: string): TrustedHtmlString;
/**
    * Mark `style` string as trusted.
    *
    * This function wraps the trusted string in `String` and brands it in a way which makes it
    * recognizable to {@link styleSanitizer} to be trusted implicitly.
    *
    * @param trustedStyle `style` string which needs to be implicitly trusted.
    * @returns a `style` `String` which has been branded to be implicitly trusted.
    */
export declare function bypassSanitizationTrustStyle(trustedStyle: string): TrustedStyleString;
/**
    * Mark `script` string as trusted.
    *
    * This function wraps the trusted string in `String` and brands it in a way which makes it
    * recognizable to {@link scriptSanitizer} to be trusted implicitly.
    *
    * @param trustedScript `script` string which needs to be implicitly trusted.
    * @returns a `script` `String` which has been branded to be implicitly trusted.
    */
export declare function bypassSanitizationTrustScript(trustedScript: string): TrustedScriptString;
/**
    * Mark `url` string as trusted.
    *
    * This function wraps the trusted string in `String` and brands it in a way which makes it
    * recognizable to {@link urlSanitizer} to be trusted implicitly.
    *
    * @param trustedUrl `url` string which needs to be implicitly trusted.
    * @returns a `url` `String` which has been branded to be implicitly trusted.
    */
export declare function bypassSanitizationTrustUrl(trustedUrl: string): TrustedUrlString;
/**
    * Mark `url` string as trusted.
    *
    * This function wraps the trusted string in `String` and brands it in a way which makes it
    * recognizable to {@link resourceUrlSanitizer} to be trusted implicitly.
    *
    * @param trustedResourceUrl `url` string which needs to be implicitly trusted.
    * @returns a `url` `String` which has been branded to be implicitly trusted.
    */
export declare function bypassSanitizationTrustResourceUrl(trustedResourceUrl: string): TrustedResourceUrlString;
export {};

/**
    * @license
    * Copyright Google Inc. All Rights Reserved.
    *
    * Use of this source code is governed by an MIT-style license that can be
    * found in the LICENSE file at https://angular.io/license
    */
import './ng_dev_mode';
import { LContext } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/render3/interfaces/context';
import { LViewData } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/render3/interfaces/view';
/** Returns the matching `LContext` data for a given DOM node, directive or component instance.
    *
    * This function will examine the provided DOM element, component, or directive instance\'s
    * monkey-patched property to derive the `LContext` data. Once called then the monkey-patched
    * value will be that of the newly created `LContext`.
    *
    * If the monkey-patched value is the `LViewData` instance then the context value for that
    * target will be created and the monkey-patch reference will be updated. Therefore when this
    * function is called it may mutate the provided element\'s, component\'s or any of the associated
    * directive\'s monkey-patch values.
    *
    * If the monkey-patch value is not detected then the code will walk up the DOM until an element
    * is found which contains a monkey-patch reference. When that occurs then the provided element
    * will be updated with a new context (which is then returned). If the monkey-patch value is not
    * detected for a component/directive instance then it will throw an error (all components and
    * directives should be automatically monkey-patched by ivy).
    *
    * @param target Component, Directive or DOM Node.
    */
export declare function getContext(target: any): LContext | null;
/**
    * Takes a component instance and returns the view for that component.
    *
    * @param componentInstance
    * @returns The component's view
    */
export declare function getComponentViewByInstance(componentInstance: {}): LViewData;
/**
    * Assigns the given data to the given target (which could be a component,
    * directive or DOM node instance) using monkey-patching.
    */
export declare function attachPatchData(target: any, data: LViewData | LContext): void;
export declare function isComponentInstance(instance: any): boolean;
export declare function isDirectiveInstance(instance: any): boolean;
/**
    * Returns a list of directives extracted from the given view based on the
    * provided list of directive index values.
    *
    * @param nodeIndex The node index
    * @param lViewData The target view data
    * @param includeComponents Whether or not to include components in returned directives
    */
export declare function getDirectivesAtNodeIndex(nodeIndex: number, lViewData: LViewData, includeComponents: boolean): any[] | null;
export declare function getComponentAtNodeIndex(nodeIndex: number, lViewData: LViewData): {} | null;
/**
    * Returns a map of local references (local reference name => element or directive instance) that
    * exist on a given element.
    */
export declare function discoverLocalRefs(lViewData: LViewData, nodeIndex: number): {
        [key: string]: any;
} | null;

/**
    * A shared interface which contains an animation player
    */
export interface Player {
        parent?: Player | null;
        state: PlayState;
        play(): void;
        pause(): void;
        finish(): void;
        destroy(): void;
        addEventListener(state: PlayState | string, cb: (data?: any) => any): void;
}
export declare const enum BindingType {
        Unset = 0,
        Class = 1,
        Style = 2
}
export interface BindingStore {
        setValue(prop: string, value: any): void;
}
/**
    * Defines the shape which produces the Player.
    *
    * Used to produce a player that will be placed on an element that contains
    * styling bindings that make use of the player. This function is designed
    * to be used with `PlayerFactory`.
    */
export interface PlayerFactoryBuildFn {
        (element: HTMLElement, type: BindingType, values: {
                [key: string]: any;
        }, isFirstRender: boolean, currentPlayer: Player | null): Player | null;
}
/**
    * Used as a reference to build a player from a styling template binding
    * (`[style]` and `[class]`).
    *
    * The `fn` function will be called once any styling-related changes are
    * evaluated on an element and is expected to return a player that will
    * be then run on the element.
    *
    * `[style]`, `[style.prop]`, `[class]` and `[class.name]` template bindings
    * all accept a `PlayerFactory` as input and this player factories.
    */
export interface PlayerFactory {
        '__brand__': 'Brand for PlayerFactory that nothing will match';
}
export interface PlayerBuilder extends BindingStore {
        buildPlayer(currentPlayer: Player | null, isFirstRender: boolean): Player | undefined | null;
}
/**
    * The state of a given player
    *
    * Do not change the increasing nature of the numbers since the player
    * code may compare state by checking if a number is higher or lower than
    * a certain numeric value.
    */
export declare const enum PlayState {
        Pending = 0,
        Running = 1,
        Paused = 2,
        Finished = 100,
        Destroyed = 200
}
/**
    * The context that stores all the active players and queued player factories present on an element.
    */
export interface PlayerContext extends Array<null | number | Player | PlayerBuilder> {
        [PlayerIndex.NonBuilderPlayersStart]: number;
        [PlayerIndex.ClassMapPlayerBuilderPosition]: PlayerBuilder | null;
        [PlayerIndex.ClassMapPlayerPosition]: Player | null;
        [PlayerIndex.StyleMapPlayerBuilderPosition]: PlayerBuilder | null;
        [PlayerIndex.StyleMapPlayerPosition]: Player | null;
}
/**
    * Designed to be used as an injection service to capture all animation players.
    *
    * When present all animation players will be passed into the flush method below.
    * This feature is designed to service application-wide animation testing, live
    * debugging as well as custom animation choreographing tools.
    */
export interface PlayerHandler {
        /**
            * Designed to kick off the player at the end of change detection
            */
        flushPlayers(): void;
        /**
            * @param player The player that has been scheduled to run within the application.
            * @param context The context as to where the player was bound to
            */
        queuePlayer(player: Player, context: ComponentInstance | DirectiveInstance | HTMLElement): void;
}
export declare const enum PlayerIndex {
        NonBuilderPlayersStart = 0,
        ClassMapPlayerBuilderPosition = 1,
        ClassMapPlayerPosition = 2,
        StyleMapPlayerBuilderPosition = 3,
        StyleMapPlayerPosition = 4,
        PlayerBuildersStartPosition = 1,
        SinglePlayerBuildersStartPosition = 5,
        PlayerAndPlayerBuildersTupleSize = 2,
        PlayerOffsetPosition = 1
}
export declare type ComponentInstance = {};
export declare type DirectiveInstance = {};

/**
    * @license
    * Copyright Google Inc. All Rights Reserved.
    *
    * Use of this source code is governed by an MIT-style license that can be
    * found in the LICENSE file at https://angular.io/license
    */
import { RElement } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/render3/interfaces/renderer';
import { LViewData } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/render3/interfaces/view';
/**
    * This property will be monkey-patched on elements, components and directives
    */
export declare const MONKEY_PATCH_KEY_NAME = "__ngContext__";
/**
    * The internal view context which is specific to a given DOM element, directive or
    * component instance. Each value in here (besides the LViewData and element node details)
    * can be present, null or undefined. If undefined then it implies the value has not been
    * looked up yet, otherwise, if null, then a lookup was executed and nothing was found.
    *
    * Each value will get filled when the respective value is examined within the getContext
    * function. The component, element and each directive instance will share the same instance
    * of the context.
    */
export interface LContext {
        /**
            * The component's parent view data.
            */
        lViewData: LViewData;
        /**
            * The index instance of the node.
            */
        nodeIndex: number;
        /**
            * The instance of the DOM node that is attached to the lNode.
            */
        native: RElement;
        /**
            * The instance of the Component node.
            */
        component: {} | null | undefined;
        /**
            * The list of active directives that exist on this element.
            */
        directives: any[] | null | undefined;
        /**
            * The map of local references (local reference name => element or directive instance) that exist
            * on this element.
            */
        localRefs: {
                [key: string]: any;
        } | null | undefined;
}

/**
    * @license
    * Copyright Google Inc. All Rights Reserved.
    *
    * Use of this source code is governed by an MIT-style license that can be
    * found in the LICENSE file at https://angular.io/license
    */
import { PlayerFactory, PlayerFactoryBuildFn } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/render3/interfaces/player';
/**
    * Combines the binding value and a factory for an animation player.
    *
    * Used to bind a player to an element template binding (currently only
    * `[style]`, `[style.prop]`, `[class]` and `[class.name]` bindings
    * supported). The provided `factoryFn` function will be run once all
    * the associated bindings have been evaluated on the element and is
    * designed to return a player which will then be placed on the element.
    *
    * @param factoryFn The function that is used to create a player
    *   once all the rendering-related (styling values) have been
    *   processed for the element binding.
    * @param value The raw value that will be exposed to the binding
    *   so that the binding can update its internal values when
    *   any changes are evaluated.
    */
export declare function bindPlayerFactory<T>(factoryFn: PlayerFactoryBuildFn, value: T): PlayerFactory;
export declare class BoundPlayerFactory<T> {
        fn: PlayerFactoryBuildFn;
        value: T;
        '__brand__': 'Brand for PlayerFactory that nothing will match';
        constructor(fn: PlayerFactoryBuildFn, value: T);
}

/**
    * @license
    * Copyright Google Inc. All Rights Reserved.
    *
    * Use of this source code is governed by an MIT-style license that can be
    * found in the LICENSE file at https://angular.io/license
    */
import './ng_dev_mode';
import { ComponentInstance, DirectiveInstance, Player } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/render3/interfaces/player';
/**
    * Adds a player to an element, directive or component instance that will later be
    * animated once change detection has passed.
    *
    * When a player is added to a reference it will stay active until `player.destroy()`
    * is called. Once called then the player will be removed from the active players
    * present on the associated ref instance.
    *
    * To get a list of all the active players on an element see [getPlayers].
    *
    * @param ref The element, directive or component that the player will be placed on.
    * @param player The player that will be triggered to play once change detection has run.
    */
export declare function addPlayer(ref: ComponentInstance | DirectiveInstance | HTMLElement, player: Player): void;
/**
    * Returns a list of all the active players present on the provided ref instance (which can
    * be an instance of a directive, component or element).
    *
    * This function will only return players that have been added to the ref instance using
    * `addPlayer` or any players that are active through any template styling bindings
    * (`[style]`, `[style.prop]`, `[class]` and `[class.name]`).
    *
    * @publicApi
    */
export declare function getPlayers(ref: ComponentInstance | DirectiveInstance | HTMLElement): Player[];

/**
    * @license
    * Copyright Google Inc. All Rights Reserved.
    *
    * Use of this source code is governed by an MIT-style license that can be
    * found in the LICENSE file at https://angular.io/license
    */
import { injectChangeDetectorRef as render3InjectChangeDetectorRef } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/render3/view_engine_compatibility';
/**
    * Base class for Angular Views, provides change detection functionality.
    * A change-detection tree collects all views that are to be checked for changes.
    * Use the methods to add and remove views from the tree, initiate change-detection,
    * and explicitly mark views as _dirty_, meaning that they have changed and need to be rerendered.
    *
    * @usageNotes
    *
    * The following examples demonstrate how to modify default change-detection behavior
    * to perform explicit detection when needed.
    *
    * ### Use `markForCheck()` with `CheckOnce` strategy
    *
    * The following example sets the `OnPush` change-detection strategy for a component
    * (`CheckOnce`, rather than the default `CheckAlways`), then forces a second check
    * after an interval. See [live demo](http://plnkr.co/edit/GC512b?p=preview).
    *
    * <code-example path="core/ts/change_detect/change-detection.ts"
    * region="mark-for-check"></code-example>
    *
    * ### Detach change detector to limit how often check occurs
    *
    * The following example defines a component with a large list of read-only data
    * that is expected to change constantly, many times per second.
    * To improve performance, we want to check and update the list
    * less often than the changes actually occur. To do that, we detach
    * the component's change detector and perform an explicit local check every five seconds.
    *
    * <code-example path="core/ts/change_detect/change-detection.ts" region="detach"></code-example>
    *
    *
    * ### Reattaching a detached component
    *
    * The following example creates a component displaying live data.
    * The component detaches its change detector from the main change detector tree
    * when the `live` property is set to false, and reattaches it when the property
    * becomes true.
    *
    * <code-example path="core/ts/change_detect/change-detection.ts" region="reattach"></code-example>
    *
    * @publicApi
    */
export declare abstract class ChangeDetectorRef {
        /**
            * When a view uses the {@link ChangeDetectionStrategy#OnPush OnPush} (checkOnce)
            * change detection strategy, explicitly marks the view as changed so that
            * it can be checked again.
            *
            * Components are normally marked as dirty (in need of rerendering) when inputs
            * have changed or events have fired in the view. Call this method to ensure that
            * a component is checked even if these triggers have not occured.
            *
            * <!-- TODO: Add a link to a chapter on OnPush components -->
            *
            */
        abstract markForCheck(): void;
        /**
            * Detaches this view from the change-detection tree.
            * A detached view is  not checked until it is reattached.
            * Use in combination with `detectChanges()` to implement local change detection checks.
            *
            * Detached views are not checked during change detection runs until they are
            * re-attached, even if they are marked as dirty.
            *
            * <!-- TODO: Add a link to a chapter on detach/reattach/local digest -->
            * <!-- TODO: Add a live demo once ref.detectChanges is merged into master -->
            *
            */
        abstract detach(): void;
        /**
            * Checks this view and its children. Use in combination with {@link ChangeDetectorRef#detach
            * detach}
            * to implement local change detection checks.
            *
            * <!-- TODO: Add a link to a chapter on detach/reattach/local digest -->
            * <!-- TODO: Add a live demo once ref.detectChanges is merged into master -->
            *
            */
        abstract detectChanges(): void;
        /**
            * Checks the change detector and its children, and throws if any changes are detected.
            *
            * Use in development mode to verify that running change detection doesn't introduce
            * other changes.
            */
        abstract checkNoChanges(): void;
        /**
            * Re-attaches the previously detached view to the change detection tree.
            * Views are attached to the tree by default.
            *
            * <!-- TODO: Add a link to a chapter on detach/reattach/local digest -->
            *
            */
        abstract reattach(): void;
}
export declare const SWITCH_CHANGE_DETECTOR_REF_FACTORY__POST_R3__: typeof render3InjectChangeDetectorRef;

/**
    * This value reflects the property on the window where the dev
    * tools are patched (window.ng).
    * */
export declare const GLOBAL_PUBLISH_EXPANDO_KEY = "ng";
export declare function publishDefaultGlobalUtils(): void;
export declare type GlobalDevModeContainer = {
        [GLOBAL_PUBLISH_EXPANDO_KEY]: {
                [fnName: string]: Function;
        };
};
/**
    * Publishes the given function to `window.ngDevMode` so that it can be
    * used from the browser console when an application is not in production.
    */
export declare function publishGlobalUtil(name: string, fn: Function): void;

/**
    * @license
    * Copyright Google Inc. All Rights Reserved.
    *
    * Use of this source code is governed by an MIT-style license that can be
    * found in the LICENSE file at https://angular.io/license
    */
import { Injectable } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/di/injectable';
import { Type } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/type';
/**
    * Compile an Angular injectable according to its `Injectable` metadata, and patch the resulting
    * `ngInjectableDef` onto the injectable type.
    */
export declare function compileInjectable(type: Type<any>, srcMeta?: Injectable): void;

/**
    * @license
    * Copyright Google Inc. All Rights Reserved.
    *
    * Use of this source code is governed by an MIT-style license that can be
    * found in the LICENSE file at https://angular.io/license
    */
import { ChangeDetectorRef as ViewEngine_ChangeDetectorRef } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/change_detection/change_detector_ref';
import { Injector } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/di/injector';
import { ElementRef as ViewEngine_ElementRef } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/linker/element_ref';
import { TemplateRef as ViewEngine_TemplateRef } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/linker/template_ref';
import { ViewContainerRef as ViewEngine_ViewContainerRef } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/linker/view_container_ref';
import { Renderer2 } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/render/api';
import { TContainerNode, TElementContainerNode, TElementNode, TNode } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/render3/interfaces/node';
import { LViewData } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/render3/interfaces/view';
/**
    * Creates an ElementRef from the most recent node.
    *
    * @returns The ElementRef instance to use
    */
export declare function injectElementRef(ElementRefToken: typeof ViewEngine_ElementRef): ViewEngine_ElementRef;
/**
    * Creates an ElementRef given a node.
    *
    * @param ElementRefToken The ElementRef type
    * @param tNode The node for which you'd like an ElementRef
    * @param view The view to which the node belongs
    * @returns The ElementRef instance to use
    */
export declare function createElementRef(ElementRefToken: typeof ViewEngine_ElementRef, tNode: TNode, view: LViewData): ViewEngine_ElementRef;
/**
    * Creates a TemplateRef given a node.
    *
    * @returns The TemplateRef instance to use
    */
export declare function injectTemplateRef<T>(TemplateRefToken: typeof ViewEngine_TemplateRef, ElementRefToken: typeof ViewEngine_ElementRef): ViewEngine_TemplateRef<T> | null;
/**
    * Creates a TemplateRef and stores it on the injector.
    *
    * @param TemplateRefToken The TemplateRef type
    * @param ElementRefToken The ElementRef type
    * @param hostTNode The node that is requesting a TemplateRef
    * @param hostView The view to which the node belongs
    * @returns The TemplateRef instance to use
    */
export declare function createTemplateRef<T>(TemplateRefToken: typeof ViewEngine_TemplateRef, ElementRefToken: typeof ViewEngine_ElementRef, hostTNode: TNode, hostView: LViewData): ViewEngine_TemplateRef<T> | null;
/**
    * Creates a ViewContainerRef and stores it on the injector. Or, if the ViewContainerRef
    * already exists, retrieves the existing ViewContainerRef.
    *
    * @returns The ViewContainerRef instance to use
    */
export declare function injectViewContainerRef(ViewContainerRefToken: typeof ViewEngine_ViewContainerRef, ElementRefToken: typeof ViewEngine_ElementRef): ViewEngine_ViewContainerRef;
export declare class NodeInjector implements Injector {
        constructor(_tNode: TElementNode | TContainerNode | TElementContainerNode, _hostView: LViewData);
        get(token: any, notFoundValue?: any): any;
}
/**
    * Creates a ViewContainerRef and stores it on the injector.
    *
    * @param ViewContainerRefToken The ViewContainerRef type
    * @param ElementRefToken The ElementRef type
    * @param hostTNode The node that is requesting a ViewContainerRef
    * @param hostView The view to which the node belongs
    * @returns The ViewContainerRef instance to use
    */
export declare function createContainerRef(ViewContainerRefToken: typeof ViewEngine_ViewContainerRef, ElementRefToken: typeof ViewEngine_ElementRef, hostTNode: TElementNode | TContainerNode | TElementContainerNode, hostView: LViewData): ViewEngine_ViewContainerRef;
/** Returns a ChangeDetectorRef (a.k.a. a ViewRef) */
export declare function injectChangeDetectorRef(): ViewEngine_ChangeDetectorRef;
/**
    * Creates a ViewRef and stores it on the injector as ChangeDetectorRef (public alias).
    *
    * @param hostTNode The node that is requesting a ChangeDetectorRef
    * @param hostView The view to which the node belongs
    * @param context The context for this change detector ref
    * @returns The ChangeDetectorRef to use
    */
export declare function createViewRef(hostTNode: TNode, hostView: LViewData, context: any): ViewEngine_ChangeDetectorRef;
/** Returns a Renderer2 (or throws when application was bootstrapped with Renderer3) */
export declare function injectRenderer2(): Renderer2;

/**
  * @license
  * Copyright Google Inc. All Rights Reserved.
  *
  * Use of this source code is governed by an MIT-style license that can be
  * found in the LICENSE file at https://angular.io/license
  */
import { RendererType2 } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/render/api';
import { SecurityContext } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/sanitization/security';
import { BindingFlags, ElementData, ElementHandleEventFn, NodeDef, NodeFlags, QueryValueType, ViewData, ViewDefinitionFactory } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/view/types';
export declare function anchorDef(flags: NodeFlags, matchedQueriesDsl: null | [string | number, QueryValueType][], ngContentIndex: null | number, childCount: number, handleEvent?: null | ElementHandleEventFn, templateFactory?: ViewDefinitionFactory): NodeDef;
export declare function elementDef(checkIndex: number, flags: NodeFlags, matchedQueriesDsl: null | [string | number, QueryValueType][], ngContentIndex: null | number, childCount: number, namespaceAndName: string | null, fixedAttrs?: null | [string, string][], bindings?: null | [BindingFlags, string, string | SecurityContext | null][], outputs?: null | ([string, string])[], handleEvent?: null | ElementHandleEventFn, componentView?: null | ViewDefinitionFactory, componentRendererType?: RendererType2 | null): NodeDef;
export declare function createElement(view: ViewData, renderHost: any, def: NodeDef): ElementData;
export declare function listenToElementOutputs(view: ViewData, compView: ViewData, def: NodeDef, el: any): void;
export declare function checkAndUpdateElementInline(view: ViewData, def: NodeDef, v0: any, v1: any, v2: any, v3: any, v4: any, v5: any, v6: any, v7: any, v8: any, v9: any): boolean;
export declare function checkAndUpdateElementDynamic(view: ViewData, def: NodeDef, values: any[]): boolean;

/**
  * @license
  * Copyright Google Inc. All Rights Reserved.
  *
  * Use of this source code is governed by an MIT-style license that can be
  * found in the LICENSE file at https://angular.io/license
  */
import { ComponentFactory } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/linker/component_factory';
import { NgModuleFactory } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/linker/ng_module_factory';
import { Type } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/type';
import { NgModuleDefinitionFactory, ProviderOverride } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/view/types';
export declare function overrideProvider(override: ProviderOverride): void;
export declare function overrideComponentView(comp: Type<any>, componentFactory: ComponentFactory<any>): void;
export declare function clearOverrides(): void;
export declare function createNgModuleFactory(ngModuleType: Type<any>, bootstrapComponents: Type<any>[], defFactory: NgModuleDefinitionFactory): NgModuleFactory<any>;

/**
  * @license
  * Copyright Google Inc. All Rights Reserved.
  *
  * Use of this source code is governed by an MIT-style license that can be
  * found in the LICENSE file at https://angular.io/license
  */
import { NodeDef, ViewData } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/view/types';
export declare function ngContentDef(ngContentIndex: null | number, index: number): NodeDef;
export declare function appendNgContent(view: ViewData, renderHost: any, def: NodeDef): void;

/**
  * @license
  * Copyright Google Inc. All Rights Reserved.
  *
  * Use of this source code is governed by an MIT-style license that can be
  * found in the LICENSE file at https://angular.io/license
  */
import { DepDef, DepFlags, NgModuleData, NgModuleDefinition, NgModuleProviderDef, NodeFlags } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/view/types';
export declare function moduleProvideDef(flags: NodeFlags, token: any, value: any, deps: ([DepFlags, any] | any)[]): NgModuleProviderDef;
export declare function moduleDef(providers: NgModuleProviderDef[]): NgModuleDefinition;
export declare function initNgModule(data: NgModuleData): void;
export declare function resolveNgModuleDep(data: NgModuleData, depDef: DepDef, notFoundValue?: any): any;
export declare function callNgModuleLifecycle(ngModule: NgModuleData, lifecycles: NodeFlags): void;

/**
  * @license
  * Copyright Google Inc. All Rights Reserved.
  *
  * Use of this source code is governed by an MIT-style license that can be
  * found in the LICENSE file at https://angular.io/license
  */
import { NodeDef, PureExpressionData, ViewData } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/view/types';
export declare function purePipeDef(checkIndex: number, argCount: number): NodeDef;
export declare function pureArrayDef(checkIndex: number, argCount: number): NodeDef;
export declare function pureObjectDef(checkIndex: number, propToIndex: {
    [p: string]: number;
}): NodeDef;
export declare function createPureExpression(view: ViewData, def: NodeDef): PureExpressionData;
export declare function checkAndUpdatePureExpressionInline(view: ViewData, def: NodeDef, v0: any, v1: any, v2: any, v3: any, v4: any, v5: any, v6: any, v7: any, v8: any, v9: any): boolean;
export declare function checkAndUpdatePureExpressionDynamic(view: ViewData, def: NodeDef, values: any[]): boolean;

/**
  * @license
  * Copyright Google Inc. All Rights Reserved.
  *
  * Use of this source code is governed by an MIT-style license that can be
  * found in the LICENSE file at https://angular.io/license
  */
import { QueryList } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/linker/query_list';
import { NodeDef, NodeFlags, QueryBindingType, QueryValueType, ViewData } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/view/types';
export declare function queryDef(flags: NodeFlags, id: number, bindings: {
    [propName: string]: QueryBindingType;
}): NodeDef;
export declare function createQuery(): QueryList<any>;
export declare function dirtyParentQueries(view: ViewData): void;
export declare function checkAndUpdateQuery(view: ViewData, nodeDef: NodeDef): void;
export declare function getQueryValue(view: ViewData, nodeDef: NodeDef, queryValueType: QueryValueType): any;

/**
  * @license
  * Copyright Google Inc. All Rights Reserved.
  *
  * Use of this source code is governed by an MIT-style license that can be
  * found in the LICENSE file at https://angular.io/license
  */
import { ApplicationRef } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/application_ref';
import { ChangeDetectorRef } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/change_detection/change_detection';
import { Injector } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/di/injector';
import { ComponentFactory } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/linker/component_factory';
import { NgModuleRef } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/linker/ng_module_factory';
import { ViewContainerRef } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/linker/view_container_ref';
import { EmbeddedViewRef, InternalViewRef } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/linker/view_ref';
import { Renderer as RendererV1 } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/render/api';
import { Type } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/type';
import { ElementData, NgModuleDefinition, NodeDef, TemplateData, ViewContainerData, ViewData, ViewDefinitionFactory } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/view/types';
export declare function createComponentFactory(selector: string, componentType: Type<any>, viewDefFactory: ViewDefinitionFactory, inputs: {
    [propName: string]: string;
} | null, outputs: {
    [propName: string]: string;
}, ngContentSelectors: string[]): ComponentFactory<any>;
export declare function getComponentViewDefinitionFactory(componentFactory: ComponentFactory<any>): ViewDefinitionFactory;
export declare function createViewContainerData(view: ViewData, elDef: NodeDef, elData: ElementData): ViewContainerData;
export declare function createChangeDetectorRef(view: ViewData): ChangeDetectorRef;
export declare class ViewRef_ implements EmbeddedViewRef<any>, InternalViewRef {
    constructor(_view: ViewData);
    readonly rootNodes: any[];
    readonly context: any;
    readonly destroyed: boolean;
    markForCheck(): void;
    detach(): void;
    detectChanges(): void;
    checkNoChanges(): void;
    reattach(): void;
    onDestroy(callback: Function): void;
    destroy(): void;
    detachFromAppRef(): void;
    attachToAppRef(appRef: ApplicationRef): void;
    attachToViewContainerRef(vcRef: ViewContainerRef): void;
}
export declare function createTemplateData(view: ViewData, def: NodeDef): TemplateData;
export declare function createInjector(view: ViewData, elDef: NodeDef): Injector;
export declare function nodeValue(view: ViewData, index: number): any;
export declare function createRendererV1(view: ViewData): RendererV1;
export declare function createNgModuleRef(moduleType: Type<any>, parent: Injector, bootstrapComponents: Type<any>[], def: NgModuleDefinition): NgModuleRef<any>;

/**
    * @license
    * Copyright Google Inc. All Rights Reserved.
    *
    * Use of this source code is governed by an MIT-style license that can be
    * found in the LICENSE file at https://angular.io/license
    */
import { Renderer2, RendererFactory2, RendererStyleFlags2, RendererType2 } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/render/api';
import { DebugContext } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/view/types';
export declare function initServicesIfNeeded(): void;
export declare function getCurrentDebugContext(): DebugContext | null;
export declare class DebugRendererFactory2 implements RendererFactory2 {
        constructor(delegate: RendererFactory2);
        createRenderer(element: any, renderData: RendererType2 | null): Renderer2;
        begin(): void;
        end(): void;
        whenRenderingDone(): Promise<any>;
}
export declare class DebugRenderer2 implements Renderer2 {
        readonly data: {
                [key: string]: any;
        };
        /**
            * Factory function used to create a `DebugContext` when a node is created.
            *
            * The `DebugContext` allows to retrieve information about the nodes that are useful in tests.
            *
            * The factory is configurable so that the `DebugRenderer2` could instantiate either a View Engine
            * or a Render context.
            */
        debugContextFactory: (nativeElement?: any) => DebugContext | null;
        constructor(delegate: Renderer2);
        destroyNode(node: any): void;
        destroy(): void;
        createElement(name: string, namespace?: string): any;
        createComment(value: string): any;
        createText(value: string): any;
        appendChild(parent: any, newChild: any): void;
        insertBefore(parent: any, newChild: any, refChild: any): void;
        removeChild(parent: any, oldChild: any): void;
        selectRootElement(selectorOrNode: string | any, preserveContent?: boolean): any;
        setAttribute(el: any, name: string, value: string, namespace?: string): void;
        removeAttribute(el: any, name: string, namespace?: string): void;
        addClass(el: any, name: string): void;
        removeClass(el: any, name: string): void;
        setStyle(el: any, style: string, value: any, flags: RendererStyleFlags2): void;
        removeStyle(el: any, style: string, flags: RendererStyleFlags2): void;
        setProperty(el: any, name: string, value: any): void;
        listen(target: 'document' | 'windows' | 'body' | any, eventName: string, callback: (event: any) => boolean): () => void;
        parentNode(node: any): any;
        nextSibling(node: any): any;
        setValue(node: any, value: string): void;
}

/**
  * @license
  * Copyright Google Inc. All Rights Reserved.
  *
  * Use of this source code is governed by an MIT-style license that can be
  * found in the LICENSE file at https://angular.io/license
  */
import { NodeDef, TextData, ViewData } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/view/types';
export declare function textDef(checkIndex: number, ngContentIndex: number | null, staticText: string[]): NodeDef;
export declare function createText(view: ViewData, renderHost: any, def: NodeDef): TextData;
export declare function checkAndUpdateTextInline(view: ViewData, def: NodeDef, v0: any, v1: any, v2: any, v3: any, v4: any, v5: any, v6: any, v7: any, v8: any, v9: any): boolean;
export declare function checkAndUpdateTextDynamic(view: ViewData, def: NodeDef, values: any[]): boolean;

/**
    * @license
    * Copyright Google Inc. All Rights Reserved.
    *
    * Use of this source code is governed by an MIT-style license that can be
    * found in the LICENSE file at https://angular.io/license
    */
import { ViewEncapsulation } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/metadata/view';
import { RendererType2 } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/render/api';
import { BindingDef, BindingFlags, Definition, DefinitionFactory, DepDef, DepFlags, ElementData, NodeDef, QueryValueType, ViewData } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/view/types';
export declare const NOOP: any;
export declare function tokenKey(token: any): string;
export declare function unwrapValue(view: ViewData, nodeIdx: number, bindingIdx: number, value: any): any;
export declare function createRendererType2(values: {
        styles: (string | any[])[];
        encapsulation: ViewEncapsulation;
        data: {
                [kind: string]: any[];
        };
}): RendererType2;
export declare function resolveRendererType2(type?: RendererType2 | null): RendererType2 | null;
export declare function checkBinding(view: ViewData, def: NodeDef, bindingIdx: number, value: any): boolean;
export declare function checkAndUpdateBinding(view: ViewData, def: NodeDef, bindingIdx: number, value: any): boolean;
export declare function checkBindingNoChanges(view: ViewData, def: NodeDef, bindingIdx: number, value: any): void;
export declare function markParentViewsForCheck(view: ViewData): void;
export declare function markParentViewsForCheckProjectedViews(view: ViewData, endView: ViewData): void;
export declare function dispatchEvent(view: ViewData, nodeIndex: number, eventName: string, event: any): boolean | undefined;
export declare function declaredViewContainer(view: ViewData): ElementData | null;
/**
    * for component views, this is the host element.
    * for embedded views, this is the index of the parent node
    * that contains the view container.
    */
export declare function viewParentEl(view: ViewData): NodeDef | null;
export declare function renderNode(view: ViewData, def: NodeDef): any;
export declare function elementEventFullName(target: string | null, name: string): string;
export declare function isComponentView(view: ViewData): boolean;
export declare function isEmbeddedView(view: ViewData): boolean;
export declare function filterQueryId(queryId: number): number;
export declare function splitMatchedQueriesDsl(matchedQueriesDsl: [string | number, QueryValueType][] | null): {
        matchedQueries: {
                [queryId: string]: QueryValueType;
        };
        references: {
                [refId: string]: QueryValueType;
        };
        matchedQueryIds: number;
};
export declare function splitDepsDsl(deps: ([DepFlags, any] | any)[], sourceName?: string): DepDef[];
export declare function getParentRenderElement(view: ViewData, renderHost: any, def: NodeDef): any;
export declare function resolveDefinition<D extends Definition<any>>(factory: DefinitionFactory<D>): D;
export declare function rootRenderNodes(view: ViewData): any[];
export declare const enum RenderNodeAction {
        Collect = 0,
        AppendChild = 1,
        InsertBefore = 2,
        RemoveChild = 3
}
export declare function visitRootRenderNodes(view: ViewData, action: RenderNodeAction, parentNode: any, nextSibling: any, target?: any[]): void;
export declare function visitSiblingRenderNodes(view: ViewData, action: RenderNodeAction, startIndex: number, endIndex: number, parentNode: any, nextSibling: any, target?: any[]): void;
export declare function visitProjectedRenderNodes(view: ViewData, ngContentIndex: number, action: RenderNodeAction, parentNode: any, nextSibling: any, target?: any[]): void;
export declare function splitNamespace(name: string): string[];
export declare function calcBindingFlags(bindings: BindingDef[]): BindingFlags;
export declare function interpolate(valueCount: number, constAndInterp: string[]): string;
export declare function inlineInterpolate(valueCount: number, c0: string, a1: any, c1: string, a2?: any, c2?: string, a3?: any, c3?: string, a4?: any, c4?: string, a5?: any, c5?: string, a6?: any, c6?: string, a7?: any, c7?: string, a8?: any, c8?: string, a9?: any, c9?: string): string;
export declare const EMPTY_ARRAY: any[];
export declare const EMPTY_MAP: {
        [key: string]: any;
};

/**
  * @license
  * Copyright Google Inc. All Rights Reserved.
  *
  * Use of this source code is governed by an MIT-style license that can be
  * found in the LICENSE file at https://angular.io/license
  */
import { ArgumentType, NodeDef, RootData, ViewData, ViewDefinition, ViewFlags, ViewUpdateFn } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/view/types';
export declare function viewDef(flags: ViewFlags, nodes: NodeDef[], updateDirectives?: null | ViewUpdateFn, updateRenderer?: null | ViewUpdateFn): ViewDefinition;
export declare function createEmbeddedView(parent: ViewData, anchorDef: NodeDef, viewDef: ViewDefinition, context?: any): ViewData;
export declare function createRootView(root: RootData, def: ViewDefinition, context?: any): ViewData;
export declare function createComponentView(parentView: ViewData, nodeDef: NodeDef, viewDef: ViewDefinition, hostElement: any): ViewData;
export declare function checkNoChangesView(view: ViewData): void;
export declare function checkAndUpdateView(view: ViewData): void;
export declare function checkAndUpdateNode(view: ViewData, nodeDef: NodeDef, argStyle: ArgumentType, v0?: any, v1?: any, v2?: any, v3?: any, v4?: any, v5?: any, v6?: any, v7?: any, v8?: any, v9?: any): boolean;
export declare function checkNoChangesNode(view: ViewData, nodeDef: NodeDef, argStyle: ArgumentType, v0?: any, v1?: any, v2?: any, v3?: any, v4?: any, v5?: any, v6?: any, v7?: any, v8?: any, v9?: any): any;
export declare function destroyView(view: ViewData): void;

/**
  * @license
  * Copyright Google Inc. All Rights Reserved.
  *
  * Use of this source code is governed by an MIT-style license that can be
  * found in the LICENSE file at https://angular.io/license
  */
import { ElementData, ViewData } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/view/types';
export declare function attachEmbeddedView(parentView: ViewData, elementData: ElementData, viewIndex: number | undefined | null, view: ViewData): void;
export declare function detachEmbeddedView(elementData: ElementData, viewIndex?: number): ViewData | null;
export declare function detachProjectedView(view: ViewData): void;
export declare function moveEmbeddedView(elementData: ElementData, oldViewIndex: number, newViewIndex: number): ViewData;
export declare function renderDetachView(view: ViewData): void;

/**
    * @license
    * Copyright Google Inc. All Rights Reserved.
    *
    * Use of this source code is governed by an MIT-style license that can be
    * found in the LICENSE file at https://angular.io/license
    */
import { Injector } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/di';
import { ErrorHandler } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/error_handler';
import { ComponentFactory } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/linker/component_factory';
import { NgModuleRef } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/linker/ng_module_factory';
import { QueryList } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/linker/query_list';
import { TemplateRef } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/linker/template_ref';
import { ViewContainerRef } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/linker/view_container_ref';
import { Renderer2, RendererFactory2, RendererType2 } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/render/api';
import { Sanitizer, SecurityContext } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/sanitization/security';
import { Type } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/type';
/**
    * Factory for ViewDefinitions/NgModuleDefinitions.
    * We use a function so we can reexeute it in case an error happens and use the given logger
    * function to log the error from the definition of the node, which is shown in all browser
    * logs.
    */
export interface DefinitionFactory<D extends Definition<any>> {
        (logger: NodeLogger): D;
}
/**
    * Function to call console.error at the right source location. This is an indirection
    * via another function as browser will log the location that actually called
    * `console.error`.
    */
export interface NodeLogger {
        (): () => void;
}
export interface Definition<DF extends DefinitionFactory<any>> {
        factory: DF | null;
}
export interface NgModuleDefinition extends Definition<NgModuleDefinitionFactory> {
        providers: NgModuleProviderDef[];
        providersByKey: {
                [tokenKey: string]: NgModuleProviderDef;
        };
        modules: any[];
        isRoot: boolean;
}
export interface NgModuleDefinitionFactory extends DefinitionFactory<NgModuleDefinition> {
}
export interface ViewDefinition extends Definition<ViewDefinitionFactory> {
        flags: ViewFlags;
        updateDirectives: ViewUpdateFn;
        updateRenderer: ViewUpdateFn;
        handleEvent: ViewHandleEventFn;
        /**
            * Order: Depth first.
            * Especially providers are before elements / anchors.
            */
        nodes: NodeDef[];
        /** aggregated NodeFlags for all nodes **/
        nodeFlags: NodeFlags;
        rootNodeFlags: NodeFlags;
        lastRenderRootNode: NodeDef | null;
        bindingCount: number;
        outputCount: number;
        /**
            * Binary or of all query ids that are matched by one of the nodes.
            * This includes query ids from templates as well.
            * Used as a bloom filter.
            */
        nodeMatchedQueries: number;
}
export interface ViewDefinitionFactory extends DefinitionFactory<ViewDefinition> {
}
export interface ViewUpdateFn {
        (check: NodeCheckFn, view: ViewData): void;
}
export interface NodeCheckFn {
        (view: ViewData, nodeIndex: number, argStyle: ArgumentType.Dynamic, values: any[]): any;
        (view: ViewData, nodeIndex: number, argStyle: ArgumentType.Inline, v0?: any, v1?: any, v2?: any, v3?: any, v4?: any, v5?: any, v6?: any, v7?: any, v8?: any, v9?: any): any;
}
export declare const enum ArgumentType {
        Inline = 0,
        Dynamic = 1
}
export interface ViewHandleEventFn {
        (view: ViewData, nodeIndex: number, eventName: string, event: any): boolean;
}
/**
    * Bitmask for ViewDefinition.flags.
    */
export declare const enum ViewFlags {
        None = 0,
        OnPush = 2
}
/**
    * A node definition in the view.
    *
    * Note: We use one type for all nodes so that loops that loop over all nodes
    * of a ViewDefinition stay monomorphic!
    */
export interface NodeDef {
        flags: NodeFlags;
        nodeIndex: number;
        checkIndex: number;
        parent: NodeDef | null;
        renderParent: NodeDef | null;
        /** this is checked against NgContentDef.index to find matched nodes */
        ngContentIndex: number | null;
        /** number of transitive children */
        childCount: number;
        /** aggregated NodeFlags for all transitive children (does not include self) **/
        childFlags: NodeFlags;
        /** aggregated NodeFlags for all direct children (does not include self) **/
        directChildFlags: NodeFlags;
        bindingIndex: number;
        bindings: BindingDef[];
        bindingFlags: BindingFlags;
        outputIndex: number;
        outputs: OutputDef[];
        /**
            * references that the user placed on the element
            */
        references: {
                [refId: string]: QueryValueType;
        };
        /**
            * ids and value types of all queries that are matched by this node.
            */
        matchedQueries: {
                [queryId: number]: QueryValueType;
        };
        /** Binary or of all matched query ids of this node. */
        matchedQueryIds: number;
        /**
            * Binary or of all query ids that are matched by one of the children.
            * This includes query ids from templates as well.
            * Used as a bloom filter.
            */
        childMatchedQueries: number;
        element: ElementDef | null;
        provider: ProviderDef | null;
        text: TextDef | null;
        query: QueryDef | null;
        ngContent: NgContentDef | null;
}
/**
    * Bitmask for NodeDef.flags.
    * Naming convention:
    * - `Type...`: flags that are mutually exclusive
    * - `Cat...`: union of multiple `Type...` (short for category).
    */
export declare const enum NodeFlags {
        None = 0,
        TypeElement = 1,
        TypeText = 2,
        ProjectedTemplate = 4,
        CatRenderNode = 3,
        TypeNgContent = 8,
        TypePipe = 16,
        TypePureArray = 32,
        TypePureObject = 64,
        TypePurePipe = 128,
        CatPureExpression = 224,
        TypeValueProvider = 256,
        TypeClassProvider = 512,
        TypeFactoryProvider = 1024,
        TypeUseExistingProvider = 2048,
        LazyProvider = 4096,
        PrivateProvider = 8192,
        TypeDirective = 16384,
        Component = 32768,
        CatProviderNoDirective = 3840,
        CatProvider = 20224,
        OnInit = 65536,
        OnDestroy = 131072,
        DoCheck = 262144,
        OnChanges = 524288,
        AfterContentInit = 1048576,
        AfterContentChecked = 2097152,
        AfterViewInit = 4194304,
        AfterViewChecked = 8388608,
        EmbeddedViews = 16777216,
        ComponentView = 33554432,
        TypeContentQuery = 67108864,
        TypeViewQuery = 134217728,
        StaticQuery = 268435456,
        DynamicQuery = 536870912,
        TypeNgModule = 1073741824,
        CatQuery = 201326592,
        Types = 201347067
}
export interface BindingDef {
        flags: BindingFlags;
        ns: string | null;
        name: string | null;
        nonMinifiedName: string | null;
        securityContext: SecurityContext | null;
        suffix: string | null;
}
export declare const enum BindingFlags {
        TypeElementAttribute = 1,
        TypeElementClass = 2,
        TypeElementStyle = 4,
        TypeProperty = 8,
        SyntheticProperty = 16,
        SyntheticHostProperty = 32,
        CatSyntheticProperty = 48,
        Types = 15
}
export interface OutputDef {
        type: OutputType;
        target: 'window' | 'document' | 'body' | 'component' | null;
        eventName: string;
        propName: string | null;
}
export declare const enum OutputType {
        ElementOutput = 0,
        DirectiveOutput = 1
}
export declare const enum QueryValueType {
        ElementRef = 0,
        RenderElement = 1,
        TemplateRef = 2,
        ViewContainerRef = 3,
        Provider = 4
}
export interface ElementDef {
        name: string | null;
        ns: string | null;
        /** ns, name, value */
        attrs: [string, string, string][] | null;
        template: ViewDefinition | null;
        componentProvider: NodeDef | null;
        componentRendererType: RendererType2 | null;
        componentView: ViewDefinitionFactory | null;
        /**
            * visible public providers for DI in the view,
            * as see from this element. This does not include private providers.
            */
        publicProviders: {
                [tokenKey: string]: NodeDef;
        } | null;
        /**
            * same as visiblePublicProviders, but also includes private providers
            * that are located on this element.
            */
        allProviders: {
                [tokenKey: string]: NodeDef;
        } | null;
        handleEvent: ElementHandleEventFn | null;
}
export interface ElementHandleEventFn {
        (view: ViewData, eventName: string, event: any): boolean;
}
export interface ProviderDef {
        token: any;
        value: any;
        deps: DepDef[];
}
export interface NgModuleProviderDef {
        flags: NodeFlags;
        index: number;
        token: any;
        value: any;
        deps: DepDef[];
}
export interface DepDef {
        flags: DepFlags;
        token: any;
        tokenKey: string;
}
/**
    * Bitmask for DI flags
    */
export declare const enum DepFlags {
        None = 0,
        SkipSelf = 1,
        Optional = 2,
        Self = 4,
        Value = 8
}
export interface TextDef {
        prefix: string;
}
export interface QueryDef {
        id: number;
        filterId: number;
        bindings: QueryBindingDef[];
}
export interface QueryBindingDef {
        propName: string;
        bindingType: QueryBindingType;
}
export declare const enum QueryBindingType {
        First = 0,
        All = 1
}
export interface NgContentDef {
        /**
            * this index is checked against NodeDef.ngContentIndex to find the nodes
            * that are matched by this ng-content.
            * Note that a NodeDef with an ng-content can be reprojected, i.e.
            * have a ngContentIndex on its own.
            */
        index: number;
}
export interface NgModuleData extends Injector, NgModuleRef<any> {
        _def: NgModuleDefinition;
        _parent: Injector;
        _providers: any[];
}
/**
    * View instance data.
    * Attention: Adding fields to this is performance sensitive!
    */
export interface ViewData {
        def: ViewDefinition;
        root: RootData;
        renderer: Renderer2;
        parentNodeDef: NodeDef | null;
        parent: ViewData | null;
        viewContainerParent: ViewData | null;
        component: any;
        context: any;
        nodes: {
                [key: number]: NodeData;
        };
        state: ViewState;
        oldValues: any[];
        disposables: DisposableFn[] | null;
        initIndex: number;
}
/**
    * Bitmask of states
    */
export declare const enum ViewState {
        BeforeFirstCheck = 1,
        FirstCheck = 2,
        Attached = 4,
        ChecksEnabled = 8,
        IsProjectedView = 16,
        CheckProjectedView = 32,
        CheckProjectedViews = 64,
        Destroyed = 128,
        InitState_Mask = 1792,
        InitState_BeforeInit = 0,
        InitState_CallingOnInit = 256,
        InitState_CallingAfterContentInit = 512,
        InitState_CallingAfterViewInit = 768,
        InitState_AfterInit = 1024,
        CatDetectChanges = 12,
        CatInit = 13
}
export declare function shiftInitState(view: ViewData, priorInitState: ViewState, newInitState: ViewState): boolean;
export declare function shouldCallLifecycleInitHook(view: ViewData, initState: ViewState, index: number): boolean;
export interface DisposableFn {
        (): void;
}
/**
    * Node instance data.
    *
    * We have a separate type per NodeType to save memory
    * (TextData | ElementData | ProviderData | PureExpressionData | QueryList<any>)
    *
    * To keep our code monomorphic,
    * we prohibit using `NodeData` directly but enforce the use of accessors (`asElementData`, ...).
    * This way, no usage site can get a `NodeData` from view.nodes and then use it for different
    * purposes.
    */
export declare class NodeData {
}
/**
    * Data for an instantiated NodeType.Text.
    *
    * Attention: Adding fields to this is performance sensitive!
    */
export interface TextData {
        renderText: any;
}
/**
    * Accessor for view.nodes, enforcing that every usage site stays monomorphic.
    */
export declare function asTextData(view: ViewData, index: number): TextData;
/**
    * Data for an instantiated NodeType.Element.
    *
    * Attention: Adding fields to this is performance sensitive!
    */
export interface ElementData {
        renderElement: any;
        componentView: ViewData;
        viewContainer: ViewContainerData | null;
        template: TemplateData;
}
export interface ViewContainerData extends ViewContainerRef {
        _embeddedViews: ViewData[];
}
export interface TemplateData extends TemplateRef<any> {
        _projectedViews: ViewData[];
}
/**
    * Accessor for view.nodes, enforcing that every usage site stays monomorphic.
    */
export declare function asElementData(view: ViewData, index: number): ElementData;
/**
    * Data for an instantiated NodeType.Provider.
    *
    * Attention: Adding fields to this is performance sensitive!
    */
export interface ProviderData {
        instance: any;
}
/**
    * Accessor for view.nodes, enforcing that every usage site stays monomorphic.
    */
export declare function asProviderData(view: ViewData, index: number): ProviderData;
/**
    * Data for an instantiated NodeType.PureExpression.
    *
    * Attention: Adding fields to this is performance sensitive!
    */
export interface PureExpressionData {
        value: any;
}
/**
    * Accessor for view.nodes, enforcing that every usage site stays monomorphic.
    */
export declare function asPureExpressionData(view: ViewData, index: number): PureExpressionData;
/**
    * Accessor for view.nodes, enforcing that every usage site stays monomorphic.
    */
export declare function asQueryList(view: ViewData, index: number): QueryList<any>;
export interface RootData {
        injector: Injector;
        ngModule: NgModuleRef<any>;
        projectableNodes: any[][];
        selectorOrNode: any;
        renderer: Renderer2;
        rendererFactory: RendererFactory2;
        errorHandler: ErrorHandler;
        sanitizer: Sanitizer;
}
export declare abstract class DebugContext {
        abstract readonly view: ViewData;
        abstract readonly nodeIndex: number | null;
        abstract readonly injector: Injector;
        abstract readonly component: any;
        abstract readonly providerTokens: any[];
        abstract readonly references: {
                [key: string]: any;
        };
        abstract readonly context: any;
        abstract readonly componentRenderElement: any;
        abstract readonly renderNode: any;
        abstract logError(console: Console, ...values: any[]): void;
}
export declare const enum CheckType {
        CheckAndUpdate = 0,
        CheckNoChanges = 1
}
export interface ProviderOverride {
        token: any;
        flags: NodeFlags;
        value: any;
        deps: ([DepFlags, any] | any)[];
        deprecatedBehavior: boolean;
}
export interface Services {
        setCurrentNode(view: ViewData, nodeIndex: number): void;
        createRootView(injector: Injector, projectableNodes: any[][], rootSelectorOrNode: string | any, def: ViewDefinition, ngModule: NgModuleRef<any>, context?: any): ViewData;
        createEmbeddedView(parent: ViewData, anchorDef: NodeDef, viewDef: ViewDefinition, context?: any): ViewData;
        createComponentView(parentView: ViewData, nodeDef: NodeDef, viewDef: ViewDefinition, hostElement: any): ViewData;
        createNgModuleRef(moduleType: Type<any>, parent: Injector, bootstrapComponents: Type<any>[], def: NgModuleDefinition): NgModuleRef<any>;
        overrideProvider(override: ProviderOverride): void;
        overrideComponentView(compType: Type<any>, compFactory: ComponentFactory<any>): void;
        clearOverrides(): void;
        checkAndUpdateView(view: ViewData): void;
        checkNoChangesView(view: ViewData): void;
        destroyView(view: ViewData): void;
        resolveDep(view: ViewData, elDef: NodeDef | null, allowPrivateServices: boolean, depDef: DepDef, notFoundValue?: any): any;
        createDebugContext(view: ViewData, nodeIndex: number): DebugContext;
        handleEvent: ViewHandleEventFn;
        updateDirectives: (view: ViewData, checkType: CheckType) => void;
        updateRenderer: (view: ViewData, checkType: CheckType) => void;
        dirtyParentQueries: (view: ViewData) => void;
}
/**
    * This object is used to prevent cycles in the source files and to have a place where
    * debug mode can hook it. It is lazily filled when `isDevMode` is known.
    */
export declare const Services: Services;

/**
    * @license
    * Copyright Google Inc. All Rights Reserved.
    *
    * Use of this source code is governed by an MIT-style license that can be
    * found in the LICENSE file at https://angular.io/license
    */
import { StaticProvider } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/di/provider';
/**
    * A type describing supported iterable types.
    *
    * @publicApi
    */
export declare type NgIterable<T> = Array<T> | Iterable<T>;
/**
    * A strategy for tracking changes over time to an iterable. Used by {@link NgForOf} to
    * respond to changes in an iterable by effecting equivalent changes in the DOM.
    *
    * @publicApi
    */
export interface IterableDiffer<V> {
        /**
            * Compute a difference between the previous state and the new `object` state.
            *
            * @param object containing the new value.
            * @returns an object describing the difference. The return value is only valid until the next
            * `diff()` invocation.
            */
        diff(object: NgIterable<V>): IterableChanges<V> | null;
}
/**
    * An object describing the changes in the `Iterable` collection since last time
    * `IterableDiffer#diff()` was invoked.
    *
    * @publicApi
    */
export interface IterableChanges<V> {
        /**
            * Iterate over all changes. `IterableChangeRecord` will contain information about changes
            * to each item.
            */
        forEachItem(fn: (record: IterableChangeRecord<V>) => void): void;
        /**
            * Iterate over a set of operations which when applied to the original `Iterable` will produce the
            * new `Iterable`.
            *
            * NOTE: These are not necessarily the actual operations which were applied to the original
            * `Iterable`, rather these are a set of computed operations which may not be the same as the
            * ones applied.
            *
            * @param record A change which needs to be applied
            * @param previousIndex The `IterableChangeRecord#previousIndex` of the `record` refers to the
            *        original `Iterable` location, where as `previousIndex` refers to the transient location
            *        of the item, after applying the operations up to this point.
            * @param currentIndex The `IterableChangeRecord#currentIndex` of the `record` refers to the
            *        original `Iterable` location, where as `currentIndex` refers to the transient location
            *        of the item, after applying the operations up to this point.
            */
        forEachOperation(fn: (record: IterableChangeRecord<V>, previousIndex: number | null, currentIndex: number | null) => void): void;
        /**
            * Iterate over changes in the order of original `Iterable` showing where the original items
            * have moved.
            */
        forEachPreviousItem(fn: (record: IterableChangeRecord<V>) => void): void;
        /** Iterate over all added items. */
        forEachAddedItem(fn: (record: IterableChangeRecord<V>) => void): void;
        /** Iterate over all moved items. */
        forEachMovedItem(fn: (record: IterableChangeRecord<V>) => void): void;
        /** Iterate over all removed items. */
        forEachRemovedItem(fn: (record: IterableChangeRecord<V>) => void): void;
        /** Iterate over all items which had their identity (as computed by the `TrackByFunction`)
            * changed. */
        forEachIdentityChange(fn: (record: IterableChangeRecord<V>) => void): void;
}
/**
    * Record representing the item change information.
    *
    * @publicApi
    */
export interface IterableChangeRecord<V> {
        /** Current index of the item in `Iterable` or null if removed. */
        readonly currentIndex: number | null;
        /** Previous index of the item in `Iterable` or null if added. */
        readonly previousIndex: number | null;
        /** The item. */
        readonly item: V;
        /** Track by identity as computed by the `TrackByFunction`. */
        readonly trackById: any;
}
/**
    * @deprecated v4.0.0 - Use IterableChangeRecord instead.
    * @publicApi
    */
export interface CollectionChangeRecord<V> extends IterableChangeRecord<V> {
}
/**
    * An optional function passed into {@link NgForOf} that defines how to track
    * items in an iterable (e.g. fby index or id)
    *
    * @publicApi
    */
export interface TrackByFunction<T> {
        (index: number, item: T): any;
}
/**
    * Provides a factory for {@link IterableDiffer}.
    *
    * @publicApi
    */
export interface IterableDifferFactory {
        supports(objects: any): boolean;
        create<V>(trackByFn?: TrackByFunction<V>): IterableDiffer<V>;
}
/**
    * A repository of different iterable diffing strategies used by NgFor, NgClass, and others.
    *
    * @publicApi
    */
export declare class IterableDiffers {
        /** @nocollapse */
        static ngInjectableDef: never;
        /**
            * @deprecated v4.0.0 - Should be private
            */
        factories: IterableDifferFactory[];
        constructor(factories: IterableDifferFactory[]);
        static create(factories: IterableDifferFactory[], parent?: IterableDiffers): IterableDiffers;
        /**
            * Takes an array of {@link IterableDifferFactory} and returns a provider used to extend the
            * inherited {@link IterableDiffers} instance with the provided factories and return a new
            * {@link IterableDiffers} instance.
            *
            * @usageNotes
            * ### Example
            *
            * The following example shows how to extend an existing list of factories,
            * which will only be applied to the injector for this component and its children.
            * This step is all that's required to make a new {@link IterableDiffer} available.
            *
            * ```
            * @Component({
            *   viewProviders: [
            *     IterableDiffers.extend([new ImmutableListDiffer()])
            *   ]
            * })
            * ```
            */
        static extend(factories: IterableDifferFactory[]): StaticProvider;
        find(iterable: any): IterableDifferFactory;
}
export declare function getTypeNameForDebugging(type: any): string;

/**
    * @license
    * Copyright Google Inc. All Rights Reserved.
    *
    * Use of this source code is governed by an MIT-style license that can be
    * found in the LICENSE file at https://angular.io/license
    */
import { StaticProvider } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/di';
/**
    * A differ that tracks changes made to an object over time.
    *
    * @publicApi
    */
export interface KeyValueDiffer<K, V> {
        /**
            * Compute a difference between the previous state and the new `object` state.
            *
            * @param object containing the new value.
            * @returns an object describing the difference. The return value is only valid until the next
            * `diff()` invocation.
            */
        diff(object: Map<K, V>): KeyValueChanges<K, V> | null;
        /**
            * Compute a difference between the previous state and the new `object` state.
            *
            * @param object containing the new value.
            * @returns an object describing the difference. The return value is only valid until the next
            * `diff()` invocation.
            */
        diff(object: {
                [key: string]: V;
        }): KeyValueChanges<string, V> | null;
}
/**
    * An object describing the changes in the `Map` or `{[k:string]: string}` since last time
    * `KeyValueDiffer#diff()` was invoked.
    *
    * @publicApi
    */
export interface KeyValueChanges<K, V> {
        /**
            * Iterate over all changes. `KeyValueChangeRecord` will contain information about changes
            * to each item.
            */
        forEachItem(fn: (r: KeyValueChangeRecord<K, V>) => void): void;
        /**
            * Iterate over changes in the order of original Map showing where the original items
            * have moved.
            */
        forEachPreviousItem(fn: (r: KeyValueChangeRecord<K, V>) => void): void;
        /**
            * Iterate over all keys for which values have changed.
            */
        forEachChangedItem(fn: (r: KeyValueChangeRecord<K, V>) => void): void;
        /**
            * Iterate over all added items.
            */
        forEachAddedItem(fn: (r: KeyValueChangeRecord<K, V>) => void): void;
        /**
            * Iterate over all removed items.
            */
        forEachRemovedItem(fn: (r: KeyValueChangeRecord<K, V>) => void): void;
}
/**
    * Record representing the item change information.
    *
    * @publicApi
    */
export interface KeyValueChangeRecord<K, V> {
        /**
            * Current key in the Map.
            */
        readonly key: K;
        /**
            * Current value for the key or `null` if removed.
            */
        readonly currentValue: V | null;
        /**
            * Previous value for the key or `null` if added.
            */
        readonly previousValue: V | null;
}
/**
    * Provides a factory for {@link KeyValueDiffer}.
    *
    * @publicApi
    */
export interface KeyValueDifferFactory {
        /**
            * Test to see if the differ knows how to diff this kind of object.
            */
        supports(objects: any): boolean;
        /**
            * Create a `KeyValueDiffer`.
            */
        create<K, V>(): KeyValueDiffer<K, V>;
}
/**
    * A repository of different Map diffing strategies used by NgClass, NgStyle, and others.
    *
    * @publicApi
    */
export declare class KeyValueDiffers {
        /** @nocollapse */
        static ngInjectableDef: never;
        /**
            * @deprecated v4.0.0 - Should be private.
            */
        factories: KeyValueDifferFactory[];
        constructor(factories: KeyValueDifferFactory[]);
        static create<S>(factories: KeyValueDifferFactory[], parent?: KeyValueDiffers): KeyValueDiffers;
        /**
            * Takes an array of {@link KeyValueDifferFactory} and returns a provider used to extend the
            * inherited {@link KeyValueDiffers} instance with the provided factories and return a new
            * {@link KeyValueDiffers} instance.
            *
            * @usageNotes
            * ### Example
            *
            * The following example shows how to extend an existing list of factories,
            * which will only be applied to the injector for this component and its children.
            * This step is all that's required to make a new {@link KeyValueDiffer} available.
            *
            * ```
            * @Component({
            *   viewProviders: [
            *     KeyValueDiffers.extend([new ImmutableMapDiffer()])
            *   ]
            * })
            * ```
            */
        static extend<S>(factories: KeyValueDifferFactory[]): StaticProvider;
        find(kv: any): KeyValueDifferFactory;
}

/**
    * @license
    * Copyright Google Inc. All Rights Reserved.
    *
    * Use of this source code is governed by an MIT-style license that can be
    * found in the LICENSE file at https://angular.io/license
    */
import { IterableChangeRecord, IterableChanges, IterableDiffer, IterableDifferFactory, NgIterable, TrackByFunction } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/change_detection/differs/iterable_differs';
export declare class DefaultIterableDifferFactory implements IterableDifferFactory {
        constructor();
        supports(obj: Object | null | undefined): boolean;
        create<V>(trackByFn?: TrackByFunction<V>): DefaultIterableDiffer<V>;
}
/**
    * @deprecated v4.0.0 - Should not be part of public API.
    * @publicApi
    */
export declare class DefaultIterableDiffer<V> implements IterableDiffer<V>, IterableChanges<V> {
        readonly length: number;
        readonly collection: V[] | Iterable<V> | null;
        constructor(trackByFn?: TrackByFunction<V>);
        forEachItem(fn: (record: IterableChangeRecord_<V>) => void): void;
        forEachOperation(fn: (item: IterableChangeRecord<V>, previousIndex: number | null, currentIndex: number | null) => void): void;
        forEachPreviousItem(fn: (record: IterableChangeRecord_<V>) => void): void;
        forEachAddedItem(fn: (record: IterableChangeRecord_<V>) => void): void;
        forEachMovedItem(fn: (record: IterableChangeRecord_<V>) => void): void;
        forEachRemovedItem(fn: (record: IterableChangeRecord_<V>) => void): void;
        forEachIdentityChange(fn: (record: IterableChangeRecord_<V>) => void): void;
        diff(collection: NgIterable<V>): DefaultIterableDiffer<V> | null;
        onDestroy(): void;
        check(collection: NgIterable<V>): boolean;
        readonly isDirty: boolean;
}
export declare class IterableChangeRecord_<V> implements IterableChangeRecord<V> {
        item: V;
        trackById: any;
        currentIndex: number | null;
        previousIndex: number | null;
        constructor(item: V, trackById: any);
}

/**
    * @license
    * Copyright Google Inc. All Rights Reserved.
    *
    * Use of this source code is governed by an MIT-style license that can be
    * found in the LICENSE file at https://angular.io/license
    */
import { KeyValueChangeRecord, KeyValueChanges, KeyValueDiffer, KeyValueDifferFactory } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/change_detection/differs/keyvalue_differs';
export declare class DefaultKeyValueDifferFactory<K, V> implements KeyValueDifferFactory {
        constructor();
        supports(obj: any): boolean;
        create<K, V>(): KeyValueDiffer<K, V>;
}
export declare class DefaultKeyValueDiffer<K, V> implements KeyValueDiffer<K, V>, KeyValueChanges<K, V> {
        readonly isDirty: boolean;
        forEachItem(fn: (r: KeyValueChangeRecord<K, V>) => void): void;
        forEachPreviousItem(fn: (r: KeyValueChangeRecord<K, V>) => void): void;
        forEachChangedItem(fn: (r: KeyValueChangeRecord<K, V>) => void): void;
        forEachAddedItem(fn: (r: KeyValueChangeRecord<K, V>) => void): void;
        forEachRemovedItem(fn: (r: KeyValueChangeRecord<K, V>) => void): void;
        diff(map?: Map<any, any> | {
                [k: string]: any;
        } | null): any;
        onDestroy(): void;
        /**
            * Check the current state of the map vs the previous.
            * The algorithm is optimised for when the keys do no change.
            */
        check(map: Map<any, any> | {
                [k: string]: any;
        }): boolean;
}

/**
    * To create a Pipe, you must implement this interface.
    *
    * Angular invokes the `transform` method with the value of a binding
    * as the first argument, and any parameters as the second argument in list form.
    *
    * @usageNotes
    * ### Example
    *
    * The `RepeatPipe` below repeats the value as many times as indicated by the first argument:
    *
    * ```
    * import {Pipe, PipeTransform} from '@angular/core';
    *
    * @Pipe({name: 'repeat'})
    * export class RepeatPipe implements PipeTransform {
    *   transform(value: any, times: number) {
    *     return value.repeat(times);
    *   }
    * }
    * ```
    *
    * Invoking `{{ 'ok' | repeat:3 }}` in a template produces `okokok`.
    *
    * @publicApi
    */
export interface PipeTransform {
        transform(value: any, ...args: any[]): any;
}

/**
    * @license
    * Copyright Google Inc. All Rights Reserved.
    *
    * Use of this source code is governed by an MIT-style license that can be
    * found in the LICENSE file at https://angular.io/license
    */
import { Type } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/type';
import { GetterFn, MethodFn, SetterFn } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/reflection/types';
export interface PlatformReflectionCapabilities {
        isReflectionEnabled(): boolean;
        factory(type: Type<any>): Function;
        hasLifecycleHook(type: any, lcProperty: string): boolean;
        guards(type: any): {
                [key: string]: any;
        };
        /**
            * Return a list of annotations/types for constructor parameters
            */
        parameters(type: Type<any>): any[][];
        /**
            * Return a list of annotations declared on the class
            */
        annotations(type: Type<any>): any[];
        /**
            * Return a object literal which describes the annotations on Class fields/properties.
            */
        propMetadata(typeOrFunc: Type<any>): {
                [key: string]: any[];
        };
        getter(name: string): GetterFn;
        setter(name: string): SetterFn;
        method(name: string): MethodFn;
        importUri(type: Type<any>): string;
        resourceUri(type: Type<any>): string;
        resolveIdentifier(name: string, moduleUrl: string, members: string[], runtime: any): any;
        resolveEnum(enumIdentifier: any, name: string): any;
}

/**
    * @license
    * Copyright Google Inc. All Rights Reserved.
    *
    * Use of this source code is governed by an MIT-style license that can be
    * found in the LICENSE file at https://angular.io/license
    */
import { Type } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/core';
import { Injector } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/di/injector';
import { Sanitizer } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/sanitization/security';
import { ComponentDef, ComponentType } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/render3/interfaces/definition';
import { PlayerHandler } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/render3/interfaces/player';
import { RElement, Renderer3, RendererFactory3 } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/render3/interfaces/renderer';
import { LViewData, RootContext } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/render3/interfaces/view';
/** Options that control how the component should be bootstrapped. */
export interface CreateComponentOptions {
        /** Which renderer factory to use. */
        rendererFactory?: RendererFactory3;
        /** A custom sanitizer instance */
        sanitizer?: Sanitizer;
        /** A custom animation player handler */
        playerHandler?: PlayerHandler;
        /**
            * Host element on which the component will be bootstrapped. If not specified,
            * the component definition's `tag` is used to query the existing DOM for the
            * element to bootstrap.
            */
        host?: RElement | string;
        /** Module injector for the component. If unspecified, the injector will be NULL_INJECTOR. */
        injector?: Injector;
        /**
            * List of features to be applied to the created component. Features are simply
            * functions that decorate a component with a certain behavior.
            *
            * Typically, the features in this list are features that cannot be added to the
            * other features list in the component definition because they rely on other factors.
            *
            * Example: `RootLifecycleHooks` is a function that adds lifecycle hook capabilities
            * to root components in a tree-shakable way. It cannot be added to the component
            * features list because there's no way of knowing when the component will be used as
            * a root component.
            */
        hostFeatures?: HostFeature[];
        /**
            * A function which is used to schedule change detection work in the future.
            *
            * When marking components as dirty, it is necessary to schedule the work of
            * change detection in the future. This is done to coalesce multiple
            * {@link markDirty} calls into a single changed detection processing.
            *
            * The default value of the scheduler is the `requestAnimationFrame` function.
            *
            * It is also useful to override this function for testing purposes.
            */
        scheduler?: (work: () => void) => void;
}
/** See CreateComponentOptions.hostFeatures */
declare type HostFeature = (<T>(component: T, componentDef: ComponentDef<T>) => void);
export declare const NULL_INJECTOR: Injector;
/**
    * Bootstraps a Component into an existing host element and returns an instance
    * of the component.
    *
    * Use this function to bootstrap a component into the DOM tree. Each invocation
    * of this function will create a separate tree of components, injectors and
    * change detection cycles and lifetimes. To dynamically insert a new component
    * into an existing tree such that it shares the same injection, change detection
    * and object lifetime, use {@link ViewContainer#createComponent}.
    *
    * @param componentType Component to bootstrap
    * @param options Optional parameters which control bootstrapping
    */
export declare function renderComponent<T>(componentType: ComponentType<T> | Type<T>, opts?: CreateComponentOptions): T;
/**
    * Creates the root component view and the root component node.
    *
    * @param rNode Render host element.
    * @param def ComponentDef
    * @param rootView The parent view where the host node is stored
    * @param renderer The current renderer
    * @param sanitizer The sanitizer, if provided
    *
    * @returns Component view created
    */
export declare function createRootComponentView(rNode: RElement | null, def: ComponentDef<any>, rootView: LViewData, renderer: Renderer3, sanitizer?: Sanitizer | null): LViewData;
/**
    * Creates a root component and sets it up with features and host bindings. Shared by
    * renderComponent() and ViewContainerRef.createComponent().
    */
export declare function createRootComponent<T>(componentView: LViewData, componentDef: ComponentDef<T>, rootView: LViewData, rootContext: RootContext, hostFeatures: HostFeature[] | null): any;
export declare function createRootContext(scheduler?: (workFn: () => void) => void, playerHandler?: PlayerHandler | null): RootContext;
/**
    * Used to enable lifecycle hooks on the root component.
    *
    * Include this feature when calling `renderComponent` if the root component
    * you are rendering has lifecycle hooks defined. Otherwise, the hooks won't
    * be called properly.
    *
    * Example:
    *
    * ```
    * renderComponent(AppComponent, {features: [RootLifecycleHooks]});
    * ```
    */
export declare function LifecycleHooksFeature(component: any, def: ComponentDef<any>): void;
/**
    * Wait on component until it is rendered.
    *
    * This function returns a `Promise` which is resolved when the component's
    * change detection is executed. This is determined by finding the scheduler
    * associated with the `component`'s render tree and waiting until the scheduler
    * flushes. If nothing is scheduled, the function returns a resolved promise.
    *
    * Example:
    * ```
    * await whenRendered(myComponent);
    * ```
    *
    * @param component Component to wait upon
    * @returns Promise which resolves when the component is rendered.
    */
export declare function whenRendered(component: any): Promise<null>;
export {};

/**
    * @license
    * Copyright Google Inc. All Rights Reserved.
    *
    * Use of this source code is governed by an MIT-style license that can be
    * found in the LICENSE file at https://angular.io/license
    */
import './ng_dev_mode';
import { ChangeDetectionStrategy } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/change_detection/constants';
import { NgModuleDef } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/metadata/ng_module';
import { ViewEncapsulation } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/metadata/view';
import { Type } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/type';
import { BaseDef, ComponentDef, ComponentDefFeature, ComponentQuery, ComponentTemplate, ComponentType, DirectiveDef, DirectiveDefFeature, DirectiveType, DirectiveTypesOrFactory, PipeDef, PipeType, PipeTypesOrFactory } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/render3/interfaces/definition';
import { CssSelectorList, SelectorFlags } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/render3/interfaces/projection';
export declare const EMPTY: {};
export declare const EMPTY_ARRAY: any[];
/**
    * Create a component definition object.
    *
    *
    * # Example
    * ```
    * class MyDirective {
    *   // Generated by Angular Template Compiler
    *   // [Symbol] syntax will not be supported by TypeScript until v2.7
    *   static ngComponentDef = defineComponent({
    *     ...
    *   });
    * }
    * ```
    */
export declare function defineComponent<T>(componentDefinition: {
        /**
            * Directive type, needed to configure the injector.
            */
        type: Type<T>;
        /** The selectors that will be used to match nodes to this component. */
        selectors: CssSelectorList;
        /**
            * Factory method used to create an instance of directive.
            */
        factory: (t: Type<T> | null) => T;
        /**
            * The number of nodes, local refs, and pipes in this component template.
            *
            * Used to calculate the length of this component's LViewData array, so we
            * can pre-fill the array and set the binding start index.
            */
        consts: number;
        /**
            * The number of bindings in this component template (including pure fn bindings).
            *
            * Used to calculate the length of this component's LViewData array, so we
            * can pre-fill the array and set the host binding start index.
            */
        vars: number;
        /**
            * The number of host bindings (including pure fn bindings) in this component.
            *
            * Used to calculate the length of the LViewData array for the *parent* component
            * of this component.
            */
        hostVars?: number;
        /**
            * Static attributes to set on host element.
            *
            * Even indices: attribute name
            * Odd indices: attribute value
            */
        attributes?: string[];
        /**
            * A map of input names.
            *
            * The format is in: `{[actualPropertyName: string]:(string|[string, string])}`.
            *
            * Given:
            * ```
            * class MyComponent {
            *   @Input()
            *   publicInput1: string;
            *
            *   @Input('publicInput2')
            *   declaredInput2: string;
            * }
            * ```
            *
            * is described as:
            * ```
            * {
            *   publicInput1: 'publicInput1',
            *   declaredInput2: ['declaredInput2', 'publicInput2'],
            * }
            * ```
            *
            * Which the minifier may translate to:
            * ```
            * {
            *   minifiedPublicInput1: 'publicInput1',
            *   minifiedDeclaredInput2: [ 'publicInput2', 'declaredInput2'],
            * }
            * ```
            *
            * This allows the render to re-construct the minified, public, and declared names
            * of properties.
            *
            * NOTE:
            *  - Because declared and public name are usually same we only generate the array
            *    `['declared', 'public']` format when they differ.
            *  - The reason why this API and `outputs` API is not the same is that `NgOnChanges` has
            *    inconsistent behavior in that it uses declared names rather than minified or public. For
            *    this reason `NgOnChanges` will be deprecated and removed in future version and this
            *    API will be simplified to be consistent with `output`.
            */
        inputs?: {
                [P in keyof T]?: string | [string, string];
        };
        /**
            * A map of output names.
            *
            * The format is in: `{[actualPropertyName: string]:string}`.
            *
            * Which the minifier may translate to: `{[minifiedPropertyName: string]:string}`.
            *
            * This allows the render to re-construct the minified and non-minified names
            * of properties.
            */
        outputs?: {
                [P in keyof T]?: string;
        };
        /**
            * Function executed by the parent template to allow child directive to apply host bindings.
            */
        hostBindings?: (directiveIndex: number, elementIndex: number) => void;
        /**
            * Function to create instances of content queries associated with a given directive.
            */
        contentQueries?: ((dirIndex: number) => void);
        /** Refreshes content queries associated with directives in a given view */
        contentQueriesRefresh?: ((directiveIndex: number, queryIndex: number) => void);
        /**
            * Defines the name that can be used in the template to assign this directive to a variable.
            *
            * See: {@link Directive.exportAs}
            */
        exportAs?: string;
        /**
            * Template function use for rendering DOM.
            *
            * This function has following structure.
            *
            * ```
            * function Template<T>(ctx:T, creationMode: boolean) {
            *   if (creationMode) {
            *     // Contains creation mode instructions.
            *   }
            *   // Contains binding update instructions
            * }
            * ```
            *
            * Common instructions are:
            * Creation mode instructions:
            *  - `elementStart`, `elementEnd`
            *  - `text`
            *  - `container`
            *  - `listener`
            *
            * Binding update instructions:
            * - `bind`
            * - `elementAttribute`
            * - `elementProperty`
            * - `elementClass`
            * - `elementStyle`
            *
            */
        template: ComponentTemplate<T>;
        /**
            * Additional set of instructions specific to view query processing. This could be seen as a
            * set of instruction to be inserted into the template function.
            *
            * Query-related instructions need to be pulled out to a specific function as a timing of
            * execution is different as compared to all other instructions (after change detection hooks but
            * before view hooks).
            */
        viewQuery?: ComponentQuery<T> | null;
        /**
            * A list of optional features to apply.
            *
            * See: {@link NgOnChangesFeature}, {@link ProvidersFeature}
            */
        features?: ComponentDefFeature[];
        /**
            * Defines template and style encapsulation options available for Component's {@link Component}.
            */
        encapsulation?: ViewEncapsulation;
        /**
            * Defines arbitrary developer-defined data to be stored on a renderer instance.
            * This is useful for renderers that delegate to other renderers.
            *
            * see: animation
            */
        data?: {
                [kind: string]: any;
        };
        /**
            * A set of styles that the component needs to be present for component to render correctly.
            */
        styles?: string[];
        /**
            * The strategy that the default change detector uses to detect changes.
            * When set, takes effect the next time change detection is triggered.
            */
        changeDetection?: ChangeDetectionStrategy;
        /**
            * Registry of directives and components that may be found in this component's view.
            *
            * The property is either an array of `DirectiveDef`s or a function which returns the array of
            * `DirectiveDef`s. The function is necessary to be able to support forward declarations.
            */
        directives?: DirectiveTypesOrFactory | null;
        /**
            * Registry of pipes that may be found in this component's view.
            *
            * The property is either an array of `PipeDefs`s or a function which returns the array of
            * `PipeDefs`s. The function is necessary to be able to support forward declarations.
            */
        pipes?: PipeTypesOrFactory | null;
}): never;
export declare function extractDirectiveDef(type: DirectiveType<any> & ComponentType<any>): DirectiveDef<any> | ComponentDef<any>;
export declare function extractPipeDef(type: PipeType<any>): PipeDef<any>;
export declare function defineNgModule<T>(def: {
        type: T;
} & Partial<NgModuleDef<T>>): never;
/**
    * Create a base definition
    *
    * # Example
    * ```
    * class ShouldBeInherited {
    *   static ngBaseDef = defineBase({
    *      ...
    *   })
    * }
    * @param baseDefinition The base definition parameters
    */
export declare function defineBase<T>(baseDefinition: {
        /**
            * A map of input names.
            *
            * The format is in: `{[actualPropertyName: string]:(string|[string, string])}`.
            *
            * Given:
            * ```
            * class MyComponent {
            *   @Input()
            *   publicInput1: string;
            *
            *   @Input('publicInput2')
            *   declaredInput2: string;
            * }
            * ```
            *
            * is described as:
            * ```
            * {
            *   publicInput1: 'publicInput1',
            *   declaredInput2: ['declaredInput2', 'publicInput2'],
            * }
            * ```
            *
            * Which the minifier may translate to:
            * ```
            * {
            *   minifiedPublicInput1: 'publicInput1',
            *   minifiedDeclaredInput2: [ 'declaredInput2', 'publicInput2'],
            * }
            * ```
            *
            * This allows the render to re-construct the minified, public, and declared names
            * of properties.
            *
            * NOTE:
            *  - Because declared and public name are usually same we only generate the array
            *    `['declared', 'public']` format when they differ.
            *  - The reason why this API and `outputs` API is not the same is that `NgOnChanges` has
            *    inconsistent behavior in that it uses declared names rather than minified or public. For
            *    this reason `NgOnChanges` will be deprecated and removed in future version and this
            *    API will be simplified to be consistent with `outputs`.
            */
        inputs?: {
                [P in keyof T]?: string | [string, string];
        };
        /**
            * A map of output names.
            *
            * The format is in: `{[actualPropertyName: string]:string}`.
            *
            * Which the minifier may translate to: `{[minifiedPropertyName: string]:string}`.
            *
            * This allows the render to re-construct the minified and non-minified names
            * of properties.
            */
        outputs?: {
                [P in keyof T]?: string;
        };
}): BaseDef<T>;
/**
    * Create a directive definition object.
    *
    * # Example
    * ```
    * class MyDirective {
    *   // Generated by Angular Template Compiler
    *   // [Symbol] syntax will not be supported by TypeScript until v2.7
    *   static ngDirectiveDef = defineDirective({
    *     ...
    *   });
    * }
    * ```
    */
export declare const defineDirective: <T>(directiveDefinition: {
        /**
            * Directive type, needed to configure the injector.
            */
        type: Type<T>;
        /** The selectors that will be used to match nodes to this directive. */
        selectors: (string | SelectorFlags)[][];
        /**
            * Factory method used to create an instance of directive.
            */
        factory: (t: Type<T> | null) => T;
        /**
            * Static attributes to set on host element.
            *
            * Even indices: attribute name
            * Odd indices: attribute value
            */
        attributes?: string[] | undefined;
        /**
            * A map of input names.
            *
            * The format is in: `{[actualPropertyName: string]:(string|[string, string])}`.
            *
            * Given:
            * ```
            * class MyComponent {
            *   @Input()
            *   publicInput1: string;
            *
            *   @Input('publicInput2')
            *   declaredInput2: string;
            * }
            * ```
            *
            * is described as:
            * ```
            * {
            *   publicInput1: 'publicInput1',
            *   declaredInput2: ['declaredInput2', 'publicInput2'],
            * }
            * ```
            *
            * Which the minifier may translate to:
            * ```
            * {
            *   minifiedPublicInput1: 'publicInput1',
            *   minifiedDeclaredInput2: [ 'publicInput2', 'declaredInput2'],
            * }
            * ```
            *
            * This allows the render to re-construct the minified, public, and declared names
            * of properties.
            *
            * NOTE:
            *  - Because declared and public name are usually same we only generate the array
            *    `['declared', 'public']` format when they differ.
            *  - The reason why this API and `outputs` API is not the same is that `NgOnChanges` has
            *    inconsistent behavior in that it uses declared names rather than minified or public. For
            *    this reason `NgOnChanges` will be deprecated and removed in future version and this
            *    API will be simplified to be consistent with `output`.
            */
        inputs?: { [P in keyof T]?: string | [string, string] | undefined; } | undefined;
        /**
            * A map of output names.
            *
            * The format is in: `{[actualPropertyName: string]:string}`.
            *
            * Which the minifier may translate to: `{[minifiedPropertyName: string]:string}`.
            *
            * This allows the render to re-construct the minified and non-minified names
            * of properties.
            */
        outputs?: { [P in keyof T]?: string | undefined; } | undefined;
        /**
            * A list of optional features to apply.
            *
            * See: {@link NgOnChangesFeature}, {@link ProvidersFeature}, {@link InheritDefinitionFeature}
            */
        features?: DirectiveDefFeature[] | undefined;
        /**
            * The number of host bindings (including pure fn bindings) in this directive.
            *
            * Used to calculate the length of the LViewData array for the *parent* component
            * of this directive.
            */
        hostVars?: number | undefined;
        /**
            * Function executed by the parent template to allow child directive to apply host bindings.
            */
        hostBindings?: ((directiveIndex: number, elementIndex: number) => void) | undefined;
        /**
            * Function to create instances of content queries associated with a given directive.
            */
        contentQueries?: ((directiveIndex: number) => void) | undefined;
        /** Refreshes content queries associated with directives in a given view */
        contentQueriesRefresh?: ((directiveIndex: number, queryIndex: number) => void) | undefined;
        /**
            * Defines the name that can be used in the template to assign this directive to a variable.
            *
            * See: {@link Directive.exportAs}
            */
        exportAs?: string | undefined;
}) => never;
/**
    * Create a pipe definition object.
    *
    * # Example
    * ```
    * class MyPipe implements PipeTransform {
    *   // Generated by Angular Template Compiler
    *   static ngPipeDef = definePipe({
    *     ...
    *   });
    * }
    * ```
    * @param pipeDef Pipe definition generated by the compiler
    */
export declare function definePipe<T>(pipeDef: {
        /** Name of the pipe. Used for matching pipes in template to pipe defs. */
        name: string;
        /** Pipe class reference. Needed to extract pipe lifecycle hooks. */
        type: Type<T>;
        /** A factory for creating a pipe instance. */
        factory: (t: Type<T> | null) => T;
        /** Whether the pipe is pure. */
        pure?: boolean;
}): never;
/**
    * The following getter methods retrieve the definition form the type. Currently the retrieval
    * honors inheritance, but in the future we may change the rule to require that definitions are
    * explicit. This would require some sort of migration strategy.
    */
export declare function getComponentDef<T>(type: any): ComponentDef<T> | null;
export declare function getDirectiveDef<T>(type: any): DirectiveDef<T> | null;
export declare function getPipeDef<T>(type: any): PipeDef<T> | null;
export declare function getNgModuleDef<T>(type: any): NgModuleDef<T> | null;

/**
    * @license
    * Copyright Google Inc. All Rights Reserved.
    *
    * Use of this source code is governed by an MIT-style license that can be
    * found in the LICENSE file at https://angular.io/license
    */
import { Injector } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/di/injector';
import { LContext } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/render3/interfaces/context';
import { LViewData, RootContext } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/render3/interfaces/view';
/**
    * Returns the component instance associated with a given DOM host element.
    * Elements which don't represent components return `null`.
    *
    * @param element Host DOM element from which the component should be retrieved for.
    *
    * ```
    * <my-app>
    *   #VIEW
    *     <div>
    *       <child-comp></child-comp>
    *     </div>
    * </mp-app>
    *
    * expect(getComponent(<child-comp>) instanceof ChildComponent).toBeTruthy();
    * expect(getComponent(<my-app>) instanceof MyApp).toBeTruthy();
    * ```
    *
    * @publicApi
    */
export declare function getComponent<T = {}>(element: Element): T | null;
/**
    * Returns the component instance associated with view which owns the DOM element (`null`
    * otherwise).
    *
    * @param element DOM element which is owned by an existing component's view.
    *
    * ```
    * <my-app>
    *   #VIEW
    *     <div>
    *       <child-comp></child-comp>
    *     </div>
    * </mp-app>
    *
    * expect(getViewComponent(<child-comp>) instanceof MyApp).toBeTruthy();
    * expect(getViewComponent(<my-app>)).toEqual(null);
    * ```
    *
    * @publicApi
    */
export declare function getViewComponent<T = {}>(element: Element | {}): T | null;
/**
    * Returns the `RootContext` instance that is associated with
    * the application where the target is situated.
    *
    */
export declare function getRootContext(target: LViewData | {}): RootContext;
/**
    * Retrieve all root components.
    *
    * Root components are those which have been bootstrapped by Angular.
    *
    * @param target A DOM element, component or directive instance.
    *
    * @publicApi
    */
export declare function getRootComponents(target: {}): any[];
/**
    * Retrieves an `Injector` associated with the element, component or directive.
    *
    * @param target A DOM element, component or directive instance.
    *
    * @publicApi
    */
export declare function getInjector(target: {}): Injector;
/**
    * Retrieves directives associated with a given DOM host element.
    *
    * @param target A DOM element, component or directive instance.
    *
    * @publicApi
    */
export declare function getDirectives(target: {}): Array<{}>;
/**
    * Returns LContext associated with a target passed as an argument.
    * Throws if a given target doesn't have associated LContext.
    *
    */
export declare function loadContext(target: {}): LContext;
/**
    * Retrieve the root view from any component by walking the parent `LViewData` until
    * reaching the root `LViewData`.
    *
    * @param componentOrView any component or view
    *
    */
export declare function getRootView(componentOrView: LViewData | {}): LViewData;
/**
    * Retrieve map of local references.
    *
    * The references are retrieved as a map of local reference name to element or directive instance.
    *
    * @param target A DOM element, component or directive instance.
    *
    * @publicApi
    */
export declare function getLocalRefs(target: {}): {
        [key: string]: any;
};
/**
    * Retrieve the host element of the component.
    *
    * Use this function to retrieve the host element of the component. The host
    * element is the element which the component is associated with.
    *
    * @param directive Component or Directive for which the host element should be retrieved.
    *
    * @publicApi
    */
export declare function getHostElement<T>(directive: T): Element;
/**
    * Retrieves the rendered text for a given component.
    *
    * This function retrieves the host element of a component and
    * and then returns the `textContent` for that element. This implies
    * that the text returned will include re-projected content of
    * the component as well.
    *
    * @param component The component to return the content text for.
    */
export declare function getRenderedText(component: any): string;

/**
    * @license
    * Copyright Google Inc. All Rights Reserved.
    *
    * Use of this source code is governed by an MIT-style license that can be
    * found in the LICENSE file at https://angular.io/license
    */
import { ComponentDef, DirectiveDef } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/render3/interfaces/definition';
/**
    * Merges the definition from a super class to a sub class.
    * @param definition The definition that is a SubClass of another directive of component
    */
export declare function InheritDefinitionFeature(definition: DirectiveDef<any> | ComponentDef<any>): void;

/**
    * @license
    * Copyright Google Inc. All Rights Reserved.
    *
    * Use of this source code is governed by an MIT-style license that can be
    * found in the LICENSE file at https://angular.io/license
    */
import { DirectiveDef } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/render3/interfaces/definition';
/**
    * The NgOnChangesFeature decorates a component with support for the ngOnChanges
    * lifecycle hook, so it should be included in any component that implements
    * that hook.
    *
    * If the component or directive uses inheritance, the NgOnChangesFeature MUST
    * be included as a feature AFTER {@link InheritDefinitionFeature}, otherwise
    * inherited properties will not be propagated to the ngOnChanges lifecycle
    * hook.
    *
    * Example usage:
    *
    * ```
    * static ngComponentDef = defineComponent({
    *   ...
    *   inputs: {name: 'publicName'},
    *   features: [NgOnChangesFeature]
    * });
    * ```
    */
export declare function NgOnChangesFeature<T>(definition: DirectiveDef<T>): void;

/**
    * @license
    * Copyright Google Inc. All Rights Reserved.
    *
    * Use of this source code is governed by an MIT-style license that can be
    * found in the LICENSE file at https://angular.io/license
    */
import { Provider } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/di/provider';
import { DirectiveDef } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/render3/interfaces/definition';
/**
    * This feature resolves the providers of a directive (or component),
    * and publish them into the DI system, making it visible to others for injection.
    *
    * For example:
    * class ComponentWithProviders {
    *   constructor(private greeter: GreeterDE) {}
    *
    *   static ngComponentDef = defineComponent({
    *     type: ComponentWithProviders,
    *     selectors: [['component-with-providers']],
    *    factory: () => new ComponentWithProviders(directiveInject(GreeterDE as any)),
    *    consts: 1,
    *    vars: 1,
    *    template: function(fs: RenderFlags, ctx: ComponentWithProviders) {
    *      if (fs & RenderFlags.Create) {
    *        text(0);
    *      }
    *      if (fs & RenderFlags.Update) {
    *        textBinding(0, bind(ctx.greeter.greet()));
    *      }
    *    },
    *    features: [ProvidersFeature([GreeterDE])]
    *  });
    * }
    *
    * @param definition
    */
export declare function ProvidersFeature<T>(providers: Provider[], viewProviders?: Provider[]): (definition: DirectiveDef<T>) => void;

/**
    * @license
    * Copyright Google Inc. All Rights Reserved.
    *
    * Use of this source code is governed by an MIT-style license that can be
    * found in the LICENSE file at https://angular.io/license
    */
import { ViewEncapsulation } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/core';
import { Type } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/type';
import { CssSelectorList } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/render3/interfaces/projection';
/**
    * Definition of what a template rendering function should look like for a component.
    */
export declare type ComponentTemplate<T> = {
        (rf: RenderFlags, ctx: T): void;
        ngPrivateData?: never;
};
/**
    * Definition of what a query function should look like.
    */
export declare type ComponentQuery<T> = ComponentTemplate<T>;
/**
    * Flags passed into template functions to determine which blocks (i.e. creation, update)
    * should be executed.
    *
    * Typically, a template runs both the creation block and the update block on initialization and
    * subsequent runs only execute the update block. However, dynamically created views require that
    * the creation block be executed separately from the update block (for backwards compat).
    */
export declare const enum RenderFlags {
        Create = 1,
        Update = 2
}
/**
    * A subclass of `Type` which has a static `ngComponentDef`:`ComponentDef` field making it
    * consumable for rendering.
    */
export interface ComponentType<T> extends Type<T> {
        ngComponentDef: never;
}
/**
    * A subclass of `Type` which has a static `ngDirectiveDef`:`DirectiveDef` field making it
    * consumable for rendering.
    */
export interface DirectiveType<T> extends Type<T> {
        ngDirectiveDef: never;
}
export declare const enum DirectiveDefFlags {
        ContentQuery = 2
}
/**
    * A subclass of `Type` which has a static `ngPipeDef`:`PipeDef` field making it
    * consumable for rendering.
    */
export interface PipeType<T> extends Type<T> {
        ngPipeDef: never;
}
export declare type DirectiveDefWithMeta<T, Selector extends string, ExportAs extends string, InputMap extends {
        [key: string]: string;
}, OutputMap extends {
        [key: string]: string;
}, QueryFields extends string[]> = DirectiveDef<T>;
/**
    * Runtime information for classes that are inherited by components or directives
    * that aren't defined as components or directives.
    *
    * This is an internal data structure used by the render to determine what inputs
    * and outputs should be inherited.
    *
    * See: {@link defineBase}
    */
export interface BaseDef<T> {
        /**
            * A dictionary mapping the inputs' minified property names to their public API names, which
            * are their aliases if any, or their original unminified property names
            * (as in `@Input('alias') propertyName: any;`).
            */
        readonly inputs: {
                [P in keyof T]: string;
        };
        /**
            * @deprecated This is only here because `NgOnChanges` incorrectly uses declared name instead of
            * public or minified name.
            */
        readonly declaredInputs: {
                [P in keyof T]: P;
        };
        /**
            * A dictionary mapping the outputs' minified property names to their public API names, which
            * are their aliases if any, or their original unminified property names
            * (as in `@Output('alias') propertyName: any;`).
            */
        readonly outputs: {
                [P in keyof T]: P;
        };
}
/**
    * Runtime link information for Directives.
    *
    * This is internal data structure used by the render to link
    * directives into templates.
    *
    * NOTE: Always use `defineDirective` function to create this object,
    * never create the object directly since the shape of this object
    * can change between versions.
    *
    * @param Selector type metadata specifying the selector of the directive or component
    *
    * See: {@link defineDirective}
    */
export interface DirectiveDef<T> extends BaseDef<T> {
        /** Token representing the directive. Used by DI. */
        type: Type<T>;
        /** Function that resolves providers and publishes them into the DI system. */
        providersResolver: ((def: DirectiveDef<T>) => void) | null;
        /** The selectors that will be used to match nodes to this directive. */
        readonly selectors: CssSelectorList;
        /**
            * Name under which the directive is exported (for use with local references in template)
            */
        readonly exportAs: string | null;
        /**
            * Factory function used to create a new directive instance.
            */
        factory: (t: Type<T> | null) => T;
        /**
            * Function to create instances of content queries associated with a given directive.
            */
        contentQueries: ((directiveIndex: number) => void) | null;
        /** Refreshes content queries associated with directives in a given view */
        contentQueriesRefresh: ((directiveIndex: number, queryIndex: number) => void) | null;
        /**
            * The number of host bindings (including pure fn bindings) in this directive/component.
            *
            * Used to calculate the length of the LViewData array for the *parent* component
            * of this directive/component.
            */
        readonly hostVars: number;
        /** Refreshes host bindings on the associated directive. */
        hostBindings: HostBindingsFunction | null;
        /**
            * Static attributes to set on host element.
            *
            * Even indices: attribute name
            * Odd indices: attribute value
            */
        readonly attributes: string[] | null;
        onInit: (() => void) | null;
        doCheck: (() => void) | null;
        afterContentInit: (() => void) | null;
        afterContentChecked: (() => void) | null;
        afterViewInit: (() => void) | null;
        afterViewChecked: (() => void) | null;
        onDestroy: (() => void) | null;
        /**
            * The features applied to this directive
            */
        readonly features: DirectiveDefFeature[] | null;
}
export declare type ComponentDefWithMeta<T, Selector extends String, ExportAs extends string, InputMap extends {
        [key: string]: string;
}, OutputMap extends {
        [key: string]: string;
}, QueryFields extends string[]> = ComponentDef<T>;
/**
    * Runtime link information for Components.
    *
    * This is internal data structure used by the render to link
    * components into templates.
    *
    * NOTE: Always use `defineComponent` function to create this object,
    * never create the object directly since the shape of this object
    * can change between versions.
    *
    * See: {@link defineComponent}
    */
export interface ComponentDef<T> extends DirectiveDef<T> {
        /**
            * Runtime unique component ID.
            */
        readonly id: string;
        /**
            * The View template of the component.
            */
        readonly template: ComponentTemplate<T>;
        /**
            * A set of styles that the component needs to be present for component to render correctly.
            */
        readonly styles: string[];
        /**
            * The number of nodes, local refs, and pipes in this component template.
            *
            * Used to calculate the length of the component's LViewData array, so we
            * can pre-fill the array and set the binding start index.
            */
        readonly consts: number;
        /**
            * The number of bindings in this component template (including pure fn bindings).
            *
            * Used to calculate the length of the component's LViewData array, so we
            * can pre-fill the array and set the host binding start index.
            */
        readonly vars: number;
        /**
            * Query-related instructions for a component.
            */
        viewQuery: ComponentQuery<T> | null;
        /**
            * The view encapsulation type, which determines how styles are applied to
            * DOM elements. One of
            * - `Emulated` (default): Emulate native scoping of styles.
            * - `Native`: Use the native encapsulation mechanism of the renderer.
            * - `ShadowDom`: Use modern [ShadowDOM](https://w3c.github.io/webcomponents/spec/shadow/) and
            *   create a ShadowRoot for component's host element.
            * - `None`: Do not provide any template or style encapsulation.
            */
        readonly encapsulation: ViewEncapsulation;
        /**
            * Defines arbitrary developer-defined data to be stored on a renderer instance.
            * This is useful for renderers that delegate to other renderers.
            */
        readonly data: {
                [kind: string]: any;
        };
        /** Whether or not this component's ChangeDetectionStrategy is OnPush */
        readonly onPush: boolean;
        /**
    
            * Registry of directives and components that may be found in this view.
            *
            * The property is either an array of `DirectiveDef`s or a function which returns the array of
            * `DirectiveDef`s. The function is necessary to be able to support forward declarations.
            */
        directiveDefs: DirectiveDefListOrFactory | null;
        /**
            * Registry of pipes that may be found in this view.
            *
            * The property is either an array of `PipeDefs`s or a function which returns the array of
            * `PipeDefs`s. The function is necessary to be able to support forward declarations.
            */
        pipeDefs: PipeDefListOrFactory | null;
        /**
            * Used to store the result of `noSideEffects` function so that it is not removed by closure
            * compiler. The property should never be read.
            */
        readonly _?: never;
}
/**
    * Runtime link information for Pipes.
    *
    * This is internal data structure used by the renderer to link
    * pipes into templates.
    *
    * NOTE: Always use `definePipe` function to create this object,
    * never create the object directly since the shape of this object
    * can change between versions.
    *
    * See: {@link definePipe}
    */
export interface PipeDef<T> {
        /**
            * Pipe name.
            *
            * Used to resolve pipe in templates.
            */
        readonly name: string;
        /**
            * Factory function used to create a new pipe instance.
            */
        factory: (t: Type<T> | null) => T;
        /**
            * Whether or not the pipe is pure.
            *
            * Pure pipes result only depends on the pipe input and not on internal
            * state of the pipe.
            */
        readonly pure: boolean;
        onDestroy: (() => void) | null;
}
export declare type PipeDefWithMeta<T, Name extends string> = PipeDef<T>;
export interface DirectiveDefFeature {
        <T>(directiveDef: DirectiveDef<T>): void;
        ngInherit?: true;
}
export interface ComponentDefFeature {
        <T>(componentDef: ComponentDef<T>): void;
        ngInherit?: true;
}
/**
    * Type used for directiveDefs on component definition.
    *
    * The function is necessary to be able to support forward declarations.
    */
export declare type DirectiveDefListOrFactory = (() => DirectiveDefList) | DirectiveDefList;
export declare type DirectiveDefList = (DirectiveDef<any> | ComponentDef<any>)[];
export declare type DirectiveTypesOrFactory = (() => DirectiveTypeList) | DirectiveTypeList;
export declare type DirectiveTypeList = (DirectiveDef<any> | ComponentDef<any> | Type<any>)[];
export declare type HostBindingsFunction = (directiveIndex: number, elementIndex: number) => void;
/**
    * Type used for PipeDefs on component definition.
    *
    * The function is necessary to be able to support forward declarations.
    */
export declare type PipeDefListOrFactory = (() => PipeDefList) | PipeDefList;
export declare type PipeDefList = PipeDef<any>[];
export declare type PipeTypesOrFactory = (() => DirectiveTypeList) | DirectiveTypeList;
export declare type PipeTypeList = (PipeDef<any> | Type<any>)[];
export declare const unusedValueExportToPlacateAjd = 1;
export declare const enum InitialStylingFlags {
        VALUES_MODE = 1
}

/**
    * @license
    * Copyright Google Inc. All Rights Reserved.
    *
    * Use of this source code is governed by an MIT-style license that can be
    * found in the LICENSE file at https://angular.io/license
    */
import { ChangeDetectorRef as ViewEngine_ChangeDetectorRef } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/change_detection/change_detector_ref';
import { InjectionToken } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/di/injection_token';
import { Injector } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/di/injector';
import { ComponentFactory as viewEngine_ComponentFactory, ComponentRef as viewEngine_ComponentRef } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/linker/component_factory';
import { ComponentFactoryResolver as viewEngine_ComponentFactoryResolver } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/linker/component_factory_resolver';
import { ElementRef as viewEngine_ElementRef } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/linker/element_ref';
import { NgModuleRef as viewEngine_NgModuleRef } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/linker/ng_module_factory';
import { RendererFactory2 } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/render/api';
import { Type } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/type';
import { ComponentDef } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/render3/interfaces/definition';
import { TContainerNode, TElementContainerNode, TElementNode } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/render3/interfaces/node';
import { LViewData, RootContext } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/render3/interfaces/view';
import { ViewRef } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/render3/view_ref';
export declare class ComponentFactoryResolver extends viewEngine_ComponentFactoryResolver {
        resolveComponentFactory<T>(component: Type<T>): viewEngine_ComponentFactory<T>;
}
/**
    * Default {@link RootContext} for all components rendered with {@link renderComponent}.
    */
export declare const ROOT_CONTEXT: InjectionToken<RootContext>;
/**
    * A change detection scheduler token for {@link RootContext}. This token is the default value used
    * for the default `RootContext` found in the {@link ROOT_CONTEXT} token.
    */
export declare const SCHEDULER: InjectionToken<(fn: () => void) => void>;
/**
    * A function used to wrap the `RendererFactory2`.
    * Used in tests to change the `RendererFactory2` into a `DebugRendererFactory2`.
    */
export declare const WRAP_RENDERER_FACTORY2: InjectionToken<(rf: RendererFactory2) => RendererFactory2>;
/**
    * Render3 implementation of {@link viewEngine_ComponentFactory}.
    */
export declare class ComponentFactory<T> extends viewEngine_ComponentFactory<T> {
        selector: string;
        componentType: Type<any>;
        ngContentSelectors: string[];
        readonly inputs: {
                propName: string;
                templateName: string;
        }[];
        readonly outputs: {
                propName: string;
                templateName: string;
        }[];
        constructor(componentDef: ComponentDef<any>);
        create(injector: Injector, projectableNodes?: any[][] | undefined, rootSelectorOrNode?: any, ngModule?: viewEngine_NgModuleRef<any> | undefined): viewEngine_ComponentRef<T>;
}
/**
    * Creates a ComponentFactoryResolver and stores it on the injector. Or, if the
    * ComponentFactoryResolver
    * already exists, retrieves the existing ComponentFactoryResolver.
    *
    * @returns The ComponentFactoryResolver instance to use
    */
export declare function injectComponentFactoryResolver(): viewEngine_ComponentFactoryResolver;
/**
    * Represents an instance of a Component created via a {@link ComponentFactory}.
    *
    * `ComponentRef` provides access to the Component Instance as well other objects related to this
    * Component Instance and allows you to destroy the Component Instance via the {@link #destroy}
    * method.
    *
    */
export declare class ComponentRef<T> extends viewEngine_ComponentRef<T> {
        location: viewEngine_ElementRef;
        destroyCbs: (() => void)[] | null;
        instance: T;
        hostView: ViewRef<T>;
        changeDetectorRef: ViewEngine_ChangeDetectorRef;
        componentType: Type<T>;
        constructor(componentType: Type<T>, instance: T, location: viewEngine_ElementRef, _rootView: LViewData, _tNode: TElementNode | TContainerNode | TElementContainerNode);
        readonly injector: Injector;
        destroy(): void;
        onDestroy(callback: () => void): void;
}

/**
    * @license
    * Copyright Google Inc. All Rights Reserved.
    *
    * Use of this source code is governed by an MIT-style license that can be
    * found in the LICENSE file at https://angular.io/license
    */
import { InjectionToken } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/di/injection_token';
import { Injector } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/di/injector';
import { InjectFlags } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/di/injector_compatibility';
import { Type } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/type';
import { RelativeInjectorLocation } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/render3/interfaces/injector';
import { TContainerNode, TElementContainerNode, TElementNode, TNode } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/render3/interfaces/node';
import { LViewData, TData, TView } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/render3/interfaces/view';
/**
    * Registers this directive as present in its node's injector by flipping the directive's
    * corresponding bit in the injector's bloom filter.
    *
    * @param injectorIndex The index of the node injector where this token should be registered
    * @param tView The TView for the injector's bloom filters
    * @param type The directive token to register
    */
export declare function bloomAdd(injectorIndex: number, tView: TView, type: Type<any> | InjectionToken<any>): void;
/**
    * Creates (or gets an existing) injector for a given element or container.
    *
    * @param tNode for which an injector should be retrieved / created.
    * @param hostView View where the node is stored
    * @returns Node injector
    */
export declare function getOrCreateNodeInjectorForNode(tNode: TElementNode | TContainerNode | TElementContainerNode, hostView: LViewData): number;
export declare function getInjectorIndex(tNode: TNode, hostView: LViewData): number;
/**
    * Finds the index of the parent injector, with a view offset if applicable. Used to set the
    * parent injector initially.
    *
    * Returns a combination of number of `ViewData` we have to go up and index in that `Viewdata`
    */
export declare function getParentInjectorLocation(tNode: TNode, view: LViewData): RelativeInjectorLocation;
/**
    * Makes a type or an injection token public to the DI system by adding it to an
    * injector's bloom filter.
    *
    * @param di The node injector in which a directive will be added
    * @param token The type or the injection token to be made public
    */
export declare function diPublicInInjector(injectorIndex: number, view: LViewData, token: InjectionToken<any> | Type<any>): void;
/**
    * Inject static attribute value into directive constructor.
    *
    * This method is used with `factory` functions which are generated as part of
    * `defineDirective` or `defineComponent`. The method retrieves the static value
    * of an attribute. (Dynamic attributes are not supported since they are not resolved
    *  at the time of injection and can change over time.)
    *
    * # Example
    * Given:
    * ```
    * @Component(...)
    * class MyComponent {
    *   constructor(@Attribute('title') title: string) { ... }
    * }
    * ```
    * When instantiated with
    * ```
    * <my-component title="Hello"></my-component>
    * ```
    *
    * Then factory method generated is:
    * ```
    * MyComponent.ngComponentDef = defineComponent({
    *   factory: () => new MyComponent(injectAttribute('title'))
    *   ...
    * })
    * ```
    *
    * @publicApi
    */
export declare function injectAttributeImpl(tNode: TNode, attrNameToInject: string): string | undefined;
/**
    * Returns the value associated to the given token from the NodeInjectors => ModuleInjector.
    *
    * Look for the injector providing the token by walking up the node injector tree and then
    * the module injector tree.
    *
    * @param nodeInjector Node injector where the search should start
    * @param token The token to look for
    * @param flags Injection flags
    * @returns the value from the injector or `null` when not found
    */
export declare function getOrCreateInjectable<T>(tNode: TElementNode | TContainerNode | TElementContainerNode, lViewData: LViewData, token: Type<T> | InjectionToken<T>, flags?: InjectFlags, notFoundValue?: any): T | null;
/**
 * Retrieve or instantiate the injectable from the `lData` at particular `index`.
 *
 * This function checks to see if the value has already been instantiated and if so returns the
 * cached `injectable`. Otherwise if it detects that the value is still a factory it
 * instantiates the `injectable` and caches the value.
 */
export declare function getNodeInjectable(tData: TData, lData: LViewData, index: number, tNode: TElementNode): any;
/**
    * Returns the bit in an injector's bloom filter that should be used to determine whether or not
    * the directive might be provided by the injector.
    *
    * When a directive is public, it is added to the bloom filter and given a unique ID that can be
    * retrieved on the Type. When the directive isn't public or the token is not a directive `null`
    * is returned as the node injector can not possibly provide that token.
    *
    * @param token the injection token
    * @returns the matching bit to check in the bloom filter or `null` if the token is not known.
    */
export declare function bloomHashBitOrFactory(token: Type<any> | InjectionToken<any>): number | Function | undefined;
export declare function bloomHasToken(bloomHash: number, injectorIndex: number, injectorView: LViewData | TData): boolean;
export declare function injectInjector(): NodeInjector;
export declare class NodeInjector implements Injector {
        constructor(_tNode: TElementNode | TContainerNode | TElementContainerNode, _hostView: LViewData);
        get(token: any): any;
}
export declare function getFactoryOf<T>(type: Type<any>): ((type: Type<T> | null) => T) | null;
export declare function getInheritedFactory<T>(type: Type<any>): (type: Type<T>) => T;

/**
    * Expresses a single CSS Selector.
    *
    * Beginning of array
    * - First index: element name
    * - Subsequent odd indices: attr keys
    * - Subsequent even indices: attr values
    *
    * After SelectorFlags.CLASS flag
    * - Class name values
    *
    * SelectorFlags.NOT flag
    * - Changes the mode to NOT
    * - Can be combined with other flags to set the element / attr / class mode
    *
    * e.g. SelectorFlags.NOT | SelectorFlags.ELEMENT
    *
    * Example:
    * Original: `div.foo.bar[attr1=val1][attr2]`
    * Parsed: ['div', 'attr1', 'val1', 'attr2', '', SelectorFlags.CLASS, 'foo', 'bar']
    *
    * Original: 'div[attr1]:not(.foo[attr2])
    * Parsed: [
    *  'div', 'attr1', '',
    *  SelectorFlags.NOT | SelectorFlags.ATTRIBUTE 'attr2', '', SelectorFlags.CLASS, 'foo'
    * ]
    *
    * See more examples in node_selector_matcher_spec.ts
    */
export declare type CssSelector = (string | SelectorFlags)[];
/**
    * A list of CssSelectors.
    *
    * A directive or component can have multiple selectors. This type is used for
    * directive defs so any of the selectors in the list will match that directive.
    *
    * Original: 'form, [ngForm]'
    * Parsed: [['form'], ['', 'ngForm', '']]
    */
export declare type CssSelectorList = CssSelector[];
/** Flags used to build up CssSelectors */
export declare const enum SelectorFlags {
        /** Indicates this is the beginning of a new negative selector */
        NOT = 1,
        /** Mode for matching attributes */
        ATTRIBUTE = 2,
        /** Mode for matching tag names */
        ELEMENT = 4,
        /** Mode for matching class names */
        CLASS = 8
}
export declare const NG_PROJECT_AS_ATTR_NAME = "ngProjectAs";
export declare const unusedValueExportToPlacateAjd = 1;

/**
    * @license
    * Copyright Google Inc. All Rights Reserved.
    *
    * Use of this source code is governed by an MIT-style license that can be
    * found in the LICENSE file at https://angular.io/license
    */
import { InjectionToken } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/di/injection_token';
import { Injector } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/di/injector';
import { InjectFlags } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/di/injector_compatibility';
import { QueryList } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/linker';
import { Sanitizer } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/sanitization/security';
import { StyleSanitizeFn } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/sanitization/style_sanitizer';
import { Type } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/type';
import { LContainer } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/render3/interfaces/container';
import { ComponentDef, ComponentQuery, ComponentTemplate, DirectiveDefListOrFactory, InitialStylingFlags, PipeDefListOrFactory, RenderFlags } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/render3/interfaces/definition';
import { LocalRefExtractor, TAttributes, TContainerNode, TElementContainerNode, TElementNode, TNode, TNodeType, TProjectionNode, TViewNode } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/render3/interfaces/node';
import { PlayerFactory } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/render3/interfaces/player';
import { CssSelectorList } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/render3/interfaces/projection';
import { LQueries } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/render3/interfaces/query';
import { RComment, RElement, RText, Renderer3, RendererFactory3 } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/render3/interfaces/renderer';
import { SanitizerFn } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/render3/interfaces/sanitization';
import { LViewData, LViewFlags, RootContext, RootContextFlags, TView } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/render3/interfaces/view';
import { NO_CHANGE } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/render3/tokens';
/**
    * Refreshes the view, executing the following steps in that order:
    * triggers init hooks, refreshes dynamic embedded views, triggers content hooks, sets host
    * bindings, refreshes child components.
    * Note: view hooks are triggered later when leaving the view.
    */
export declare function refreshDescendantViews(viewData: LViewData, rf: RenderFlags | null): void;
/** Sets the host bindings for the current view. */
export declare function setHostBindings(tView: TView, viewData: LViewData): void;
export declare function createLViewData<T>(parentViewData: LViewData | null, renderer: Renderer3, tView: TView, context: T | null, flags: LViewFlags, sanitizer?: Sanitizer | null, injector?: Injector | null): LViewData;
/**
    * Create and stores the TNode, and hooks it up to the tree.
    *
    * @param index The index at which the TNode should be saved (null if view, since they are not
    * saved).
    * @param type The type of TNode to create
    * @param native The native element for this node, if applicable
    * @param name The tag name of the associated native element, if applicable
    * @param attrs Any attrs for the native element, if applicable
    */
export declare function createNodeAtIndex(index: number, type: TNodeType.Element, native: RElement | RText | null, name: string | null, attrs: TAttributes | null): TElementNode;
export declare function createNodeAtIndex(index: number, type: TNodeType.Container, native: RComment, name: string | null, attrs: TAttributes | null): TContainerNode;
export declare function createNodeAtIndex(index: number, type: TNodeType.Projection, native: null, name: null, attrs: TAttributes | null): TProjectionNode;
export declare function createNodeAtIndex(index: number, type: TNodeType.ElementContainer, native: RComment, name: null, attrs: TAttributes | null): TElementContainerNode;
export declare function createNodeAtIndex(index: number, type: TNodeType.IcuContainer, native: RComment, name: null, attrs: TAttributes | null): TElementContainerNode;
export declare function createViewNode(index: number, view: LViewData): TViewNode;
/**
    * When elements are created dynamically after a view blueprint is created (e.g. through
    * i18nApply() or ComponentFactory.create), we need to adjust the blueprint for future
    * template passes.
    */
export declare function allocExpando(view: LViewData): void;
/**
    *
    * @param hostNode Existing node to render into.
    * @param templateFn Template function with the instructions.
    * @param consts The number of nodes, local refs, and pipes in this template
    * @param context to pass into the template.
    * @param providedRendererFactory renderer factory to use
    * @param host The host element node to use
    * @param directives Directive defs that should be used for matching
    * @param pipes Pipe defs that should be used for matching
    */
export declare function renderTemplate<T>(hostNode: RElement, templateFn: ComponentTemplate<T>, consts: number, vars: number, context: T, providedRendererFactory: RendererFactory3, hostView: LViewData | null, directives?: DirectiveDefListOrFactory | null, pipes?: PipeDefListOrFactory | null, sanitizer?: Sanitizer | null): LViewData;
/**
    * Used for creating the LViewNode of a dynamic embedded view,
    * either through ViewContainerRef.createEmbeddedView() or TemplateRef.createEmbeddedView().
    * Such lViewNode will then be renderer with renderEmbeddedTemplate() (see below).
    */
export declare function createEmbeddedViewAndNode<T>(tView: TView, context: T, declarationView: LViewData, renderer: Renderer3, queries: LQueries | null, injectorIndex: number): LViewData;
/**
    * Used for rendering embedded views (e.g. dynamically created views)
    *
    * Dynamically created views must store/retrieve their TViews differently from component views
    * because their template functions are nested in the template functions of their hosts, creating
    * closures. If their host template happens to be an embedded template in a loop (e.g. ngFor inside
    * an ngFor), the nesting would mean we'd have multiple instances of the template function, so we
    * can't store TViews in the template function itself (as we do for comps). Instead, we store the
    * TView for dynamically created views on their host TNode, which only has one instance.
    */
export declare function renderEmbeddedTemplate<T>(viewToRender: LViewData, tView: TView, context: T, rf: RenderFlags): void;
/**
    * Retrieves a context at the level specified and saves it as the global, contextViewData.
    * Will get the next level up if level is not specified.
    *
    * This is used to save contexts of parent views so they can be bound in embedded views, or
    * in conjunction with reference() to bind a ref from a parent view.
    *
    * @param level The relative level of the view from which to grab context compared to contextVewData
    * @returns context
    */
export declare function nextContext<T = any>(level?: number): T;
export declare function namespaceSVG(): void;
export declare function namespaceMathML(): void;
export declare function namespaceHTML(): void;
/**
    * Creates an empty element using {@link elementStart} and {@link elementEnd}
    *
    * @param index Index of the element in the data array
    * @param name Name of the DOM Node
    * @param attrs Statically bound set of attributes to be written into the DOM element on creation.
    * @param localRefs A set of local reference bindings on the element.
    */
export declare function element(index: number, name: string, attrs?: TAttributes | null, localRefs?: string[] | null): void;
/**
    * Creates a logical container for other nodes (<ng-container>) backed by a comment node in the DOM.
    * The instruction must later be followed by `elementContainerEnd()` call.
    *
    * @param index Index of the element in the LViewData array
    * @param attrs Set of attributes to be used when matching directives.
    * @param localRefs A set of local reference bindings on the element.
    *
    * Even if this instruction accepts a set of attributes no actual attribute values are propagated to
    * the DOM (as a comment node can't have attributes). Attributes are here only for directive
    * matching purposes and setting initial inputs of directives.
    */
export declare function elementContainerStart(index: number, attrs?: TAttributes | null, localRefs?: string[] | null): void;
/** Mark the end of the <ng-container>. */
export declare function elementContainerEnd(): void;
/**
    * Create DOM element. The instruction must later be followed by `elementEnd()` call.
    *
    * @param index Index of the element in the LViewData array
    * @param name Name of the DOM Node
    * @param attrs Statically bound set of attributes to be written into the DOM element on creation.
    * @param localRefs A set of local reference bindings on the element.
    *
    * Attributes and localRefs are passed as an array of strings where elements with an even index
    * hold an attribute name and elements with an odd index hold an attribute value, ex.:
    * ['id', 'warning5', 'class', 'alert']
    */
export declare function elementStart(index: number, name: string, attrs?: TAttributes | null, localRefs?: string[] | null): void;
/**
    * Creates a native element from a tag name, using a renderer.
    * @param name the tag name
    * @param overriddenRenderer Optional A renderer to override the default one
    * @returns the element created
    */
export declare function elementCreate(name: string, overriddenRenderer?: Renderer3): RElement;
/**
    * Gets TView from a template function or creates a new TView
    * if it doesn't already exist.
    *
    * @param templateFn The template from which to get static data
    * @param consts The number of nodes, local refs, and pipes in this view
    * @param vars The number of bindings and pure function bindings in this view
    * @param directives Directive defs that should be saved on TView
    * @param pipes Pipe defs that should be saved on TView
    * @returns TView
    */
export declare function getOrCreateTView(templateFn: ComponentTemplate<any>, consts: number, vars: number, directives: DirectiveDefListOrFactory | null, pipes: PipeDefListOrFactory | null, viewQuery: ComponentQuery<any> | null): TView;
/**
    * Creates a TView instance
    *
    * @param viewIndex The viewBlockId for inline views, or -1 if it's a component/dynamic
    * @param templateFn Template function
    * @param consts The number of nodes, local refs, and pipes in this template
    * @param directives Registry of directives for this view
    * @param pipes Registry of pipes for this view
    */
export declare function createTView(viewIndex: number, templateFn: ComponentTemplate<any> | null, consts: number, vars: number, directives: DirectiveDefListOrFactory | null, pipes: PipeDefListOrFactory | null, viewQuery: ComponentQuery<any> | null): TView;
export declare function createError(text: string, token: any): Error;
/**
    * Locates the host native element, used for bootstrapping existing nodes into rendering pipeline.
    *
    * @param elementOrSelector Render element or CSS selector to locate the element.
    */
export declare function locateHostElement(factory: RendererFactory3, elementOrSelector: RElement | string): RElement | null;
/**
    * Adds an event listener to the current node.
    *
    * If an output exists on one of the node's directives, it also subscribes to the output
    * and saves the subscription for later cleanup.
    *
    * @param eventName Name of the event
    * @param listenerFn The function to be called when event emits
    * @param useCapture Whether or not to use capture in event listener.
    */
export declare function listener(eventName: string, listenerFn: (e?: any) => any, useCapture?: boolean): void;
/**
    * Saves context for this cleanup function in LView.cleanupInstances.
    *
    * On the first template pass, saves in TView:
    * - Cleanup function
    * - Index of context we just saved in LView.cleanupInstances
    */
export declare function storeCleanupWithContext(view: LViewData | null, context: any, cleanupFn: Function): void;
/**
    * Saves the cleanup function itself in LView.cleanupInstances.
    *
    * This is necessary for functions that are wrapped with their contexts, like in renderer2
    * listeners.
    *
    * On the first template pass, the index of the cleanup function is saved in TView.
    */
export declare function storeCleanupFn(view: LViewData, cleanupFn: Function): void;
/** Mark the end of the element. */
export declare function elementEnd(): void;
/**
    * Updates the value of removes an attribute on an Element.
    *
    * @param number index The index of the element in the data array
    * @param name name The name of the attribute.
    * @param value value The attribute is removed when value is `null` or `undefined`.
    *                  Otherwise the attribute value is set to the stringified value.
    * @param sanitizer An optional function used to sanitize the value.
    */
export declare function elementAttribute(index: number, name: string, value: any, sanitizer?: SanitizerFn | null): void;
/**
    * Update a property on an Element.
    *
    * If the property name also exists as an input property on one of the element's directives,
    * the component property will be set instead of the element property. This check must
    * be conducted at runtime so child components that add new @Inputs don't have to be re-compiled.
    *
    * @param index The index of the element to update in the data array
    * @param propName Name of property. Because it is going to DOM, this is not subject to
    *        renaming as part of minification.
    * @param value New value to write.
    * @param sanitizer An optional function used to sanitize the value.
    */
export declare function elementProperty<T>(index: number, propName: string, value: T | NO_CHANGE, sanitizer?: SanitizerFn | null): void;
/**
    * Constructs a TNode object from the arguments.
    *
    * @param type The type of the node
    * @param adjustedIndex The index of the TNode in TView.data, adjusted for HEADER_OFFSET
    * @param tagName The tag name of the node
    * @param attrs The attributes defined on this node
    * @param tViews Any TViews attached to this node
    * @returns the TNode object
    */
export declare function createTNode(viewData: LViewData, type: TNodeType, adjustedIndex: number, tagName: string | null, attrs: TAttributes | null, tViews: TView[] | null): TNode;
/**
    * Add or remove a class in a `classList` on a DOM element.
    *
    * This instruction is meant to handle the [class.foo]="exp" case
    *
    * @param index The index of the element to update in the data array
    * @param classIndex Index of class to toggle. Because it is going to DOM, this is not subject to
    *        renaming as part of minification.
    * @param value A value indicating if a given class should be added or removed.
    * @param directiveIndex the index for the directive that is attempting to change styling.
    */
export declare function elementClassProp(index: number, classIndex: number, value: boolean | PlayerFactory, directiveIndex?: number): void;
/**
    * Assign any inline style values to the element during creation mode.
    *
    * This instruction is meant to be called during creation mode to apply all styling
    * (e.g. `style="..."`) values to the element. This is also where the provided index
    * value is allocated for the styling details for its corresponding element (the element
    * index is the previous index value from this one).
    *
    * (Note this function calls `elementStylingApply` immediately when called.)
    *
    *
    * @param index Index value which will be allocated to store styling data for the element.
    *        (Note that this is not the element index, but rather an index value allocated
    *        specifically for element styling--the index must be the next index after the element
    *        index.)
    * @param classDeclarations A key/value array of CSS classes that will be registered on the element.
    *   Each individual style will be used on the element as long as it is not overridden
    *   by any classes placed on the element by multiple (`[class]`) or singular (`[class.named]`)
    *   bindings. If a class binding changes its value to a falsy value then the matching initial
    *   class value that are passed in here will be applied to the element (if matched).
    * @param styleDeclarations A key/value array of CSS styles that will be registered on the element.
    *   Each individual style will be used on the element as long as it is not overridden
    *   by any styles placed on the element by multiple (`[style]`) or singular (`[style.prop]`)
    *   bindings. If a style binding changes its value to null then the initial styling
    *   values that are passed in here will be applied to the element (if matched).
    * @param styleSanitizer An optional sanitizer function that will be used (if provided)
    *   to sanitize the any CSS property values that are applied to the element (during rendering).
    * @param directiveIndex the index for the directive that is attempting to change styling.
    */
export declare function elementStyling(classDeclarations?: (string | boolean | InitialStylingFlags)[] | null, styleDeclarations?: (string | boolean | InitialStylingFlags)[] | null, styleSanitizer?: StyleSanitizeFn | null, directiveIndex?: number): void;
/**
    * Apply all styling values to the element which have been queued by any styling instructions.
    *
    * This instruction is meant to be run once one or more `elementStyle` and/or `elementStyleProp`
    * have been issued against the element. This function will also determine if any styles have
    * changed and will then skip the operation if there is nothing new to render.
    *
    * Once called then all queued styles will be flushed.
    *
    * @param index Index of the element's styling storage that will be rendered.
    *        (Note that this is not the element index, but rather an index value allocated
    *        specifically for element styling--the index must be the next index after the element
    *        index.)
    * @param directiveIndex the index for the directive that is attempting to change styling.
    */
export declare function elementStylingApply(index: number, directiveIndex?: number): void;
/**
    * Queue a given style to be rendered on an Element.
    *
    * If the style value is `null` then it will be removed from the element
    * (or assigned a different value depending if there are any styles placed
    * on the element with `elementStyle` or any styles that are present
    * from when the element was created (with `elementStyling`).
    *
    * (Note that the styling instruction will not be applied until `elementStylingApply` is called.)
    *
    * @param index Index of the element's styling storage to change in the data array.
    *        (Note that this is not the element index, but rather an index value allocated
    *        specifically for element styling--the index must be the next index after the element
    *        index.)
    * @param styleIndex Index of the style property on this element. (Monotonically increasing.)
    * @param value New value to write (null to remove).
    * @param suffix Optional suffix. Used with scalar values to add unit such as `px`.
    *        Note that when a suffix is provided then the underlying sanitizer will
    *        be ignored.
    * @param directiveIndex the index for the directive that is attempting to change styling.
    */
export declare function elementStyleProp(index: number, styleIndex: number, value: string | number | String | PlayerFactory | null, suffix?: string, directiveIndex?: number): void;
/**
    * Queue a key/value map of styles to be rendered on an Element.
    *
    * This instruction is meant to handle the `[style]="exp"` usage. When styles are applied to
    * the Element they will then be placed with respect to any styles set with `elementStyleProp`.
    * If any styles are set to `null` then they will be removed from the element (unless the same
    * style properties have been assigned to the element during creation using `elementStyling`).
    *
    * (Note that the styling instruction will not be applied until `elementStylingApply` is called.)
    *
    * @param index Index of the element's styling storage to change in the data array.
    *        (Note that this is not the element index, but rather an index value allocated
    *        specifically for element styling--the index must be the next index after the element
    *        index.)
    * @param classes A key/value style map of CSS classes that will be added to the given element.
    *        Any missing classes (that have already been applied to the element beforehand) will be
    *        removed (unset) from the element's list of CSS classes.
    * @param styles A key/value style map of the styles that will be applied to the given element.
    *        Any missing styles (that have already been applied to the element beforehand) will be
    *        removed (unset) from the element's styling.
    * @param directiveIndex the index for the directive that is attempting to change styling.
    */
export declare function elementStylingMap<T>(index: number, classes: {
        [key: string]: any;
} | string | NO_CHANGE | null, styles?: {
        [styleName: string]: any;
} | NO_CHANGE | null, directiveIndex?: number): void;
/**
    * Create static text node
    *
    * @param index Index of the node in the data array
    * @param value Value to write. This value will be stringified.
    */
export declare function text(index: number, value?: any): void;
/**
    * Create text node with binding
    * Bindings should be handled externally with the proper interpolation(1-8) method
    *
    * @param index Index of the node in the data array.
    * @param value Stringified value to write.
    */
export declare function textBinding<T>(index: number, value: T | NO_CHANGE): void;
/**
    * Instantiate a root component.
    */
export declare function instantiateRootComponent<T>(tView: TView, viewData: LViewData, def: ComponentDef<T>): T;
/**
 * Generates a new block in TView.expandoInstructions for this node.
 *
 * Each expando block starts with the element index (turned negative so we can distinguish
 * it from the hostVar count) and the directive count. See more in VIEW_DATA.md.
 */
export declare function generateExpandoInstructionBlock(tView: TView, tNode: TNode, directiveCount: number): void;
/**
 * On the first template pass, we need to reserve space for host binding values
 * after directives are matched (so all directives are saved, then bindings).
 * Because we are updating the blueprint, we only need to do this once.
 */
export declare function prefillHostVars(tView: TView, viewData: LViewData, totalHostVars: number): void;
/** Stores index of component's host element so it will be queued for view refresh during CD. */
export declare function queueComponentIndexForCheck(previousOrParentTNode: TNode): void;
/**
    * Initializes the flags on the current node, setting all indices to the initial index,
    * the directive count to 0, and adding the isComponent flag.
    * @param index the initial index
    */
export declare function initNodeFlags(tNode: TNode, index: number, numberOfDirectives: number): void;
/**
    * Creates a LContainer, either from a container instruction, or for a ViewContainerRef.
    *
    * @param hostNative The host element for the LContainer
    * @param hostTNode The host TNode for the LContainer
    * @param currentView The parent view of the LContainer
    * @param native The native comment element
    * @param isForViewContainerRef Optional a flag indicating the ViewContainerRef case
    * @returns LContainer
    */
export declare function createLContainer(hostNative: RElement | RComment, hostTNode: TElementNode | TContainerNode | TElementContainerNode, currentView: LViewData, native: RComment, isForViewContainerRef?: boolean): LContainer;
/**
    * Creates an LContainer for an ng-template (dynamically-inserted view), e.g.
    *
    * <ng-template #foo>
    *    <div></div>
    * </ng-template>
    *
    * @param index The index of the container in the data array
    * @param templateFn Inline template
    * @param consts The number of nodes, local refs, and pipes for this template
    * @param vars The number of bindings for this template
    * @param tagName The name of the container element, if applicable
    * @param attrs The attrs attached to the container, if applicable
    * @param localRefs A set of local reference bindings on the element.
    * @param localRefExtractor A function which extracts local-refs values from the template.
    *        Defaults to the current element associated with the local-ref.
    */
export declare function template(index: number, templateFn: ComponentTemplate<any> | null, consts: number, vars: number, tagName?: string | null, attrs?: TAttributes | null, localRefs?: string[] | null, localRefExtractor?: LocalRefExtractor): void;
/**
    * Creates an LContainer for inline views, e.g.
    *
    * % if (showing) {
    *   <div></div>
    * % }
    *
    * @param index The index of the container in the data array
    */
export declare function container(index: number): void;
/**
    * Sets a container up to receive views.
    *
    * @param index The index of the container in the data array
    */
export declare function containerRefreshStart(index: number): void;
/**
    * Marks the end of the LContainer.
    *
    * Marking the end of LContainer is the time when to child views get inserted or removed.
    */
export declare function containerRefreshEnd(): void;
/**
    * Marks the start of an embedded view.
    *
    * @param viewBlockId The ID of this view
    * @return boolean Whether or not this view is in creation mode
    */
export declare function embeddedViewStart(viewBlockId: number, consts: number, vars: number): RenderFlags;
/** Marks the end of an embedded view. */
export declare function embeddedViewEnd(): void;
/**
    * Refreshes components by entering the component view and processing its bindings, queries, etc.
    *
    * @param adjustedElementIndex  Element index in LViewData[] (adjusted for HEADER_OFFSET)
    */
export declare function componentRefresh<T>(adjustedElementIndex: number, parentFirstTemplatePass: boolean, rf: RenderFlags | null): void;
/** Returns a boolean for whether the view is attached */
export declare function viewAttached(view: LViewData): boolean;
/**
    * Instruction to distribute projectable nodes among <ng-content> occurrences in a given template.
    * It takes all the selectors from the entire component's template and decides where
    * each projected node belongs (it re-distributes nodes among "buckets" where each "bucket" is
    * backed by a selector).
    *
    * This function requires CSS selectors to be provided in 2 forms: parsed (by a compiler) and text,
    * un-parsed form.
    *
    * The parsed form is needed for efficient matching of a node against a given CSS selector.
    * The un-parsed, textual form is needed for support of the ngProjectAs attribute.
    *
    * Having a CSS selector in 2 different formats is not ideal, but alternatives have even more
    * drawbacks:
    * - having only a textual form would require runtime parsing of CSS selectors;
    * - we can't have only a parsed as we can't re-construct textual form from it (as entered by a
    * template author).
    *
    * @param selectors A collection of parsed CSS selectors
    * @param rawSelectors A collection of CSS selectors in the raw, un-parsed form
    */
export declare function projectionDef(selectors?: CssSelectorList[], textSelectors?: string[]): void;
/**
    * Inserts previously re-distributed projected nodes. This instruction must be preceded by a call
    * to the projectionDef instruction.
    *
    * @param nodeIndex
    * @param selectorIndex:
    *        - 0 when the selector is `*` (or unspecified as this is the default value),
    *        - 1 based index of the selector from the {@link projectionDef}
    */
export declare function projection(nodeIndex: number, selectorIndex?: number, attrs?: string[]): void;
/**
    * Adds LViewData or LContainer to the end of the current view tree.
    *
    * This structure will be used to traverse through nested views to remove listeners
    * and call onDestroy callbacks.
    *
    * @param currentView The view where LViewData or LContainer should be added
    * @param adjustedHostIndex Index of the view's host node in LViewData[], adjusted for header
    * @param state The LViewData or LContainer to add to the view tree
    * @returns The state passed in
    */
export declare function addToViewTree<T extends LViewData | LContainer>(currentView: LViewData, adjustedHostIndex: number, state: T): T;
/** Marks current view and all ancestors dirty */
export declare function markViewDirty(view: LViewData): void;
/**
    * Used to schedule change detection on the whole application.
    *
    * Unlike `tick`, `scheduleTick` coalesces multiple calls into one change detection run.
    * It is usually called indirectly by calling `markDirty` when the view needs to be
    * re-rendered.
    *
    * Typically `scheduleTick` uses `requestAnimationFrame` to coalesce multiple
    * `scheduleTick` requests. The scheduling function can be overridden in
    * `renderComponent`'s `scheduler` option.
    */
export declare function scheduleTick<T>(rootContext: RootContext, flags: RootContextFlags): void;
/**
    * Used to perform change detection on the whole application.
    *
    * This is equivalent to `detectChanges`, but invoked on root component. Additionally, `tick`
    * executes lifecycle hooks and conditionally checks components based on their
    * `ChangeDetectionStrategy` and dirtiness.
    *
    * The preferred way to trigger change detection is to call `markDirty`. `markDirty` internally
    * schedules `tick` using a scheduler in order to coalesce multiple `markDirty` calls into a
    * single change detection run. By default, the scheduler is `requestAnimationFrame`, but can
    * be changed when calling `renderComponent` and providing the `scheduler` option.
    */
export declare function tick<T>(component: T): void;
/**
    * Synchronously perform change detection on a component (and possibly its sub-components).
    *
    * This function triggers change detection in a synchronous way on a component. There should
    * be very little reason to call this function directly since a preferred way to do change
    * detection is to {@link markDirty} the component and wait for the scheduler to call this method
    * at some future point in time. This is because a single user action often results in many
    * components being invalidated and calling change detection on each component synchronously
    * would be inefficient. It is better to wait until all components are marked as dirty and
    * then perform single change detection across all of the components
    *
    * @param component The component which the change detection should be performed on.
    */
export declare function detectChanges<T>(component: T): void;
/**
    * Synchronously perform change detection on a root view and its components.
    *
    * @param lViewData The view which the change detection should be performed on.
    */
export declare function detectChangesInRootView(lViewData: LViewData): void;
/**
    * Checks the change detector and its children, and throws if any changes are detected.
    *
    * This is used in development mode to verify that running change detection doesn't
    * introduce other changes.
    */
export declare function checkNoChanges<T>(component: T): void;
/**
    * Checks the change detector on a root view and its components, and throws if any changes are
    * detected.
    *
    * This is used in development mode to verify that running change detection doesn't
    * introduce other changes.
    *
    * @param lViewData The view which the change detection should be checked on.
    */
export declare function checkNoChangesInRootView(lViewData: LViewData): void;
/**
    * Mark the component as dirty (needing change detection).
    *
    * Marking a component dirty will schedule a change detection on this
    * component at some point in the future. Marking an already dirty
    * component as dirty is a noop. Only one outstanding change detection
    * can be scheduled per component tree. (Two components bootstrapped with
    * separate `renderComponent` will have separate schedulers)
    *
    * When the root component is bootstrapped with `renderComponent`, a scheduler
    * can be provided.
    *
    * @param component Component to mark as dirty.
    *
    * @publicApi
    */
export declare function markDirty<T>(component: T): void;
/**
    * Creates a single value binding.
    *
    * @param value Value to diff
    */
export declare function bind<T>(value: T): T | NO_CHANGE;
/**
    * Create interpolation bindings with a variable number of expressions.
    *
    * If there are 1 to 8 expressions `interpolation1()` to `interpolation8()` should be used instead.
    * Those are faster because there is no need to create an array of expressions and iterate over it.
    *
    * `values`:
    * - has static text at even indexes,
    * - has evaluated expressions at odd indexes.
    *
    * Returns the concatenated string when any of the arguments changes, `NO_CHANGE` otherwise.
    */
export declare function interpolationV(values: any[]): string | NO_CHANGE;
/**
    * Creates an interpolation binding with 1 expression.
    *
    * @param prefix static value used for concatenation only.
    * @param v0 value checked for change.
    * @param suffix static value used for concatenation only.
    */
export declare function interpolation1(prefix: string, v0: any, suffix: string): string | NO_CHANGE;
/** Creates an interpolation binding with 2 expressions. */
export declare function interpolation2(prefix: string, v0: any, i0: string, v1: any, suffix: string): string | NO_CHANGE;
/** Creates an interpolation binding with 3 expressions. */
export declare function interpolation3(prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, suffix: string): string | NO_CHANGE;
/** Create an interpolation binding with 4 expressions. */
export declare function interpolation4(prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string, v3: any, suffix: string): string | NO_CHANGE;
/** Creates an interpolation binding with 5 expressions. */
export declare function interpolation5(prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string, v3: any, i3: string, v4: any, suffix: string): string | NO_CHANGE;
/** Creates an interpolation binding with 6 expressions. */
export declare function interpolation6(prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string, v3: any, i3: string, v4: any, i4: string, v5: any, suffix: string): string | NO_CHANGE;
/** Creates an interpolation binding with 7 expressions. */
export declare function interpolation7(prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string, v3: any, i3: string, v4: any, i4: string, v5: any, i5: string, v6: any, suffix: string): string | NO_CHANGE;
/** Creates an interpolation binding with 8 expressions. */
export declare function interpolation8(prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string, v3: any, i3: string, v4: any, i4: string, v5: any, i5: string, v6: any, i6: string, v7: any, suffix: string): string | NO_CHANGE;
/** Store a value in the `data` at a given `index`. */
export declare function store<T>(index: number, value: T): void;
/**
    * Retrieves a local reference from the current contextViewData.
    *
    * If the reference to retrieve is in a parent view, this instruction is used in conjunction
    * with a nextContext() call, which walks up the tree and updates the contextViewData instance.
    *
    * @param index The index of the local ref in contextViewData.
    */
export declare function reference<T>(index: number): T;
export declare function loadQueryList<T>(queryListIdx: number): QueryList<T>;
/** Retrieves a value from current `viewData`. */
export declare function load<T>(index: number): T;
/** Gets the current binding value. */
export declare function getBinding(bindingIndex: number): any;
/** Updates binding if changed, then returns whether it was updated. */
export declare function bindingUpdated(bindingIndex: number, value: any): boolean;
/** Updates binding and returns the value. */
export declare function updateBinding(bindingIndex: number, value: any): any;
/** Updates 2 bindings if changed, then returns whether either was updated. */
export declare function bindingUpdated2(bindingIndex: number, exp1: any, exp2: any): boolean;
/** Updates 3 bindings if changed, then returns whether any was updated. */
export declare function bindingUpdated3(bindingIndex: number, exp1: any, exp2: any, exp3: any): boolean;
/** Updates 4 bindings if changed, then returns whether any was updated. */
export declare function bindingUpdated4(bindingIndex: number, exp1: any, exp2: any, exp3: any, exp4: any): boolean;
/**
    * Returns the value associated to the given token from the injectors.
    *
    * `directiveInject` is intended to be used for directive, component and pipe factories.
    *  All other injection use `inject` which does not walk the node injector tree.
    *
    * Usage example (in factory function):
    *
    * class SomeDirective {
    *   constructor(directive: DirectiveA) {}
    *
    *   static ngDirectiveDef = defineDirective({
    *     type: SomeDirective,
    *     factory: () => new SomeDirective(directiveInject(DirectiveA))
    *   });
    * }
    *
    * @param token the type or token to inject
    * @param flags Injection flags
    * @returns the value from the injector or `null` when not found
    */
export declare function directiveInject<T>(token: Type<T> | InjectionToken<T>): T;
export declare function directiveInject<T>(token: Type<T> | InjectionToken<T>, flags: InjectFlags): T;
/**
    * Facade for the attribute injection from DI.
    */
export declare function injectAttribute(attrNameToInject: string): string | undefined;
/**
    * Registers a QueryList, associated with a content query, for later refresh (part of a view
    * refresh).
    */
export declare function registerContentQuery<Q>(queryList: QueryList<Q>, currentDirectiveIndex: number): void;
export declare const CLEAN_PROMISE: Promise<null>;
export declare function delegateToClassInput(tNode: TNode): number;

/**
    * @license
    * Copyright Google Inc. All Rights Reserved.
    *
    * Use of this source code is governed by an MIT-style license that can be
    * found in the LICENSE file at https://angular.io/license
    */
import { Sanitizer } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/sanitization/security';
import { TElementNode, TNode, TViewNode } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/render3/interfaces/node';
import { LQueries } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/render3/interfaces/query';
import { Renderer3, RendererFactory3 } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/render3/interfaces/renderer';
import { LViewData, OpaqueViewState, TView } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/render3/interfaces/view';
export declare function getRenderer(): Renderer3;
export declare function setRenderer(r: Renderer3): void;
export declare function getRendererFactory(): RendererFactory3;
export declare function setRendererFactory(factory: RendererFactory3): void;
export declare function getCurrentSanitizer(): Sanitizer | null;
export declare function getElementDepthCount(): number;
export declare function increaseElementDepthCount(): void;
export declare function decreaseElementDepthCount(): void;
export declare function getBindingsEnabled(): boolean;
/**
    * Enables directive matching on elements.
    *
    *  * Example:
    * ```
    * <my-comp my-directive>
    *   Should match component / directive.
    * </my-comp>
    * <div ngNonBindable>
    *   <!-- disabledBindings() -->
    *   <my-comp my-directive>
    *     Should not match component / directive because we are in ngNonBindable.
    *   </my-comp>
    *   <!-- enableBindings() -->
    * </div>
    * ```
    */
export declare function enableBindings(): void;
/**
    * Disables directive matching on element.
    *
    *  * Example:
    * ```
    * <my-comp my-directive>
    *   Should match component / directive.
    * </my-comp>
    * <div ngNonBindable>
    *   <!-- disabledBindings() -->
    *   <my-comp my-directive>
    *     Should not match component / directive because we are in ngNonBindable.
    *   </my-comp>
    *   <!-- enableBindings() -->
    * </div>
    * ```
    */
export declare function disableBindings(): void;
/**
    * Returns the current OpaqueViewState instance.
    *
    * Used in conjunction with the restoreView() instruction to save a snapshot
    * of the current view and restore it when listeners are invoked. This allows
    * walking the declaration view tree in listeners to get vars from parent views.
    */
export declare function getCurrentView(): OpaqueViewState;
export declare function _getViewData(): LViewData;
/**
    * Restores `contextViewData` to the given OpaqueViewState instance.
    *
    * Used in conjunction with the getCurrentView() instruction to save a snapshot
    * of the current view and restore it when listeners are invoked. This allows
    * walking the declaration view tree in listeners to get vars from parent views.
    *
    * @param viewToRestore The OpaqueViewState instance to restore.
    */
export declare function restoreView(viewToRestore: OpaqueViewState): void;
export declare function getPreviousOrParentTNode(): TNode;
export declare function setPreviousOrParentTNode(tNode: TNode): void;
export declare function setTNodeAndViewData(tNode: TNode, view: LViewData): void;
export declare function getIsParent(): boolean;
export declare function setIsParent(value: boolean): void;
export declare function getTView(): TView;
export declare function getCurrentQueries(): LQueries | null;
export declare function setCurrentQueries(queries: LQueries | null): void;
/**
    * Query instructions can ask for "current queries" in 2 different cases:
    * - when creating view queries (at the root of a component view, before any node is created - in
    * this case currentQueries points to view queries)
    * - when creating content queries (i.e. this previousOrParentTNode points to a node on which we
    * create content queries).
    */
export declare function getOrCreateCurrentQueries(QueryType: {
        new (parent: null, shallow: null, deep: null): LQueries;
}): LQueries;
export declare function getCreationMode(): boolean;
/**
    * Internal function that returns the current LViewData instance.
    *
    * The getCurrentView() instruction should be used for anything public.
    */
export declare function getViewData(): LViewData;
export declare function getContextViewData(): LViewData;
export declare function getCleanup(view: LViewData): any[];
export declare function getTViewCleanup(view: LViewData): any[];
export declare function getCheckNoChangesMode(): boolean;
export declare function setCheckNoChangesMode(mode: boolean): void;
export declare function getFirstTemplatePass(): boolean;
export declare function setFirstTemplatePass(value: boolean): void;
export declare function getBindingRoot(): number;
export declare function setBindingRoot(value: number): void;
/**
    * Swap the current state with a new state.
    *
    * For performance reasons we store the state in the top level of the module.
    * This way we minimize the number of properties to read. Whenever a new view
    * is entered we have to store the state for later, and when the view is
    * exited the state has to be restored
    *
    * @param newView New state to become active
    * @param host Element to which the View is a child of
    * @returns the previous state;
    */
export declare function enterView(newView: LViewData, hostTNode: TElementNode | TViewNode | null): LViewData;
export declare function nextContextImpl<T = any>(level?: number): T;
/**
    * Resets the application state.
    */
export declare function resetComponentState(): void;
/**
    * Used in lieu of enterView to make it clear when we are exiting a child view. This makes
    * the direction of traversal (up or down the view tree) a bit clearer.
    *
    * @param newView New state to become active
    * @param creationOnly An optional boolean to indicate that the view was processed in creation mode
    * only, i.e. the first update will be done later. Only possible for dynamically created views.
    */
export declare function leaveView(newView: LViewData, creationOnly?: boolean): void;
export declare function assertPreviousIsParent(): void;
export declare function assertHasParent(): void;
export declare function assertDataInRange(index: number, arr?: any[]): void;
export declare function assertDataNext(index: number, arr?: any[]): void;

/**
    * @license
    * Copyright Google Inc. All Rights Reserved.
    *
    * Use of this source code is governed by an MIT-style license that can be
    * found in the LICENSE file at https://angular.io/license
    */
import { NO_CHANGE } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/render3/tokens';
/**
    * Extracts a part of a message and removes the rest.
    *
    * This method is used for extracting a part of the message associated with a template. A translated
    * message can span multiple templates.
    *
    * Example:
    * ```
    * <div i18n>Translate <span *ngIf>me</span>!</div>
    * ```
    *
    * @param message The message to crop
    * @param subTemplateIndex Index of the sub-template to extract. If undefined it returns the
    * external template and removes all sub-templates.
    */
export declare function getTranslationForTemplate(message: string, subTemplateIndex?: number): string;
/**
    * Marks a block of text as translatable.
    *
    * The instructions `i18nStart` and `i18nEnd` mark the translation block in the template.
    * The translation `message` is the value which is locale specific. The translation string may
    * contain placeholders which associate inner elements and sub-templates within the translation.
    *
    * The translation `message` placeholders are:
    * - `�{index}(:{block})�`: *Binding Placeholder*: Marks a location where an expression will be
    *   interpolated into. The placeholder `index` points to the expression binding index. An optional
    *   `block` that matches the sub-template in which it was declared.
    * - `�#{index}(:{block})�`/`�/#{index}(:{block})�`: *Element Placeholder*:  Marks the beginning
    *   and end of DOM element that were embedded in the original translation block. The placeholder
    *   `index` points to the element index in the template instructions set. An optional `block` that
    *   matches the sub-template in which it was declared.
    * - `�*{index}:{block}�`/`�/*{index}:{block}�`: *Sub-template Placeholder*: Sub-templates must be
    *   split up and translated separately in each angular template function. The `index` points to the
    *   `template` instruction index. A `block` that matches the sub-template in which it was declared.
    *
    * @param index A unique index of the translation in the static block.
    * @param message The translation message.
    * @param subTemplateIndex Optional sub-template index in the `message`.
    */
export declare function i18nStart(index: number, message: string, subTemplateIndex?: number): void;
/**
    * Handles message string post-processing for internationalization.
    *
    * Handles message string post-processing by transforming it from intermediate
    * format (that might contain some markers that we need to replace) to the final
    * form, consumable by i18nStart instruction. Post processing steps include:
    *
    * 1. Resolve all multi-value cases (like [�*1:1��#2:1�|�#4:1�|�5�])
    * 2. Replace all ICU vars (like "VAR_PLURAL")
    * 3. Replace all ICU references with corresponding values (like �ICU_EXP_ICU_1�)
    *    in case multiple ICUs have the same placeholder name
    *
    * @param message Raw translation string for post processing
    * @param replacements Set of replacements that should be applied
    *
    * @returns Transformed string that can be consumed by i18nStart instruction
    *
    * @publicAPI
    */
export declare function i18nPostprocess(message: string, replacements: {
        [key: string]: (string | string[]);
}): string;
/**
    * Translates a translation block marked by `i18nStart` and `i18nEnd`. It inserts the text/ICU nodes
    * into the render tree, moves the placeholder nodes and removes the deleted nodes.
    */
export declare function i18nEnd(): void;
/**
    *
    * Use this instruction to create a translation block that doesn't contain any placeholder.
    * It calls both {@link i18nStart} and {@link i18nEnd} in one instruction.
    *
    * The translation `message` is the value which is locale specific. The translation string may
    * contain placeholders which associate inner elements and sub-templates within the translation.
    *
    * The translation `message` placeholders are:
    * - `�{index}(:{block})�`: *Binding Placeholder*: Marks a location where an expression will be
    *   interpolated into. The placeholder `index` points to the expression binding index. An optional
    *   `block` that matches the sub-template in which it was declared.
    * - `�#{index}(:{block})�`/`�/#{index}(:{block})�`: *Element Placeholder*:  Marks the beginning
    *   and end of DOM element that were embedded in the original translation block. The placeholder
    *   `index` points to the element index in the template instructions set. An optional `block` that
    *   matches the sub-template in which it was declared.
    * - `�*{index}:{block}�`/`�/*{index}:{block}�`: *Sub-template Placeholder*: Sub-templates must be
    *   split up and translated separately in each angular template function. The `index` points to the
    *   `template` instruction index. A `block` that matches the sub-template in which it was declared.
    *
    * @param index A unique index of the translation in the static block.
    * @param message The translation message.
    * @param subTemplateIndex Optional sub-template index in the `message`.
    */
export declare function i18n(index: number, message: string, subTemplateIndex?: number): void;
/**
    * Marks a list of attributes as translatable.
    *
    * @param index A unique index in the static block
    * @param values
    */
export declare function i18nAttributes(index: number, values: string[]): void;
/**
    * Stores the values of the bindings during each update cycle in order to determine if we need to
    * update the translated nodes.
    *
    * @param expression The binding's new value or NO_CHANGE
    */
export declare function i18nExp<T>(expression: T | NO_CHANGE): void;
/**
    * Updates a translation block or an i18n attribute when the bindings have changed.
    *
    * @param index Index of either {@link i18nStart} (translation block) or {@link i18nAttributes}
    * (i18n attribute) on which it should update the content.
    */
export declare function i18nApply(index: number): void;

/**
  * @license
  * Copyright Google Inc. All Rights Reserved.
  *
  * Use of this source code is governed by an MIT-style license that can be
  * found in the LICENSE file at https://angular.io/license
  */
import { Injector } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/di/injector';
import { StaticProvider } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/di/provider';
import { ComponentFactoryResolver as viewEngine_ComponentFactoryResolver } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/linker/component_factory_resolver';
import { InternalNgModuleRef, NgModuleFactory as viewEngine_NgModuleFactory, NgModuleRef as viewEngine_NgModuleRef } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/linker/ng_module_factory';
import { NgModuleDef } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/metadata/ng_module';
import { Type } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/type';
export interface NgModuleType {
    ngModuleDef: NgModuleDef<any>;
}
export declare const COMPONENT_FACTORY_RESOLVER: StaticProvider;
export declare class NgModuleRef<T> extends viewEngine_NgModuleRef<T> implements InternalNgModuleRef<T> {
    _bootstrapComponents: Type<any>[];
    injector: Injector;
    componentFactoryResolver: viewEngine_ComponentFactoryResolver;
    instance: T;
    destroyCbs: (() => void)[] | null;
    constructor(ngModuleType: Type<T>, parentInjector: Injector | null);
    destroy(): void;
    onDestroy(callback: () => void): void;
}
export declare class NgModuleFactory<T> extends viewEngine_NgModuleFactory<T> {
    moduleType: Type<T>;
    constructor(moduleType: Type<T>);
    create(parentInjector: Injector | null): viewEngine_NgModuleRef<T>;
}

/**
    * @license
    * Copyright Google Inc. All Rights Reserved.
    *
    * Use of this source code is governed by an MIT-style license that can be
    * found in the LICENSE file at https://angular.io/license
    */
import { StylingContext } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/render3/interfaces/styling';
import { LViewData, TView } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/render3/interfaces/view';
/**
    * TNodeType corresponds to the TNode.type property. It contains information
    * on how to map a particular set of bits in TNode.flags to the node type.
    */
export declare const enum TNodeType {
        Container = 0,
        Projection = 1,
        View = 2,
        Element = 3,
        ViewOrElement = 2,
        ElementContainer = 4,
        IcuContainer = 5
}
/**
    * Corresponds to the TNode.flags property.
    */
export declare const enum TNodeFlags {
        /** The number of directives on this node is encoded on the least significant bits */
        DirectiveCountMask = 4095,
        /** This bit is set if the node is a component */
        isComponent = 4096,
        /** This bit is set if the node has been projected */
        isProjected = 8192,
        /** This bit is set if the node has any content queries */
        hasContentQuery = 16384,
        /** This bit is set if the node has any directives that contain [class properties */
        hasClassInput = 32768,
        /** The index of the first directive on this node is encoded on the most significant bits  */
        DirectiveStartingIndexShift = 16
}
/**
    * Corresponds to the TNode.providerIndexes property.
    */
export declare const enum TNodeProviderIndexes {
        /** The index of the first provider on this node is encoded on the least significant bits */
        ProvidersStartIndexMask = 65535,
        /** The count of view providers from the component on this node is encoded on the 16 most
             significant bits */
        CptViewProvidersCountShift = 16,
        CptViewProvidersCountShifter = 65536
}
/**
    * A set of marker values to be used in the attributes arrays. Those markers indicate that some
    * items are not regular attributes and the processing should be adapted accordingly.
    */
export declare const enum AttributeMarker {
        /**
            * Marker indicates that the following 3 values in the attributes array are:
            * namespaceUri, attributeName, attributeValue
            * in that order.
            */
        NamespaceURI = 0,
        /**
            * This marker indicates that the following attribute names were extracted from bindings (ex.:
            * [foo]="exp") and / or event handlers (ex. (bar)="doSth()").
            * Taking the above bindings and outputs as an example an attributes array could look as follows:
            * ['class', 'fade in', AttributeMarker.SelectOnly, 'foo', 'bar']
            */
        SelectOnly = 1
}
/**
    * A combination of:
    * - attribute names and values
    * - special markers acting as flags to alter attributes processing.
    */
export declare type TAttributes = (string | AttributeMarker)[];
/**
    * Binding data (flyweight) for a particular node that is shared between all templates
    * of a specific type.
    *
    * If a property is:
    *    - PropertyAliases: that property's data was generated and this is it
    *    - Null: that property's data was already generated and nothing was found.
    *    - Undefined: that property's data has not yet been generated
    *
    * see: https://en.wikipedia.org/wiki/Flyweight_pattern for more on the Flyweight pattern
    */
export interface TNode {
        /** The type of the TNode. See TNodeType. */
        type: TNodeType;
        /**
            * Index of the TNode in TView.data and corresponding native element in LViewData.
            *
            * This is necessary to get from any TNode to its corresponding native element when
            * traversing the node tree.
            *
            * If index is -1, this is a dynamically created container node or embedded view node.
            */
        index: number;
        /**
            * The index of the closest injector in this node's LViewData.
            *
            * If the index === -1, there is no injector on this node or any ancestor node in this view.
            *
            * If the index !== -1, it is the index of this node's injector OR the index of a parent injector
            * in the same view. We pass the parent injector index down the node tree of a view so it's
            * possible to find the parent injector without walking a potentially deep node tree. Injector
            * indices are not set across view boundaries because there could be multiple component hosts.
            *
            * If tNode.injectorIndex === tNode.parent.injectorIndex, then the index belongs to a parent
            * injector.
            */
        injectorIndex: number;
        /**
            * This number stores two values using its bits:
            *
            * - the number of directives on that node (first 12 bits)
            * - the starting index of the node's directives in the directives array (last 20 bits).
            *
            * These two values are necessary so DI can effectively search the directives associated
            * with a node without searching the whole directives array.
            */
        flags: TNodeFlags;
        /**
            * This number stores two values using its bits:
            *
            * - the index of the first provider on that node (first 16 bits)
            * - the count of view providers from the component on this node (last 16 bits)
            */
        providerIndexes: TNodeProviderIndexes;
        /** The tag name associated with this node. */
        tagName: string | null;
        /**
            * Attributes associated with an element. We need to store attributes to support various use-cases
            * (attribute injection, content projection with selectors, directives matching).
            * Attributes are stored statically because reading them from the DOM would be way too slow for
            * content projection and queries.
            *
            * Since attrs will always be calculated first, they will never need to be marked undefined by
            * other instructions.
            *
            * For regular attributes a name of an attribute and its value alternate in the array.
            * e.g. ['role', 'checkbox']
            * This array can contain flags that will indicate "special attributes" (attributes with
            * namespaces, attributes extracted from bindings and outputs).
            */
        attrs: TAttributes | null;
        /**
            * A set of local names under which a given element is exported in a template and
            * visible to queries. An entry in this array can be created for different reasons:
            * - an element itself is referenced, ex.: `<div #foo>`
            * - a component is referenced, ex.: `<my-cmpt #foo>`
            * - a directive is referenced, ex.: `<my-cmpt #foo="directiveExportAs">`.
            *
            * A given element might have different local names and those names can be associated
            * with a directive. We store local names at even indexes while odd indexes are reserved
            * for directive index in a view (or `-1` if there is no associated directive).
            *
            * Some examples:
            * - `<div #foo>` => `["foo", -1]`
            * - `<my-cmpt #foo>` => `["foo", myCmptIdx]`
            * - `<my-cmpt #foo #bar="directiveExportAs">` => `["foo", myCmptIdx, "bar", directiveIdx]`
            * - `<div #foo #bar="directiveExportAs">` => `["foo", -1, "bar", directiveIdx]`
            */
        localNames: (string | number)[] | null;
        /** Information about input properties that need to be set once from attribute data. */
        initialInputs: InitialInputData | null | undefined;
        /**
            * Input data for all directives on this node.
            *
            * - `undefined` means that the prop has not been initialized yet,
            * - `null` means that the prop has been initialized but no inputs have been found.
            */
        inputs: PropertyAliases | null | undefined;
        /**
            * Output data for all directives on this node.
            *
            * - `undefined` means that the prop has not been initialized yet,
            * - `null` means that the prop has been initialized but no outputs have been found.
            */
        outputs: PropertyAliases | null | undefined;
        /**
            * The TView or TViews attached to this node.
            *
            * If this TNode corresponds to an LContainer with inline views, the container will
            * need to store separate static data for each of its view blocks (TView[]). Otherwise,
            * nodes in inline views with the same index as nodes in their parent views will overwrite
            * each other, as they are in the same template.
            *
            * Each index in this array corresponds to the static data for a certain
            * view. So if you had V(0) and V(1) in a container, you might have:
            *
            * [
            *   [{tagName: 'div', attrs: ...}, null],     // V(0) TView
            *   [{tagName: 'button', attrs ...}, null]    // V(1) TView
            *
            * If this TNode corresponds to an LContainer with a template (e.g. structural
            * directive), the template's TView will be stored here.
            *
            * If this TNode corresponds to an element, tViews will be null .
            */
        tViews: TView | TView[] | null;
        /**
            * The next sibling node. Necessary so we can propagate through the root nodes of a view
            * to insert them or remove them from the DOM.
            */
        next: TNode | null;
        /**
            * First child of the current node.
            *
            * For component nodes, the child will always be a ContentChild (in same view).
            * For embedded view nodes, the child will be in their child view.
            */
        child: TNode | null;
        /**
            * Parent node (in the same view only).
            *
            * We need a reference to a node's parent so we can append the node to its parent's native
            * element at the appropriate time.
            *
            * If the parent would be in a different view (e.g. component host), this property will be null.
            * It's important that we don't try to cross component boundaries when retrieving the parent
            * because the parent will change (e.g. index, attrs) depending on where the component was
            * used (and thus shouldn't be stored on TNode). In these cases, we retrieve the parent through
            * LView.node instead (which will be instance-specific).
            *
            * If this is an inline view node (V), the parent will be its container.
            */
        parent: TElementNode | TContainerNode | null;
        /**
            * If this node is part of an i18n block, it indicates whether this node is part of the DOM.
            * If this node is not part of an i18n block, this field is null.
            */
        detached: boolean | null;
        stylingTemplate: StylingContext | null;
        /**
            * List of projected TNodes for a given component host element OR index into the said nodes.
            *
            * For easier discussion assume this example:
            * `<parent>`'s view definition:
            * ```
            * <child id="c1">content1</child>
            * <child id="c2"><span>content2</span></child>
            * ```
            * `<child>`'s view definition:
            * ```
            * <ng-content id="cont1"></ng-content>
            * ```
            *
            * If `Array.isArray(projection)` then `TNode` is a host element:
            * - `projection` stores the content nodes which are to be projected.
            *    - The nodes represent categories defined by the selector: For example:
            *      `<ng-content/><ng-content select="abc"/>` would represent the heads for `<ng-content/>`
            *      and `<ng-content select="abc"/>` respectively.
            *    - The nodes we store in `projection` are heads only, we used `.next` to get their
            *      siblings.
            *    - The nodes `.next` is sorted/rewritten as part of the projection setup.
            *    - `projection` size is equal to the number of projections `<ng-content>`. The size of
            *      `c1` will be `1` because `<child>` has only one `<ng-content>`.
            * - we store `projection` with the host (`c1`, `c2`) rather than the `<ng-content>` (`cont1`)
            *   because the same component (`<child>`) can be used in multiple locations (`c1`, `c2`) and as
            *   a result have different set of nodes to project.
            * - without `projection` it would be difficult to efficiently traverse nodes to be projected.
            *
            * If `typeof projection == 'number'` then `TNode` is a `<ng-content>` element:
            * - `projection` is an index of the host's `projection`Nodes.
            *   - This would return the first head node to project:
            *     `getHost(currentTNode).projection[currentTNode.projection]`.
            * - When projecting nodes the parent node retrieved may be a `<ng-content>` node, in which case
            *   the process is recursive in nature (not implementation).
            */
        projection: (TNode | null)[] | number | null;
}
/** Static data for an element  */
export interface TElementNode extends TNode {
        /** Index in the data[] array */
        index: number;
        child: TElementNode | TTextNode | TElementContainerNode | TContainerNode | TProjectionNode | null;
        /**
            * Element nodes will have parents unless they are the first node of a component or
            * embedded view (which means their parent is in a different view and must be
            * retrieved using viewData[HOST_NODE]).
            */
        parent: TElementNode | TElementContainerNode | null;
        tViews: null;
        /**
            * If this is a component TNode with projection, this will be an array of projected
            * TNodes (see TNode.projection for more info). If it's a regular element node or a
            * component without projection, it will be null.
            */
        projection: (TNode | null)[] | null;
}
/** Static data for a text node */
export interface TTextNode extends TNode {
        /** Index in the data[] array */
        index: number;
        child: null;
        /**
            * Text nodes will have parents unless they are the first node of a component or
            * embedded view (which means their parent is in a different view and must be
            * retrieved using LView.node).
            */
        parent: TElementNode | TElementContainerNode | null;
        tViews: null;
        projection: null;
}
/** Static data for an LContainer */
export interface TContainerNode extends TNode {
        /**
            * Index in the data[] array.
            *
            * If it's -1, this is a dynamically created container node that isn't stored in
            * data[] (e.g. when you inject ViewContainerRef) .
            */
        index: number;
        child: null;
        /**
            * Container nodes will have parents unless:
            *
            * - They are the first node of a component or embedded view
            * - They are dynamically created
            */
        parent: TElementNode | TElementContainerNode | null;
        tViews: TView | TView[] | null;
        projection: null;
}
/** Static data for an <ng-container> */
export interface TElementContainerNode extends TNode {
        /** Index in the LViewData[] array. */
        index: number;
        child: TElementNode | TTextNode | TContainerNode | TElementContainerNode | TProjectionNode | null;
        parent: TElementNode | TElementContainerNode | null;
        tViews: null;
        projection: null;
}
/** Static data for an ICU expression */
export interface TIcuContainerNode extends TNode {
        /** Index in the LViewData[] array. */
        index: number;
        child: TElementNode | TTextNode | null;
        parent: TElementNode | TElementContainerNode | null;
        tViews: null;
        projection: null;
        /**
            * Indicates the current active case for an ICU expression.
            * It is null when there is no active case.
            */
        activeCaseIndex: number | null;
}
/** Static data for a view  */
export interface TViewNode extends TNode {
        /** If -1, it's a dynamically created view. Otherwise, it is the view block ID. */
        index: number;
        child: TElementNode | TTextNode | TElementContainerNode | TContainerNode | TProjectionNode | null;
        parent: TContainerNode | null;
        tViews: null;
        projection: null;
}
/** Static data for an LProjectionNode  */
export interface TProjectionNode extends TNode {
        /** Index in the data[] array */
        child: null;
        /**
            * Projection nodes will have parents unless they are the first node of a component
            * or embedded view (which means their parent is in a different view and must be
            * retrieved using LView.node).
            */
        parent: TElementNode | TElementContainerNode | null;
        tViews: null;
        /** Index of the projection node. (See TNode.projection for more info.) */
        projection: number;
}
/**
    * This mapping is necessary so we can set input properties and output listeners
    * properly at runtime when property names are minified or aliased.
    *
    * Key: unminified / public input or output name
    * Value: array containing minified / internal name and related directive index
    *
    * The value must be an array to support inputs and outputs with the same name
    * on the same node.
    */
export declare type PropertyAliases = {
        [key: string]: PropertyAliasValue;
};
/**
    * Store the runtime input or output names for all the directives.
    *
    * - Even indices: directive index
    * - Odd indices: minified / internal name
    *
    * e.g. [0, 'change-minified']
    */
export declare type PropertyAliasValue = (number | string)[];
/**
    * This array contains information about input properties that
    * need to be set once from attribute data. It's ordered by
    * directive index (relative to element) so it's simple to
    * look up a specific directive's initial input data.
    *
    * Within each sub-array:
    *
    * Even indices: minified/internal input name
    * Odd indices: initial value
    *
    * If a directive on a node does not have any input properties
    * that should be set from attributes, its index is set to null
    * to avoid a sparse array.
    *
    * e.g. [null, ['role-min', 'button']]
    */
export declare type InitialInputData = (InitialInputs | null)[];
/**
    * Used by InitialInputData to store input properties
    * that should be set once from attributes.
    *
    * Even indices: minified/internal input name
    * Odd indices: initial value
    *
    * e.g. ['role-min', 'button']
    */
export declare type InitialInputs = string[];
export declare const unusedValueExportToPlacateAjd = 1;
/**
    * Type representing a set of TNodes that can have local refs (`#foo`) placed on them.
    */
export declare type TNodeWithLocalRefs = TContainerNode | TElementNode | TElementContainerNode;
/**
    * Type for a function that extracts a value for a local refs.
    * Example:
    * - `<div #nativeDivEl>` - `nativeDivEl` should point to the native `<div>` element;
    * - `<ng-template #tplRef>` - `tplRef` should point to the `TemplateRef` instance;
    */
export declare type LocalRefExtractor = (tNode: TNodeWithLocalRefs, currentView: LViewData) => any;

/**
    * @license
    * Copyright Google Inc. All Rights Reserved.
    *
    * Use of this source code is governed by an MIT-style license that can be
    * found in the LICENSE file at https://angular.io/license
    */
import { Type } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/type';
/**
    * Adds decorator, constructor, and property metadata to a given type via static metadata fields
    * on the type.
    *
    * These metadata fields can later be read with Angular's `ReflectionCapabilities` API.
    *
    * Calls to `setClassMetadata` can be marked as pure, resulting in the metadata assignments being
    * tree-shaken away during production builds.
    */
export declare function setClassMetadata(type: Type<any>, decorators: any[] | null, ctorParameters: any[] | null, propDecorators: {
        [field: string]: any;
} | null): void;

/**
    * Create a pipe.
    *
    * @param index Pipe index where the pipe will be stored.
    * @param pipeName The name of the pipe
    * @returns T the instance of the pipe.
    */
export declare function pipe(index: number, pipeName: string): any;
/**
    * Invokes a pipe with 1 arguments.
    *
    * This instruction acts as a guard to {@link PipeTransform#transform} invoking
    * the pipe only when an input to the pipe changes.
    *
    * @param index Pipe index where the pipe was stored on creation.
    * @param slotOffset the offset in the reserved slot space
    * @param v1 1st argument to {@link PipeTransform#transform}.
    */
export declare function pipeBind1(index: number, slotOffset: number, v1: any): any;
/**
    * Invokes a pipe with 2 arguments.
    *
    * This instruction acts as a guard to {@link PipeTransform#transform} invoking
    * the pipe only when an input to the pipe changes.
    *
    * @param index Pipe index where the pipe was stored on creation.
    * @param slotOffset the offset in the reserved slot space
    * @param v1 1st argument to {@link PipeTransform#transform}.
    * @param v2 2nd argument to {@link PipeTransform#transform}.
    */
export declare function pipeBind2(index: number, slotOffset: number, v1: any, v2: any): any;
/**
    * Invokes a pipe with 3 arguments.
    *
    * This instruction acts as a guard to {@link PipeTransform#transform} invoking
    * the pipe only when an input to the pipe changes.
    *
    * @param index Pipe index where the pipe was stored on creation.
    * @param slotOffset the offset in the reserved slot space
    * @param v1 1st argument to {@link PipeTransform#transform}.
    * @param v2 2nd argument to {@link PipeTransform#transform}.
    * @param v3 4rd argument to {@link PipeTransform#transform}.
    */
export declare function pipeBind3(index: number, slotOffset: number, v1: any, v2: any, v3: any): any;
/**
    * Invokes a pipe with 4 arguments.
    *
    * This instruction acts as a guard to {@link PipeTransform#transform} invoking
    * the pipe only when an input to the pipe changes.
    *
    * @param index Pipe index where the pipe was stored on creation.
    * @param slotOffset the offset in the reserved slot space
    * @param v1 1st argument to {@link PipeTransform#transform}.
    * @param v2 2nd argument to {@link PipeTransform#transform}.
    * @param v3 3rd argument to {@link PipeTransform#transform}.
    * @param v4 4th argument to {@link PipeTransform#transform}.
    */
export declare function pipeBind4(index: number, slotOffset: number, v1: any, v2: any, v3: any, v4: any): any;
/**
    * Invokes a pipe with variable number of arguments.
    *
    * This instruction acts as a guard to {@link PipeTransform#transform} invoking
    * the pipe only when an input to the pipe changes.
    *
    * @param index Pipe index where the pipe was stored on creation.
    * @param slotOffset the offset in the reserved slot space
    * @param values Array of arguments to pass to {@link PipeTransform#transform} method.
    */
export declare function pipeBindV(index: number, slotOffset: number, values: any[]): any;

/**
    * @license
    * Copyright Google Inc. All Rights Reserved.
    *
    * Use of this source code is governed by an MIT-style license that can be
    * found in the LICENSE file at https://angular.io/license
    */
import { QueryList as viewEngine_QueryList } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/linker/query_list';
import { Type } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/type';
import { TContainerNode, TElementContainerNode, TElementNode } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/render3/interfaces/node';
import { LQueries } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/render3/interfaces/query';
/**
    * A predicate which determines if a given element/directive should be included in the query
    * results.
    */
export interface QueryPredicate<T> {
        /**
            * If looking for directives then it contains the directive type.
            */
        type: Type<T> | null;
        /**
            * If selector then contains local names to query for.
            */
        selector: string[] | null;
        /**
            * Indicates which token should be read from DI for this query.
            */
        read: Type<T> | null;
}
/**
    * An object representing a query, which is a combination of:
    * - query predicate to determines if a given element/directive should be included in the query
    * - values collected based on a predicate
    * - `QueryList` to which collected values should be reported
    */
export interface LQuery<T> {
        /**
            * Next query. Used when queries are stored as a linked list in `LQueries`.
            */
        next: LQuery<any> | null;
        /**
            * Destination to which the value should be added.
            */
        list: QueryList<T>;
        /**
            * A predicate which determines if a given element/directive should be included in the query
            * results.
            */
        predicate: QueryPredicate<T>;
        /**
            * Values which have been located.
            *
            * This is what builds up the `QueryList._valuesTree`.
            */
        values: any[];
        /**
            * A pointer to an array that stores collected values from views. This is necessary so we know a
            * container into which to insert nodes collected from views.
            */
        containerValues: any[] | null;
}
export declare class LQueries_ implements LQueries {
        parent: LQueries_ | null;
        constructor(parent: LQueries_ | null, shallow: LQuery<any> | null, deep: LQuery<any> | null);
        track<T>(queryList: viewEngine_QueryList<T>, predicate: Type<T> | string[], descend?: boolean, read?: Type<T>): void;
        clone(): LQueries;
        container(): LQueries | null;
        createView(): LQueries | null;
        insertView(index: number): void;
        addNode(tNode: TElementNode | TContainerNode | TElementContainerNode): LQueries | null;
        removeView(): void;
}
export declare type QueryList<T> = viewEngine_QueryList<T>;
export declare const QueryList: typeof viewEngine_QueryList;
/**
    * Creates and returns a QueryList.
    *
    * @param memoryIndex The index in memory where the QueryList should be saved. If null,
    * this is is a content query and the QueryList will be saved later through directiveCreate.
    * @param predicate The type for which the query will search
    * @param descend Whether or not to descend into children
    * @param read What to save in the query
    * @returns QueryList<T>
    */
export declare function query<T>(memoryIndex: number | null, predicate: Type<any> | string[], descend?: boolean, read?: any): QueryList<T>;
/**
    * Refreshes a query by combining matches from all active views and removing matches from deleted
    * views.
    * Returns true if a query got dirty during change detection, false otherwise.
    */
export declare function queryRefresh(queryList: QueryList<any>): boolean;

/**
    * If the value hasn't been saved, calls the pure function to store and return the
    * value. If it has been saved, returns the saved value.
    *
    * @param slotOffset the offset from binding root to the reserved slot
    * @param pureFn Function that returns a value
    * @param thisArg Optional calling context of pureFn
    * @returns value
    */
export declare function pureFunction0<T>(slotOffset: number, pureFn: () => T, thisArg?: any): T;
/**
    * If the value of the provided exp has changed, calls the pure function to return
    * an updated value. Or if the value has not changed, returns cached value.
    *
    * @param slotOffset the offset from binding root to the reserved slot
    * @param pureFn Function that returns an updated value
    * @param exp Updated expression value
    * @param thisArg Optional calling context of pureFn
    * @returns Updated or cached value
    */
export declare function pureFunction1(slotOffset: number, pureFn: (v: any) => any, exp: any, thisArg?: any): any;
/**
    * If the value of any provided exp has changed, calls the pure function to return
    * an updated value. Or if no values have changed, returns cached value.
    *
    * @param slotOffset the offset from binding root to the reserved slot
    * @param pureFn
    * @param exp1
    * @param exp2
    * @param thisArg Optional calling context of pureFn
    * @returns Updated or cached value
    */
export declare function pureFunction2(slotOffset: number, pureFn: (v1: any, v2: any) => any, exp1: any, exp2: any, thisArg?: any): any;
/**
    * If the value of any provided exp has changed, calls the pure function to return
    * an updated value. Or if no values have changed, returns cached value.
    *
    * @param slotOffset the offset from binding root to the reserved slot
    * @param pureFn
    * @param exp1
    * @param exp2
    * @param exp3
    * @param thisArg Optional calling context of pureFn
    * @returns Updated or cached value
    */
export declare function pureFunction3(slotOffset: number, pureFn: (v1: any, v2: any, v3: any) => any, exp1: any, exp2: any, exp3: any, thisArg?: any): any;
/**
    * If the value of any provided exp has changed, calls the pure function to return
    * an updated value. Or if no values have changed, returns cached value.
    *
    * @param slotOffset the offset from binding root to the reserved slot
    * @param pureFn
    * @param exp1
    * @param exp2
    * @param exp3
    * @param exp4
    * @param thisArg Optional calling context of pureFn
    * @returns Updated or cached value
    */
export declare function pureFunction4(slotOffset: number, pureFn: (v1: any, v2: any, v3: any, v4: any) => any, exp1: any, exp2: any, exp3: any, exp4: any, thisArg?: any): any;
/**
    * If the value of any provided exp has changed, calls the pure function to return
    * an updated value. Or if no values have changed, returns cached value.
    *
    * @param slotOffset the offset from binding root to the reserved slot
    * @param pureFn
    * @param exp1
    * @param exp2
    * @param exp3
    * @param exp4
    * @param exp5
    * @param thisArg Optional calling context of pureFn
    * @returns Updated or cached value
    */
export declare function pureFunction5(slotOffset: number, pureFn: (v1: any, v2: any, v3: any, v4: any, v5: any) => any, exp1: any, exp2: any, exp3: any, exp4: any, exp5: any, thisArg?: any): any;
/**
    * If the value of any provided exp has changed, calls the pure function to return
    * an updated value. Or if no values have changed, returns cached value.
    *
    * @param slotOffset the offset from binding root to the reserved slot
    * @param pureFn
    * @param exp1
    * @param exp2
    * @param exp3
    * @param exp4
    * @param exp5
    * @param exp6
    * @param thisArg Optional calling context of pureFn
    * @returns Updated or cached value
    */
export declare function pureFunction6(slotOffset: number, pureFn: (v1: any, v2: any, v3: any, v4: any, v5: any, v6: any) => any, exp1: any, exp2: any, exp3: any, exp4: any, exp5: any, exp6: any, thisArg?: any): any;
/**
    * If the value of any provided exp has changed, calls the pure function to return
    * an updated value. Or if no values have changed, returns cached value.
    *
    * @param slotOffset the offset from binding root to the reserved slot
    * @param pureFn
    * @param exp1
    * @param exp2
    * @param exp3
    * @param exp4
    * @param exp5
    * @param exp6
    * @param exp7
    * @param thisArg Optional calling context of pureFn
    * @returns Updated or cached value
    */
export declare function pureFunction7(slotOffset: number, pureFn: (v1: any, v2: any, v3: any, v4: any, v5: any, v6: any, v7: any) => any, exp1: any, exp2: any, exp3: any, exp4: any, exp5: any, exp6: any, exp7: any, thisArg?: any): any;
/**
    * If the value of any provided exp has changed, calls the pure function to return
    * an updated value. Or if no values have changed, returns cached value.
    *
    * @param slotOffset the offset from binding root to the reserved slot
    * @param pureFn
    * @param exp1
    * @param exp2
    * @param exp3
    * @param exp4
    * @param exp5
    * @param exp6
    * @param exp7
    * @param exp8
    * @param thisArg Optional calling context of pureFn
    * @returns Updated or cached value
    */
export declare function pureFunction8(slotOffset: number, pureFn: (v1: any, v2: any, v3: any, v4: any, v5: any, v6: any, v7: any, v8: any) => any, exp1: any, exp2: any, exp3: any, exp4: any, exp5: any, exp6: any, exp7: any, exp8: any, thisArg?: any): any;
/**
    * pureFunction instruction that can support any number of bindings.
    *
    * If the value of any provided exp has changed, calls the pure function to return
    * an updated value. Or if no values have changed, returns cached value.
    *
    * @param slotOffset the offset from binding root to the reserved slot
    * @param pureFn A pure function that takes binding values and builds an object or array
    * containing those values.
    * @param exps An array of binding values
    * @param thisArg Optional calling context of pureFn
    * @returns Updated or cached value
    */
export declare function pureFunctionV(slotOffset: number, pureFn: (...v: any[]) => any, exps: any[], thisArg?: any): any;

/**
    * @license
    * Copyright Google Inc. All Rights Reserved.
    *
    * Use of this source code is governed by an MIT-style license that can be
    * found in the LICENSE file at https://angular.io/license
    */
import { TemplateRef as ViewEngine_TemplateRef } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/linker/template_ref';
import { TNode } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/render3/interfaces/node';
import { LViewData } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/render3/interfaces/view';
/**
    * Retrieves `TemplateRef` instance from `Injector` when a local reference is placed on the
    * `<ng-template>` element.
    */
export declare function templateRefExtractor(tNode: TNode, currentView: LViewData): ViewEngine_TemplateRef<{}> | null;

/**
  * @license
  * Copyright Google Inc. All Rights Reserved.
  *
  * Use of this source code is governed by an MIT-style license that can be
  * found in the LICENSE file at https://angular.io/license
  */
export interface NO_CHANGE {
    brand: 'NO_CHANGE';
}
/** A special value which designates that a value has not changed. */
export declare const NO_CHANGE: NO_CHANGE;

/**
    * A set of interfaces which are shared between `@angular/core` and `@angular/compiler` to allow
    * for late binding of `@angular/compiler` for JIT purposes.
    *
    * This file has two copies. Please ensure that they are in sync:
    *  - packages/compiler/src/compiler_facade_interface.ts             (master)
    *  - packages/core/src/render3/jit/compiler_facade_interface.ts     (copy)
    *
    * Please ensure that the two files are in sync using this command:
    * ```
    * cp packages/compiler/src/compiler_facade_interface.ts \
    *    packages/core/src/render3/jit/compiler_facade_interface.ts
    * ```
    */
export interface ExportedCompilerFacade {
        ɵcompilerFacade: CompilerFacade;
}
export interface CompilerFacade {
        compilePipe(angularCoreEnv: CoreEnvironment, sourceMapUrl: string, meta: R3PipeMetadataFacade): any;
        compileInjectable(angularCoreEnv: CoreEnvironment, sourceMapUrl: string, meta: R3InjectableMetadataFacade): any;
        compileInjector(angularCoreEnv: CoreEnvironment, sourceMapUrl: string, meta: R3InjectorMetadataFacade): any;
        compileNgModule(angularCoreEnv: CoreEnvironment, sourceMapUrl: string, meta: R3NgModuleMetadataFacade): any;
        compileDirective(angularCoreEnv: CoreEnvironment, sourceMapUrl: string, meta: R3DirectiveMetadataFacade): any;
        compileComponent(angularCoreEnv: CoreEnvironment, sourceMapUrl: string, meta: R3ComponentMetadataFacade): any;
        R3ResolvedDependencyType: typeof R3ResolvedDependencyType;
}
export interface CoreEnvironment {
        [name: string]: Function;
}
export declare type StringMap = {
        [key: string]: string;
};
export declare type StringMapWithRename = {
        [key: string]: string | [string, string];
};
export declare type Provider = any;
export declare enum R3ResolvedDependencyType {
        Token = 0,
        Attribute = 1
}
export interface R3DependencyMetadataFacade {
        token: any;
        resolved: R3ResolvedDependencyType;
        host: boolean;
        optional: boolean;
        self: boolean;
        skipSelf: boolean;
}
export interface R3PipeMetadataFacade {
        name: string;
        type: any;
        pipeName: string;
        deps: R3DependencyMetadataFacade[] | null;
        pure: boolean;
}
export interface R3InjectableMetadataFacade {
        name: string;
        type: any;
        ctorDeps: R3DependencyMetadataFacade[] | null;
        providedIn: any;
        useClass?: any;
        useFactory?: any;
        useExisting?: any;
        useValue?: any;
        userDeps?: R3DependencyMetadataFacade[];
}
export interface R3NgModuleMetadataFacade {
        type: any;
        bootstrap: Function[];
        declarations: Function[];
        imports: Function[];
        exports: Function[];
        emitInline: boolean;
}
export interface R3InjectorMetadataFacade {
        name: string;
        type: any;
        deps: R3DependencyMetadataFacade[] | null;
        providers: any;
        imports: any;
}
export interface R3DirectiveMetadataFacade {
        name: string;
        type: any;
        typeArgumentCount: number;
        typeSourceSpan: null;
        deps: R3DependencyMetadataFacade[] | null;
        selector: string | null;
        queries: R3QueryMetadataFacade[];
        host: {
                [key: string]: string;
        };
        propMetadata: {
                [key: string]: any[];
        };
        lifecycle: {
                usesOnChanges: boolean;
        };
        inputs: string[];
        outputs: string[];
        usesInheritance: boolean;
        exportAs: string | null;
        providers: Provider[] | null;
}
export interface R3ComponentMetadataFacade extends R3DirectiveMetadataFacade {
        template: string;
        preserveWhitespaces: boolean;
        animations: any[] | undefined;
        viewQueries: R3QueryMetadataFacade[];
        pipes: Map<string, any>;
        directives: Map<string, any>;
        styles: string[];
        encapsulation: ViewEncapsulation;
        viewProviders: Provider[] | null;
}
export declare type ViewEncapsulation = number;
export interface R3QueryMetadataFacade {
        propertyName: string;
        first: boolean;
        predicate: any | string[];
        descendants: boolean;
        read: any | null;
}

/**
    * @license
    * Copyright Google Inc. All Rights Reserved.
    *
    * Use of this source code is governed by an MIT-style license that can be
    * found in the LICENSE file at https://angular.io/license
    */
import { InjectionToken } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/di/injection_token';
import { Injector } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/di/injector';
import { QueryList } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/linker';
import { Sanitizer } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/sanitization/security';
import { Type } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/type';
import { LContainer } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/render3/interfaces/container';
import { ComponentDef, ComponentQuery, ComponentTemplate, DirectiveDef, DirectiveDefList, HostBindingsFunction, PipeDef, PipeDefList } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/render3/interfaces/definition';
import { I18nUpdateOpCodes, TI18n } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/render3/interfaces/i18n';
import { TElementNode, TNode, TViewNode } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/render3/interfaces/node';
import { PlayerHandler } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/render3/interfaces/player';
import { LQueries } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/render3/interfaces/query';
import { RElement, Renderer3 } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/render3/interfaces/renderer';
import { StylingContext } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/render3/interfaces/styling';
/** Size of LViewData's header. Necessary to adjust for it when setting slots.  */
export declare const HEADER_OFFSET = 17;
export declare const TVIEW = 0;
export declare const FLAGS = 1;
export declare const PARENT = 2;
export declare const NEXT = 3;
export declare const QUERIES = 4;
export declare const HOST = 5;
export declare const HOST_NODE = 6;
export declare const BINDING_INDEX = 7;
export declare const CLEANUP = 8;
export declare const CONTEXT = 9;
export declare const INJECTOR = 10;
export declare const RENDERER = 11;
export declare const SANITIZER = 12;
export declare const TAIL = 13;
export declare const CONTAINER_INDEX = 14;
export declare const CONTENT_QUERIES = 15;
export declare const DECLARATION_VIEW = 16;
export interface OpaqueViewState {
        '__brand__': 'Brand for OpaqueViewState that nothing will match';
}
/**
    * `LViewData` stores all of the information needed to process the instructions as
    * they are invoked from the template. Each embedded view and component view has its
    * own `LViewData`. When processing a particular view, we set the `viewData` to that
    * `LViewData`. When that view is done processing, the `viewData` is set back to
    * whatever the original `viewData` was before (the parent `LViewData`).
    *
    * Keeping separate state for each view facilities view insertion / deletion, so we
    * don't have to edit the data array based on which views are present.
    */
export interface LViewData extends Array<any> {
        /**
            * The static data for this view. We need a reference to this so we can easily walk up the
            * node tree in DI and get the TView.data array associated with a node (where the
            * directive defs are stored).
            */
        readonly [TVIEW]: TView;
        /** Flags for this view. See LViewFlags for more info. */
        [FLAGS]: LViewFlags;
        /**
            * The parent view is needed when we exit the view and must restore the previous
            * `LViewData`. Without this, the render method would have to keep a stack of
            * views as it is recursively rendering templates.
            *
            * This is the "insertion" view for embedded views. This allows us to properly
            * destroy embedded views.
            */
        [PARENT]: LViewData | null;
        /**
            *
            * The next sibling LViewData or LContainer.
            *
            * Allows us to propagate between sibling view states that aren't in the same
            * container. Embedded views already have a node.next, but it is only set for
            * views in the same container. We need a way to link component views and views
            * across containers as well.
            */
        [NEXT]: LViewData | LContainer | null;
        /** Queries active for this view - nodes from a view are reported to those queries. */
        [QUERIES]: LQueries | null;
        /**
            * The host node for this LViewData instance, if this is a component view.
            *
            * If this is an embedded view, HOST will be null.
            */
        [HOST]: RElement | StylingContext | null;
        /**
            * Pointer to the `TViewNode` or `TElementNode` which represents the root of the view.
            *
            * If `TViewNode`, this is an embedded view of a container. We need this to be able to
            * efficiently find the `LViewNode` when inserting the view into an anchor.
            *
            * If `TElementNode`, this is the LView of a component.
            *
            * If null, this is the root view of an application (root component is in this view).
            */
        [HOST_NODE]: TViewNode | TElementNode | null;
        /**
            * The binding index we should access next.
            *
            * This is stored so that bindings can continue where they left off
            * if a view is left midway through processing bindings (e.g. if there is
            * a setter that creates an embedded view, like in ngIf).
            */
        [BINDING_INDEX]: number;
        /**
            * When a view is destroyed, listeners need to be released and outputs need to be
            * unsubscribed. This context array stores both listener functions wrapped with
            * their context and output subscription instances for a particular view.
            *
            * These change per LView instance, so they cannot be stored on TView. Instead,
            * TView.cleanup saves an index to the necessary context in this array.
            */
        [CLEANUP]: any[] | null;
        /**
            * - For dynamic views, this is the context with which to render the template (e.g.
            *   `NgForContext`), or `{}` if not defined explicitly.
            * - For root view of the root component the context contains change detection data.
            * - For non-root components, the context is the component instance,
            * - For inline views, the context is null.
            */
        [CONTEXT]: {} | RootContext | null;
        /** An optional Module Injector to be used as fall back after Element Injectors are consulted. */
        readonly [INJECTOR]: Injector | null;
        /** Renderer to be used for this view. */
        [RENDERER]: Renderer3;
        /** An optional custom sanitizer. */
        [SANITIZER]: Sanitizer | null;
        /**
            * The last LViewData or LContainer beneath this LViewData in the hierarchy.
            *
            * The tail allows us to quickly add a new state to the end of the view list
            * without having to propagate starting from the first child.
            */
        [TAIL]: LViewData | LContainer | null;
        /**
            * The index of the parent container's host node. Applicable only to embedded views that
            * have been inserted dynamically. Will be -1 for component views and inline views.
            *
            * This is necessary to jump from dynamically created embedded views to their parent
            * containers because their parent cannot be stored on the TViewNode (views may be inserted
            * in multiple containers, so the parent cannot be shared between view instances).
            */
        [CONTAINER_INDEX]: number;
        /**
            * Stores QueryLists associated with content queries of a directive. This data structure is
            * filled-in as part of a directive creation process and is later used to retrieve a QueryList to
            * be refreshed.
            */
        [CONTENT_QUERIES]: QueryList<any>[] | null;
        /**
            * View where this view's template was declared.
            *
            * Only applicable for dynamically created views. Will be null for inline/component views.
            *
            * The template for a dynamically created view may be declared in a different view than
            * it is inserted. We already track the "insertion view" (view where the template was
            * inserted) in LViewData[PARENT], but we also need access to the "declaration view"
            * (view where the template was declared). Otherwise, we wouldn't be able to call the
            * view's template function with the proper contexts. Context should be inherited from
            * the declaration view tree, not the insertion view tree.
            *
            * Example (AppComponent template):
            *
            * <ng-template #foo></ng-template>       <-- declared here -->
            * <some-comp [tpl]="foo"></some-comp>    <-- inserted inside this component -->
            *
            * The <ng-template> above is declared in the AppComponent template, but it will be passed into
            * SomeComp and inserted there. In this case, the declaration view would be the AppComponent,
            * but the insertion view would be SomeComp. When we are removing views, we would want to
            * traverse through the insertion view to clean up listeners. When we are calling the
            * template function during change detection, we need the declaration view to get inherited
            * context.
            */
        [DECLARATION_VIEW]: LViewData | null;
}
/** Flags associated with an LView (saved in LViewData[FLAGS]) */
export declare const enum LViewFlags {
        /**
            * Whether or not the view is in creationMode.
            *
            * This must be stored in the view rather than using `data` as a marker so that
            * we can properly support embedded views. Otherwise, when exiting a child view
            * back into the parent view, `data` will be defined and `creationMode` will be
            * improperly reported as false.
            */
        CreationMode = 1,
        /** Whether this view has default change detection strategy (checks always) or onPush */
        CheckAlways = 2,
        /** Whether or not this view is currently dirty (needing check) */
        Dirty = 4,
        /** Whether or not this view is currently attached to change detection tree. */
        Attached = 8,
        /**
            *  Whether or not the init hooks have run.
            *
            * If on, the init hooks haven't yet been run and should be executed by the first component that
            * runs OR the first cR() instruction that runs (so inits are run for the top level view before
            * any embedded views).
            */
        RunInit = 16,
        /** Whether or not this view is destroyed. */
        Destroyed = 32,
        /** Whether or not this view is the root view */
        IsRoot = 64
}
/**
    * The static data for an LView (shared between all templates of a
    * given type).
    *
    * Stored on the template function as ngPrivateData.
    */
export interface TView {
        /**
            * ID for inline views to determine whether a view is the same as the previous view
            * in a certain position. If it's not, we know the new view needs to be inserted
            * and the one that exists needs to be removed (e.g. if/else statements)
            *
            * If this is -1, then this is a component view or a dynamically created view.
            */
        readonly id: number;
        /**
            * This is a blueprint used to generate LViewData instances for this TView. Copying this
            * blueprint is faster than creating a new LViewData from scratch.
            */
        blueprint: LViewData;
        /**
            * The template function used to refresh the view of dynamically created views
            * and components. Will be null for inline views.
            */
        template: ComponentTemplate<{}> | null;
        /**
            * A function containing query-related instructions.
            */
        viewQuery: ComponentQuery<{}> | null;
        /**
            * Pointer to the `TNode` that represents the root of the view.
            *
            * If this is a `TNode` for an `LViewNode`, this is an embedded view of a container.
            * We need this pointer to be able to efficiently find this node when inserting the view
            * into an anchor.
            *
            * If this is a `TElementNode`, this is the view of a root component. It has exactly one
            * root TNode.
            *
            * If this is null, this is the view of a component that is not at root. We do not store
            * the host TNodes for child component views because they can potentially have several
            * different host TNodes, depending on where the component is being used. These host
            * TNodes cannot be shared (due to different indices, etc).
            */
        node: TViewNode | TElementNode | null;
        /** Whether or not this template has been processed. */
        firstTemplatePass: boolean;
        /** Static data equivalent of LView.data[]. Contains TNodes, PipeDefInternal or TI18n. */
        data: TData;
        /**
            * The binding start index is the index at which the data array
            * starts to store bindings only. Saving this value ensures that we
            * will begin reading bindings at the correct point in the array when
            * we are in update mode.
            */
        bindingStartIndex: number;
        /**
            * The index where the "expando" section of `LViewData` begins. The expando
            * section contains injectors, directive instances, and host binding values.
            * Unlike the "consts" and "vars" sections of `LViewData`, the length of this
            * section cannot be calculated at compile-time because directives are matched
            * at runtime to preserve locality.
            *
            * We store this start index so we know where to start checking host bindings
            * in `setHostBindings`.
            */
        expandoStartIndex: number;
        /**
            * Index of the host node of the first LView or LContainer beneath this LView in
            * the hierarchy.
            *
            * Necessary to store this so views can traverse through their nested views
            * to remove listeners and call onDestroy callbacks.
            *
            * For embedded views, we store the index of an LContainer's host rather than the first
            * LView to avoid managing splicing when views are added/removed.
            */
        childIndex: number;
        /**
            * A reference to the first child node located in the view.
            */
        firstChild: TNode | null;
        /**
            * Set of instructions used to process host bindings efficiently.
            *
            * See VIEW_DATA.md for more information.
            */
        expandoInstructions: (number | HostBindingsFunction)[] | null;
        /**
            * Full registry of directives and components that may be found in this view.
            *
            * It's necessary to keep a copy of the full def list on the TView so it's possible
            * to render template functions without a host component.
            */
        directiveRegistry: DirectiveDefList | null;
        /**
            * Full registry of pipes that may be found in this view.
            *
            * The property is either an array of `PipeDefs`s or a function which returns the array of
            * `PipeDefs`s. The function is necessary to be able to support forward declarations.
            *
            * It's necessary to keep a copy of the full def list on the TView so it's possible
            * to render template functions without a host component.
            */
        pipeRegistry: PipeDefList | null;
        /**
            * Array of ngOnInit and ngDoCheck hooks that should be executed for this view in
            * creation mode.
            *
            * Even indices: Directive index
            * Odd indices: Hook function
            */
        initHooks: HookData | null;
        /**
            * Array of ngDoCheck hooks that should be executed for this view in update mode.
            *
            * Even indices: Directive index
            * Odd indices: Hook function
            */
        checkHooks: HookData | null;
        /**
            * Array of ngAfterContentInit and ngAfterContentChecked hooks that should be executed
            * for this view in creation mode.
            *
            * Even indices: Directive index
            * Odd indices: Hook function
            */
        contentHooks: HookData | null;
        /**
            * Array of ngAfterContentChecked hooks that should be executed for this view in update
            * mode.
            *
            * Even indices: Directive index
            * Odd indices: Hook function
            */
        contentCheckHooks: HookData | null;
        /**
            * Array of ngAfterViewInit and ngAfterViewChecked hooks that should be executed for
            * this view in creation mode.
            *
            * Even indices: Directive index
            * Odd indices: Hook function
            */
        viewHooks: HookData | null;
        /**
            * Array of ngAfterViewChecked hooks that should be executed for this view in
            * update mode.
            *
            * Even indices: Directive index
            * Odd indices: Hook function
            */
        viewCheckHooks: HookData | null;
        /**
            * Array of ngOnDestroy hooks that should be executed when this view is destroyed.
            *
            * Even indices: Directive index
            * Odd indices: Hook function
            */
        destroyHooks: HookData | null;
        /**
            * Array of pipe ngOnDestroy hooks that should be executed when this view is destroyed.
            *
            * Even indices: Index of pipe in data
            * Odd indices: Hook function
            *
            * These must be stored separately from directive destroy hooks because their contexts
            * are stored in data.
            */
        pipeDestroyHooks: HookData | null;
        /**
            * When a view is destroyed, listeners need to be released and outputs need to be
            * unsubscribed. This cleanup array stores both listener data (in chunks of 4)
            * and output data (in chunks of 2) for a particular view. Combining the arrays
            * saves on memory (70 bytes per array) and on a few bytes of code size (for two
            * separate for loops).
            *
            * If it's a native DOM listener being stored:
            * 1st index is: event name to remove
            * 2nd index is: index of native element in LView.data[]
            * 3rd index is: index of wrapped listener function in LView.cleanupInstances[]
            * 4th index is: useCapture boolean
            *
            * If it's a renderer2 style listener or ViewRef destroy hook being stored:
            * 1st index is: index of the cleanup function in LView.cleanupInstances[]
            * 2nd index is: null
            *
            * If it's an output subscription or query list destroy hook:
            * 1st index is: output unsubscribe function / query list destroy function
            * 2nd index is: index of function context in LView.cleanupInstances[]
            */
        cleanup: any[] | null;
        /**
            * A list of element indices for child components that will need to be
            * refreshed when the current view has finished its check. These indices have
            * already been adjusted for the HEADER_OFFSET.
            *
            */
        components: number[] | null;
        /**
            * A list of indices for child directives that have content queries.
            *
            * Even indices: Directive indices
            * Odd indices: Starting index of content queries (stored in CONTENT_QUERIES) for this directive
            */
        contentQueries: number[] | null;
}
export declare const enum RootContextFlags {
        Empty = 0,
        DetectChanges = 1,
        FlushPlayers = 2
}
/**
    * RootContext contains information which is shared for all components which
    * were bootstrapped with {@link renderComponent}.
    */
export interface RootContext {
        /**
            * A function used for scheduling change detection in the future. Usually
            * this is `requestAnimationFrame`.
            */
        scheduler: (workFn: () => void) => void;
        /**
            * A promise which is resolved when all components are considered clean (not dirty).
            *
            * This promise is overwritten every time a first call to {@link markDirty} is invoked.
            */
        clean: Promise<null>;
        /**
            * RootComponents - The components that were instantiated by the call to
            * {@link renderComponent}.
            */
        components: {}[];
        /**
            * The player flushing handler to kick off all animations
            */
        playerHandler: PlayerHandler | null;
        /**
            * What render-related operations to run once a scheduler has been set
            */
        flags: RootContextFlags;
}
/**
    * Array of hooks that should be executed for a view and their directive indices.
    *
    * Even indices: Directive index
    * Odd indices: Hook function
    */
export declare type HookData = (number | (() => void))[];
/**
    * Static data that corresponds to the instance-specific data array on an LView.
    *
    * Each node's static data is stored in tData at the same index that it's stored
    * in the data array.  Any nodes that do not have static data store a null value in
    * tData to avoid a sparse array.
    *
    * Each pipe's definition is stored here at the same index as its pipe instance in
    * the data array.
    *
    * Injector bloom filters are also stored here.
    */
export declare type TData = (TNode | PipeDef<any> | DirectiveDef<any> | ComponentDef<any> | number | Type<any> | InjectionToken<any> | TI18n | I18nUpdateOpCodes | null)[];
export declare const unusedValueExportToPlacateAjd = 1;

/**
    * The goal here is to make sure that the browser DOM API is the Renderer.
    * We do this by defining a subset of DOM API to be the renderer and than
    * use that time for rendering.
    *
    * At runtime we can than use the DOM api directly, in server or web-worker
    * it will be easy to implement such API.
    */
import { RendererStyleFlags2, RendererType2 } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/render/api';
export declare enum RendererStyleFlags3 {
        Important = 1,
        DashCase = 2
}
export declare type Renderer3 = ObjectOrientedRenderer3 | ProceduralRenderer3;
/**
    * Object Oriented style of API needed to create elements and text nodes.
    *
    * This is the native browser API style, e.g. operations are methods on individual objects
    * like HTMLElement. With this style, no additional code is needed as a facade
    * (reducing payload size).
    * */
export interface ObjectOrientedRenderer3 {
        createComment(data: string): RComment;
        createElement(tagName: string): RElement;
        createElementNS(namespace: string, tagName: string): RElement;
        createTextNode(data: string): RText;
        querySelector(selectors: string): RElement | null;
}
/** Returns whether the `renderer` is a `ProceduralRenderer3` */
export declare function isProceduralRenderer(renderer: ProceduralRenderer3 | ObjectOrientedRenderer3): renderer is ProceduralRenderer3;
/**
    * Procedural style of API needed to create elements and text nodes.
    *
    * In non-native browser environments (e.g. platforms such as web-workers), this is the
    * facade that enables element manipulation. This also facilitates backwards compatibility
    * with Renderer2.
    */
export interface ProceduralRenderer3 {
        destroy(): void;
        createComment(value: string): RComment;
        createElement(name: string, namespace?: string | null): RElement;
        createText(value: string): RText;
        /**
            * This property is allowed to be null / undefined,
            * in which case the view engine won't call it.
            * This is used as a performance optimization for production mode.
            */
        destroyNode?: ((node: RNode) => void) | null;
        appendChild(parent: RElement, newChild: RNode): void;
        insertBefore(parent: RNode, newChild: RNode, refChild: RNode | null): void;
        removeChild(parent: RElement, oldChild: RNode): void;
        selectRootElement(selectorOrNode: string | any): RElement;
        parentNode(node: RNode): RElement | null;
        nextSibling(node: RNode): RNode | null;
        setAttribute(el: RElement, name: string, value: string, namespace?: string | null): void;
        removeAttribute(el: RElement, name: string, namespace?: string | null): void;
        addClass(el: RElement, name: string): void;
        removeClass(el: RElement, name: string): void;
        setStyle(el: RElement, style: string, value: any, flags?: RendererStyleFlags2 | RendererStyleFlags3): void;
        removeStyle(el: RElement, style: string, flags?: RendererStyleFlags2 | RendererStyleFlags3): void;
        setProperty(el: RElement, name: string, value: any): void;
        setValue(node: RText, value: string): void;
        listen(target: RNode, eventName: string, callback: (event: any) => boolean | void): () => void;
}
export interface RendererFactory3 {
        createRenderer(hostElement: RElement | null, rendererType: RendererType2 | null): Renderer3;
        begin?(): void;
        end?(): void;
}
export declare const domRendererFactory3: RendererFactory3;
/** Subset of API needed for appending elements and text nodes. */
export interface RNode {
        parentNode: RNode | null;
        nextSibling: RNode | null;
        removeChild(oldChild: RNode): void;
        /**
            * Insert a child node.
            *
            * Used exclusively for adding View root nodes into ViewAnchor location.
            */
        insertBefore(newChild: RNode, refChild: RNode | null, isViewRoot: boolean): void;
        /**
            * Append a child node.
            *
            * Used exclusively for building up DOM which are static (ie not View roots)
            */
        appendChild(newChild: RNode): RNode;
}
/**
    * Subset of API needed for writing attributes, properties, and setting up
    * listeners on Element.
    */
export interface RElement extends RNode {
        style: RCssStyleDeclaration;
        classList: RDomTokenList;
        className: string;
        setAttribute(name: string, value: string): void;
        removeAttribute(name: string): void;
        setAttributeNS(namespaceURI: string, qualifiedName: string, value: string): void;
        addEventListener(type: string, listener: EventListener, useCapture?: boolean): void;
        removeEventListener(type: string, listener?: EventListener, options?: boolean): void;
        setProperty?(name: string, value: any): void;
}
export interface RCssStyleDeclaration {
        removeProperty(propertyName: string): string;
        setProperty(propertyName: string, value: string | null, priority?: string): void;
}
export interface RDomTokenList {
        add(token: string): void;
        remove(token: string): void;
}
export interface RText extends RNode {
        textContent: string | null;
}
export interface RComment extends RNode {
}
export declare const unusedValueExportToPlacateAjd = 1;

/**
    * @license
    * Copyright Google Inc. All Rights Reserved.
    *
    * Use of this source code is governed by an MIT-style license that can be
    * found in the LICENSE file at https://angular.io/license
    */
import { ApplicationRef } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/application_ref';
import { ChangeDetectorRef as viewEngine_ChangeDetectorRef } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/change_detection/change_detector_ref';
import { ViewContainerRef as viewEngine_ViewContainerRef } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/linker/view_container_ref';
import { EmbeddedViewRef as viewEngine_EmbeddedViewRef, InternalViewRef as viewEngine_InternalViewRef } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/linker/view_ref';
import { LViewData } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/render3/interfaces/view';
export interface viewEngine_ChangeDetectorRef_interface extends viewEngine_ChangeDetectorRef {
}
export declare class ViewRef<T> implements viewEngine_EmbeddedViewRef<T>, viewEngine_InternalViewRef, viewEngine_ChangeDetectorRef_interface {
        readonly rootNodes: any[];
        constructor(_view: LViewData, _context: T | null, _componentIndex: number);
        readonly context: T;
        readonly destroyed: boolean;
        destroy(): void;
        onDestroy(callback: Function): void;
        /**
            * Marks a view and all of its ancestors dirty.
            *
            * It also triggers change detection by calling `scheduleTick` internally, which coalesces
            * multiple `markForCheck` calls to into one change detection run.
            *
            * This can be used to ensure an {@link ChangeDetectionStrategy#OnPush OnPush} component is
            * checked when it needs to be re-rendered but the two normal triggers haven't marked it
            * dirty (i.e. inputs haven't changed and events haven't fired in the view).
            *
            * <!-- TODO: Add a link to a chapter on OnPush components -->
            *
            * @usageNotes
            * ### Example
            *
            * ```typescript
            * @Component({
            *   selector: 'my-app',
            *   template: `Number of ticks: {{numberOfTicks}}`
            *   changeDetection: ChangeDetectionStrategy.OnPush,
            * })
            * class AppComponent {
            *   numberOfTicks = 0;
            *
            *   constructor(private ref: ChangeDetectorRef) {
            *     setInterval(() => {
            *       this.numberOfTicks++;
            *       // the following is required, otherwise the view will not be updated
            *       this.ref.markForCheck();
            *     }, 1000);
            *   }
            * }
            * ```
            */
        markForCheck(): void;
        /**
            * Detaches the view from the change detection tree.
            *
            * Detached views will not be checked during change detection runs until they are
            * re-attached, even if they are dirty. `detach` can be used in combination with
            * {@link ChangeDetectorRef#detectChanges detectChanges} to implement local change
            * detection checks.
            *
            * <!-- TODO: Add a link to a chapter on detach/reattach/local digest -->
            * <!-- TODO: Add a live demo once ref.detectChanges is merged into master -->
            *
            * @usageNotes
            * ### Example
            *
            * The following example defines a component with a large list of readonly data.
            * Imagine the data changes constantly, many times per second. For performance reasons,
            * we want to check and update the list every five seconds. We can do that by detaching
            * the component's change detector and doing a local check every five seconds.
            *
            * ```typescript
            * class DataProvider {
            *   // in a real application the returned data will be different every time
            *   get data() {
            *     return [1,2,3,4,5];
            *   }
            * }
            *
            * @Component({
            *   selector: 'giant-list',
            *   template: `
            *     <li *ngFor="let d of dataProvider.data">Data {{d}}</li>
            *   `,
            * })
            * class GiantList {
            *   constructor(private ref: ChangeDetectorRef, private dataProvider: DataProvider) {
            *     ref.detach();
            *     setInterval(() => {
            *       this.ref.detectChanges();
            *     }, 5000);
            *   }
            * }
            *
            * @Component({
            *   selector: 'app',
            *   providers: [DataProvider],
            *   template: `
            *     <giant-list><giant-list>
            *   `,
            * })
            * class App {
            * }
            * ```
            */
        detach(): void;
        /**
            * Re-attaches a view to the change detection tree.
            *
            * This can be used to re-attach views that were previously detached from the tree
            * using {@link ChangeDetectorRef#detach detach}. Views are attached to the tree by default.
            *
            * <!-- TODO: Add a link to a chapter on detach/reattach/local digest -->
            *
            * @usageNotes
            * ### Example
            *
            * The following example creates a component displaying `live` data. The component will detach
            * its change detector from the main change detector tree when the component's live property
            * is set to false.
            *
            * ```typescript
            * class DataProvider {
            *   data = 1;
            *
            *   constructor() {
            *     setInterval(() => {
            *       this.data = this.data * 2;
            *     }, 500);
            *   }
            * }
            *
            * @Component({
            *   selector: 'live-data',
            *   inputs: ['live'],
            *   template: 'Data: {{dataProvider.data}}'
            * })
            * class LiveData {
            *   constructor(private ref: ChangeDetectorRef, private dataProvider: DataProvider) {}
            *
            *   set live(value) {
            *     if (value) {
            *       this.ref.reattach();
            *     } else {
            *       this.ref.detach();
            *     }
            *   }
            * }
            *
            * @Component({
            *   selector: 'my-app',
            *   providers: [DataProvider],
            *   template: `
            *     Live Update: <input type="checkbox" [(ngModel)]="live">
            *     <live-data [live]="live"><live-data>
            *   `,
            * })
            * class AppComponent {
            *   live = true;
            * }
            * ```
            */
        reattach(): void;
        /**
            * Checks the view and its children.
            *
            * This can also be used in combination with {@link ChangeDetectorRef#detach detach} to implement
            * local change detection checks.
            *
            * <!-- TODO: Add a link to a chapter on detach/reattach/local digest -->
            * <!-- TODO: Add a live demo once ref.detectChanges is merged into master -->
            *
            * @usageNotes
            * ### Example
            *
            * The following example defines a component with a large list of readonly data.
            * Imagine, the data changes constantly, many times per second. For performance reasons,
            * we want to check and update the list every five seconds.
            *
            * We can do that by detaching the component's change detector and doing a local change detection
            * check every five seconds.
            *
            * See {@link ChangeDetectorRef#detach detach} for more information.
            */
        detectChanges(): void;
        /**
            * Checks the change detector and its children, and throws if any changes are detected.
            *
            * This is used in development mode to verify that running change detection doesn't
            * introduce other changes.
            */
        checkNoChanges(): void;
        attachToViewContainerRef(vcRef: viewEngine_ViewContainerRef): void;
        detachFromAppRef(): void;
        attachToAppRef(appRef: ApplicationRef): void;
}

/**
    * @license
    * Copyright Google Inc. All Rights Reserved.
    *
    * Use of this source code is governed by an MIT-style license that can be
    * found in the LICENSE file at https://angular.io/license
    */
import { InjectionToken } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/di/injection_token';
import { InjectFlags } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/di/injector_compatibility';
import { Type } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/type';
import { TElementNode } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/render3/interfaces/node';
import { LViewData, TData } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/render3/interfaces/view';
export declare const TNODE = 8;
export declare const PARENT_INJECTOR = 8;
export declare const INJECTOR_SIZE = 9;
/**
    * Represents a relative location of parent injector.
    *
    * The interfaces encodes number of parents `LViewData`s to traverse and index in the `LViewData`
    * pointing to the parent injector.
    */
export interface RelativeInjectorLocation {
        __brand__: 'RelativeInjectorLocationFlags';
}
export declare const enum RelativeInjectorLocationFlags {
        InjectorIndexMask = 32767,
        AcrossHostBoundary = 32768,
        ViewOffsetShift = 16,
        NO_PARENT = -1
}
export declare const NO_PARENT_INJECTOR: RelativeInjectorLocation;
/**
 * Factory for creating instances of injectors in the NodeInjector.
 *
 * This factory is complicated by the fact that it can resolve `multi` factories as well.
 *
 * NOTE: Some of the fields are optional which means that this class has two hidden classes.
 * - One without `multi` support (most common)
 * - One with `multi` values, (rare).
 *
 * Since VMs can cache up to 4 inline hidden classes this is OK.
 *
 * - Single factory: Only `resolving` and `factory` is defined.
 * - `providers` factory: `componentProviders` is a number and `index = -1`.
 * - `viewProviders` factory: `componentProviders` is a number and `index` points to `providers`.
 */
export declare class NodeInjectorFactory {
        /**
            * Factory to invoke in order to create a new instance.
            */
        factory: (this: NodeInjectorFactory, _: null, 
        /**
            * array where injectables tokens are stored. This is used in
            * case of an error reporting to produce friendlier errors.
            */
        tData: TData, 
        /**
            * array where existing instances of injectables are stored. This is used in case
            * of multi shadow is needed. See `multi` field documentation.
            */
        lData: LViewData, 
        /**
            * The TNode of the same element injector.
            */
        tNode: TElementNode) => any;
        /**
            * The inject implementation to be activated when using the factory.
            */
        injectImpl: null | (<T>(token: Type<T> | InjectionToken<T>, flags: InjectFlags) => T);
        /**
            * Marker set to true during factory invocation to see if we get into recursive loop.
            * Recursive loop causes an error to be displayed.
            */
        resolving: boolean;
        /**
            * Marks that the token can see other Tokens declared in `viewProviders` on the same node.
            */
        canSeeViewProviders: boolean;
        /**
            * An array of factories to use in case of `multi` provider.
            */
        multi?: Array<() => any>;
        /**
            * Number of `multi`-providers which belong to the component.
            *
            * This is needed because when multiple components and directives declare the `multi` provider
            * they have to be concatenated in the correct order.
            *
            * Example:
            *
            * If we have a component and directive active an a single element as declared here
            * ```
            * component:
            *   provides: [ {provide: String, useValue: 'component', multi: true} ],
            *   viewProvides: [ {provide: String, useValue: 'componentView', multi: true} ],
            *
            * directive:
            *   provides: [ {provide: String, useValue: 'directive', multi: true} ],
            * ```
            *
            * Then the expected results are:
            *
            * ```
            * providers: ['component', 'directive']
            * viewProviders: ['component', 'componentView', 'directive']
            * ```
            *
            * The way to think about it is that the `viewProviders` have been inserted after the component
            * but before the directives, which is why we need to know how many `multi`s have been declared by
            * the component.
            */
        componentProviders?: number;
        /**
            * Current index of the Factory in the `data`. Needed for `viewProviders` and `providers` merging.
            * See `providerFactory`.
            */
        index?: number;
        /**
            * Because the same `multi` provider can be declared in `provides` and `viewProvides` it is
            * possible for `viewProvides` to shadow the `provides`. For this reason we store the
            * `provideFactory` of the `providers` so that `providers` can be extended with `viewProviders`.
            *
            * Example:
            *
            * Given:
            * ```
            * provides: [ {provide: String, useValue: 'all', multi: true} ],
            * viewProvides: [ {provide: String, useValue: 'viewOnly', multi: true} ],
            * ```
            *
            * We have to return `['all']` in case of content injection, but `['all', 'viewOnly']` in case
            * of view injection. We further have to make sure that the shared instances (in our case
            * `all`) are the exact same instance in both the content as well as the view injection. (We
            * have to make sure that we don't double instantiate.) For this reason the `viewProvides`
            * `Factory` has a pointer to the shadowed `provides` factory so that it can instantiate the
            * `providers` (`['all']`) and then extend it with `viewProviders` (`['all'] + ['viewOnly'] =
            * ['all', 'viewOnly']`).
            */
        providerFactory?: NodeInjectorFactory | null;
        constructor(
        /**
            * Factory to invoke in order to create a new instance.
            */
        factory: (this: NodeInjectorFactory, _: null, 
        /**
            * array where injectables tokens are stored. This is used in
            * case of an error reporting to produce friendlier errors.
            */
        tData: TData, 
        /**
            * array where existing instances of injectables are stored. This is used in case
            * of multi shadow is needed. See `multi` field documentation.
            */
        lData: LViewData, 
        /**
            * The TNode of the same element injector.
            */
        tNode: TElementNode) => any, 
        /**
            * Set to `true` if the token is declared in `viewProviders` (or if it is component).
            */
        isViewProvider: boolean, injectImplementation: null | (<T>(token: Type<T> | InjectionToken<T>, flags: InjectFlags) => T));
}
export declare function isFactory(obj: any): obj is NodeInjectorFactory;
export declare const unusedValueExportToPlacateAjd = 1;

/**
    * @license
    * Copyright Google Inc. All Rights Reserved.
    *
    * Use of this source code is governed by an MIT-style license that can be
    * found in the LICENSE file at https://angular.io/license
    */
import { LQueries } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/render3/interfaces/query';
import { RComment, RElement } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/render3/interfaces/renderer';
import { StylingContext } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/render3/interfaces/styling';
import { HOST, LViewData, NEXT, PARENT, QUERIES } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/render3/interfaces/view';
/**
    * Below are constants for LContainer indices to help us look up LContainer members
    * without having to remember the specific indices.
    * Uglify will inline these when minifying so there shouldn't be a cost.
    */
export declare const ACTIVE_INDEX = 0;
export declare const VIEWS = 1;
export declare const NATIVE = 6;
export declare const RENDER_PARENT = 7;
/**
    * The state associated with a container.
    *
    * This is an array so that its structure is closer to LViewData. This helps
    * when traversing the view tree (which is a mix of containers and component
    * views), so we can jump to viewOrContainer[NEXT] in the same way regardless
    * of type.
    */
export interface LContainer extends Array<any> {
        /**
            * The next active index in the views array to read or write to. This helps us
            * keep track of where we are in the views array.
            * In the case the LContainer is created for a ViewContainerRef,
            * it is set to null to identify this scenario, as indices are "absolute" in that case,
            * i.e. provided directly by the user of the ViewContainerRef API.
            */
        [ACTIVE_INDEX]: number;
        /**
            * A list of the container's currently active child views. Views will be inserted
            * here as they are added and spliced from here when they are removed. We need
            * to keep a record of current views so we know which views are already in the DOM
            * (and don't need to be re-added) and so we can remove views from the DOM when they
            * are no longer required.
            */
        [VIEWS]: LViewData[];
        /**
            * Access to the parent view is necessary so we can propagate back
            * up from inside a container to parent[NEXT].
            */
        [PARENT]: LViewData | null;
        /**
            * This allows us to jump from a container to a sibling container or component
            * view with the same parent, so we can remove listeners efficiently.
            */
        [NEXT]: LViewData | LContainer | null;
        /**
            * Queries active for this container - all the views inserted to / removed from
            * this container are reported to queries referenced here.
            */
        [QUERIES]: LQueries | null;
        /**
            * The host element of this LContainer.
            *
            * The host could be an LViewData if this container is on a component node.
            * In that case, the component LViewData is its HOST.
            *
            * It could also be a styling context if this is a node with a style/class
            * binding.
            */
        [HOST]: RElement | RComment | StylingContext | LViewData;
        /** The comment element that serves as an anchor for this LContainer. */
        [NATIVE]: RComment;
        /**
            * Parent Element which will contain the location where all of the views will be
            * inserted into to.
            *
            * If `renderParent` is `null` it is headless. This means that it is contained
            * in another view which in turn is contained in another container and
            * therefore it does not yet have its own parent.
            *
            * If `renderParent` is not `null` then it may be:
            * - same as `tContainerNode.parent` in which case it is just a normal container.
            * - different from `tContainerNode.parent` in which case it has been re-projected.
            *   In other words `tContainerNode.parent` is logical parent where as
            *   `tContainerNode.projectedParent` is render parent.
            *
            * When views are inserted into `LContainer` then `renderParent` is:
            * - `null`, we are in a view, keep going up a hierarchy until actual
            *   `renderParent` is found.
            * - not `null`, then use the `projectedParent.native` as the `RElement` to insert
            * views into.
            */
        [RENDER_PARENT]: RElement | null;
}
export declare const unusedValueExportToPlacateAjd = 1;

/**
    * @license
    * Copyright Google Inc. All Rights Reserved.
    *
    * Use of this source code is governed by an MIT-style license that can be
    * found in the LICENSE file at https://angular.io/license
    */
import { QueryList } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/linker';
import { Type } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/type';
import { TContainerNode, TElementContainerNode, TElementNode } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/render3/interfaces/node';
/** Used for tracking queries (e.g. ViewChild, ContentChild). */
export interface LQueries {
        /**
            * The parent LQueries instance.
            *
            * When there is a content query, a new LQueries instance is created to avoid mutating any
            * existing LQueries. After we are done searching content children, the parent property allows
            * us to traverse back up to the original LQueries instance to continue to search for matches
            * in the main view.
            */
        parent: LQueries | null;
        /**
            * Ask queries to prepare copy of itself. This assures that tracking new queries on content nodes
            * doesn't mutate list of queries tracked on a parent node. We will clone LQueries before
            * constructing content queries.
            */
        clone(): LQueries;
        /**
            * Notify `LQueries` that a new `TNode` has been created and needs to be added to query results
            * if matching query predicate.
            */
        addNode(tNode: TElementNode | TContainerNode | TElementContainerNode): LQueries | null;
        /**
            * Notify `LQueries` that a new LContainer was added to ivy data structures. As a result we need
            * to prepare room for views that might be inserted into this container.
            */
        container(): LQueries | null;
        /**
            * Notify `LQueries` that a new `LView` has been created. As a result we need to prepare room
            * and collect nodes that match query predicate.
            */
        createView(): LQueries | null;
        /**
            * Notify `LQueries` that a new `LView` has been added to `LContainer`. As a result all
            * the matching nodes from this view should be added to container's queries.
            */
        insertView(newViewIndex: number): void;
        /**
            * Notify `LQueries` that an `LView` has been removed from `LContainer`. As a result all
            * the matching nodes from this view should be removed from container's queries.
            */
        removeView(): void;
        /**
            * Add additional `QueryList` to track.
            *
            * @param queryList `QueryList` to update with changes.
            * @param predicate Either `Type` or selector array of [key, value] predicates.
            * @param descend If true the query will recursively apply to the children.
            * @param read Indicates which token should be read from DI for this query.
            */
        track<T>(queryList: QueryList<T>, predicate: Type<any> | string[], descend?: boolean, read?: Type<T>): void;
}
export declare const unusedValueExportToPlacateAjd = 1;

/**
    * Function used to sanitize the value before writing it into the renderer.
    */
export declare type SanitizerFn = (value: any) => string;

/**
    * @license
    * Copyright Google Inc. All Rights Reserved.
    *
    * Use of this source code is governed by an MIT-style license that can be
    * found in the LICENSE file at https://angular.io/license
    */
import { StyleSanitizeFn } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/sanitization/style_sanitizer';
import { RElement } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/render3/interfaces/renderer';
import { PlayerContext } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/render3/interfaces/player';
/**
    * The styling context acts as a styling manifest (shaped as an array) for determining which
    * styling properties have been assigned via the provided `updateStylingMap`, `updateStyleProp`
    * and `updateClassProp` functions. There are also two initialization functions
    * `allocStylingContext` and `createStylingContextTemplate` which are used to initialize
    * and/or clone the context.
    *
    * The context is an array where the first two cells are used for static data (initial styling)
    * and dirty flags / index offsets). The remaining set of cells is used for multi (map) and single
    * (prop) style values.
    *
    * each value from here onwards is mapped as so:
    * [i] = mutation/type flag for the style/class value
    * [i + 1] = prop string (or null incase it has been removed)
    * [i + 2] = value string (or null incase it has been removed)
    *
    * There are three types of styling types stored in this context:
    *   initial: any styles that are passed in once the context is created
    *            (these are stored in the first cell of the array and the first
    *             value of this array is always `null` even if no initial styling exists.
    *             the `null` value is there so that any new styles have a parent to point
    *             to. This way we can always assume that there is a parent.)
    *
    *   single: any styles that are updated using `updateStyleProp` or `updateClassProp` (fixed set)
    *
    *   multi: any styles that are updated using `updateStylingMap` (dynamic set)
    *
    * Note that context is only used to collect style information. Only when `renderStyling`
    * is called is when the styling payload will be rendered (or built as a key/value map).
    *
    * When the context is created, depending on what initial styling values are passed in, the
    * context itself will be pre-filled with slots based on the initial style properties. Say
    * for example we have a series of initial styles that look like so:
    *
    *   style="width:100px; height:200px;"
    *   class="foo"
    *
    * Then the initial state of the context (once initialized) will look like so:
    *
    * ```
    * context = [
    *   element,
    *   playerContext | null,
    *   styleSanitizer | null,
    *   [null, '100px', '200px', true],  // property names are not needed since they have already been
    * written to DOM.
    *
    *   configMasterVal,
    *   1, // this instructs how many `style` values there are so that class index values can be
    * offsetted
    *   { classOne: true, classTwo: false } | 'classOne classTwo' | null // last class value provided
    * into updateStylingMap
    *   { styleOne: '100px', styleTwo: 0 } | null // last style value provided into updateStylingMap
    *
    *   // 8
    *   'width',
    *   pointers(1, 15);  // Point to static `width`: `100px` and multi `width`.
    *   null,
    *
    *   // 11
    *   'height',
    *   pointers(2, 18); // Point to static `height`: `200px` and multi `height`.
    *   null,
    *
    *   // 14
    *   'foo',
    *   pointers(1, 21);  // Point to static `foo`: `true` and multi `foo`.
    *   null,
    *
    *   // 17
    *   'width',
    *   pointers(1, 6);  // Point to static `width`: `100px` and single `width`.
    *   null,
    *
    *   // 21
    *   'height',
    *   pointers(2, 9);  // Point to static `height`: `200px` and single `height`.
    *   null,
    *
    *   // 24
    *   'foo',
    *   pointers(3, 12);  // Point to static `foo`: `true` and single `foo`.
    *   null,
    * ]
    *
    * function pointers(staticIndex: number, dynamicIndex: number) {
    *   // combine the two indices into a single word.
    *   return (staticIndex << StylingFlags.BitCountSize) |
    *     (dynamicIndex << (StylingIndex.BitCountSize + StylingFlags.BitCountSize));
    * }
    * ```
    *
    * The values are duplicated so that space is set aside for both multi ([style] and [class])
    * and single ([style.prop] or [class.named]) values. The respective config values
    * (configValA, configValB, etc...) are a combination of the StylingFlags with two index
    * values: the `initialIndex` (which points to the index location of the style value in
    * the initial styles array in slot 0) and the `dynamicIndex` (which points to the
    * matching single/multi index position in the context array for the same prop).
    *
    * This means that every time `updateStyleProp` or `updateClassProp` are called then they
    * must be called using an index value (not a property string) which references the index
    * value of the initial style prop/class when the context was created. This also means that
    * `updateStyleProp` or `updateClassProp` cannot be called with a new property (only
    * `updateStylingMap` can include new CSS properties that will be added to the context).
    */
export interface StylingContext extends Array<InitialStyles | {
        [key: string]: any;
} | number | string | boolean | RElement | StyleSanitizeFn | PlayerContext | null> {
        /**
            * Location of animation context (which contains the active players) for this element styling
            * context.
            */
        [StylingIndex.PlayerContext]: PlayerContext | null;
        /**
            * The style sanitizer that is used within this context
            */
        [StylingIndex.StyleSanitizerPosition]: StyleSanitizeFn | null;
        /**
            * Location of initial data shared by all instances of this style.
            */
        [StylingIndex.InitialStylesPosition]: InitialStyles;
        /**
            * A numeric value representing the configuration status (whether the context is dirty or not)
            * mixed together (using bit shifting) with a index value which tells the starting index value
            * of where the multi style entries begin.
            */
        [StylingIndex.MasterFlagPosition]: number;
        /**
            * A numeric value representing the class index offset value. Whenever a single class is
            * applied (using `elementClassProp`) it should have an styling index value that doesn't
            * need to take into account any style values that exist in the context.
            */
        [StylingIndex.ClassOffsetPosition]: number;
        /**
            * Location of element that is used as a target for this context.
            */
        [StylingIndex.ElementPosition]: RElement | null;
        /**
            * The last class value that was interpreted by elementStylingMap. This is cached
            * So that the algorithm can exit early incase the value has not changed.
            */
        [StylingIndex.PreviousOrCachedMultiClassValue]: {
                [key: string]: any;
        } | string | null;
        /**
            * The last style value that was interpreted by elementStylingMap. This is cached
            * So that the algorithm can exit early incase the value has not changed.
            */
        [StylingIndex.PreviousMultiStyleValue]: {
                [key: string]: any;
        } | null;
}
/**
    * The initial styles is populated whether or not there are any initial styles passed into
    * the context during allocation. The 0th value must be null so that index values of `0` within
    * the context flags can always point to a null value safely when nothing is set.
    *
    * All other entries in this array are of `string` value and correspond to the values that
    * were extracted from the `style=""` attribute in the HTML code for the provided template.
    */
export interface InitialStyles extends Array<string | null | boolean> {
        [0]: null;
}
/**
    * Used to set the context to be dirty or not both on the master flag (position 1)
    * or for each single/multi property that exists in the context.
    */
export declare const enum StylingFlags {
        None = 0,
        Dirty = 1,
        Class = 2,
        Sanitize = 4,
        PlayerBuildersDirty = 8,
        OnlyProcessSingleClasses = 16,
        BitCountSize = 5,
        BitMask = 31
}
/** Used as numeric pointer values to determine what cells to update in the `StylingContext` */
export declare const enum StylingIndex {
        PlayerContext = 0,
        StyleSanitizerPosition = 1,
        InitialStylesPosition = 2,
        MasterFlagPosition = 3,
        ClassOffsetPosition = 4,
        ElementPosition = 5,
        PreviousOrCachedMultiClassValue = 6,
        PreviousMultiStyleValue = 7,
        SingleStylesStartPosition = 8,
        FlagsOffset = 0,
        PropertyOffset = 1,
        ValueOffset = 2,
        PlayerBuilderIndexOffset = 3,
        Size = 4,
        BitCountSize = 14,
        BitMask = 16383
}

/**
    * `I18nMutateOpCode` defines OpCodes for `I18nMutateOpCodes` array.
    *
    * OpCodes contain three parts:
    *  1) Parent node index offset.
    *  2) Reference node index offset.
    *  3) The OpCode to execute.
    *
    * See: `I18nCreateOpCodes` for example of usage.
    */
import { SanitizerFn } from '@angular/core/--/--/--/--/--/node_modules/@angular/core/src/render3/interfaces/sanitization';
export declare const enum I18nMutateOpCode {
        SHIFT_REF = 3,
        SHIFT_PARENT = 17,
        MASK_OPCODE = 7,
        MASK_REF = 136,
        Select = 0,
        AppendChild = 1,
        InsertBefore = 2,
        Remove = 3,
        Attr = 4,
        ElementEnd = 5,
        RemoveNestedIcu = 6
}
/**
    * Marks that the next string is for element.
    *
    * See `I18nMutateOpCodes` documentation.
    */
export declare const ELEMENT_MARKER: ELEMENT_MARKER;
export interface ELEMENT_MARKER {
        marker: 'element';
}
/**
    * Marks that the next string is for comment.
    *
    * See `I18nMutateOpCodes` documentation.
    */
export declare const COMMENT_MARKER: COMMENT_MARKER;
export interface COMMENT_MARKER {
        marker: 'comment';
}
/**
    * Array storing OpCode for dynamically creating `i18n` blocks.
    *
    * Example:
    * ```
    * <I18nCreateOpCode>[
    *   // For adding text nodes
    *   // ---------------------
    *   // Equivalent to:
    *   //   const node = lViewData[index++] = document.createTextNode('abc');
    *   //   lViewData[1].insertBefore(node, lViewData[2]);
    *   'abc', 1 << SHIFT_PARENT | 2 << SHIFT_REF | InsertBefore,
    *
    *   // Equivalent to:
    *   //   const node = lViewData[index++] = document.createTextNode('xyz');
    *   //   lViewData[1].appendChild(node);
    *   'xyz', 1 << SHIFT_PARENT | AppendChild,
    *
    *   // For adding element nodes
    *   // ---------------------
    *   // Equivalent to:
    *   //   const node = lViewData[index++] = document.createElement('div');
    *   //   lViewData[1].insertBefore(node, lViewData[2]);
    *   ELEMENT_MARKER, 'div', 1 << SHIFT_PARENT | 2 << SHIFT_REF | InsertBefore,
    *
    *   // Equivalent to:
    *   //   const node = lViewData[index++] = document.createElement('div');
    *   //   lViewData[1].appendChild(node);
    *   ELEMENT_MARKER, 'div', 1 << SHIFT_PARENT | AppendChild,
    *
    *   // For adding comment nodes
    *   // ---------------------
    *   // Equivalent to:
    *   //   const node = lViewData[index++] = document.createComment('');
    *   //   lViewData[1].insertBefore(node, lViewData[2]);
    *   COMMENT_MARKER, '', 1 << SHIFT_PARENT | 2 << SHIFT_REF | InsertBefore,
    *
    *   // Equivalent to:
    *   //   const node = lViewData[index++] = document.createComment('');
    *   //   lViewData[1].appendChild(node);
    *   COMMENT_MARKER, '', 1 << SHIFT_PARENT | AppendChild,
    *
    *   // For moving existing nodes to a different location
    *   // --------------------------------------------------
    *   // Equivalent to:
    *   //   const node = lViewData[1];
    *   //   lViewData[2].insertBefore(node, lViewData[3]);
    *   1 << SHIFT_REF | Select, 2 << SHIFT_PARENT | 3 << SHIFT_REF | InsertBefore,
    *
    *   // Equivalent to:
    *   //   const node = lViewData[1];
    *   //   lViewData[2].appendChild(node);
    *   1 << SHIFT_REF | Select, 2 << SHIFT_PARENT | AppendChild,
    *
    *   // For removing existing nodes
    *   // --------------------------------------------------
    *   //   const node = lViewData[1];
    *   //   removeChild(tView.data(1), node, lViewData);
    *   1 << SHIFT_REF | Remove,
    *
    *   // For writing attributes
    *   // --------------------------------------------------
    *   //   const node = lViewData[1];
    *   //   node.setAttribute('attr', 'value');
    *   1 << SHIFT_REF | Select, 'attr', 'value'
    *            // NOTE: Select followed by two string (vs select followed by OpCode)
    * ];
    * ```
    * NOTE:
    *   - `index` is initial location where the extra nodes should be stored in the EXPANDO section of
    * `LVIewData`.
    *
    * See: `applyI18nCreateOpCodes`;
    */
export interface I18nMutateOpCodes extends Array<number | string | ELEMENT_MARKER | COMMENT_MARKER | null> {
}
export declare const enum I18nUpdateOpCode {
        SHIFT_REF = 2,
        SHIFT_ICU = 17,
        MASK_OPCODE = 3,
        MASK_REF = 68,
        Text = 0,
        Attr = 1,
        IcuSwitch = 2,
        IcuUpdate = 3
}
/**
    * Stores DOM operations which need to be applied to update DOM render tree due to changes in
    * expressions.
    *
    * The basic idea is that `i18nExp` OpCodes capture expression changes and update a change
    * mask bit. (Bit 1 for expression 1, bit 2 for expression 2 etc..., bit 32 for expression 32 and
    * higher.) The OpCodes then compare its own change mask against the expression change mask to
    * determine if the OpCodes should execute.
    *
    * These OpCodes can be used by both the i18n block as well as ICU sub-block.
    *
    * ## Example
    *
    * Assume
    * ```
    *   if (rf & RenderFlags.Update) {
    *    i18nExp(bind(ctx.exp1)); // If changed set mask bit 1
    *    i18nExp(bind(ctx.exp2)); // If changed set mask bit 2
    *    i18nExp(bind(ctx.exp3)); // If changed set mask bit 3
    *    i18nExp(bind(ctx.exp4)); // If changed set mask bit 4
    *    i18nApply(0);            // Apply all changes by executing the OpCodes.
    *  }
    * ```
    * We can assume that each call to `i18nExp` sets an internal `changeMask` bit depending on the
    * index of `i18nExp`.
    *
    * OpCodes
    * ```
    * <I18nUpdateOpCodes>[
    *   // The following OpCodes represent: `<div i18n-title="pre{{exp1}}in{{exp2}}post">`
    *   // If `changeMask & 0b11`
    *   //        has changed then execute update OpCodes.
    *   //        has NOT changed then skip `7` values and start processing next OpCodes.
    *   0b11, 7,
    *   // Concatenate `newValue = 'pre'+lViewData[bindIndex-4]+'in'+lViewData[bindIndex-3]+'post';`.
    *   'pre', -4, 'in', -3, 'post',
    *   // Update attribute: `elementAttribute(1, 'title', sanitizerFn(newValue));`
    *   1 << SHIFT_REF | Attr, 'title', sanitizerFn,
    *
    *   // The following OpCodes represent: `<div i18n>Hello {{exp3}}!">`
    *   // If `changeMask & 0b100`
    *   //        has changed then execute update OpCodes.
    *   //        has NOT changed then skip `4` values and start processing next OpCodes.
    *   0b100, 4,
    *   // Concatenate `newValue = 'Hello ' + lViewData[bindIndex -2] + '!';`.
    *   'Hello ', -2, '!',
    *   // Update text: `lViewData[1].textContent = newValue;`
    *   1 << SHIFT_REF | Text,
    *
    *   // The following OpCodes represent: `<div i18n>{exp4, plural, ... }">`
    *   // If `changeMask & 0b1000`
    *   //        has changed then execute update OpCodes.
    *   //        has NOT changed then skip `4` values and start processing next OpCodes.
    *   0b1000, 4,
    *   // Concatenate `newValue = lViewData[bindIndex -1];`.
    *   -1,
    *   // Switch ICU: `icuSwitchCase(lViewData[1], 0, newValue);`
    *   0 << SHIFT_ICU | 1 << SHIFT_REF | IcuSwitch,
    *
    *   // Note `changeMask & -1` is always true, so the IcuUpdate will always execute.
    *   -1, 1,
    *   // Update ICU: `icuUpdateCase(lViewData[1], 0);`
    *   0 << SHIFT_ICU | 1 << SHIFT_REF | IcuUpdate,
    *
    * ];
    * ```
    *
    */
export interface I18nUpdateOpCodes extends Array<string | number | SanitizerFn | null> {
}
/**
    * Store information for the i18n translation block.
    */
export interface TI18n {
        /**
            * Number of slots to allocate in expando.
            *
            * This is the max number of DOM elements which will be created by this i18n + ICU blocks. When
            * the DOM elements are being created they are stored in the EXPANDO, so that update OpCodes can
            * write into them.
            */
        vars: number;
        /**
            * Index in EXPANDO where the i18n stores its DOM nodes.
            *
            * When the bindings are processed by the `i18nEnd` instruction it is necessary to know where the
            * newly created DOM nodes will be inserted.
            */
        expandoStartIndex: number;
        /**
            * A set of OpCodes which will create the Text Nodes and ICU anchors for the translation blocks.
            *
            * NOTE: The ICU anchors are filled in with ICU Update OpCode.
            */
        create: I18nMutateOpCodes;
        /**
            * A set of OpCodes which will be executed on each change detection to determine if any changes to
            * DOM are required.
            */
        update: I18nUpdateOpCodes;
        /**
            * A list of ICUs in a translation block (or `null` if block has no ICUs).
            *
            * Example:
            * Given: `<div i18n>You have {count, plural, ...} and {state, switch, ...}</div>`
            * There would be 2 ICUs in this array.
            *   1. `{count, plural, ...}`
            *   2. `{state, switch, ...}`
            */
        icus: TIcu[] | null;
}
/**
    * Defines the ICU type of `select` or `plural`
    */
export declare const enum IcuType {
        select = 0,
        plural = 1
}
export interface TIcu {
        /**
            * Defines the ICU type of `select` or `plural`
            */
        type: IcuType;
        /**
            * Number of slots to allocate in expando for each case.
            *
            * This is the max number of DOM elements which will be created by this i18n + ICU blocks. When
            * the DOM elements are being created they are stored in the EXPANDO, so that update OpCodes can
            * write into them.
            */
        vars: number[];
        /**
            * An optional array of child/sub ICUs.
            *
            * In case of nested ICUs such as:
            * ```
            * {�0�, plural,
            *   =0 {zero}
            *   other {�0� {�1�, select,
            *                     cat {cats}
            *                     dog {dogs}
            *                     other {animals}
            *                   }!
            *   }
            * }
            * ```
            * When the parent ICU is changing it must clean up child ICUs as well. For this reason it needs
            * to know which child ICUs to run clean up for as well.
            *
            * In the above example this would be:
            * ```
            * [
            *   [],   // `=0` has no sub ICUs
            *   [1],  // `other` has one subICU at `1`st index.
            * ]
            * ```
            *
            * The reason why it is Array of Arrays is because first array represents the case, and second
            * represents the child ICUs to clean up. There may be more than one child ICUs per case.
            */
        childIcus: number[][];
        /**
            * Index in EXPANDO where the i18n stores its DOM nodes.
            *
            * When the bindings are processed by the `i18nEnd` instruction it is necessary to know where the
            * newly created DOM nodes will be inserted.
            */
        expandoStartIndex: number;
        /**
            * A list of case values which the current ICU will try to match.
            *
            * The last value is `other`
            */
        cases: any[];
        /**
            * A set of OpCodes to apply in order to build up the DOM render tree for the ICU
            */
        create: I18nMutateOpCodes[];
        /**
            * A set of OpCodes to apply in order to destroy the DOM render tree for the ICU.
            */
        remove: I18nMutateOpCodes[];
        /**
            * A set of OpCodes to apply in order to update the DOM render tree for the ICU bindings.
            */
        update: I18nUpdateOpCodes[];
}
export declare const unusedValueExportToPlacateAjd = 1;


}
