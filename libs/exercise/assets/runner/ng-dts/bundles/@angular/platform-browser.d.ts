declare module '@angular/platform-browser' {
// Generated by dts-bundle v0.7.3
// Dependencies for this module:
//   @angular/core
//   @angular/common

/**
  * @license
  * Copyright Google Inc. All Rights Reserved.
  *
  * Use of this source code is governed by an MIT-style license that can be
  * found in the LICENSE file at https://angular.io/license
  */
export * from '@angular/platform-browser/--/--/--/--/--/node_modules/@angular/platform-browser/public_api';

/**
    * @module
    * @description
    * Entry point for all public APIs of this package.
    */
export * from '@angular/platform-browser/--/--/--/--/--/node_modules/@angular/platform-browser/src/platform-browser';

/**
  * @license
  * Copyright Google Inc. All Rights Reserved.
  *
  * Use of this source code is governed by an MIT-style license that can be
  * found in the LICENSE file at https://angular.io/license
  */
export { BrowserModule, platformBrowser } from '@angular/platform-browser/--/--/--/--/--/node_modules/@angular/platform-browser/src/browser';
export { Meta, MetaDefinition } from '@angular/platform-browser/--/--/--/--/--/node_modules/@angular/platform-browser/src/browser/meta';
export { Title } from '@angular/platform-browser/--/--/--/--/--/node_modules/@angular/platform-browser/src/browser/title';
export { disableDebugTools, enableDebugTools } from '@angular/platform-browser/--/--/--/--/--/node_modules/@angular/platform-browser/src/browser/tools/tools';
export { BrowserTransferStateModule, StateKey, TransferState, makeStateKey } from '@angular/platform-browser/--/--/--/--/--/node_modules/@angular/platform-browser/src/browser/transfer_state';
export { By } from '@angular/platform-browser/--/--/--/--/--/node_modules/@angular/platform-browser/src/dom/debug/by';
export { DOCUMENT } from '@angular/platform-browser/--/--/--/--/--/node_modules/@angular/platform-browser/src/dom/dom_tokens';
export { EVENT_MANAGER_PLUGINS, EventManager } from '@angular/platform-browser/--/--/--/--/--/node_modules/@angular/platform-browser/src/dom/events/event_manager';
export { HAMMER_GESTURE_CONFIG, HAMMER_LOADER, HammerGestureConfig, HammerLoader } from '@angular/platform-browser/--/--/--/--/--/node_modules/@angular/platform-browser/src/dom/events/hammer_gestures';
export { DomSanitizer, SafeHtml, SafeResourceUrl, SafeScript, SafeStyle, SafeUrl, SafeValue } from '@angular/platform-browser/--/--/--/--/--/node_modules/@angular/platform-browser/src/security/dom_sanitization_service';
export * from '@angular/platform-browser/--/--/--/--/--/node_modules/@angular/platform-browser/src/private_export';
export { VERSION } from '@angular/platform-browser/--/--/--/--/--/node_modules/@angular/platform-browser/src/version';

/**
    * @license
    * Copyright Google Inc. All Rights Reserved.
    *
    * Use of this source code is governed by an MIT-style license that can be
    * found in the LICENSE file at https://angular.io/license
    */
import { ErrorHandler, ModuleWithProviders, PlatformRef, StaticProvider } from '@angular/core';
export declare const INTERNAL_BROWSER_PLATFORM_PROVIDERS: StaticProvider[];
/**
    * @security Replacing built-in sanitization providers exposes the application to XSS risks.
    * Attacker-controlled data introduced by an unsanitized provider could expose your
    * application to XSS risks. For more detail, see the [Security Guide](http://g.co/ng/security).
    * @publicApi
    */
export declare const BROWSER_SANITIZATION_PROVIDERS: StaticProvider[];
/**
    * @publicApi
    */
export declare const platformBrowser: (extraProviders?: StaticProvider[]) => PlatformRef;
export declare function initDomAdapter(): void;
export declare function errorHandler(): ErrorHandler;
export declare function _document(): any;
export declare const BROWSER_MODULE_PROVIDERS: StaticProvider[];
/**
    * Exports required infrastructure for all Angular apps.
    * Included by defaults in all Angular apps created with the CLI
    * `new` command.
    * Re-exports `CommonModule` and `ApplicationModule`, making their
    * exports and providers available to all apps.
    *
    * @publicApi
    */
export declare class BrowserModule {
        constructor(parentModule: BrowserModule | null);
        /**
            * Configures a browser-based app to transition from a server-rendered app, if
            * one is present on the page.
            *
            * @param params An object containing an identifier for the app to transition.
            * The ID must match between the client and server versions of the app.
            * @returns The reconfigured `BrowserModule` to import into the app's root `AppModule`.
            */
        static withServerTransition(params: {
                appId: string;
        }): ModuleWithProviders<BrowserModule>;
}

/**
    * Represents a meta element.
    *
    * @publicApi
    */
export declare type MetaDefinition = {
        charset?: string;
        content?: string;
        httpEquiv?: string;
        id?: string;
        itemprop?: string;
        name?: string;
        property?: string;
        scheme?: string;
        url?: string;
} & {
        [prop: string]: string;
};
/**
    * Factory to create Meta service.
    */
export declare function createMeta(): Meta;
/**
    * A service that can be used to get and add meta tags.
    *
    * @publicApi
    */
export declare class Meta {
        constructor(_doc: any);
        addTag(tag: MetaDefinition, forceCreation?: boolean): HTMLMetaElement | null;
        addTags(tags: MetaDefinition[], forceCreation?: boolean): HTMLMetaElement[];
        getTag(attrSelector: string): HTMLMetaElement | null;
        getTags(attrSelector: string): HTMLMetaElement[];
        updateTag(tag: MetaDefinition, selector?: string): HTMLMetaElement | null;
        removeTag(attrSelector: string): void;
        removeTagElement(meta: HTMLMetaElement): void;
}

/**
    * Factory to create Title service.
    */
export declare function createTitle(): Title;
/**
    * A service that can be used to get and set the title of a current HTML document.
    *
    * Since an Angular application can't be bootstrapped on the entire HTML document (`<html>` tag)
    * it is not possible to bind to the `text` property of the `HTMLTitleElement` elements
    * (representing the `<title>` tag). Instead, this service can be used to set and get the current
    * title value.
    *
    * @publicApi
    */
export declare class Title {
        constructor(_doc: any);
        /**
            * Get the title of the current HTML document.
            */
        getTitle(): string;
        /**
            * Set the title of the current HTML document.
            * @param newTitle
            */
        setTitle(newTitle: string): void;
}

/**
    * @license
    * Copyright Google Inc. All Rights Reserved.
    *
    * Use of this source code is governed by an MIT-style license that can be
    * found in the LICENSE file at https://angular.io/license
    */
import { ComponentRef } from '@angular/core';
/**
    * Enabled Angular debug tools that are accessible via your browser's
    * developer console.
    *
    * Usage:
    *
    * 1. Open developer console (e.g. in Chrome Ctrl + Shift + j)
    * 1. Type `ng.` (usually the console will show auto-complete suggestion)
    * 1. Try the change detection profiler `ng.profiler.timeChangeDetection()`
    *    then hit Enter.
    *
    * @publicApi
    */
export declare function enableDebugTools<T>(ref: ComponentRef<T>): ComponentRef<T>;
/**
    * Disables Angular tools.
    *
    * @publicApi
    */
export declare function disableDebugTools(): void;

/**
    * @license
    * Copyright Google Inc. All Rights Reserved.
    *
    * Use of this source code is governed by an MIT-style license that can be
    * found in the LICENSE file at https://angular.io/license
    */
export declare function escapeHtml(text: string): string;
export declare function unescapeHtml(text: string): string;
/**
    * A type-safe key to use with `TransferState`.
    *
    * Example:
    *
    * ```
    * const COUNTER_KEY = makeStateKey<number>('counter');
    * let value = 10;
    *
    * transferState.set(COUNTER_KEY, value);
    * ```
    *
    * @publicApi
    */
export declare type StateKey<T> = string & {
        __not_a_string: never;
};
/**
    * Create a `StateKey<T>` that can be used to store value of type T with `TransferState`.
    *
    * Example:
    *
    * ```
    * const COUNTER_KEY = makeStateKey<number>('counter');
    * let value = 10;
    *
    * transferState.set(COUNTER_KEY, value);
    * ```
    *
    * @publicApi
    */
export declare function makeStateKey<T = void>(key: string): StateKey<T>;
/**
    * A key value store that is transferred from the application on the server side to the application
    * on the client side.
    *
    * `TransferState` will be available as an injectable token. To use it import
    * `ServerTransferStateModule` on the server and `BrowserTransferStateModule` on the client.
    *
    * The values in the store are serialized/deserialized using JSON.stringify/JSON.parse. So only
    * boolean, number, string, null and non-class objects will be serialized and deserialzied in a
    * non-lossy manner.
    *
    * @publicApi
    */
export declare class TransferState {
        /**
            * Get the value corresponding to a key. Return `defaultValue` if key is not found.
            */
        get<T>(key: StateKey<T>, defaultValue: T): T;
        /**
            * Set the value corresponding to a key.
            */
        set<T>(key: StateKey<T>, value: T): void;
        /**
            * Remove a key from the store.
            */
        remove<T>(key: StateKey<T>): void;
        /**
            * Test whether a key exists in the store.
            */
        hasKey<T>(key: StateKey<T>): boolean;
        /**
            * Register a callback to provide the value for a key when `toJson` is called.
            */
        onSerialize<T>(key: StateKey<T>, callback: () => T): void;
        /**
            * Serialize the current state of the store to JSON.
            */
        toJson(): string;
}
export declare function initTransferState(doc: Document, appId: string): TransferState;
/**
    * NgModule to install on the client side while using the `TransferState` to transfer state from
    * server to client.
    *
    * @publicApi
    */
export declare class BrowserTransferStateModule {
}

/**
    * @license
    * Copyright Google Inc. All Rights Reserved.
    *
    * Use of this source code is governed by an MIT-style license that can be
    * found in the LICENSE file at https://angular.io/license
    */
import { DebugElement, Predicate, Type } from '@angular/core';
/**
    * Predicates for use with {@link DebugElement}'s query functions.
    *
    * @publicApi
    */
export declare class By {
        /**
            * Match all elements.
            *
            * @usageNotes
            * ### Example
            *
            * {@example platform-browser/dom/debug/ts/by/by.ts region='by_all'}
            */
        static all(): Predicate<DebugElement>;
        /**
            * Match elements by the given CSS selector.
            *
            * @usageNotes
            * ### Example
            *
            * {@example platform-browser/dom/debug/ts/by/by.ts region='by_css'}
            */
        static css(selector: string): Predicate<DebugElement>;
        /**
            * Match elements that have the given directive present.
            *
            * @usageNotes
            * ### Example
            *
            * {@example platform-browser/dom/debug/ts/by/by.ts region='by_directive'}
            */
        static directive(type: Type<any>): Predicate<DebugElement>;
}

/**
    * @license
    * Copyright Google Inc. All Rights Reserved.
    *
    * Use of this source code is governed by an MIT-style license that can be
    * found in the LICENSE file at https://angular.io/license
    */
import { InjectionToken } from '@angular/core';
/**
    * A DI Token representing the main rendering context. In a browser this is the DOM Document.
    *
    * Note: Document might not be available in the Application Context when Application and Rendering
    * Contexts are not the same (e.g. when running the application into a Web Worker).
    *
    * @deprecated import from `@angular/common` instead.
    * @publicApi
    */
export declare const DOCUMENT: InjectionToken<Document>;

/**
    * @license
    * Copyright Google Inc. All Rights Reserved.
    *
    * Use of this source code is governed by an MIT-style license that can be
    * found in the LICENSE file at https://angular.io/license
    */
import { InjectionToken, NgZone } from '@angular/core';
/**
    * The injection token for the event-manager plug-in service.
    *
    * @publicApi
    */
export declare const EVENT_MANAGER_PLUGINS: InjectionToken<EventManagerPlugin[]>;
/**
    * An injectable service that provides event management for Angular
    * through a browser plug-in.
    *
    * @publicApi
    */
export declare class EventManager {
        /**
            * Initializes an instance of the event-manager service.
            */
        constructor(plugins: EventManagerPlugin[], _zone: NgZone);
        /**
            * Registers a handler for a specific element and event.
            *
            * @param element The HTML element to receive event notifications.
            * @param eventName The name of the event to listen for.
            * @param handler A function to call when the notification occurs. Receives the
            * event object as an argument.
            * @returns  A callback function that can be used to remove the handler.
            */
        addEventListener(element: HTMLElement, eventName: string, handler: Function): Function;
        /**
            * Registers a global handler for an event in a target view.
            *
            * @param target A target for global event notifications. One of "window", "document", or "body".
            * @param eventName The name of the event to listen for.
            * @param handler A function to call when the notification occurs. Receives the
            * event object as an argument.
            * @returns A callback function that can be used to remove the handler.
            */
        addGlobalEventListener(target: string, eventName: string, handler: Function): Function;
        /**
            * Retrieves the compilation zone in which event listeners are registered.
            */
        getZone(): NgZone;
}
export declare abstract class EventManagerPlugin {
        constructor(_doc: any);
        manager: EventManager;
        abstract supports(eventName: string): boolean;
        abstract addEventListener(element: HTMLElement, eventName: string, handler: Function): Function;
        addGlobalEventListener(element: string, eventName: string, handler: Function): Function;
}

/**
    * @license
    * Copyright Google Inc. All Rights Reserved.
    *
    * Use of this source code is governed by an MIT-style license that can be
    * found in the LICENSE file at https://angular.io/license
    */
import { InjectionToken, ɵConsole as Console } from '@angular/core';
import { EventManagerPlugin } from '@angular/platform-browser/--/--/--/--/--/node_modules/@angular/platform-browser/src/dom/events/event_manager';
/**
    * DI token for providing [HammerJS](http://hammerjs.github.io/) support to Angular.
    * @see `HammerGestureConfig`
    *
    * @publicApi
    */
export declare const HAMMER_GESTURE_CONFIG: InjectionToken<HammerGestureConfig>;
/**
    * Function that loads HammerJS, returning a promise that is resolved once HammerJs is loaded.
    *
    * @publicApi
    */
export declare type HammerLoader = () => Promise<void>;
/**
    * Injection token used to provide a {@link HammerLoader} to Angular.
    *
    * @publicApi
    */
export declare const HAMMER_LOADER: InjectionToken<HammerLoader>;
export interface HammerInstance {
        on(eventName: string, callback?: Function): void;
        off(eventName: string, callback?: Function): void;
        destroy?(): void;
}
/**
    * An injectable [HammerJS Manager](http://hammerjs.github.io/api/#hammer.manager)
    * for gesture recognition. Configures specific event recognition.
    * @publicApi
    */
export declare class HammerGestureConfig {
        /**
            * A set of supported event names for gestures to be used in Angular.
            * Angular supports all built-in recognizers, as listed in
            * [HammerJS documentation](http://hammerjs.github.io/).
            */
        events: string[];
        /**
         * Maps gesture event names to a set of configuration options
         * that specify overrides to the default values for specific properties.
         *
         * The key is a supported event name to be configured,
         * and the options object contains a set of properties, with override values
         * to be applied to the named recognizer event.
         * For example, to disable recognition of the rotate event, specify
         *  `{"rotate": {"enable": false}}`.
         *
         * Properties that are not present take the HammerJS default values.
         * For information about which properties are supported for which events,
         * and their allowed and default values, see
         * [HammerJS documentation](http://hammerjs.github.io/).
         *
         */
        overrides: {
                [key: string]: Object;
        };
        /**
            * Properties whose default values can be overridden for a given event.
            * Different sets of properties apply to different events.
            * For information about which properties are supported for which events,
            * and their allowed and default values, see
            * [HammerJS documentation](http://hammerjs.github.io/).
            */
        options?: {
                cssProps?: any;
                domEvents?: boolean;
                enable?: boolean | ((manager: any) => boolean);
                preset?: any[];
                touchAction?: string;
                recognizers?: any[];
                inputClass?: any;
                inputTarget?: EventTarget;
        };
        /**
            * Creates a [HammerJS Manager](http://hammerjs.github.io/api/#hammer.manager)
            * and attaches it to a given HTML element.
            * @param element The element that will recognize gestures.
            * @returns A HammerJS event-manager object.
            */
        buildHammer(element: HTMLElement): HammerInstance;
}
export declare class HammerGesturesPlugin extends EventManagerPlugin {
        constructor(doc: any, _config: HammerGestureConfig, console: Console, loader?: HammerLoader | null | undefined);
        supports(eventName: string): boolean;
        addEventListener(element: HTMLElement, eventName: string, handler: Function): Function;
        isCustomEvent(eventName: string): boolean;
}

/**
    * @license
    * Copyright Google Inc. All Rights Reserved.
    *
    * Use of this source code is governed by an MIT-style license that can be
    * found in the LICENSE file at https://angular.io/license
    */
import { Sanitizer, SecurityContext } from '@angular/core';
export { SecurityContext };
/**
    * Marker interface for a value that's safe to use in a particular context.
    *
    * @publicApi
    */
export interface SafeValue {
}
/**
    * Marker interface for a value that's safe to use as HTML.
    *
    * @publicApi
    */
export interface SafeHtml extends SafeValue {
}
/**
    * Marker interface for a value that's safe to use as style (CSS).
    *
    * @publicApi
    */
export interface SafeStyle extends SafeValue {
}
/**
    * Marker interface for a value that's safe to use as JavaScript.
    *
    * @publicApi
    */
export interface SafeScript extends SafeValue {
}
/**
    * Marker interface for a value that's safe to use as a URL linking to a document.
    *
    * @publicApi
    */
export interface SafeUrl extends SafeValue {
}
/**
    * Marker interface for a value that's safe to use as a URL to load executable code from.
    *
    * @publicApi
    */
export interface SafeResourceUrl extends SafeValue {
}
/**
    * DomSanitizer helps preventing Cross Site Scripting Security bugs (XSS) by sanitizing
    * values to be safe to use in the different DOM contexts.
    *
    * For example, when binding a URL in an `<a [href]="someValue">` hyperlink, `someValue` will be
    * sanitized so that an attacker cannot inject e.g. a `javascript:` URL that would execute code on
    * the website.
    *
    * In specific situations, it might be necessary to disable sanitization, for example if the
    * application genuinely needs to produce a `javascript:` style link with a dynamic value in it.
    * Users can bypass security by constructing a value with one of the `bypassSecurityTrust...`
    * methods, and then binding to that value from the template.
    *
    * These situations should be very rare, and extraordinary care must be taken to avoid creating a
    * Cross Site Scripting (XSS) security bug!
    *
    * When using `bypassSecurityTrust...`, make sure to call the method as early as possible and as
    * close as possible to the source of the value, to make it easy to verify no security bug is
    * created by its use.
    *
    * It is not required (and not recommended) to bypass security if the value is safe, e.g. a URL that
    * does not start with a suspicious protocol, or an HTML snippet that does not contain dangerous
    * code. The sanitizer leaves safe values intact.
    *
    * @security Calling any of the `bypassSecurityTrust...` APIs disables Angular's built-in
    * sanitization for the value passed in. Carefully check and audit all values and code paths going
    * into this call. Make sure any user data is appropriately escaped for this security context.
    * For more detail, see the [Security Guide](http://g.co/ng/security).
    *
    * @publicApi
    */
export declare abstract class DomSanitizer implements Sanitizer {
        /**
            * Sanitizes a value for use in the given SecurityContext.
            *
            * If value is trusted for the context, this method will unwrap the contained safe value and use
            * it directly. Otherwise, value will be sanitized to be safe in the given context, for example
            * by replacing URLs that have an unsafe protocol part (such as `javascript:`). The implementation
            * is responsible to make sure that the value can definitely be safely used in the given context.
            */
        abstract sanitize(context: SecurityContext, value: SafeValue | string | null): string | null;
        /**
            * Bypass security and trust the given value to be safe HTML. Only use this when the bound HTML
            * is unsafe (e.g. contains `<script>` tags) and the code should be executed. The sanitizer will
            * leave safe HTML intact, so in most situations this method should not be used.
            *
            * **WARNING:** calling this method with untrusted user data exposes your application to XSS
            * security risks!
            */
        abstract bypassSecurityTrustHtml(value: string): SafeHtml;
        /**
            * Bypass security and trust the given value to be safe style value (CSS).
            *
            * **WARNING:** calling this method with untrusted user data exposes your application to XSS
            * security risks!
            */
        abstract bypassSecurityTrustStyle(value: string): SafeStyle;
        /**
            * Bypass security and trust the given value to be safe JavaScript.
            *
            * **WARNING:** calling this method with untrusted user data exposes your application to XSS
            * security risks!
            */
        abstract bypassSecurityTrustScript(value: string): SafeScript;
        /**
            * Bypass security and trust the given value to be a safe style URL, i.e. a value that can be used
            * in hyperlinks or `<img src>`.
            *
            * **WARNING:** calling this method with untrusted user data exposes your application to XSS
            * security risks!
            */
        abstract bypassSecurityTrustUrl(value: string): SafeUrl;
        /**
            * Bypass security and trust the given value to be a safe resource URL, i.e. a location that may
            * be used to load executable code from, like `<script src>`, or `<iframe src>`.
            *
            * **WARNING:** calling this method with untrusted user data exposes your application to XSS
            * security risks!
            */
        abstract bypassSecurityTrustResourceUrl(value: string): SafeResourceUrl;
}
export declare class DomSanitizerImpl extends DomSanitizer {
        constructor(_doc: any);
        sanitize(ctx: SecurityContext, value: SafeValue | string | null): string | null;
        bypassSecurityTrustHtml(value: string): SafeHtml;
        bypassSecurityTrustStyle(value: string): SafeStyle;
        bypassSecurityTrustScript(value: string): SafeScript;
        bypassSecurityTrustUrl(value: string): SafeUrl;
        bypassSecurityTrustResourceUrl(value: string): SafeResourceUrl;
}

/**
  * @license
  * Copyright Google Inc. All Rights Reserved.
  *
  * Use of this source code is governed by an MIT-style license that can be
  * found in the LICENSE file at https://angular.io/license
  */
export { BROWSER_SANITIZATION_PROVIDERS as ɵBROWSER_SANITIZATION_PROVIDERS, INTERNAL_BROWSER_PLATFORM_PROVIDERS as ɵINTERNAL_BROWSER_PLATFORM_PROVIDERS, initDomAdapter as ɵinitDomAdapter } from '@angular/platform-browser/--/--/--/--/--/node_modules/@angular/platform-browser/src/browser';
export { BrowserDomAdapter as ɵBrowserDomAdapter } from '@angular/platform-browser/--/--/--/--/--/node_modules/@angular/platform-browser/src/browser/browser_adapter';
export { BrowserPlatformLocation as ɵBrowserPlatformLocation } from '@angular/platform-browser/--/--/--/--/--/node_modules/@angular/platform-browser/src/browser/location/browser_platform_location';
export { TRANSITION_ID as ɵTRANSITION_ID } from '@angular/platform-browser/--/--/--/--/--/node_modules/@angular/platform-browser/src/browser/server-transition';
export { BrowserGetTestability as ɵBrowserGetTestability } from '@angular/platform-browser/--/--/--/--/--/node_modules/@angular/platform-browser/src/browser/testability';
export { escapeHtml as ɵescapeHtml } from '@angular/platform-browser/--/--/--/--/--/node_modules/@angular/platform-browser/src/browser/transfer_state';
export { ELEMENT_PROBE_PROVIDERS as ɵELEMENT_PROBE_PROVIDERS } from '@angular/platform-browser/--/--/--/--/--/node_modules/@angular/platform-browser/src/dom/debug/ng_probe';
export { DomAdapter as ɵDomAdapter, getDOM as ɵgetDOM, setRootDomAdapter as ɵsetRootDomAdapter } from '@angular/platform-browser/--/--/--/--/--/node_modules/@angular/platform-browser/src/dom/dom_adapter';
export { DomRendererFactory2 as ɵDomRendererFactory2, NAMESPACE_URIS as ɵNAMESPACE_URIS, flattenStyles as ɵflattenStyles, shimContentAttribute as ɵshimContentAttribute, shimHostAttribute as ɵshimHostAttribute } from '@angular/platform-browser/--/--/--/--/--/node_modules/@angular/platform-browser/src/dom/dom_renderer';
export { DomEventsPlugin as ɵDomEventsPlugin } from '@angular/platform-browser/--/--/--/--/--/node_modules/@angular/platform-browser/src/dom/events/dom_events';
export { HammerGesturesPlugin as ɵHammerGesturesPlugin } from '@angular/platform-browser/--/--/--/--/--/node_modules/@angular/platform-browser/src/dom/events/hammer_gestures';
export { KeyEventsPlugin as ɵKeyEventsPlugin } from '@angular/platform-browser/--/--/--/--/--/node_modules/@angular/platform-browser/src/dom/events/key_events';
export { DomSharedStylesHost as ɵDomSharedStylesHost, SharedStylesHost as ɵSharedStylesHost } from '@angular/platform-browser/--/--/--/--/--/node_modules/@angular/platform-browser/src/dom/shared_styles_host';
export { DomSanitizerImpl as ɵDomSanitizerImpl } from '@angular/platform-browser/--/--/--/--/--/node_modules/@angular/platform-browser/src/security/dom_sanitization_service';

/**
    * @module
    * @description
    * Entry point for all public APIs of the common package.
    */
import { Version } from '@angular/core';
/**
    * @publicApi
    */
export declare const VERSION: Version;

/**
    * @license
    * Copyright Google Inc. All Rights Reserved.
    *
    * Use of this source code is governed by an MIT-style license that can be
    * found in the LICENSE file at https://angular.io/license
    */
import { GenericBrowserDomAdapter } from '@angular/platform-browser/--/--/--/--/--/node_modules/@angular/platform-browser/src/browser/generic_browser_adapter';
/**
    * A `DomAdapter` powered by full browser DOM APIs.
    *
    * @security Tread carefully! Interacting with the DOM directly is dangerous and
    * can introduce XSS risks.
    */
export declare class BrowserDomAdapter extends GenericBrowserDomAdapter {
        parse(templateHtml: string): void;
        static makeCurrent(): void;
        hasProperty(element: Node, name: string): boolean;
        setProperty(el: Node, name: string, value: any): void;
        getProperty(el: Node, name: string): any;
        invoke(el: Node, methodName: string, args: any[]): any;
        logError(error: string): void;
        log(error: string): void;
        logGroup(error: string): void;
        logGroupEnd(): void;
        readonly attrToPropMap: any;
        contains(nodeA: any, nodeB: any): boolean;
        querySelector(el: HTMLElement, selector: string): any;
        querySelectorAll(el: any, selector: string): any[];
        on(el: Node, evt: any, listener: any): void;
        onAndCancel(el: Node, evt: any, listener: any): Function;
        dispatchEvent(el: Node, evt: any): void;
        createMouseEvent(eventType: string): MouseEvent;
        createEvent(eventType: any): Event;
        preventDefault(evt: Event): void;
        isPrevented(evt: Event): boolean;
        getInnerHTML(el: HTMLElement): string;
        getTemplateContent(el: Node): Node | null;
        getOuterHTML(el: HTMLElement): string;
        nodeName(node: Node): string;
        nodeValue(node: Node): string | null;
        type(node: HTMLInputElement): string;
        content(node: Node): Node;
        firstChild(el: Node): Node | null;
        nextSibling(el: Node): Node | null;
        parentElement(el: Node): Node | null;
        childNodes(el: any): Node[];
        childNodesAsList(el: Node): any[];
        clearNodes(el: Node): void;
        appendChild(el: Node, node: Node): void;
        removeChild(el: Node, node: Node): void;
        replaceChild(el: Node, newChild: Node, oldChild: Node): void;
        remove(node: Node): Node;
        insertBefore(parent: Node, ref: Node, node: Node): void;
        insertAllBefore(parent: Node, ref: Node, nodes: Node[]): void;
        insertAfter(parent: Node, ref: Node, node: any): void;
        setInnerHTML(el: Element, value: string): void;
        getText(el: Node): string | null;
        setText(el: Node, value: string): void;
        getValue(el: any): string;
        setValue(el: any, value: string): void;
        getChecked(el: any): boolean;
        setChecked(el: any, value: boolean): void;
        createComment(text: string): Comment;
        createTemplate(html: any): HTMLElement;
        createElement(tagName: string, doc?: Document): HTMLElement;
        createElementNS(ns: string, tagName: string, doc?: Document): Element;
        createTextNode(text: string, doc?: Document): Text;
        createScriptTag(attrName: string, attrValue: string, doc?: Document): HTMLScriptElement;
        createStyleElement(css: string, doc?: Document): HTMLStyleElement;
        createShadowRoot(el: HTMLElement): DocumentFragment;
        getShadowRoot(el: HTMLElement): DocumentFragment;
        getHost(el: HTMLElement): HTMLElement;
        clone(node: Node): Node;
        getElementsByClassName(element: any, name: string): HTMLElement[];
        getElementsByTagName(element: any, name: string): HTMLElement[];
        classList(element: any): any[];
        addClass(element: any, className: string): void;
        removeClass(element: any, className: string): void;
        hasClass(element: any, className: string): boolean;
        setStyle(element: any, styleName: string, styleValue: string): void;
        removeStyle(element: any, stylename: string): void;
        getStyle(element: any, stylename: string): string;
        hasStyle(element: any, styleName: string, styleValue?: string | null): boolean;
        tagName(element: any): string;
        attributeMap(element: any): Map<string, string>;
        hasAttribute(element: Element, attribute: string): boolean;
        hasAttributeNS(element: Element, ns: string, attribute: string): boolean;
        getAttribute(element: Element, attribute: string): string | null;
        getAttributeNS(element: Element, ns: string, name: string): string | null;
        setAttribute(element: Element, name: string, value: string): void;
        setAttributeNS(element: Element, ns: string, name: string, value: string): void;
        removeAttribute(element: Element, attribute: string): void;
        removeAttributeNS(element: Element, ns: string, name: string): void;
        templateAwareRoot(el: Node): any;
        createHtmlDocument(): HTMLDocument;
        getDefaultDocument(): Document;
        getBoundingClientRect(el: Element): any;
        getTitle(doc: Document): string;
        setTitle(doc: Document, newTitle: string): void;
        elementMatches(n: any, selector: string): boolean;
        isTemplateElement(el: Node): boolean;
        isTextNode(node: Node): boolean;
        isCommentNode(node: Node): boolean;
        isElementNode(node: Node): boolean;
        hasShadowRoot(node: any): boolean;
        isShadowRoot(node: any): boolean;
        importIntoDoc(node: Node): any;
        adoptNode(node: Node): any;
        getHref(el: Element): string;
        getEventKey(event: any): string;
        getGlobalEventTarget(doc: Document, target: string): EventTarget | null;
        getHistory(): History;
        getLocation(): Location;
        getBaseHref(doc: Document): string | null;
        resetBaseElement(): void;
        getUserAgent(): string;
        setData(element: Element, name: string, value: string): void;
        getData(element: Element, name: string): string | null;
        getComputedStyle(element: any): any;
        supportsWebAnimation(): boolean;
        performanceNow(): number;
        supportsCookies(): boolean;
        getCookie(name: string): string | null;
        setCookie(name: string, value: string): void;
}

/**
    * @license
    * Copyright Google Inc. All Rights Reserved.
    *
    * Use of this source code is governed by an MIT-style license that can be
    * found in the LICENSE file at https://angular.io/license
    */
import { LocationChangeListener, PlatformLocation } from '@angular/common';
/**
    * `PlatformLocation` encapsulates all of the direct calls to platform APIs.
    * This class should not be used directly by an application developer. Instead, use
    * {@link Location}.
    */
export declare class BrowserPlatformLocation extends PlatformLocation {
        readonly location: Location;
        constructor(_doc: any);
        getBaseHrefFromDOM(): string;
        onPopState(fn: LocationChangeListener): void;
        onHashChange(fn: LocationChangeListener): void;
        pathname: string;
        readonly search: string;
        readonly hash: string;
        pushState(state: any, title: string, url: string): void;
        replaceState(state: any, title: string, url: string): void;
        forward(): void;
        back(): void;
}

/**
    * @license
    * Copyright Google Inc. All Rights Reserved.
    *
    * Use of this source code is governed by an MIT-style license that can be
    * found in the LICENSE file at https://angular.io/license
    */
import { InjectionToken, Injector, StaticProvider } from '@angular/core';
/**
    * An id that identifies a particular application being bootstrapped, that should
    * match across the client/server boundary.
    */
export declare const TRANSITION_ID: InjectionToken<{}>;
export declare function appInitializerFactory(transitionId: string, document: any, injector: Injector): () => void;
export declare const SERVER_TRANSITION_PROVIDERS: StaticProvider[];

/**
  * @license
  * Copyright Google Inc. All Rights Reserved.
  *
  * Use of this source code is governed by an MIT-style license that can be
  * found in the LICENSE file at https://angular.io/license
  */
import { GetTestability, Testability, TestabilityRegistry } from '@angular/core';
export declare class BrowserGetTestability implements GetTestability {
    static init(): void;
    addToWindow(registry: TestabilityRegistry): void;
    findTestabilityInTree(registry: TestabilityRegistry, elem: any, findInAncestors: boolean): Testability | null;
}

/**
    * @license
    * Copyright Google Inc. All Rights Reserved.
    *
    * Use of this source code is governed by an MIT-style license that can be
    * found in the LICENSE file at https://angular.io/license
    */
import * as core from '@angular/core';
/**
    * Returns a {@link DebugElement} for the given native DOM element, or
    * null if the given native element does not have an Angular view associated
    * with it.
    */
export declare function inspectNativeElement(element: any): core.DebugNode | null;
export declare function _createNgProbe(coreTokens: core.NgProbeToken[]): any;
/**
    * Providers which support debugging Angular applications (e.g. via `ng.probe`).
    */
export declare const ELEMENT_PROBE_PROVIDERS: core.Provider[];

/**
    * @license
    * Copyright Google Inc. All Rights Reserved.
    *
    * Use of this source code is governed by an MIT-style license that can be
    * found in the LICENSE file at https://angular.io/license
    */
import { Type } from '@angular/core';
export declare function getDOM(): DomAdapter;
export declare function setDOM(adapter: DomAdapter): void;
export declare function setRootDomAdapter(adapter: DomAdapter): void;
/**
    * Provides DOM operations in an environment-agnostic way.
    *
    * @security Tread carefully! Interacting with the DOM directly is dangerous and
    * can introduce XSS risks.
    */
export declare abstract class DomAdapter {
        resourceLoaderType: Type<any>;
        abstract hasProperty(element: any, name: string): boolean;
        abstract setProperty(el: Element, name: string, value: any): any;
        abstract getProperty(el: Element, name: string): any;
        abstract invoke(el: Element, methodName: string, args: any[]): any;
        abstract logError(error: any): any;
        abstract log(error: any): any;
        abstract logGroup(error: any): any;
        abstract logGroupEnd(): any;
        /**
            * Maps attribute names to their corresponding property names for cases
            * where attribute name doesn't match property name.
            */
        attrToPropMap: {
                [key: string]: string;
        };
        abstract contains(nodeA: any, nodeB: any): boolean;
        abstract parse(templateHtml: string): any;
        abstract querySelector(el: any, selector: string): any;
        abstract querySelectorAll(el: any, selector: string): any[];
        abstract on(el: any, evt: any, listener: any): any;
        abstract onAndCancel(el: any, evt: any, listener: any): Function;
        abstract dispatchEvent(el: any, evt: any): any;
        abstract createMouseEvent(eventType: any): any;
        abstract createEvent(eventType: string): any;
        abstract preventDefault(evt: any): any;
        abstract isPrevented(evt: any): boolean;
        abstract getInnerHTML(el: any): string;
        /** Returns content if el is a <template> element, null otherwise. */
        abstract getTemplateContent(el: any): any;
        abstract getOuterHTML(el: any): string;
        abstract nodeName(node: any): string;
        abstract nodeValue(node: any): string | null;
        abstract type(node: any): string;
        abstract content(node: any): any;
        abstract firstChild(el: any): Node | null;
        abstract nextSibling(el: any): Node | null;
        abstract parentElement(el: any): Node | null;
        abstract childNodes(el: any): Node[];
        abstract childNodesAsList(el: any): Node[];
        abstract clearNodes(el: any): any;
        abstract appendChild(el: any, node: any): any;
        abstract removeChild(el: any, node: any): any;
        abstract replaceChild(el: any, newNode: any, oldNode: any): any;
        abstract remove(el: any): Node;
        abstract insertBefore(parent: any, ref: any, node: any): any;
        abstract insertAllBefore(parent: any, ref: any, nodes: any): any;
        abstract insertAfter(parent: any, el: any, node: any): any;
        abstract setInnerHTML(el: any, value: any): any;
        abstract getText(el: any): string | null;
        abstract setText(el: any, value: string): any;
        abstract getValue(el: any): string;
        abstract setValue(el: any, value: string): any;
        abstract getChecked(el: any): boolean;
        abstract setChecked(el: any, value: boolean): any;
        abstract createComment(text: string): any;
        abstract createTemplate(html: any): HTMLElement;
        abstract createElement(tagName: any, doc?: any): HTMLElement;
        abstract createElementNS(ns: string, tagName: string, doc?: any): Element;
        abstract createTextNode(text: string, doc?: any): Text;
        abstract createScriptTag(attrName: string, attrValue: string, doc?: any): HTMLElement;
        abstract createStyleElement(css: string, doc?: any): HTMLStyleElement;
        abstract createShadowRoot(el: any): any;
        abstract getShadowRoot(el: any): any;
        abstract getHost(el: any): any;
        abstract getDistributedNodes(el: any): Node[];
        abstract clone(node: Node): Node;
        abstract getElementsByClassName(element: any, name: string): HTMLElement[];
        abstract getElementsByTagName(element: any, name: string): HTMLElement[];
        abstract classList(element: any): any[];
        abstract addClass(element: any, className: string): any;
        abstract removeClass(element: any, className: string): any;
        abstract hasClass(element: any, className: string): boolean;
        abstract setStyle(element: any, styleName: string, styleValue: string): any;
        abstract removeStyle(element: any, styleName: string): any;
        abstract getStyle(element: any, styleName: string): string;
        abstract hasStyle(element: any, styleName: string, styleValue?: string): boolean;
        abstract tagName(element: any): string;
        abstract attributeMap(element: any): Map<string, string>;
        abstract hasAttribute(element: any, attribute: string): boolean;
        abstract hasAttributeNS(element: any, ns: string, attribute: string): boolean;
        abstract getAttribute(element: any, attribute: string): string | null;
        abstract getAttributeNS(element: any, ns: string, attribute: string): string | null;
        abstract setAttribute(element: any, name: string, value: string): any;
        abstract setAttributeNS(element: any, ns: string, name: string, value: string): any;
        abstract removeAttribute(element: any, attribute: string): any;
        abstract removeAttributeNS(element: any, ns: string, attribute: string): any;
        abstract templateAwareRoot(el: any): any;
        abstract createHtmlDocument(): HTMLDocument;
        abstract getDefaultDocument(): Document;
        abstract getBoundingClientRect(el: any): any;
        abstract getTitle(doc: Document): string;
        abstract setTitle(doc: Document, newTitle: string): any;
        abstract elementMatches(n: any, selector: string): boolean;
        abstract isTemplateElement(el: any): boolean;
        abstract isTextNode(node: any): boolean;
        abstract isCommentNode(node: any): boolean;
        abstract isElementNode(node: any): boolean;
        abstract hasShadowRoot(node: any): boolean;
        abstract isShadowRoot(node: any): boolean;
        abstract importIntoDoc(node: Node): Node;
        abstract adoptNode(node: Node): Node;
        abstract getHref(element: any): string;
        abstract getEventKey(event: any): string;
        abstract resolveAndSetHref(element: any, baseUrl: string, href: string): any;
        abstract supportsDOMEvents(): boolean;
        abstract supportsNativeShadowDOM(): boolean;
        abstract getGlobalEventTarget(doc: Document, target: string): any;
        abstract getHistory(): History;
        abstract getLocation(): Location;
        abstract getBaseHref(doc: Document): string | null;
        abstract resetBaseElement(): void;
        abstract getUserAgent(): string;
        abstract setData(element: any, name: string, value: string): any;
        abstract getComputedStyle(element: any): any;
        abstract getData(element: any, name: string): string | null;
        abstract supportsWebAnimation(): boolean;
        abstract performanceNow(): number;
        abstract getAnimationPrefix(): string;
        abstract getTransitionEnd(): string;
        abstract supportsAnimation(): boolean;
        abstract supportsCookies(): boolean;
        abstract getCookie(name: string): string | null;
        abstract setCookie(name: string, value: string): any;
}

/**
  * @license
  * Copyright Google Inc. All Rights Reserved.
  *
  * Use of this source code is governed by an MIT-style license that can be
  * found in the LICENSE file at https://angular.io/license
  */
import { Renderer2, RendererFactory2, RendererType2 } from '@angular/core';
import { EventManager } from '@angular/platform-browser/--/--/--/--/--/node_modules/@angular/platform-browser/src/dom/events/event_manager';
import { DomSharedStylesHost } from '@angular/platform-browser/--/--/--/--/--/node_modules/@angular/platform-browser/src/dom/shared_styles_host';
export declare const NAMESPACE_URIS: {
    [ns: string]: string;
};
export declare const COMPONENT_VARIABLE = "%COMP%";
export declare const HOST_ATTR: string;
export declare const CONTENT_ATTR: string;
export declare function shimContentAttribute(componentShortId: string): string;
export declare function shimHostAttribute(componentShortId: string): string;
export declare function flattenStyles(compId: string, styles: Array<any | any[]>, target: string[]): string[];
export declare class DomRendererFactory2 implements RendererFactory2 {
    constructor(eventManager: EventManager, sharedStylesHost: DomSharedStylesHost);
    createRenderer(element: any, type: RendererType2 | null): Renderer2;
    begin(): void;
    end(): void;
}

/**
  * @license
  * Copyright Google Inc. All Rights Reserved.
  *
  * Use of this source code is governed by an MIT-style license that can be
  * found in the LICENSE file at https://angular.io/license
  */
import { NgZone } from '@angular/core';
import { EventManagerPlugin } from '@angular/platform-browser/--/--/--/--/--/node_modules/@angular/platform-browser/src/dom/events/event_manager';
export declare class DomEventsPlugin extends EventManagerPlugin {
    constructor(doc: any, ngZone: NgZone, platformId: {} | null);
    supports(eventName: string): boolean;
    addEventListener(element: HTMLElement, eventName: string, handler: Function): Function;
    removeEventListener(target: any, eventName: string, callback: Function): void;
}

/**
    * @license
    * Copyright Google Inc. All Rights Reserved.
    *
    * Use of this source code is governed by an MIT-style license that can be
    * found in the LICENSE file at https://angular.io/license
    */
import { NgZone } from '@angular/core';
import { EventManagerPlugin } from '@angular/platform-browser/--/--/--/--/--/node_modules/@angular/platform-browser/src/dom/events/event_manager';
/**
    * @publicApi
    * A browser plug-in that provides support for handling of key events in Angular.
    */
export declare class KeyEventsPlugin extends EventManagerPlugin {
        /**
            * Initializes an instance of the browser plug-in.
            * @param doc The document in which key events will be detected.
            */
        constructor(doc: any);
        /**
             * Reports whether a named key event is supported.
             * @param eventName The event name to query.
             * @return True if the named key event is supported.
            */
        supports(eventName: string): boolean;
        /**
            * Registers a handler for a specific element and key event.
            * @param element The HTML element to receive event notifications.
            * @param eventName The name of the key event to listen for.
            * @param handler A function to call when the notification occurs. Receives the
            * event object as an argument.
            * @returns The key event that was registered.
         */
        addEventListener(element: HTMLElement, eventName: string, handler: Function): Function;
        static parseEventName(eventName: string): {
                [key: string]: string;
        } | null;
        static getEventFullKey(event: KeyboardEvent): string;
        /**
            * Configures a handler callback for a key event.
            * @param fullKey The event name that combines all simultaneous keystrokes.
            * @param handler The function that responds to the key event.
            * @param zone The zone in which the event occurred.
            * @returns A callback function.
            */
        static eventCallback(fullKey: any, handler: Function, zone: NgZone): Function;
}

/**
  * @license
  * Copyright Google Inc. All Rights Reserved.
  *
  * Use of this source code is governed by an MIT-style license that can be
  * found in the LICENSE file at https://angular.io/license
  */
import { OnDestroy } from '@angular/core';
export declare class SharedStylesHost {
    addStyles(styles: string[]): void;
    onStylesAdded(additions: Set<string>): void;
    getAllStyles(): string[];
}
export declare class DomSharedStylesHost extends SharedStylesHost implements OnDestroy {
    constructor(_doc: any);
    addHost(hostNode: Node): void;
    removeHost(hostNode: Node): void;
    onStylesAdded(additions: Set<string>): void;
    ngOnDestroy(): void;
}

/**
    * @license
    * Copyright Google Inc. All Rights Reserved.
    *
    * Use of this source code is governed by an MIT-style license that can be
    * found in the LICENSE file at https://angular.io/license
    */
import { DomAdapter } from '@angular/platform-browser/--/--/--/--/--/node_modules/@angular/platform-browser/src/dom/dom_adapter';
/**
    * Provides DOM operations in any browser environment.
    *
    * @security Tread carefully! Interacting with the DOM directly is dangerous and
    * can introduce XSS risks.
    */
export declare abstract class GenericBrowserDomAdapter extends DomAdapter {
        constructor();
        getDistributedNodes(el: HTMLElement): Node[];
        resolveAndSetHref(el: HTMLAnchorElement, baseUrl: string, href: string): void;
        supportsDOMEvents(): boolean;
        supportsNativeShadowDOM(): boolean;
        getAnimationPrefix(): string;
        getTransitionEnd(): string;
        supportsAnimation(): boolean;
}


}
