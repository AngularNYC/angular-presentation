[
  {
    "path": "node_modules/@angular/core/core.d.ts",
    "content": "/**\n * Generated bundle index. Do not edit.\n */\nexport * from './index';\nexport { APPLICATION_MODULE_PROVIDERS as ɵangular_packages_core_core_p, _iterableDiffersFactory as ɵangular_packages_core_core_m, _keyValueDiffersFactory as ɵangular_packages_core_core_n, _localeFactory as ɵangular_packages_core_core_o } from './src/application_module';\nexport { _appIdRandomProviderFactory as ɵangular_packages_core_core_g } from './src/application_tokens';\nexport { DefaultIterableDifferFactory as ɵangular_packages_core_core_k } from './src/change_detection/differs/default_iterable_differ';\nexport { DefaultKeyValueDifferFactory as ɵangular_packages_core_core_l } from './src/change_detection/differs/default_keyvalue_differ';\nexport { injectInjectorOnly as ɵangular_packages_core_core_c } from './src/di/injector_compatibility';\nexport { ReflectiveInjector_ as ɵangular_packages_core_core_d } from './src/di/reflective_injector';\nexport { ReflectiveDependency as ɵangular_packages_core_core_e, resolveReflectiveProviders as ɵangular_packages_core_core_f } from './src/di/reflective_provider';\nexport { wtfEnabled as ɵangular_packages_core_core_q } from './src/profile/profile';\nexport { createScope as ɵangular_packages_core_core_s, detectWTF as ɵangular_packages_core_core_r, endTimeRange as ɵangular_packages_core_core_v, leave as ɵangular_packages_core_core_t, startTimeRange as ɵangular_packages_core_core_u } from './src/profile/wtf_impl';\nexport { injectAttributeImpl as ɵangular_packages_core_core_z } from './src/render3/di';\nexport { NG_INJECTABLE_DEF as ɵangular_packages_core_core_bh } from './src/render3/fields';\nexport { bindingUpdated as ɵangular_packages_core_core_ba } from './src/render3/instructions';\nexport { TElementNode as ɵangular_packages_core_core_be } from './src/render3/interfaces/node';\nexport { PlayerFactoryBuildFn as ɵangular_packages_core_core_bf } from './src/render3/interfaces/player';\nexport { LViewData as ɵangular_packages_core_core_bj } from './src/render3/interfaces/view';\nexport { getPreviousOrParentTNode as ɵangular_packages_core_core_bb, getViewData as ɵangular_packages_core_core_bc, nextContextImpl as ɵangular_packages_core_core_bd } from './src/render3/state';\nexport { BoundPlayerFactory as ɵangular_packages_core_core_bg } from './src/render3/styling/player_factory';\nexport { loadInternal as ɵangular_packages_core_core_bk } from './src/render3/util';\nexport { createElementRef as ɵangular_packages_core_core_h, createTemplateRef as ɵangular_packages_core_core_i, createViewRef as ɵangular_packages_core_core_j } from './src/render3/view_engine_compatibility';\nexport { makeParamDecorator as ɵangular_packages_core_core_a, makePropDecorator as ɵangular_packages_core_core_b } from './src/util/decorators';\nexport { getClosureSafeProperty as ɵangular_packages_core_core_bi } from './src/util/property';\nexport { _def as ɵangular_packages_core_core_w } from './src/view/provider';\nexport { DebugRendererFactory2 as ɵangular_packages_core_core_x } from './src/view/services';\nexport { DebugContext as ɵangular_packages_core_core_y } from './src/view/types';\n"
  },
  {
    "path": "node_modules/@angular/core/index.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nexport * from './public_api';\n"
  },
  {
    "path": "node_modules/@angular/core/node_modules/tslib/tslib.d.ts",
    "content": "/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\nexport declare function __extends(d: Function, b: Function): void;\r\nexport declare function __assign(t: any, ...sources: any[]): any;\r\nexport declare function __rest(t: any, propertyNames: (string | symbol)[]): any;\r\nexport declare function __decorate(decorators: Function[], target: any, key?: string | symbol, desc?: any): any;\r\nexport declare function __param(paramIndex: number, decorator: Function): Function;\r\nexport declare function __metadata(metadataKey: any, metadataValue: any): Function;\r\nexport declare function __awaiter(thisArg: any, _arguments: any, P: Function, generator: Function): any;\r\nexport declare function __generator(thisArg: any, body: Function): any;\r\nexport declare function __exportStar(m: any, exports: any): void;\r\nexport declare function __values(o: any): any;\r\nexport declare function __read(o: any, n?: number): any[];\r\nexport declare function __spread(...args: any[]): any[];\r\nexport declare function __await(v: any): any;\r\nexport declare function __asyncGenerator(thisArg: any, _arguments: any, generator: Function): any;\r\nexport declare function __asyncDelegator(o: any): any;\r\nexport declare function __asyncValues(o: any): any;\r\nexport declare function __makeTemplateObject(cooked: string[], raw: string[]): TemplateStringsArray;\r\nexport declare function __importStar<T>(mod: T): T;\r\nexport declare function __importDefault<T>(mod: T): T | { default: T };\r\n"
  },
  {
    "path": "node_modules/@angular/core/public_api.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * @module\n * @description\n * Entry point for all public APIs of this package.\n */\nexport * from './src/core';\n"
  },
  {
    "path": "node_modules/@angular/core/src/application_init.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { InjectionToken } from './di';\n/**\n * A function that will be executed when an application is initialized.\n *\n * @publicApi\n */\nexport declare const APP_INITIALIZER: InjectionToken<(() => void)[]>;\n/**\n * A class that reflects the state of running {@link APP_INITIALIZER}s.\n *\n * @publicApi\n */\nexport declare class ApplicationInitStatus {\n    private appInits;\n    private resolve;\n    private reject;\n    private initialized;\n    readonly donePromise: Promise<any>;\n    readonly done = false;\n    constructor(appInits: (() => any)[]);\n}\n"
  },
  {
    "path": "node_modules/@angular/core/src/application_module.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { ApplicationRef } from './application_ref';\nimport { IterableDiffers, KeyValueDiffers } from './change_detection/change_detection';\nimport { StaticProvider } from './di';\nexport declare function _iterableDiffersFactory(): IterableDiffers;\nexport declare function _keyValueDiffersFactory(): KeyValueDiffers;\nexport declare function _localeFactory(locale?: string): string;\n/**\n * A built-in [dependency injection token](guide/glossary#di-token)\n * that is used to configure the root injector for bootstrapping.\n */\nexport declare const APPLICATION_MODULE_PROVIDERS: StaticProvider[];\n/**\n * Configures the root injector for an app with\n * providers of `@angular/core` dependencies that `ApplicationRef` needs\n * to bootstrap components.\n *\n * Re-exported by `BrowserModule`, which is included automatically in the root\n * `AppModule` when you create a new app with the CLI `new` command.\n *\n * @publicApi\n */\nexport declare class ApplicationModule {\n    constructor(appRef: ApplicationRef);\n}\n"
  },
  {
    "path": "node_modules/@angular/core/src/application_ref.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { Observable } from 'rxjs';\nimport { InjectionToken, Injector, StaticProvider } from './di';\nimport { CompilerOptions } from './linker/compiler';\nimport { ComponentFactory, ComponentRef } from './linker/component_factory';\nimport { NgModuleFactory, NgModuleRef } from './linker/ng_module_factory';\nimport { ViewRef } from './linker/view_ref';\nimport { Type } from './type';\nimport { NgZone } from './zone/ng_zone';\nexport declare function compileNgModuleFactory__POST_R3__<M>(injector: Injector, options: CompilerOptions, moduleType: Type<M>): Promise<NgModuleFactory<M>>;\nexport declare const ALLOW_MULTIPLE_PLATFORMS: InjectionToken<boolean>;\n/**\n * A token for third-party components that can register themselves with NgProbe.\n *\n * @publicApi\n */\nexport declare class NgProbeToken {\n    name: string;\n    token: any;\n    constructor(name: string, token: any);\n}\n/**\n * Creates a platform.\n * Platforms have to be eagerly created via this function.\n *\n * @publicApi\n */\nexport declare function createPlatform(injector: Injector): PlatformRef;\n/**\n * Creates a factory for a platform\n *\n * @publicApi\n */\nexport declare function createPlatformFactory(parentPlatformFactory: ((extraProviders?: StaticProvider[]) => PlatformRef) | null, name: string, providers?: StaticProvider[]): (extraProviders?: StaticProvider[]) => PlatformRef;\n/**\n * Checks that there currently is a platform which contains the given token as a provider.\n *\n * @publicApi\n */\nexport declare function assertPlatform(requiredToken: any): PlatformRef;\n/**\n * Destroy the existing platform.\n *\n * @publicApi\n */\nexport declare function destroyPlatform(): void;\n/**\n * Returns the current platform.\n *\n * @publicApi\n */\nexport declare function getPlatform(): PlatformRef | null;\n/**\n * Provides additional options to the bootstraping process.\n *\n *\n */\nexport interface BootstrapOptions {\n    /**\n     * Optionally specify which `NgZone` should be used.\n     *\n     * - Provide your own `NgZone` instance.\n     * - `zone.js` - Use default `NgZone` which requires `Zone.js`.\n     * - `noop` - Use `NoopNgZone` which does nothing.\n     */\n    ngZone?: NgZone | 'zone.js' | 'noop';\n}\n/**\n * The Angular platform is the entry point for Angular on a web page. Each page\n * has exactly one platform, and services (such as reflection) which are common\n * to every Angular application running on the page are bound in its scope.\n *\n * A page's platform is initialized implicitly when a platform is created via a platform factory\n * (e.g. {@link platformBrowser}), or explicitly by calling the {@link createPlatform} function.\n *\n * @publicApi\n */\nexport declare class PlatformRef {\n    private _injector;\n    private _modules;\n    private _destroyListeners;\n    private _destroyed;\n    /**\n     * Creates an instance of an `@NgModule` for the given platform\n     * for offline compilation.\n     *\n     * @usageNotes\n     * ### Simple Example\n     *\n     * ```typescript\n     * my_module.ts:\n     *\n     * @NgModule({\n     *   imports: [BrowserModule]\n     * })\n     * class MyModule {}\n     *\n     * main.ts:\n     * import {MyModuleNgFactory} from './my_module.ngfactory';\n     * import {platformBrowser} from '@angular/platform-browser';\n     *\n     * let moduleRef = platformBrowser().bootstrapModuleFactory(MyModuleNgFactory);\n     * ```\n     */\n    bootstrapModuleFactory<M>(moduleFactory: NgModuleFactory<M>, options?: BootstrapOptions): Promise<NgModuleRef<M>>;\n    /**\n     * Creates an instance of an `@NgModule` for a given platform using the given runtime compiler.\n     *\n     * @usageNotes\n     * ### Simple Example\n     *\n     * ```typescript\n     * @NgModule({\n     *   imports: [BrowserModule]\n     * })\n     * class MyModule {}\n     *\n     * let moduleRef = platformBrowser().bootstrapModule(MyModule);\n     * ```\n     *\n     */\n    bootstrapModule<M>(moduleType: Type<M>, compilerOptions?: (CompilerOptions & BootstrapOptions) | Array<CompilerOptions & BootstrapOptions>): Promise<NgModuleRef<M>>;\n    private _moduleDoBootstrap;\n    /**\n     * Register a listener to be called when the platform is disposed.\n     */\n    onDestroy(callback: () => void): void;\n    /**\n     * Retrieve the platform {@link Injector}, which is the parent injector for\n     * every Angular application on the page and provides singleton providers.\n     */\n    readonly injector: Injector;\n    /**\n     * Destroy the Angular platform and all Angular applications on the page.\n     */\n    destroy(): void;\n    readonly destroyed: boolean;\n}\n/**\n * A reference to an Angular application running on a page.\n *\n * @publicApi\n */\nexport declare class ApplicationRef {\n    private _zone;\n    private _console;\n    private _injector;\n    private _exceptionHandler;\n    private _componentFactoryResolver;\n    private _initStatus;\n    private _bootstrapListeners;\n    private _views;\n    private _runningTick;\n    private _enforceNoNewChanges;\n    private _stable;\n    /**\n     * Get a list of component types registered to this application.\n     * This list is populated even before the component is created.\n     */\n    readonly componentTypes: Type<any>[];\n    /**\n     * Get a list of components registered to this application.\n     */\n    readonly components: ComponentRef<any>[];\n    /**\n     * Returns an Observable that indicates when the application is stable or unstable.\n     */\n    readonly isStable: Observable<boolean>;\n    /**\n     * Bootstrap a new component at the root level of the application.\n     *\n     * @usageNotes\n     * ### Bootstrap process\n     *\n     * When bootstrapping a new root component into an application, Angular mounts the\n     * specified application component onto DOM elements identified by the componentType's\n     * selector and kicks off automatic change detection to finish initializing the component.\n     *\n     * Optionally, a component can be mounted onto a DOM element that does not match the\n     * componentType's selector.\n     *\n     * ### Example\n     * {@example core/ts/platform/platform.ts region='longform'}\n     */\n    bootstrap<C>(componentOrFactory: ComponentFactory<C> | Type<C>, rootSelectorOrNode?: string | any): ComponentRef<C>;\n    /**\n     * Invoke this method to explicitly process change detection and its side-effects.\n     *\n     * In development mode, `tick()` also performs a second change detection cycle to ensure that no\n     * further changes are detected. If additional changes are picked up during this second cycle,\n     * bindings in the app have side-effects that cannot be resolved in a single change detection\n     * pass.\n     * In this case, Angular throws an error, since an Angular application can only have one change\n     * detection pass during which all change detection must complete.\n     */\n    tick(): void;\n    /**\n     * Attaches a view so that it will be dirty checked.\n     * The view will be automatically detached when it is destroyed.\n     * This will throw if the view is already attached to a ViewContainer.\n     */\n    attachView(viewRef: ViewRef): void;\n    /**\n     * Detaches a view from dirty checking again.\n     */\n    detachView(viewRef: ViewRef): void;\n    private _loadComponent;\n    private _unloadComponent;\n    /**\n     * Returns the number of attached views.\n     */\n    readonly viewCount: number;\n}\n"
  },
  {
    "path": "node_modules/@angular/core/src/application_tokens.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { InjectionToken } from './di';\nimport { ComponentRef } from './linker/component_factory';\n/**\n * A DI Token representing a unique string id assigned to the application by Angular and used\n * primarily for prefixing application attributes and CSS styles when\n * {@link ViewEncapsulation#Emulated ViewEncapsulation.Emulated} is being used.\n *\n * If you need to avoid randomly generated value to be used as an application id, you can provide\n * a custom value via a DI provider <!-- TODO: provider --> configuring the root {@link Injector}\n * using this token.\n * @publicApi\n */\nexport declare const APP_ID: InjectionToken<string>;\nexport declare function _appIdRandomProviderFactory(): string;\n/**\n * Providers that will generate a random APP_ID_TOKEN.\n * @publicApi\n */\nexport declare const APP_ID_RANDOM_PROVIDER: {\n    provide: InjectionToken<string>;\n    useFactory: typeof _appIdRandomProviderFactory;\n    deps: any[];\n};\n/**\n * A function that will be executed when a platform is initialized.\n * @publicApi\n */\nexport declare const PLATFORM_INITIALIZER: InjectionToken<(() => void)[]>;\n/**\n * A token that indicates an opaque platform id.\n * @publicApi\n */\nexport declare const PLATFORM_ID: InjectionToken<Object>;\n/**\n * All callbacks provided via this token will be called for every component that is bootstrapped.\n * Signature of the callback:\n *\n * `(componentRef: ComponentRef) => void`.\n *\n * @publicApi\n */\nexport declare const APP_BOOTSTRAP_LISTENER: InjectionToken<((compRef: ComponentRef<any>) => void)[]>;\n/**\n * A token which indicates the root directory of the application\n * @publicApi\n */\nexport declare const PACKAGE_ROOT_URL: InjectionToken<string>;\n"
  },
  {
    "path": "node_modules/@angular/core/src/change_detection.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * @module\n * @description\n * Change detection enables data binding in Angular.\n */\nexport { ChangeDetectionStrategy, ChangeDetectorRef, CollectionChangeRecord, DefaultIterableDiffer, IterableChangeRecord, IterableChanges, IterableDiffer, IterableDifferFactory, IterableDiffers, KeyValueChangeRecord, KeyValueChanges, KeyValueDiffer, KeyValueDifferFactory, KeyValueDiffers, NgIterable, PipeTransform, SimpleChange, SimpleChanges, TrackByFunction, WrappedValue } from './change_detection/change_detection';\n"
  },
  {
    "path": "node_modules/@angular/core/src/change_detection/change_detection_util.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nexport declare function devModeEqual(a: any, b: any): boolean;\n/**\n * Indicates that the result of a {@link Pipe} transformation has changed even though the\n * reference has not changed.\n *\n * Wrapped values are unwrapped automatically during the change detection, and the unwrapped value\n * is stored.\n *\n * Example:\n *\n * ```\n * if (this._latestValue === this._latestReturnedValue) {\n *    return this._latestReturnedValue;\n *  } else {\n *    this._latestReturnedValue = this._latestValue;\n *    return WrappedValue.wrap(this._latestValue); // this will force update\n *  }\n * ```\n *\n * @publicApi\n */\nexport declare class WrappedValue {\n    /** @deprecated from 5.3, use `unwrap()` instead - will switch to protected */\n    wrapped: any;\n    constructor(value: any);\n    /** Creates a wrapped value. */\n    static wrap(value: any): WrappedValue;\n    /**\n     * Returns the underlying value of a wrapped value.\n     * Returns the given `value` when it is not wrapped.\n     **/\n    static unwrap(value: any): any;\n    /** Returns true if `value` is a wrapped value. */\n    static isWrapped(value: any): value is WrappedValue;\n}\n/**\n * Represents a basic change from a previous to a new value.\n *\n * @publicApi\n */\nexport declare class SimpleChange {\n    previousValue: any;\n    currentValue: any;\n    firstChange: boolean;\n    constructor(previousValue: any, currentValue: any, firstChange: boolean);\n    /**\n     * Check whether the new value is the first value assigned.\n     */\n    isFirstChange(): boolean;\n}\nexport declare function isListLikeIterable(obj: any): boolean;\nexport declare function areIterablesEqual(a: any, b: any, comparator: (a: any, b: any) => boolean): boolean;\nexport declare function iterateListLike(obj: any, fn: (p: any) => any): void;\nexport declare function isJsObject(o: any): boolean;\n"
  },
  {
    "path": "node_modules/@angular/core/src/change_detection/change_detection.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { IterableDiffers } from './differs/iterable_differs';\nimport { KeyValueDiffers } from './differs/keyvalue_differs';\nexport { SimpleChanges } from '../metadata/lifecycle_hooks';\nexport { SimpleChange, WrappedValue, devModeEqual } from './change_detection_util';\nexport { ChangeDetectorRef } from './change_detector_ref';\nexport { ChangeDetectionStrategy, ChangeDetectorStatus, isDefaultChangeDetectionStrategy } from './constants';\nexport { DefaultIterableDifferFactory } from './differs/default_iterable_differ';\nexport { DefaultIterableDiffer } from './differs/default_iterable_differ';\nexport { DefaultKeyValueDifferFactory } from './differs/default_keyvalue_differ';\nexport { CollectionChangeRecord, IterableChangeRecord, IterableChanges, IterableDiffer, IterableDifferFactory, IterableDiffers, NgIterable, TrackByFunction } from './differs/iterable_differs';\nexport { KeyValueChangeRecord, KeyValueChanges, KeyValueDiffer, KeyValueDifferFactory, KeyValueDiffers } from './differs/keyvalue_differs';\nexport { PipeTransform } from './pipe_transform';\nexport declare const defaultIterableDiffers: IterableDiffers;\nexport declare const defaultKeyValueDiffers: KeyValueDiffers;\n"
  },
  {
    "path": "node_modules/@angular/core/src/change_detection/change_detector_ref.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { injectChangeDetectorRef as render3InjectChangeDetectorRef } from '../render3/view_engine_compatibility';\n/**\n * Base class for Angular Views, provides change detection functionality.\n * A change-detection tree collects all views that are to be checked for changes.\n * Use the methods to add and remove views from the tree, initiate change-detection,\n * and explicitly mark views as _dirty_, meaning that they have changed and need to be rerendered.\n *\n * @usageNotes\n *\n * The following examples demonstrate how to modify default change-detection behavior\n * to perform explicit detection when needed.\n *\n * ### Use `markForCheck()` with `CheckOnce` strategy\n *\n * The following example sets the `OnPush` change-detection strategy for a component\n * (`CheckOnce`, rather than the default `CheckAlways`), then forces a second check\n * after an interval. See [live demo](http://plnkr.co/edit/GC512b?p=preview).\n *\n * <code-example path=\"core/ts/change_detect/change-detection.ts\"\n * region=\"mark-for-check\"></code-example>\n *\n * ### Detach change detector to limit how often check occurs\n *\n * The following example defines a component with a large list of read-only data\n * that is expected to change constantly, many times per second.\n * To improve performance, we want to check and update the list\n * less often than the changes actually occur. To do that, we detach\n * the component's change detector and perform an explicit local check every five seconds.\n *\n * <code-example path=\"core/ts/change_detect/change-detection.ts\" region=\"detach\"></code-example>\n *\n *\n * ### Reattaching a detached component\n *\n * The following example creates a component displaying live data.\n * The component detaches its change detector from the main change detector tree\n * when the `live` property is set to false, and reattaches it when the property\n * becomes true.\n *\n * <code-example path=\"core/ts/change_detect/change-detection.ts\" region=\"reattach\"></code-example>\n *\n * @publicApi\n */\nexport declare abstract class ChangeDetectorRef {\n    /**\n     * When a view uses the {@link ChangeDetectionStrategy#OnPush OnPush} (checkOnce)\n     * change detection strategy, explicitly marks the view as changed so that\n     * it can be checked again.\n     *\n     * Components are normally marked as dirty (in need of rerendering) when inputs\n     * have changed or events have fired in the view. Call this method to ensure that\n     * a component is checked even if these triggers have not occured.\n     *\n     * <!-- TODO: Add a link to a chapter on OnPush components -->\n     *\n     */\n    abstract markForCheck(): void;\n    /**\n     * Detaches this view from the change-detection tree.\n     * A detached view is  not checked until it is reattached.\n     * Use in combination with `detectChanges()` to implement local change detection checks.\n     *\n     * Detached views are not checked during change detection runs until they are\n     * re-attached, even if they are marked as dirty.\n     *\n     * <!-- TODO: Add a link to a chapter on detach/reattach/local digest -->\n     * <!-- TODO: Add a live demo once ref.detectChanges is merged into master -->\n     *\n     */\n    abstract detach(): void;\n    /**\n     * Checks this view and its children. Use in combination with {@link ChangeDetectorRef#detach\n     * detach}\n     * to implement local change detection checks.\n     *\n     * <!-- TODO: Add a link to a chapter on detach/reattach/local digest -->\n     * <!-- TODO: Add a live demo once ref.detectChanges is merged into master -->\n     *\n     */\n    abstract detectChanges(): void;\n    /**\n     * Checks the change detector and its children, and throws if any changes are detected.\n     *\n     * Use in development mode to verify that running change detection doesn't introduce\n     * other changes.\n     */\n    abstract checkNoChanges(): void;\n    /**\n     * Re-attaches the previously detached view to the change detection tree.\n     * Views are attached to the tree by default.\n     *\n     * <!-- TODO: Add a link to a chapter on detach/reattach/local digest -->\n     *\n     */\n    abstract reattach(): void;\n}\nexport declare const SWITCH_CHANGE_DETECTOR_REF_FACTORY__POST_R3__: typeof render3InjectChangeDetectorRef;\n"
  },
  {
    "path": "node_modules/@angular/core/src/change_detection/constants.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * The strategy that the default change detector uses to detect changes.\n * When set, takes effect the next time change detection is triggered.\n *\n * @publicApi\n */\nexport declare enum ChangeDetectionStrategy {\n    /**\n     * Use the `CheckOnce` strategy, meaning that automatic change detection is deactivated\n     * until reactivated by setting the strategy to `Default` (`CheckAlways`).\n     * Change detection can still be explictly invoked.\n     */\n    OnPush = 0,\n    /**\n     * Use the default `CheckAlways` strategy, in which change detection is automatic until\n     * explicitly deactivated.\n     */\n    Default = 1\n}\n/**\n * Defines the possible states of the default change detector.\n * @see `ChangeDetectorRef`\n */\nexport declare enum ChangeDetectorStatus {\n    /**\n     * A state in which, after calling `detectChanges()`, the change detector\n     * state becomes `Checked`, and must be explicitly invoked or reactivated.\n     */\n    CheckOnce = 0,\n    /**\n     * A state in which change detection is skipped until the change detector mode\n     * becomes `CheckOnce`.\n     */\n    Checked = 1,\n    /**\n     * A state in which change detection continues automatically until explictly\n     * deactivated.\n     */\n    CheckAlways = 2,\n    /**\n     * A state in which a change detector sub tree is not a part of the main tree and\n     * should be skipped.\n     */\n    Detached = 3,\n    /**\n     * Indicates that the change detector encountered an error checking a binding\n     * or calling a directive lifecycle method and is now in an inconsistent state. Change\n     * detectors in this state do not detect changes.\n     */\n    Errored = 4,\n    /**\n     * Indicates that the change detector has been destroyed.\n     */\n    Destroyed = 5\n}\n/**\n * Reports whether a given strategy is currently the default for change detection.\n * @param changeDetectionStrategy The strategy to check.\n * @returns True if the given strategy is the current default, false otherwise.\n * @see `ChangeDetectorStatus`\n * @see `ChangeDetectorRef`\n */\nexport declare function isDefaultChangeDetectionStrategy(changeDetectionStrategy: ChangeDetectionStrategy): boolean;\n"
  },
  {
    "path": "node_modules/@angular/core/src/change_detection/differs/default_iterable_differ.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { IterableChangeRecord, IterableChanges, IterableDiffer, IterableDifferFactory, NgIterable, TrackByFunction } from './iterable_differs';\nexport declare class DefaultIterableDifferFactory implements IterableDifferFactory {\n    constructor();\n    supports(obj: Object | null | undefined): boolean;\n    create<V>(trackByFn?: TrackByFunction<V>): DefaultIterableDiffer<V>;\n}\n/**\n * @deprecated v4.0.0 - Should not be part of public API.\n * @publicApi\n */\nexport declare class DefaultIterableDiffer<V> implements IterableDiffer<V>, IterableChanges<V> {\n    readonly length: number;\n    readonly collection: V[] | Iterable<V> | null;\n    private _linkedRecords;\n    private _unlinkedRecords;\n    private _previousItHead;\n    private _itHead;\n    private _itTail;\n    private _additionsHead;\n    private _additionsTail;\n    private _movesHead;\n    private _movesTail;\n    private _removalsHead;\n    private _removalsTail;\n    private _identityChangesHead;\n    private _identityChangesTail;\n    private _trackByFn;\n    constructor(trackByFn?: TrackByFunction<V>);\n    forEachItem(fn: (record: IterableChangeRecord_<V>) => void): void;\n    forEachOperation(fn: (item: IterableChangeRecord<V>, previousIndex: number | null, currentIndex: number | null) => void): void;\n    forEachPreviousItem(fn: (record: IterableChangeRecord_<V>) => void): void;\n    forEachAddedItem(fn: (record: IterableChangeRecord_<V>) => void): void;\n    forEachMovedItem(fn: (record: IterableChangeRecord_<V>) => void): void;\n    forEachRemovedItem(fn: (record: IterableChangeRecord_<V>) => void): void;\n    forEachIdentityChange(fn: (record: IterableChangeRecord_<V>) => void): void;\n    diff(collection: NgIterable<V>): DefaultIterableDiffer<V> | null;\n    onDestroy(): void;\n    check(collection: NgIterable<V>): boolean;\n    readonly isDirty: boolean;\n    private _addToRemovals;\n}\nexport declare class IterableChangeRecord_<V> implements IterableChangeRecord<V> {\n    item: V;\n    trackById: any;\n    currentIndex: number | null;\n    previousIndex: number | null;\n    constructor(item: V, trackById: any);\n}\n"
  },
  {
    "path": "node_modules/@angular/core/src/change_detection/differs/default_keyvalue_differ.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { KeyValueChangeRecord, KeyValueChanges, KeyValueDiffer, KeyValueDifferFactory } from './keyvalue_differs';\nexport declare class DefaultKeyValueDifferFactory<K, V> implements KeyValueDifferFactory {\n    constructor();\n    supports(obj: any): boolean;\n    create<K, V>(): KeyValueDiffer<K, V>;\n}\nexport declare class DefaultKeyValueDiffer<K, V> implements KeyValueDiffer<K, V>, KeyValueChanges<K, V> {\n    private _records;\n    private _mapHead;\n    private _appendAfter;\n    private _previousMapHead;\n    private _changesHead;\n    private _changesTail;\n    private _additionsHead;\n    private _additionsTail;\n    private _removalsHead;\n    private _removalsTail;\n    readonly isDirty: boolean;\n    forEachItem(fn: (r: KeyValueChangeRecord<K, V>) => void): void;\n    forEachPreviousItem(fn: (r: KeyValueChangeRecord<K, V>) => void): void;\n    forEachChangedItem(fn: (r: KeyValueChangeRecord<K, V>) => void): void;\n    forEachAddedItem(fn: (r: KeyValueChangeRecord<K, V>) => void): void;\n    forEachRemovedItem(fn: (r: KeyValueChangeRecord<K, V>) => void): void;\n    diff(map?: Map<any, any> | {\n        [k: string]: any;\n    } | null): any;\n    onDestroy(): void;\n    /**\n     * Check the current state of the map vs the previous.\n     * The algorithm is optimised for when the keys do no change.\n     */\n    check(map: Map<any, any> | {\n        [k: string]: any;\n    }): boolean;\n    /**\n     * Inserts a record before `before` or append at the end of the list when `before` is null.\n     *\n     * Notes:\n     * - This method appends at `this._appendAfter`,\n     * - This method updates `this._appendAfter`,\n     * - The return value is the new value for the insertion pointer.\n     */\n    private _insertBeforeOrAppend;\n    private _getOrCreateRecordForKey;\n    private _maybeAddToChanges;\n    private _addToAdditions;\n    private _addToChanges;\n}\n"
  },
  {
    "path": "node_modules/@angular/core/src/change_detection/differs/iterable_differs.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { StaticProvider } from '../../di/provider';\n/**\n * A type describing supported iterable types.\n *\n * @publicApi\n */\nexport declare type NgIterable<T> = Array<T> | Iterable<T>;\n/**\n * A strategy for tracking changes over time to an iterable. Used by {@link NgForOf} to\n * respond to changes in an iterable by effecting equivalent changes in the DOM.\n *\n * @publicApi\n */\nexport interface IterableDiffer<V> {\n    /**\n     * Compute a difference between the previous state and the new `object` state.\n     *\n     * @param object containing the new value.\n     * @returns an object describing the difference. The return value is only valid until the next\n     * `diff()` invocation.\n     */\n    diff(object: NgIterable<V>): IterableChanges<V> | null;\n}\n/**\n * An object describing the changes in the `Iterable` collection since last time\n * `IterableDiffer#diff()` was invoked.\n *\n * @publicApi\n */\nexport interface IterableChanges<V> {\n    /**\n     * Iterate over all changes. `IterableChangeRecord` will contain information about changes\n     * to each item.\n     */\n    forEachItem(fn: (record: IterableChangeRecord<V>) => void): void;\n    /**\n     * Iterate over a set of operations which when applied to the original `Iterable` will produce the\n     * new `Iterable`.\n     *\n     * NOTE: These are not necessarily the actual operations which were applied to the original\n     * `Iterable`, rather these are a set of computed operations which may not be the same as the\n     * ones applied.\n     *\n     * @param record A change which needs to be applied\n     * @param previousIndex The `IterableChangeRecord#previousIndex` of the `record` refers to the\n     *        original `Iterable` location, where as `previousIndex` refers to the transient location\n     *        of the item, after applying the operations up to this point.\n     * @param currentIndex The `IterableChangeRecord#currentIndex` of the `record` refers to the\n     *        original `Iterable` location, where as `currentIndex` refers to the transient location\n     *        of the item, after applying the operations up to this point.\n     */\n    forEachOperation(fn: (record: IterableChangeRecord<V>, previousIndex: number | null, currentIndex: number | null) => void): void;\n    /**\n     * Iterate over changes in the order of original `Iterable` showing where the original items\n     * have moved.\n     */\n    forEachPreviousItem(fn: (record: IterableChangeRecord<V>) => void): void;\n    /** Iterate over all added items. */\n    forEachAddedItem(fn: (record: IterableChangeRecord<V>) => void): void;\n    /** Iterate over all moved items. */\n    forEachMovedItem(fn: (record: IterableChangeRecord<V>) => void): void;\n    /** Iterate over all removed items. */\n    forEachRemovedItem(fn: (record: IterableChangeRecord<V>) => void): void;\n    /** Iterate over all items which had their identity (as computed by the `TrackByFunction`)\n     * changed. */\n    forEachIdentityChange(fn: (record: IterableChangeRecord<V>) => void): void;\n}\n/**\n * Record representing the item change information.\n *\n * @publicApi\n */\nexport interface IterableChangeRecord<V> {\n    /** Current index of the item in `Iterable` or null if removed. */\n    readonly currentIndex: number | null;\n    /** Previous index of the item in `Iterable` or null if added. */\n    readonly previousIndex: number | null;\n    /** The item. */\n    readonly item: V;\n    /** Track by identity as computed by the `TrackByFunction`. */\n    readonly trackById: any;\n}\n/**\n * @deprecated v4.0.0 - Use IterableChangeRecord instead.\n * @publicApi\n */\nexport interface CollectionChangeRecord<V> extends IterableChangeRecord<V> {\n}\n/**\n * An optional function passed into {@link NgForOf} that defines how to track\n * items in an iterable (e.g. fby index or id)\n *\n * @publicApi\n */\nexport interface TrackByFunction<T> {\n    (index: number, item: T): any;\n}\n/**\n * Provides a factory for {@link IterableDiffer}.\n *\n * @publicApi\n */\nexport interface IterableDifferFactory {\n    supports(objects: any): boolean;\n    create<V>(trackByFn?: TrackByFunction<V>): IterableDiffer<V>;\n}\n/**\n * A repository of different iterable diffing strategies used by NgFor, NgClass, and others.\n *\n * @publicApi\n */\nexport declare class IterableDiffers {\n    /** @nocollapse */\n    static ngInjectableDef: never;\n    /**\n     * @deprecated v4.0.0 - Should be private\n     */\n    factories: IterableDifferFactory[];\n    constructor(factories: IterableDifferFactory[]);\n    static create(factories: IterableDifferFactory[], parent?: IterableDiffers): IterableDiffers;\n    /**\n     * Takes an array of {@link IterableDifferFactory} and returns a provider used to extend the\n     * inherited {@link IterableDiffers} instance with the provided factories and return a new\n     * {@link IterableDiffers} instance.\n     *\n     * @usageNotes\n     * ### Example\n     *\n     * The following example shows how to extend an existing list of factories,\n     * which will only be applied to the injector for this component and its children.\n     * This step is all that's required to make a new {@link IterableDiffer} available.\n     *\n     * ```\n     * @Component({\n     *   viewProviders: [\n     *     IterableDiffers.extend([new ImmutableListDiffer()])\n     *   ]\n     * })\n     * ```\n     */\n    static extend(factories: IterableDifferFactory[]): StaticProvider;\n    find(iterable: any): IterableDifferFactory;\n}\nexport declare function getTypeNameForDebugging(type: any): string;\n"
  },
  {
    "path": "node_modules/@angular/core/src/change_detection/differs/keyvalue_differs.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { StaticProvider } from '../../di';\n/**\n * A differ that tracks changes made to an object over time.\n *\n * @publicApi\n */\nexport interface KeyValueDiffer<K, V> {\n    /**\n     * Compute a difference between the previous state and the new `object` state.\n     *\n     * @param object containing the new value.\n     * @returns an object describing the difference. The return value is only valid until the next\n     * `diff()` invocation.\n     */\n    diff(object: Map<K, V>): KeyValueChanges<K, V> | null;\n    /**\n     * Compute a difference between the previous state and the new `object` state.\n     *\n     * @param object containing the new value.\n     * @returns an object describing the difference. The return value is only valid until the next\n     * `diff()` invocation.\n     */\n    diff(object: {\n        [key: string]: V;\n    }): KeyValueChanges<string, V> | null;\n}\n/**\n * An object describing the changes in the `Map` or `{[k:string]: string}` since last time\n * `KeyValueDiffer#diff()` was invoked.\n *\n * @publicApi\n */\nexport interface KeyValueChanges<K, V> {\n    /**\n     * Iterate over all changes. `KeyValueChangeRecord` will contain information about changes\n     * to each item.\n     */\n    forEachItem(fn: (r: KeyValueChangeRecord<K, V>) => void): void;\n    /**\n     * Iterate over changes in the order of original Map showing where the original items\n     * have moved.\n     */\n    forEachPreviousItem(fn: (r: KeyValueChangeRecord<K, V>) => void): void;\n    /**\n     * Iterate over all keys for which values have changed.\n     */\n    forEachChangedItem(fn: (r: KeyValueChangeRecord<K, V>) => void): void;\n    /**\n     * Iterate over all added items.\n     */\n    forEachAddedItem(fn: (r: KeyValueChangeRecord<K, V>) => void): void;\n    /**\n     * Iterate over all removed items.\n     */\n    forEachRemovedItem(fn: (r: KeyValueChangeRecord<K, V>) => void): void;\n}\n/**\n * Record representing the item change information.\n *\n * @publicApi\n */\nexport interface KeyValueChangeRecord<K, V> {\n    /**\n     * Current key in the Map.\n     */\n    readonly key: K;\n    /**\n     * Current value for the key or `null` if removed.\n     */\n    readonly currentValue: V | null;\n    /**\n     * Previous value for the key or `null` if added.\n     */\n    readonly previousValue: V | null;\n}\n/**\n * Provides a factory for {@link KeyValueDiffer}.\n *\n * @publicApi\n */\nexport interface KeyValueDifferFactory {\n    /**\n     * Test to see if the differ knows how to diff this kind of object.\n     */\n    supports(objects: any): boolean;\n    /**\n     * Create a `KeyValueDiffer`.\n     */\n    create<K, V>(): KeyValueDiffer<K, V>;\n}\n/**\n * A repository of different Map diffing strategies used by NgClass, NgStyle, and others.\n *\n * @publicApi\n */\nexport declare class KeyValueDiffers {\n    /** @nocollapse */\n    static ngInjectableDef: never;\n    /**\n     * @deprecated v4.0.0 - Should be private.\n     */\n    factories: KeyValueDifferFactory[];\n    constructor(factories: KeyValueDifferFactory[]);\n    static create<S>(factories: KeyValueDifferFactory[], parent?: KeyValueDiffers): KeyValueDiffers;\n    /**\n     * Takes an array of {@link KeyValueDifferFactory} and returns a provider used to extend the\n     * inherited {@link KeyValueDiffers} instance with the provided factories and return a new\n     * {@link KeyValueDiffers} instance.\n     *\n     * @usageNotes\n     * ### Example\n     *\n     * The following example shows how to extend an existing list of factories,\n     * which will only be applied to the injector for this component and its children.\n     * This step is all that's required to make a new {@link KeyValueDiffer} available.\n     *\n     * ```\n     * @Component({\n     *   viewProviders: [\n     *     KeyValueDiffers.extend([new ImmutableMapDiffer()])\n     *   ]\n     * })\n     * ```\n     */\n    static extend<S>(factories: KeyValueDifferFactory[]): StaticProvider;\n    find(kv: any): KeyValueDifferFactory;\n}\n"
  },
  {
    "path": "node_modules/@angular/core/src/change_detection/pipe_transform.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * To create a Pipe, you must implement this interface.\n *\n * Angular invokes the `transform` method with the value of a binding\n * as the first argument, and any parameters as the second argument in list form.\n *\n * @usageNotes\n * ### Example\n *\n * The `RepeatPipe` below repeats the value as many times as indicated by the first argument:\n *\n * ```\n * import {Pipe, PipeTransform} from '@angular/core';\n *\n * @Pipe({name: 'repeat'})\n * export class RepeatPipe implements PipeTransform {\n *   transform(value: any, times: number) {\n *     return value.repeat(times);\n *   }\n * }\n * ```\n *\n * Invoking `{{ 'ok' | repeat:3 }}` in a template produces `okokok`.\n *\n * @publicApi\n */\nexport interface PipeTransform {\n    transform(value: any, ...args: any[]): any;\n}\n"
  },
  {
    "path": "node_modules/@angular/core/src/codegen_private_exports.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nexport { CodegenComponentFactoryResolver as ɵCodegenComponentFactoryResolver } from './linker/component_factory_resolver';\nexport { registerModuleFactory as ɵregisterModuleFactory } from './linker/ng_module_factory_loader';\nexport { ArgumentType as ɵArgumentType, BindingFlags as ɵBindingFlags, DepFlags as ɵDepFlags, EMPTY_ARRAY as ɵEMPTY_ARRAY, EMPTY_MAP as ɵEMPTY_MAP, NodeFlags as ɵNodeFlags, QueryBindingType as ɵQueryBindingType, QueryValueType as ɵQueryValueType, ViewDefinition as ɵViewDefinition, ViewFlags as ɵViewFlags, anchorDef as ɵand, createComponentFactory as ɵccf, createNgModuleFactory as ɵcmf, createRendererType2 as ɵcrt, directiveDef as ɵdid, elementDef as ɵeld, elementEventFullName as ɵelementEventFullName, getComponentViewDefinitionFactory as ɵgetComponentViewDefinitionFactory, inlineInterpolate as ɵinlineInterpolate, interpolate as ɵinterpolate, moduleDef as ɵmod, moduleProvideDef as ɵmpd, ngContentDef as ɵncd, nodeValue as ɵnov, pipeDef as ɵpid, providerDef as ɵprd, pureArrayDef as ɵpad, pureObjectDef as ɵpod, purePipeDef as ɵppd, queryDef as ɵqud, textDef as ɵted, unwrapValue as ɵunv, viewDef as ɵvid } from './view/index';\n"
  },
  {
    "path": "node_modules/@angular/core/src/console.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nexport declare class Console {\n    log(message: string): void;\n    warn(message: string): void;\n}\n"
  },
  {
    "path": "node_modules/@angular/core/src/core_private_export.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nexport { ALLOW_MULTIPLE_PLATFORMS as ɵALLOW_MULTIPLE_PLATFORMS } from './application_ref';\nexport { APP_ID_RANDOM_PROVIDER as ɵAPP_ID_RANDOM_PROVIDER } from './application_tokens';\nexport { defaultIterableDiffers as ɵdefaultIterableDiffers, defaultKeyValueDiffers as ɵdefaultKeyValueDiffers } from './change_detection/change_detection';\nexport { devModeEqual as ɵdevModeEqual } from './change_detection/change_detection_util';\nexport { isListLikeIterable as ɵisListLikeIterable } from './change_detection/change_detection_util';\nexport { ChangeDetectorStatus as ɵChangeDetectorStatus, isDefaultChangeDetectionStrategy as ɵisDefaultChangeDetectionStrategy } from './change_detection/constants';\nexport { Console as ɵConsole } from './console';\nexport { InjectableDef as ɵInjectableDef, InjectorDef as ɵInjectorDef, getInjectableDef as ɵgetInjectableDef } from './di/defs';\nexport { inject as ɵinject, setCurrentInjector as ɵsetCurrentInjector } from './di/injector_compatibility';\nexport { APP_ROOT as ɵAPP_ROOT } from './di/scope';\nexport { ivyEnabled as ɵivyEnabled } from './ivy_switch';\nexport { ComponentFactory as ɵComponentFactory } from './linker/component_factory';\nexport { CodegenComponentFactoryResolver as ɵCodegenComponentFactoryResolver } from './linker/component_factory_resolver';\nexport { resolveComponentResources as ɵresolveComponentResources } from './metadata/resource_loading';\nexport { ReflectionCapabilities as ɵReflectionCapabilities } from './reflection/reflection_capabilities';\nexport { GetterFn as ɵGetterFn, MethodFn as ɵMethodFn, SetterFn as ɵSetterFn } from './reflection/types';\nexport { DirectRenderer as ɵDirectRenderer, RenderDebugInfo as ɵRenderDebugInfo } from './render/api';\nexport { _sanitizeHtml as ɵ_sanitizeHtml } from './sanitization/html_sanitizer';\nexport { _sanitizeStyle as ɵ_sanitizeStyle } from './sanitization/style_sanitizer';\nexport { _sanitizeUrl as ɵ_sanitizeUrl } from './sanitization/url_sanitizer';\nexport { global as ɵglobal, looseIdentical as ɵlooseIdentical, stringify as ɵstringify } from './util';\nexport { makeDecorator as ɵmakeDecorator } from './util/decorators';\nexport { isObservable as ɵisObservable, isPromise as ɵisPromise } from './util/lang';\nexport { clearOverrides as ɵclearOverrides, initServicesIfNeeded as ɵinitServicesIfNeeded, overrideComponentView as ɵoverrideComponentView, overrideProvider as ɵoverrideProvider } from './view/index';\nexport { NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR as ɵNOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR } from './view/provider';\n"
  },
  {
    "path": "node_modules/@angular/core/src/core_render3_private_export.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nexport { defineBase as ɵdefineBase, defineComponent as ɵdefineComponent, defineDirective as ɵdefineDirective, definePipe as ɵdefinePipe, defineNgModule as ɵdefineNgModule, detectChanges as ɵdetectChanges, renderComponent as ɵrenderComponent, ComponentType as ɵComponentType, ComponentFactory as ɵRender3ComponentFactory, ComponentRef as ɵRender3ComponentRef, DirectiveType as ɵDirectiveType, RenderFlags as ɵRenderFlags, directiveInject as ɵdirectiveInject, injectAttribute as ɵinjectAttribute, getFactoryOf as ɵgetFactoryOf, getInheritedFactory as ɵgetInheritedFactory, templateRefExtractor as ɵtemplateRefExtractor, ProvidersFeature as ɵProvidersFeature, InheritDefinitionFeature as ɵInheritDefinitionFeature, NgOnChangesFeature as ɵNgOnChangesFeature, LifecycleHooksFeature as ɵLifecycleHooksFeature, NgModuleType as ɵNgModuleType, NgModuleRef as ɵRender3NgModuleRef, CssSelectorList as ɵCssSelectorList, markDirty as ɵmarkDirty, NgModuleFactory as ɵNgModuleFactory, NO_CHANGE as ɵNO_CHANGE, container as ɵcontainer, nextContext as ɵnextContext, elementStart as ɵelementStart, namespaceHTML as ɵnamespaceHTML, namespaceMathML as ɵnamespaceMathML, namespaceSVG as ɵnamespaceSVG, element as ɵelement, listener as ɵlistener, text as ɵtext, embeddedViewStart as ɵembeddedViewStart, query as ɵquery, registerContentQuery as ɵregisterContentQuery, projection as ɵprojection, bind as ɵbind, interpolation1 as ɵinterpolation1, interpolation2 as ɵinterpolation2, interpolation3 as ɵinterpolation3, interpolation4 as ɵinterpolation4, interpolation5 as ɵinterpolation5, interpolation6 as ɵinterpolation6, interpolation7 as ɵinterpolation7, interpolation8 as ɵinterpolation8, interpolationV as ɵinterpolationV, pipeBind1 as ɵpipeBind1, pipeBind2 as ɵpipeBind2, pipeBind3 as ɵpipeBind3, pipeBind4 as ɵpipeBind4, pipeBindV as ɵpipeBindV, pureFunction0 as ɵpureFunction0, pureFunction1 as ɵpureFunction1, pureFunction2 as ɵpureFunction2, pureFunction3 as ɵpureFunction3, pureFunction4 as ɵpureFunction4, pureFunction5 as ɵpureFunction5, pureFunction6 as ɵpureFunction6, pureFunction7 as ɵpureFunction7, pureFunction8 as ɵpureFunction8, pureFunctionV as ɵpureFunctionV, getCurrentView as ɵgetCurrentView, restoreView as ɵrestoreView, containerRefreshStart as ɵcontainerRefreshStart, containerRefreshEnd as ɵcontainerRefreshEnd, queryRefresh as ɵqueryRefresh, loadQueryList as ɵloadQueryList, elementEnd as ɵelementEnd, elementProperty as ɵelementProperty, projectionDef as ɵprojectionDef, reference as ɵreference, enableBindings as ɵenableBindings, disableBindings as ɵdisableBindings, elementAttribute as ɵelementAttribute, elementContainerStart as ɵelementContainerStart, elementContainerEnd as ɵelementContainerEnd, elementStyling as ɵelementStyling, elementStylingMap as ɵelementStylingMap, elementStyleProp as ɵelementStyleProp, elementStylingApply as ɵelementStylingApply, elementClassProp as ɵelementClassProp, textBinding as ɵtextBinding, template as ɵtemplate, embeddedViewEnd as ɵembeddedViewEnd, store as ɵstore, load as ɵload, pipe as ɵpipe, BaseDef as ɵBaseDef, ComponentDef as ɵComponentDef, ComponentDefWithMeta as ɵComponentDefWithMeta, DirectiveDef as ɵDirectiveDef, DirectiveDefWithMeta as ɵDirectiveDefWithMeta, PipeDef as ɵPipeDef, PipeDefWithMeta as ɵPipeDefWithMeta, whenRendered as ɵwhenRendered, i18n as ɵi18n, i18nAttributes as ɵi18nAttributes, i18nExp as ɵi18nExp, i18nStart as ɵi18nStart, i18nEnd as ɵi18nEnd, i18nApply as ɵi18nApply, i18nPostprocess as ɵi18nPostprocess, WRAP_RENDERER_FACTORY2 as ɵWRAP_RENDERER_FACTORY2, setClassMetadata as ɵsetClassMetadata, } from './render3/index';\nexport { Render3DebugRendererFactory2 as ɵRender3DebugRendererFactory2 } from './render3/debug';\nexport { compileComponent as ɵcompileComponent, compileDirective as ɵcompileDirective, } from './render3/jit/directive';\nexport { compileNgModule as ɵcompileNgModule, compileNgModuleDefs as ɵcompileNgModuleDefs, patchComponentDefWithScope as ɵpatchComponentDefWithScope, } from './render3/jit/module';\nexport { compilePipe as ɵcompilePipe, } from './render3/jit/pipe';\nexport { NgModuleDef as ɵNgModuleDef, NgModuleDefWithMeta as ɵNgModuleDefWithMeta, NgModuleTransitiveScopes as ɵNgModuleTransitiveScopes, } from './metadata/ng_module';\nexport { sanitizeHtml as ɵsanitizeHtml, sanitizeStyle as ɵsanitizeStyle, sanitizeUrl as ɵsanitizeUrl, sanitizeResourceUrl as ɵsanitizeResourceUrl, } from './sanitization/sanitization';\nexport { bypassSanitizationTrustHtml as ɵbypassSanitizationTrustHtml, bypassSanitizationTrustStyle as ɵbypassSanitizationTrustStyle, bypassSanitizationTrustScript as ɵbypassSanitizationTrustScript, bypassSanitizationTrustUrl as ɵbypassSanitizationTrustUrl, bypassSanitizationTrustResourceUrl as ɵbypassSanitizationTrustResourceUrl, } from './sanitization/bypass';\nexport { getContext as ɵgetContext } from './render3/context_discovery';\nexport { Player as ɵPlayer, PlayerFactory as ɵPlayerFactory, PlayState as ɵPlayState, PlayerHandler as ɵPlayerHandler, } from './render3/interfaces/player';\nexport { LContext as ɵLContext, } from './render3/interfaces/context';\nexport { bindPlayerFactory as ɵbindPlayerFactory, } from './render3/styling/player_factory';\nexport { addPlayer as ɵaddPlayer, getPlayers as ɵgetPlayers, } from './render3/players';\nexport { compileNgModuleFactory__POST_R3__ as ɵcompileNgModuleFactory__POST_R3__ } from './application_ref';\nexport { SWITCH_COMPILE_COMPONENT__POST_R3__ as ɵSWITCH_COMPILE_COMPONENT__POST_R3__, SWITCH_COMPILE_DIRECTIVE__POST_R3__ as ɵSWITCH_COMPILE_DIRECTIVE__POST_R3__, SWITCH_COMPILE_PIPE__POST_R3__ as ɵSWITCH_COMPILE_PIPE__POST_R3__, } from './metadata/directives';\nexport { SWITCH_COMPILE_NGMODULE__POST_R3__ as ɵSWITCH_COMPILE_NGMODULE__POST_R3__, } from './metadata/ng_module';\nexport { SWITCH_COMPILE_INJECTABLE__POST_R3__ as ɵSWITCH_COMPILE_INJECTABLE__POST_R3__, } from './di/injectable';\nexport { SWITCH_IVY_ENABLED__POST_R3__ as ɵSWITCH_IVY_ENABLED__POST_R3__, } from './ivy_switch';\nexport { SWITCH_CHANGE_DETECTOR_REF_FACTORY__POST_R3__ as ɵSWITCH_CHANGE_DETECTOR_REF_FACTORY__POST_R3__, } from './change_detection/change_detector_ref';\nexport { SWITCH_ELEMENT_REF_FACTORY__POST_R3__ as ɵSWITCH_ELEMENT_REF_FACTORY__POST_R3__, } from './linker/element_ref';\nexport { SWITCH_TEMPLATE_REF_FACTORY__POST_R3__ as ɵSWITCH_TEMPLATE_REF_FACTORY__POST_R3__, } from './linker/template_ref';\nexport { SWITCH_VIEW_CONTAINER_REF_FACTORY__POST_R3__ as ɵSWITCH_VIEW_CONTAINER_REF_FACTORY__POST_R3__, } from './linker/view_container_ref';\nexport { SWITCH_RENDERER2_FACTORY__POST_R3__ as ɵSWITCH_RENDERER2_FACTORY__POST_R3__, } from './render/api';\nexport { publishGlobalUtil as ɵpublishGlobalUtil, publishDefaultGlobalUtils as ɵpublishDefaultGlobalUtils } from './render3/global_utils';\nexport { SWITCH_INJECTOR_FACTORY__POST_R3__ as ɵSWITCH_INJECTOR_FACTORY__POST_R3__, } from './di/injector';\n"
  },
  {
    "path": "node_modules/@angular/core/src/core.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * @module\n * @description\n * Entry point from which you should import all public core APIs.\n */\nexport * from './metadata';\nexport * from './version';\nexport { TypeDecorator } from './util/decorators';\nexport * from './di';\nexport { createPlatform, assertPlatform, destroyPlatform, getPlatform, PlatformRef, ApplicationRef, createPlatformFactory, NgProbeToken } from './application_ref';\nexport { enableProdMode, isDevMode } from './is_dev_mode';\nexport { APP_ID, PACKAGE_ROOT_URL, PLATFORM_INITIALIZER, PLATFORM_ID, APP_BOOTSTRAP_LISTENER } from './application_tokens';\nexport { APP_INITIALIZER, ApplicationInitStatus } from './application_init';\nexport * from './zone';\nexport * from './render';\nexport * from './linker';\nexport { DebugElement, DebugNode, asNativeElements, getDebugNode, Predicate } from './debug/debug_node';\nexport { GetTestability, Testability, TestabilityRegistry, setTestabilityGetter } from './testability/testability';\nexport * from './change_detection';\nexport * from './platform_core_providers';\nexport { TRANSLATIONS, TRANSLATIONS_FORMAT, LOCALE_ID, MissingTranslationStrategy } from './i18n/tokens';\nexport { ApplicationModule } from './application_module';\nexport { wtfCreateScope, wtfLeave, wtfStartTimeRange, wtfEndTimeRange, WtfScopeFn } from './profile/profile';\nexport { Type } from './type';\nexport { EventEmitter } from './event_emitter';\nexport { ErrorHandler } from './error_handler';\nexport * from './core_private_export';\nexport * from './core_render3_private_export';\nexport { Sanitizer, SecurityContext } from './sanitization/security';\nexport * from './codegen_private_exports';\n"
  },
  {
    "path": "node_modules/@angular/core/src/debug/debug_node.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { Injector } from '../di';\nimport { DebugContext } from '../view/index';\nexport declare class EventListener {\n    name: string;\n    callback: Function;\n    constructor(name: string, callback: Function);\n}\n/**\n * @publicApi\n */\nexport declare class DebugNode {\n    nativeNode: any;\n    private _debugContext;\n    listeners: EventListener[];\n    parent: DebugElement | null;\n    constructor(nativeNode: any, parent: DebugNode | null, _debugContext: DebugContext);\n    readonly injector: Injector;\n    readonly componentInstance: any;\n    readonly context: any;\n    readonly references: {\n        [key: string]: any;\n    };\n    readonly providerTokens: any[];\n}\n/**\n * @publicApi\n */\nexport declare class DebugElement extends DebugNode {\n    name: string;\n    properties: {\n        [key: string]: any;\n    };\n    attributes: {\n        [key: string]: string | null;\n    };\n    classes: {\n        [key: string]: boolean;\n    };\n    styles: {\n        [key: string]: string | null;\n    };\n    childNodes: DebugNode[];\n    nativeElement: any;\n    constructor(nativeNode: any, parent: any, _debugContext: DebugContext);\n    addChild(child: DebugNode): void;\n    removeChild(child: DebugNode): void;\n    insertChildrenAfter(child: DebugNode, newChildren: DebugNode[]): void;\n    insertBefore(refChild: DebugNode, newChild: DebugNode): void;\n    query(predicate: Predicate<DebugElement>): DebugElement;\n    queryAll(predicate: Predicate<DebugElement>): DebugElement[];\n    queryAllNodes(predicate: Predicate<DebugNode>): DebugNode[];\n    readonly children: DebugElement[];\n    triggerEventHandler(eventName: string, eventObj: any): void;\n}\n/**\n * @publicApi\n */\nexport declare function asNativeElements(debugEls: DebugElement[]): any;\n/**\n * @publicApi\n */\nexport declare function getDebugNode(nativeNode: any): DebugNode | null;\nexport declare function getAllDebugNodes(): DebugNode[];\nexport declare function indexDebugNode(node: DebugNode): void;\nexport declare function removeDebugNodeFromIndex(node: DebugNode): void;\n/**\n * A boolean-valued function over a value, possibly including context information\n * regarding that value's position in an array.\n *\n * @publicApi\n */\nexport interface Predicate<T> {\n    (value: T): boolean;\n}\n"
  },
  {
    "path": "node_modules/@angular/core/src/di.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * @module\n * @description\n * The `di` module provides dependency injection container services.\n */\nexport * from './di/metadata';\nexport { InjectableType, InjectorType, defineInjectable, defineInjector } from './di/defs';\nexport { forwardRef, resolveForwardRef, ForwardRefFn } from './di/forward_ref';\nexport { Injectable, InjectableDecorator, InjectableProvider } from './di/injectable';\nexport { INJECTOR, Injector } from './di/injector';\nexport { inject, InjectFlags } from './di/injector_compatibility';\nexport { ReflectiveInjector } from './di/reflective_injector';\nexport { StaticProvider, ValueProvider, ConstructorSansProvider, ExistingProvider, FactoryProvider, Provider, TypeProvider, ClassProvider } from './di/provider';\nexport { createInjector } from './di/r3_injector';\nexport { ResolvedReflectiveFactory, ResolvedReflectiveProvider } from './di/reflective_provider';\nexport { ReflectiveKey } from './di/reflective_key';\nexport { InjectionToken } from './di/injection_token';\n"
  },
  {
    "path": "node_modules/@angular/core/src/di/defs.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { Type } from '../type';\nimport { ClassProvider, ConstructorProvider, ExistingProvider, FactoryProvider, StaticClassProvider, ValueProvider } from './provider';\n/**\n * Information about how a type or `InjectionToken` interfaces with the DI system.\n *\n * At a minimum, this includes a `factory` which defines how to create the given type `T`, possibly\n * requesting injection of other types if necessary.\n *\n * Optionally, a `providedIn` parameter specifies that the given type belongs to a particular\n * `InjectorDef`, `NgModule`, or a special scope (e.g. `'root'`). A value of `null` indicates\n * that the injectable does not belong to any scope.\n *\n * NOTE: This is a private type and should not be exported\n */\nexport interface InjectableDef<T> {\n    /**\n     * Specifies that the given type belongs to a particular injector:\n     * - `InjectorType` such as `NgModule`,\n     * - `'root'` the root injector\n     * - `'any'` all injectors.\n     * - `null`, does not belong to any injector. Must be explicitly listed in the injector\n     *   `providers`.\n     */\n    providedIn: InjectorType<any> | 'root' | 'any' | null;\n    /**\n     * Factory method to execute to create an instance of the injectable.\n     */\n    factory: () => T;\n    /**\n     * In a case of no explicit injector, a location where the instance of the injectable is stored.\n     */\n    value: T | undefined;\n}\n/**\n * Information about the providers to be included in an `Injector` as well as how the given type\n * which carries the information should be created by the DI system.\n *\n * An `InjectorDef` can import other types which have `InjectorDefs`, forming a deep nested\n * structure of providers with a defined priority (identically to how `NgModule`s also have\n * an import/dependency structure).\n *\n * NOTE: This is a private type and should not be exported\n */\nexport interface InjectorDef<T> {\n    factory: () => T;\n    providers: (Type<any> | ValueProvider | ExistingProvider | FactoryProvider | ConstructorProvider | StaticClassProvider | ClassProvider | any[])[];\n    imports: (InjectorType<any> | InjectorTypeWithProviders<any>)[];\n}\n/**\n * A `Type` which has an `InjectableDef` static field.\n *\n * `InjectableDefType`s contain their own Dependency Injection metadata and are usable in an\n * `InjectorDef`-based `StaticInjector.\n *\n * @publicApi\n */\nexport interface InjectableType<T> extends Type<T> {\n    /**\n     * Opaque type whose structure is highly version dependent. Do not rely on any properties.\n     */\n    ngInjectableDef: never;\n}\n/**\n * A type which has an `InjectorDef` static field.\n *\n * `InjectorDefTypes` can be used to configure a `StaticInjector`.\n *\n * @publicApi\n */\nexport interface InjectorType<T> extends Type<T> {\n    /**\n     * Opaque type whose structure is highly version dependent. Do not rely on any properties.\n     */\n    ngInjectorDef: never;\n}\n/**\n * Describes the `InjectorDef` equivalent of a `ModuleWithProviders`, an `InjectorDefType` with an\n * associated array of providers.\n *\n * Objects of this type can be listed in the imports section of an `InjectorDef`.\n *\n * NOTE: This is a private type and should not be exported\n */\nexport interface InjectorTypeWithProviders<T> {\n    ngModule: InjectorType<T>;\n    providers?: (Type<any> | ValueProvider | ExistingProvider | FactoryProvider | ConstructorProvider | StaticClassProvider | ClassProvider | any[])[];\n}\n/**\n * Construct an `InjectableDef` which defines how a token will be constructed by the DI system, and\n * in which injectors (if any) it will be available.\n *\n * This should be assigned to a static `ngInjectableDef` field on a type, which will then be an\n * `InjectableType`.\n *\n * Options:\n * * `providedIn` determines which injectors will include the injectable, by either associating it\n *   with an `@NgModule` or other `InjectorType`, or by specifying that this injectable should be\n *   provided in the `'root'` injector, which will be the application-level injector in most apps.\n * * `factory` gives the zero argument function which will create an instance of the injectable.\n *   The factory can call `inject` to access the `Injector` and request injection of dependencies.\n *\n * @publicApi\n */\nexport declare function defineInjectable<T>(opts: {\n    providedIn?: Type<any> | 'root' | 'any' | null;\n    factory: () => T;\n}): never;\n/**\n * Construct an `InjectorDef` which configures an injector.\n *\n * This should be assigned to a static `ngInjectorDef` field on a type, which will then be an\n * `InjectorType`.\n *\n * Options:\n *\n * * `factory`: an `InjectorType` is an instantiable type, so a zero argument `factory` function to\n *   create the type must be provided. If that factory function needs to inject arguments, it can\n *   use the `inject` function.\n * * `providers`: an optional array of providers to add to the injector. Each provider must\n *   either have a factory or point to a type which has an `ngInjectableDef` static property (the\n *   type must be an `InjectableType`).\n * * `imports`: an optional array of imports of other `InjectorType`s or `InjectorTypeWithModule`s\n *   whose providers will also be added to the injector. Locally provided types will override\n *   providers from imports.\n *\n * @publicApi\n */\nexport declare function defineInjector(options: {\n    factory: () => any;\n    providers?: any[];\n    imports?: any[];\n}): never;\n/**\n * Read the `ngInjectableDef` type in a way which is immune to accidentally reading inherited value.\n *\n * @param type type which may have `ngInjectableDef`\n */\nexport declare function getInjectableDef<T>(type: any): InjectableDef<T> | null;\n/**\n * Read the `ngInjectorDef` type in a way which is immune to accidentally reading inherited value.\n *\n * @param type type which may have `ngInjectorDef`\n */\nexport declare function getInjectorDef<T>(type: any): InjectorDef<T> | null;\n"
  },
  {
    "path": "node_modules/@angular/core/src/di/forward_ref.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { Type } from '../type';\n/**\n * An interface that a function passed into {@link forwardRef} has to implement.\n *\n * @usageNotes\n * ### Example\n *\n * {@example core/di/ts/forward_ref/forward_ref_spec.ts region='forward_ref_fn'}\n * @publicApi\n */\nexport interface ForwardRefFn {\n    (): any;\n}\n/**\n * Allows to refer to references which are not yet defined.\n *\n * For instance, `forwardRef` is used when the `token` which we need to refer to for the purposes of\n * DI is declared, but not yet defined. It is also used when the `token` which we use when creating\n * a query is not yet defined.\n *\n * @usageNotes\n * ### Example\n * {@example core/di/ts/forward_ref/forward_ref_spec.ts region='forward_ref'}\n * @publicApi\n */\nexport declare function forwardRef(forwardRefFn: ForwardRefFn): Type<any>;\n/**\n * Lazily retrieves the reference value from a forwardRef.\n *\n * Acts as the identity function when given a non-forward-ref value.\n *\n * @usageNotes\n * ### Example\n *\n * {@example core/di/ts/forward_ref/forward_ref_spec.ts region='resolve_forward_ref'}\n *\n * @see `forwardRef`\n * @publicApi\n */\nexport declare function resolveForwardRef<T>(type: T): T;\n"
  },
  {
    "path": "node_modules/@angular/core/src/di/injectable.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { compileInjectable as render3CompileInjectable } from '../render3/jit/injectable';\nimport { Type } from '../type';\nimport { InjectableDef } from './defs';\nimport { ClassSansProvider, ConstructorSansProvider, ExistingSansProvider, FactorySansProvider, StaticClassSansProvider, ValueSansProvider } from './provider';\n/**\n * Injectable providers used in `@Injectable` decorator.\n *\n * @publicApi\n */\nexport declare type InjectableProvider = ValueSansProvider | ExistingSansProvider | StaticClassSansProvider | ConstructorSansProvider | FactorySansProvider | ClassSansProvider;\n/**\n * Type of the Injectable decorator / constructor function.\n *\n * @publicApi\n */\nexport interface InjectableDecorator {\n    /**\n     * A marker metadata that marks a class as available to `Injector` for creation.\n     *\n     * For more details, see the [\"Dependency Injection Guide\"](guide/dependency-injection).\n     *\n     * @usageNotes\n     * ### Example\n     *\n     * {@example core/di/ts/metadata_spec.ts region='Injectable'}\n     *\n     * `Injector` will throw an error when trying to instantiate a class that\n     * does not have `@Injectable` marker, as shown in the example below.\n     *\n     * {@example core/di/ts/metadata_spec.ts region='InjectableThrows'}\n     *\n     */\n    (): any;\n    (options?: {\n        providedIn: Type<any> | 'root' | null;\n    } & InjectableProvider): any;\n    new (): Injectable;\n    new (options?: {\n        providedIn: Type<any> | 'root' | null;\n    } & InjectableProvider): Injectable;\n}\n/**\n * Type of the Injectable metadata.\n *\n * @publicApi\n */\nexport interface Injectable {\n    providedIn?: Type<any> | 'root' | null;\n}\n/**\n * Injectable decorator and metadata.\n *\n * @Annotation\n * @publicApi\n */\nexport declare const Injectable: InjectableDecorator;\n/**\n * Type representing injectable service.\n *\n * @publicApi\n */\nexport interface InjectableType<T> extends Type<T> {\n    ngInjectableDef: InjectableDef<T>;\n}\nexport declare const SWITCH_COMPILE_INJECTABLE__POST_R3__: typeof render3CompileInjectable;\n"
  },
  {
    "path": "node_modules/@angular/core/src/di/injection_token.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { Type } from '../type';\n/**\n * Creates a token that can be used in a DI Provider.\n *\n * Use an `InjectionToken` whenever the type you are injecting is not reified (does not have a\n * runtime representation) such as when injecting an interface, callable type, array or\n * parametrized type.\n *\n * `InjectionToken` is parameterized on `T` which is the type of object which will be returned by\n * the `Injector`. This provides additional level of type safety.\n *\n * ```\n * interface MyInterface {...}\n * var myInterface = injector.get(new InjectionToken<MyInterface>('SomeToken'));\n * // myInterface is inferred to be MyInterface.\n * ```\n *\n * When creating an `InjectionToken`, you can optionally specify a factory function which returns\n * (possibly by creating) a default value of the parameterized type `T`. This sets up the\n * `InjectionToken` using this factory as a provider as if it was defined explicitly in the\n * application's root injector. If the factory function, which takes zero arguments, needs to inject\n * dependencies, it can do so using the `inject` function. See below for an example.\n *\n * Additionally, if a `factory` is specified you can also specify the `providedIn` option, which\n * overrides the above behavior and marks the token as belonging to a particular `@NgModule`. As\n * mentioned above, `'root'` is the default value for `providedIn`.\n *\n * @usageNotes\n * ### Basic Example\n *\n * ### Plain InjectionToken\n *\n * {@example core/di/ts/injector_spec.ts region='InjectionToken'}\n *\n * ### Tree-shakable InjectionToken\n *\n * {@example core/di/ts/injector_spec.ts region='ShakableInjectionToken'}\n *\n *\n * @publicApi\n */\nexport declare class InjectionToken<T> {\n    protected _desc: string;\n    readonly ngInjectableDef: never | undefined;\n    constructor(_desc: string, options?: {\n        providedIn?: Type<any> | 'root' | null;\n        factory: () => T;\n    });\n    toString(): string;\n}\nexport interface InjectableDefToken<T> extends InjectionToken<T> {\n    ngInjectableDef: never;\n}\n"
  },
  {
    "path": "node_modules/@angular/core/src/di/injector_compatibility.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { Type } from '../type';\nimport { InjectionToken } from './injection_token';\nimport { Injector } from './injector';\n/**\n * Injection flags for DI.\n *\n * @publicApi\n */\nexport declare enum InjectFlags {\n    Default = 0,\n    /**\n     * Specifies that an injector should retrieve a dependency from any injector until reaching the\n     * host element of the current component. (Only used with Element Injector)\n     */\n    Host = 1,\n    /** Don't descend into ancestors of the node requesting injection. */\n    Self = 2,\n    /** Skip the node that is requesting injection. */\n    SkipSelf = 4,\n    /** Inject `defaultValue` instead if token not found. */\n    Optional = 8\n}\nexport declare function setCurrentInjector(injector: Injector | null | undefined): Injector | undefined | null;\n/**\n * Sets the current inject implementation.\n */\nexport declare function setInjectImplementation(impl: (<T>(token: Type<T> | InjectionToken<T>, flags?: InjectFlags) => T | null) | undefined): (<T>(token: Type<T> | InjectionToken<T>, flags?: InjectFlags) => T | null) | undefined;\nexport declare function injectInjectorOnly<T>(token: Type<T> | InjectionToken<T>): T;\nexport declare function injectInjectorOnly<T>(token: Type<T> | InjectionToken<T>, flags?: InjectFlags): T | null;\n/**\n * Injects a token from the currently active injector.\n *\n * This function must be used in the context of a factory function such as one defined for an\n * `InjectionToken`, and will throw an error if not called from such a context.\n *\n * @usageNotes\n * ### Example\n *\n * {@example core/di/ts/injector_spec.ts region='ShakeableInjectionToken'}\n *\n * Within such a factory function `inject` is utilized to request injection of a dependency, instead\n * of providing an additional array of dependencies as was common to do with `useFactory` providers.\n * `inject` is faster and more type-safe.\n *\n * @publicApi\n */\nexport declare function inject<T>(token: Type<T> | InjectionToken<T>): T;\nexport declare function inject<T>(token: Type<T> | InjectionToken<T>, flags?: InjectFlags): T | null;\n/**\n * Injects `root` tokens in limp mode.\n *\n * If no injector exists, we can still inject tree-shakable providers which have `providedIn` set to\n * `\"root\"`. This is known as the limp mode injection. In such case the value is stored in the\n * `InjectableDef`.\n */\nexport declare function injectRootLimpMode<T>(token: Type<T> | InjectionToken<T>, notFoundValue: T | undefined, flags: InjectFlags): T | null;\nexport declare function injectArgs(types: (Type<any> | InjectionToken<any> | any[])[]): any[];\n"
  },
  {
    "path": "node_modules/@angular/core/src/di/injector.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { Type } from '../type';\nimport { InjectionToken } from './injection_token';\nimport { InjectFlags } from './injector_compatibility';\nimport { StaticProvider } from './provider';\nexport declare const SOURCE = \"__source\";\nexport declare const THROW_IF_NOT_FOUND: Object;\n/**\n * An InjectionToken that gets the current `Injector` for `createInjector()`-style injectors.\n *\n * Requesting this token instead of `Injector` allows `StaticInjector` to be tree-shaken from a\n * project.\n *\n * @publicApi\n */\nexport declare const INJECTOR: InjectionToken<Injector>;\nexport declare class NullInjector implements Injector {\n    get(token: any, notFoundValue?: any): any;\n}\n/**\n * Concrete injectors implement this interface.\n *\n * For more details, see the [\"Dependency Injection Guide\"](guide/dependency-injection).\n *\n * @usageNotes\n * ### Example\n *\n * {@example core/di/ts/injector_spec.ts region='Injector'}\n *\n * `Injector` returns itself when given `Injector` as a token:\n *\n * {@example core/di/ts/injector_spec.ts region='injectInjector'}\n *\n * @publicApi\n */\nexport declare abstract class Injector {\n    static THROW_IF_NOT_FOUND: Object;\n    static NULL: Injector;\n    /**\n     * Retrieves an instance from the injector based on the provided token.\n     * @returns The instance from the injector if defined, otherwise the `notFoundValue`.\n     * @throws When the `notFoundValue` is `undefined` or `Injector.THROW_IF_NOT_FOUND`.\n     */\n    abstract get<T>(token: Type<T> | InjectionToken<T>, notFoundValue?: T, flags?: InjectFlags): T;\n    /**\n     * @deprecated from v4.0.0 use Type<T> or InjectionToken<T>\n     * @suppress {duplicate}\n     */\n    abstract get(token: any, notFoundValue?: any): any;\n    /**\n     * @deprecated from v5 use the new signature Injector.create(options)\n     */\n    static create(providers: StaticProvider[], parent?: Injector): Injector;\n    static create(options: {\n        providers: StaticProvider[];\n        parent?: Injector;\n        name?: string;\n    }): Injector;\n    /** @nocollapse */\n    static ngInjectableDef: never;\n}\nexport declare const SWITCH_INJECTOR_FACTORY__POST_R3__: () => import(\"@angular/core/src/render3/di\").NodeInjector;\nexport declare const USE_VALUE: string;\nexport declare class StaticInjector implements Injector {\n    readonly parent: Injector;\n    readonly source: string | null;\n    private _records;\n    constructor(providers: StaticProvider[], parent?: Injector, source?: string | null);\n    get<T>(token: Type<T> | InjectionToken<T>, notFoundValue?: T, flags?: InjectFlags): T;\n    get(token: any, notFoundValue?: any): any;\n    toString(): string;\n}\n"
  },
  {
    "path": "node_modules/@angular/core/src/di/metadata.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Type of the Inject decorator / constructor function.\n *\n * @publicApi\n */\nexport interface InjectDecorator {\n    /**\n     * A constructor parameter decorator that specifies a\n     * custom provider of a dependency.\n     *\n     * @see [\"Dependency Injection Guide\"](guide/dependency-injection).\n     *\n     * @usageNotes\n     * The following example shows a class constructor that specifies a\n     * custom provider of a dependency using the parameter decorator.\n     *\n     * {@example core/di/ts/metadata_spec.ts region='Inject'}\n     *\n     * When `@Inject()` is not present, the `Injector` uses the type annotation of the\n     * parameter as the provider.\n     *\n     * {@example core/di/ts/metadata_spec.ts region='InjectWithoutDecorator'}\n     */\n    (token: any): any;\n    new (token: any): Inject;\n}\n/**\n * Type of the Inject metadata.\n *\n * @publicApi\n */\nexport interface Inject {\n    /**\n     * Injector token that maps to the dependency to be injected.\n     */\n    token: any;\n}\n/**\n * Inject decorator and metadata.\n *\n * @Annotation\n * @publicApi\n */\nexport declare const Inject: InjectDecorator;\n/**\n * Type of the Optional decorator / constructor function.\n *\n * @publicApi\n */\nexport interface OptionalDecorator {\n    /**\n     * A constructor parameter decorator that marks a dependency as optional.\n     *\n     * The DI framework provides null if the dependency is not found.\n     * For example, the following code allows the possibility of a null result:\n     *\n     * {@example core/di/ts/metadata_spec.ts region='Optional'}\n     *\n     * @see [\"Dependency Injection Guide\"](guide/dependency-injection).\n     */\n    (): any;\n    new (): Optional;\n}\n/**\n * Type of the Optional metadata.\n *\n * @publicApi\n */\nexport interface Optional {\n}\n/**\n * Optional decorator and metadata.\n *\n * @Annotation\n * @publicApi\n */\nexport declare const Optional: OptionalDecorator;\n/**\n * Type of the Self decorator / constructor function.\n *\n * @publicApi\n */\nexport interface SelfDecorator {\n    /**\n     * A constructor parameter decorator that tells the DI framework\n     * to retrieve a dependency only from the local injector.\n     *\n     * In the following example, the dependency can be resolved\n     * by the local injector when instantiating the class itself, but not\n     * when instantiating a child.\n     *\n     * {@example core/di/ts/metadata_spec.ts region='Self'}\n     *\n     * @see [\"Dependency Injection Guide\"](guide/dependency-injection).\n     *\n     *\n     */\n    (): any;\n    new (): Self;\n}\n/**\n * Type of the Self metadata.\n *\n * @publicApi\n */\nexport interface Self {\n}\n/**\n * Self decorator and metadata.\n *\n * @Annotation\n * @publicApi\n */\nexport declare const Self: SelfDecorator;\n/**\n * Type of the SkipSelf decorator / constructor function.\n *\n * @publicApi\n */\nexport interface SkipSelfDecorator {\n    /**\n     * A constructor parameter decorator that tells the DI framework\n     * that dependency resolution should start from the parent injector.\n     *\n     * In the following example, the dependency can be resolved when\n     * instantiating a child, but not when instantiating the class itself.\n     *\n     * {@example core/di/ts/metadata_spec.ts region='SkipSelf'}\n     *\n     * @see [\"Dependency Injection Guide\"](guide/dependency-injection).\n     *\n     *\n     */\n    (): any;\n    new (): SkipSelf;\n}\n/**\n * Type of the SkipSelf metadata.\n *\n * @publicApi\n */\nexport interface SkipSelf {\n}\n/**\n * SkipSelf decorator and metadata.\n *\n * @Annotation\n * @publicApi\n */\nexport declare const SkipSelf: SkipSelfDecorator;\n/**\n * Type of the Host decorator / constructor function.\n *\n * @publicApi\n */\nexport interface HostDecorator {\n    /**\n     * A constructor parameter decorator that tells the DI framework\n     * to retrieve a dependency from any injector until\n     * reaching the host element of the current component.\n     *\n     * @see [\"Dependency Injection Guide\"](guide/dependency-injection).\n     *\n     * @usageNotes\n     *\n     * {@example core/di/ts/metadata_spec.ts region='Host'}\n     */\n    (): any;\n    new (): Host;\n}\n/**\n * Type of the Host metadata.\n *\n * @publicApi\n */\nexport interface Host {\n}\n/**\n * Host decorator and metadata.\n *\n * @Annotation\n * @publicApi\n */\nexport declare const Host: HostDecorator;\n"
  },
  {
    "path": "node_modules/@angular/core/src/di/provider.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { Type } from '../type';\n/**\n * Configures the `Injector` to return a value for a token.\n *\n * For more details, see the [\"Dependency Injection Guide\"](guide/dependency-injection).\n *\n * @usageNotes\n * ### Example\n *\n * {@example core/di/ts/provider_spec.ts region='ValueSansProvider'}\n *\n * @publicApi\n */\nexport interface ValueSansProvider {\n    /**\n     * The value to inject.\n     */\n    useValue: any;\n}\n/**\n * Configures the `Injector` to return a value for a token.\n *\n * For more details, see the [\"Dependency Injection Guide\"](guide/dependency-injection).\n *\n * @usageNotes\n * ### Example\n *\n * {@example core/di/ts/provider_spec.ts region='ValueProvider'}\n *\n * ### Multi-value example\n *\n * {@example core/di/ts/provider_spec.ts region='MultiProviderAspect'}\n *\n * @publicApi\n */\nexport interface ValueProvider extends ValueSansProvider {\n    /**\n     * An injection token. (Typically an instance of `Type` or `InjectionToken`, but can be `any`).\n     */\n    provide: any;\n    /**\n     * If true, then injector returns an array of instances. This is useful to allow multiple\n     * providers spread across many files to provide configuration information to a common token.\n     */\n    multi?: boolean;\n}\n/**\n * Configures the `Injector` to return an instance of `useClass` for a token.\n *\n * For more details, see the [\"Dependency Injection Guide\"](guide/dependency-injection).\n *\n * @usageNotes\n * ### Example\n *\n * {@example core/di/ts/provider_spec.ts region='StaticClassSansProvider'}\n *\n * @publicApi\n */\nexport interface StaticClassSansProvider {\n    /**\n     * An optional class to instantiate for the `token`. (If not provided `provide` is assumed to be a\n     * class to instantiate)\n     */\n    useClass: Type<any>;\n    /**\n     * A list of `token`s which need to be resolved by the injector. The list of values is then\n     * used as arguments to the `useClass` constructor.\n     */\n    deps: any[];\n}\n/**\n * Configures the `Injector` to return an instance of `useClass` for a token.\n *\n * For more details, see the [\"Dependency Injection Guide\"](guide/dependency-injection).\n *\n * @usageNotes\n * ### Example\n *\n * {@example core/di/ts/provider_spec.ts region='StaticClassProvider'}\n *\n * Note that following two providers are not equal:\n *\n * {@example core/di/ts/provider_spec.ts region='StaticClassProviderDifference'}\n *\n * ### Multi-value example\n *\n * {@example core/di/ts/provider_spec.ts region='MultiProviderAspect'}\n */\nexport interface StaticClassProvider extends StaticClassSansProvider {\n    /**\n     * An injection token. (Typically an instance of `Type` or `InjectionToken`, but can be `any`).\n     */\n    provide: any;\n    /**\n     * If true, then injector returns an array of instances. This is useful to allow multiple\n     * providers spread across many files to provide configuration information to a common token.\n     */\n    multi?: boolean;\n}\n/**\n * Configures the `Injector` to return an instance of a token.\n *\n * For more details, see the [\"Dependency Injection Guide\"](guide/dependency-injection).\n *\n * @usageNotes\n * ### Example\n *\n * ```\n * @Injectable(SomeModule, {deps: []})\n * class MyService {}\n * ```\n *\n * @publicApi\n */\nexport interface ConstructorSansProvider {\n    /**\n     * A list of `token`s which need to be resolved by the injector. The list of values is then\n     * used as arguments to the `useClass` constructor.\n     */\n    deps?: any[];\n}\n/**\n * Configures the `Injector` to return an instance of a token.\n *\n * For more details, see the [\"Dependency Injection Guide\"](guide/dependency-injection).\n *\n * @usageNotes\n * ### Example\n *\n * {@example core/di/ts/provider_spec.ts region='ConstructorProvider'}\n *\n * ### Multi-value example\n *\n * {@example core/di/ts/provider_spec.ts region='MultiProviderAspect'}\n */\nexport interface ConstructorProvider extends ConstructorSansProvider {\n    /**\n     * An injection token. (Typically an instance of `Type` or `InjectionToken`, but can be `any`).\n     */\n    provide: Type<any>;\n    /**\n     * If true, then injector returns an array of instances. This is useful to allow multiple\n     * providers spread across many files to provide configuration information to a common token.\n     */\n    multi?: boolean;\n}\n/**\n * Configures the `Injector` to return a value of another `useExisting` token.\n *\n * For more details, see the [\"Dependency Injection Guide\"](guide/dependency-injection).\n *\n * @usageNotes\n * ### Example\n *\n * {@example core/di/ts/provider_spec.ts region='ExistingSansProvider'}\n */\nexport interface ExistingSansProvider {\n    /**\n     * Existing `token` to return. (equivalent to `injector.get(useExisting)`)\n     */\n    useExisting: any;\n}\n/**\n * Configures the `Injector` to return a value of another `useExisting` token.\n *\n * For more details, see the [\"Dependency Injection Guide\"](guide/dependency-injection).\n *\n * @usageNotes\n * ### Example\n *\n * {@example core/di/ts/provider_spec.ts region='ExistingProvider'}\n *\n * ### Multi-value example\n *\n * {@example core/di/ts/provider_spec.ts region='MultiProviderAspect'}\n *\n * @publicApi\n */\nexport interface ExistingProvider extends ExistingSansProvider {\n    /**\n     * An injection token. (Typically an instance of `Type` or `InjectionToken`, but can be `any`).\n     */\n    provide: any;\n    /**\n     * If true, then injector returns an array of instances. This is useful to allow multiple\n     * providers spread across many files to provide configuration information to a common token.\n     */\n    multi?: boolean;\n}\n/**\n * Configures the `Injector` to return a value by invoking a `useFactory` function.\n *\n * For more details, see the [\"Dependency Injection Guide\"](guide/dependency-injection).\n *\n * @usageNotes\n * ### Example\n *\n * {@example core/di/ts/provider_spec.ts region='FactorySansProvider'}\n *\n * @publicApi\n */\nexport interface FactorySansProvider {\n    /**\n     * A function to invoke to create a value for this `token`. The function is invoked with\n     * resolved values of `token`s in the `deps` field.\n     */\n    useFactory: Function;\n    /**\n     * A list of `token`s which need to be resolved by the injector. The list of values is then\n     * used as arguments to the `useFactory` function.\n     */\n    deps?: any[];\n}\n/**\n * Configures the `Injector` to return a value by invoking a `useFactory` function.\n *\n * For more details, see the [\"Dependency Injection Guide\"](guide/dependency-injection).\n *\n * @usageNotes\n * ### Example\n *\n * {@example core/di/ts/provider_spec.ts region='FactoryProvider'}\n *\n * Dependencies can also be marked as optional:\n *\n * {@example core/di/ts/provider_spec.ts region='FactoryProviderOptionalDeps'}\n *\n * ### Multi-value example\n *\n * {@example core/di/ts/provider_spec.ts region='MultiProviderAspect'}\n *\n * @publicApi\n */\nexport interface FactoryProvider extends FactorySansProvider {\n    /**\n     * An injection token. (Typically an instance of `Type` or `InjectionToken`, but can be `any`).\n     */\n    provide: any;\n    /**\n     * If true, then injector returns an array of instances. This is useful to allow multiple\n     * providers spread across many files to provide configuration information to a common token.\n     */\n    multi?: boolean;\n}\n/**\n * Describes how the `Injector` should be configured in a static way (Without reflection).\n *\n * For more details, see the [\"Dependency Injection Guide\"](guide/dependency-injection).\n *\n * @see `ValueProvider`\n * @see `ExistingProvider`\n * @see `FactoryProvider`\n *\n * @publicApi\n */\nexport declare type StaticProvider = ValueProvider | ExistingProvider | StaticClassProvider | ConstructorProvider | FactoryProvider | any[];\n/**\n * Configures the `Injector` to return an instance of `Type` when `Type' is used as the token.\n *\n * Create an instance by invoking the `new` operator and supplying additional arguments.\n * This form is a short form of `TypeProvider`;\n *\n * For more details, see the [\"Dependency Injection Guide\"](guide/dependency-injection).\n *\n * @usageNotes\n * ### Example\n *\n * {@example core/di/ts/provider_spec.ts region='TypeProvider'}\n *\n * @publicApi\n */\nexport interface TypeProvider extends Type<any> {\n}\n/**\n * Configures the `Injector` to return a value by invoking a `useClass` function.\n *\n * For more details, see the [\"Dependency Injection Guide\"](guide/dependency-injection).\n *\n * @usageNotes\n * ### Example\n *\n * {@example core/di/ts/provider_spec.ts region='ClassSansProvider'}\n *\n * @publicApi\n */\nexport interface ClassSansProvider {\n    /**\n     * Class to instantiate for the `token`.\n     */\n    useClass: Type<any>;\n}\n/**\n * Configures the `Injector` to return an instance of `useClass` for a token.\n *\n * For more details, see the [\"Dependency Injection Guide\"](guide/dependency-injection).\n *\n * @usageNotes\n * ### Example\n *\n * {@example core/di/ts/provider_spec.ts region='ClassProvider'}\n *\n * Note that following two providers are not equal:\n *\n * {@example core/di/ts/provider_spec.ts region='ClassProviderDifference'}\n *\n * ### Multi-value example\n *\n * {@example core/di/ts/provider_spec.ts region='MultiProviderAspect'}\n *\n * @publicApi\n */\nexport interface ClassProvider extends ClassSansProvider {\n    /**\n     * An injection token. (Typically an instance of `Type` or `InjectionToken`, but can be `any`).\n     */\n    provide: any;\n    /**\n     * If true, then injector returns an array of instances. This is useful to allow multiple\n     * providers spread across many files to provide configuration information to a common token.\n     */\n    multi?: boolean;\n}\n/**\n * Describes how the `Injector` should be configured.\n *\n * For more details, see the [\"Dependency Injection Guide\"](guide/dependency-injection).\n *\n * @see `TypeProvider`\n * @see `ClassProvider`\n * @see `StaticProvider`\n *\n * @publicApi\n */\nexport declare type Provider = TypeProvider | ValueProvider | ClassProvider | ConstructorProvider | ExistingProvider | FactoryProvider | any[];\n"
  },
  {
    "path": "node_modules/@angular/core/src/di/r3_injector.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { Type } from '../type';\nimport { InjectorType } from './defs';\nimport { InjectionToken } from './injection_token';\nimport { Injector } from './injector';\nimport { InjectFlags } from './injector_compatibility';\nimport { ClassProvider, ConstructorProvider, ExistingProvider, FactoryProvider, StaticClassProvider, StaticProvider, TypeProvider, ValueProvider } from './provider';\n/**\n * Internal type for a single provider in a deep provider array.\n */\ndeclare type SingleProvider = TypeProvider | ValueProvider | ClassProvider | ConstructorProvider | ExistingProvider | FactoryProvider | StaticClassProvider;\n/**\n * Create a new `Injector` which is configured using a `defType` of `InjectorType<any>`s.\n *\n * @publicApi\n */\nexport declare function createInjector(defType: any, parent?: Injector | null, additionalProviders?: StaticProvider[] | null): Injector;\nexport declare class R3Injector {\n    readonly parent: Injector;\n    /**\n     * Map of tokens to records which contain the instances of those tokens.\n     */\n    private records;\n    /**\n     * The transitive set of `InjectorType`s which define this injector.\n     */\n    private injectorDefTypes;\n    /**\n     * Set of values instantiated by this injector which contain `ngOnDestroy` lifecycle hooks.\n     */\n    private onDestroy;\n    /**\n     * Flag indicating this injector provides the APP_ROOT_SCOPE token, and thus counts as the\n     * root scope.\n     */\n    private readonly isRootInjector;\n    /**\n     * Flag indicating that this injector was previously destroyed.\n     */\n    private destroyed;\n    constructor(def: InjectorType<any>, additionalProviders: StaticProvider[] | null, parent: Injector);\n    /**\n     * Destroy the injector and release references to every instance or provider associated with it.\n     *\n     * Also calls the `OnDestroy` lifecycle hooks of every instance that was created for which a\n     * hook was found.\n     */\n    destroy(): void;\n    get<T>(token: Type<T> | InjectionToken<T>, notFoundValue?: any, flags?: InjectFlags): T;\n    private assertNotDestroyed;\n    /**\n     * Add an `InjectorType` or `InjectorDefTypeWithProviders` and all of its transitive providers\n     * to this injector.\n     */\n    private processInjectorType;\n    /**\n     * Process a `SingleProvider` and add it.\n     */\n    private processProvider;\n    private hydrate;\n    private injectableDefInScope;\n}\n/**\n * Converts a `SingleProvider` into a factory function.\n *\n * @param provider provider to convert to factory\n */\nexport declare function providerToFactory(provider: SingleProvider): () => any;\nexport declare function isTypeProvider(value: SingleProvider): value is TypeProvider;\nexport {};\n"
  },
  {
    "path": "node_modules/@angular/core/src/di/reflective_errors.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { Type } from '../type';\nimport { ReflectiveInjector } from './reflective_injector';\nimport { ReflectiveKey } from './reflective_key';\nexport interface InjectionError extends Error {\n    keys: ReflectiveKey[];\n    injectors: ReflectiveInjector[];\n    constructResolvingMessage: (keys: ReflectiveKey[]) => string;\n    addKey(injector: ReflectiveInjector, key: ReflectiveKey): void;\n}\n/**\n * Thrown when trying to retrieve a dependency by key from {@link Injector}, but the\n * {@link Injector} does not have a {@link Provider} for the given key.\n *\n * @usageNotes\n * ### Example\n *\n * ```typescript\n * class A {\n *   constructor(b:B) {}\n * }\n *\n * expect(() => Injector.resolveAndCreate([A])).toThrowError();\n * ```\n */\nexport declare function noProviderError(injector: ReflectiveInjector, key: ReflectiveKey): InjectionError;\n/**\n * Thrown when dependencies form a cycle.\n *\n * @usageNotes\n * ### Example\n *\n * ```typescript\n * var injector = Injector.resolveAndCreate([\n *   {provide: \"one\", useFactory: (two) => \"two\", deps: [[new Inject(\"two\")]]},\n *   {provide: \"two\", useFactory: (one) => \"one\", deps: [[new Inject(\"one\")]]}\n * ]);\n *\n * expect(() => injector.get(\"one\")).toThrowError();\n * ```\n *\n * Retrieving `A` or `B` throws a `CyclicDependencyError` as the graph above cannot be constructed.\n */\nexport declare function cyclicDependencyError(injector: ReflectiveInjector, key: ReflectiveKey): InjectionError;\n/**\n * Thrown when a constructing type returns with an Error.\n *\n * The `InstantiationError` class contains the original error plus the dependency graph which caused\n * this object to be instantiated.\n *\n * @usageNotes\n * ### Example\n *\n * ```typescript\n * class A {\n *   constructor() {\n *     throw new Error('message');\n *   }\n * }\n *\n * var injector = Injector.resolveAndCreate([A]);\n\n * try {\n *   injector.get(A);\n * } catch (e) {\n *   expect(e instanceof InstantiationError).toBe(true);\n *   expect(e.originalException.message).toEqual(\"message\");\n *   expect(e.originalStack).toBeDefined();\n * }\n * ```\n */\nexport declare function instantiationError(injector: ReflectiveInjector, originalException: any, originalStack: any, key: ReflectiveKey): InjectionError;\n/**\n * Thrown when an object other then {@link Provider} (or `Type`) is passed to {@link Injector}\n * creation.\n *\n * @usageNotes\n * ### Example\n *\n * ```typescript\n * expect(() => Injector.resolveAndCreate([\"not a type\"])).toThrowError();\n * ```\n */\nexport declare function invalidProviderError(provider: any): Error;\n/**\n * Thrown when the class has no annotation information.\n *\n * Lack of annotation information prevents the {@link Injector} from determining which dependencies\n * need to be injected into the constructor.\n *\n * @usageNotes\n * ### Example\n *\n * ```typescript\n * class A {\n *   constructor(b) {}\n * }\n *\n * expect(() => Injector.resolveAndCreate([A])).toThrowError();\n * ```\n *\n * This error is also thrown when the class not marked with {@link Injectable} has parameter types.\n *\n * ```typescript\n * class B {}\n *\n * class A {\n *   constructor(b:B) {} // no information about the parameter types of A is available at runtime.\n * }\n *\n * expect(() => Injector.resolveAndCreate([A,B])).toThrowError();\n * ```\n *\n */\nexport declare function noAnnotationError(typeOrFunc: Type<any> | Function, params: any[][]): Error;\n/**\n * Thrown when getting an object by index.\n *\n * @usageNotes\n * ### Example\n *\n * ```typescript\n * class A {}\n *\n * var injector = Injector.resolveAndCreate([A]);\n *\n * expect(() => injector.getAt(100)).toThrowError();\n * ```\n *\n */\nexport declare function outOfBoundsError(index: number): Error;\n/**\n * Thrown when a multi provider and a regular provider are bound to the same token.\n *\n * @usageNotes\n * ### Example\n *\n * ```typescript\n * expect(() => Injector.resolveAndCreate([\n *   { provide: \"Strings\", useValue: \"string1\", multi: true},\n *   { provide: \"Strings\", useValue: \"string2\", multi: false}\n * ])).toThrowError();\n * ```\n */\nexport declare function mixingMultiProvidersWithRegularProvidersError(provider1: any, provider2: any): Error;\n"
  },
  {
    "path": "node_modules/@angular/core/src/di/reflective_injector.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { Injector } from './injector';\nimport { Provider } from './provider';\nimport { ResolvedReflectiveProvider } from './reflective_provider';\n/**\n * A ReflectiveDependency injection container used for instantiating objects and resolving\n * dependencies.\n *\n * An `Injector` is a replacement for a `new` operator, which can automatically resolve the\n * constructor dependencies.\n *\n * In typical use, application code asks for the dependencies in the constructor and they are\n * resolved by the `Injector`.\n *\n * @usageNotes\n * ### Example\n *\n * The following example creates an `Injector` configured to create `Engine` and `Car`.\n *\n * ```typescript\n * @Injectable()\n * class Engine {\n * }\n *\n * @Injectable()\n * class Car {\n *   constructor(public engine:Engine) {}\n * }\n *\n * var injector = ReflectiveInjector.resolveAndCreate([Car, Engine]);\n * var car = injector.get(Car);\n * expect(car instanceof Car).toBe(true);\n * expect(car.engine instanceof Engine).toBe(true);\n * ```\n *\n * Notice, we don't use the `new` operator because we explicitly want to have the `Injector`\n * resolve all of the object's dependencies automatically.\n *\n * @deprecated from v5 - slow and brings in a lot of code, Use `Injector.create` instead.\n * @publicApi\n */\nexport declare abstract class ReflectiveInjector implements Injector {\n    /**\n     * Turns an array of provider definitions into an array of resolved providers.\n     *\n     * A resolution is a process of flattening multiple nested arrays and converting individual\n     * providers into an array of `ResolvedReflectiveProvider`s.\n     *\n     * @usageNotes\n     * ### Example\n     *\n     * ```typescript\n     * @Injectable()\n     * class Engine {\n     * }\n     *\n     * @Injectable()\n     * class Car {\n     *   constructor(public engine:Engine) {}\n     * }\n     *\n     * var providers = ReflectiveInjector.resolve([Car, [[Engine]]]);\n     *\n     * expect(providers.length).toEqual(2);\n     *\n     * expect(providers[0] instanceof ResolvedReflectiveProvider).toBe(true);\n     * expect(providers[0].key.displayName).toBe(\"Car\");\n     * expect(providers[0].dependencies.length).toEqual(1);\n     * expect(providers[0].factory).toBeDefined();\n     *\n     * expect(providers[1].key.displayName).toBe(\"Engine\");\n     * });\n     * ```\n     *\n     */\n    static resolve(providers: Provider[]): ResolvedReflectiveProvider[];\n    /**\n     * Resolves an array of providers and creates an injector from those providers.\n     *\n     * The passed-in providers can be an array of `Type`, `Provider`,\n     * or a recursive array of more providers.\n     *\n     * @usageNotes\n     * ### Example\n     *\n     * ```typescript\n     * @Injectable()\n     * class Engine {\n     * }\n     *\n     * @Injectable()\n     * class Car {\n     *   constructor(public engine:Engine) {}\n     * }\n     *\n     * var injector = ReflectiveInjector.resolveAndCreate([Car, Engine]);\n     * expect(injector.get(Car) instanceof Car).toBe(true);\n     * ```\n     */\n    static resolveAndCreate(providers: Provider[], parent?: Injector): ReflectiveInjector;\n    /**\n     * Creates an injector from previously resolved providers.\n     *\n     * This API is the recommended way to construct injectors in performance-sensitive parts.\n     *\n     * @usageNotes\n     * ### Example\n     *\n     * ```typescript\n     * @Injectable()\n     * class Engine {\n     * }\n     *\n     * @Injectable()\n     * class Car {\n     *   constructor(public engine:Engine) {}\n     * }\n     *\n     * var providers = ReflectiveInjector.resolve([Car, Engine]);\n     * var injector = ReflectiveInjector.fromResolvedProviders(providers);\n     * expect(injector.get(Car) instanceof Car).toBe(true);\n     * ```\n     */\n    static fromResolvedProviders(providers: ResolvedReflectiveProvider[], parent?: Injector): ReflectiveInjector;\n    /**\n     * Parent of this injector.\n     *\n     * <!-- TODO: Add a link to the section of the user guide talking about hierarchical injection.\n     * -->\n     */\n    abstract readonly parent: Injector | null;\n    /**\n     * Resolves an array of providers and creates a child injector from those providers.\n     *\n     * <!-- TODO: Add a link to the section of the user guide talking about hierarchical injection.\n     * -->\n     *\n     * The passed-in providers can be an array of `Type`, `Provider`,\n     * or a recursive array of more providers.\n     *\n     * @usageNotes\n     * ### Example\n     *\n     * ```typescript\n     * class ParentProvider {}\n     * class ChildProvider {}\n     *\n     * var parent = ReflectiveInjector.resolveAndCreate([ParentProvider]);\n     * var child = parent.resolveAndCreateChild([ChildProvider]);\n     *\n     * expect(child.get(ParentProvider) instanceof ParentProvider).toBe(true);\n     * expect(child.get(ChildProvider) instanceof ChildProvider).toBe(true);\n     * expect(child.get(ParentProvider)).toBe(parent.get(ParentProvider));\n     * ```\n     */\n    abstract resolveAndCreateChild(providers: Provider[]): ReflectiveInjector;\n    /**\n     * Creates a child injector from previously resolved providers.\n     *\n     * <!-- TODO: Add a link to the section of the user guide talking about hierarchical injection.\n     * -->\n     *\n     * This API is the recommended way to construct injectors in performance-sensitive parts.\n     *\n     * @usageNotes\n     * ### Example\n     *\n     * ```typescript\n     * class ParentProvider {}\n     * class ChildProvider {}\n     *\n     * var parentProviders = ReflectiveInjector.resolve([ParentProvider]);\n     * var childProviders = ReflectiveInjector.resolve([ChildProvider]);\n     *\n     * var parent = ReflectiveInjector.fromResolvedProviders(parentProviders);\n     * var child = parent.createChildFromResolved(childProviders);\n     *\n     * expect(child.get(ParentProvider) instanceof ParentProvider).toBe(true);\n     * expect(child.get(ChildProvider) instanceof ChildProvider).toBe(true);\n     * expect(child.get(ParentProvider)).toBe(parent.get(ParentProvider));\n     * ```\n     */\n    abstract createChildFromResolved(providers: ResolvedReflectiveProvider[]): ReflectiveInjector;\n    /**\n     * Resolves a provider and instantiates an object in the context of the injector.\n     *\n     * The created object does not get cached by the injector.\n     *\n     * @usageNotes\n     * ### Example\n     *\n     * ```typescript\n     * @Injectable()\n     * class Engine {\n     * }\n     *\n     * @Injectable()\n     * class Car {\n     *   constructor(public engine:Engine) {}\n     * }\n     *\n     * var injector = ReflectiveInjector.resolveAndCreate([Engine]);\n     *\n     * var car = injector.resolveAndInstantiate(Car);\n     * expect(car.engine).toBe(injector.get(Engine));\n     * expect(car).not.toBe(injector.resolveAndInstantiate(Car));\n     * ```\n     */\n    abstract resolveAndInstantiate(provider: Provider): any;\n    /**\n     * Instantiates an object using a resolved provider in the context of the injector.\n     *\n     * The created object does not get cached by the injector.\n     *\n     * @usageNotes\n     * ### Example\n     *\n     * ```typescript\n     * @Injectable()\n     * class Engine {\n     * }\n     *\n     * @Injectable()\n     * class Car {\n     *   constructor(public engine:Engine) {}\n     * }\n     *\n     * var injector = ReflectiveInjector.resolveAndCreate([Engine]);\n     * var carProvider = ReflectiveInjector.resolve([Car])[0];\n     * var car = injector.instantiateResolved(carProvider);\n     * expect(car.engine).toBe(injector.get(Engine));\n     * expect(car).not.toBe(injector.instantiateResolved(carProvider));\n     * ```\n     */\n    abstract instantiateResolved(provider: ResolvedReflectiveProvider): any;\n    abstract get(token: any, notFoundValue?: any): any;\n}\nexport declare class ReflectiveInjector_ implements ReflectiveInjector {\n    private static INJECTOR_KEY;\n    readonly parent: Injector | null;\n    keyIds: number[];\n    objs: any[];\n    /**\n     * Private\n     */\n    constructor(_providers: ResolvedReflectiveProvider[], _parent?: Injector);\n    get(token: any, notFoundValue?: any): any;\n    resolveAndCreateChild(providers: Provider[]): ReflectiveInjector;\n    createChildFromResolved(providers: ResolvedReflectiveProvider[]): ReflectiveInjector;\n    resolveAndInstantiate(provider: Provider): any;\n    instantiateResolved(provider: ResolvedReflectiveProvider): any;\n    getProviderAtIndex(index: number): ResolvedReflectiveProvider;\n    private _getMaxNumberOfObjects;\n    private _instantiateProvider;\n    private _instantiate;\n    private _getByReflectiveDependency;\n    private _getByKey;\n    private _getObjByKeyId;\n    readonly displayName: string;\n    toString(): string;\n}\n"
  },
  {
    "path": "node_modules/@angular/core/src/di/reflective_key.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * A unique object used for retrieving items from the {@link ReflectiveInjector}.\n *\n * Keys have:\n * - a system-wide unique `id`.\n * - a `token`.\n *\n * `Key` is used internally by {@link ReflectiveInjector} because its system-wide unique `id` allows\n * the\n * injector to store created objects in a more efficient way.\n *\n * `Key` should not be created directly. {@link ReflectiveInjector} creates keys automatically when\n * resolving\n * providers.\n *\n * @deprecated No replacement\n * @publicApi\n */\nexport declare class ReflectiveKey {\n    token: Object;\n    id: number;\n    readonly displayName: string;\n    /**\n     * Private\n     */\n    constructor(token: Object, id: number);\n    /**\n     * Retrieves a `Key` for a token.\n     */\n    static get(token: Object): ReflectiveKey;\n    /**\n     * @returns the number of keys registered in the system.\n     */\n    static readonly numberOfKeys: number;\n}\nexport declare class KeyRegistry {\n    private _allKeys;\n    get(token: Object): ReflectiveKey;\n    readonly numberOfKeys: number;\n}\n"
  },
  {
    "path": "node_modules/@angular/core/src/di/reflective_provider.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { Self, SkipSelf } from './metadata';\nimport { Provider } from './provider';\nimport { ReflectiveKey } from './reflective_key';\n/**\n * `Dependency` is used by the framework to extend DI.\n * This is internal to Angular and should not be used directly.\n */\nexport declare class ReflectiveDependency {\n    key: ReflectiveKey;\n    optional: boolean;\n    visibility: Self | SkipSelf | null;\n    constructor(key: ReflectiveKey, optional: boolean, visibility: Self | SkipSelf | null);\n    static fromKey(key: ReflectiveKey): ReflectiveDependency;\n}\n/**\n * An internal resolved representation of a `Provider` used by the `Injector`.\n *\n * @usageNotes\n * This is usually created automatically by `Injector.resolveAndCreate`.\n *\n * It can be created manually, as follows:\n *\n * ### Example\n *\n * ```typescript\n * var resolvedProviders = Injector.resolve([{ provide: 'message', useValue: 'Hello' }]);\n * var injector = Injector.fromResolvedProviders(resolvedProviders);\n *\n * expect(injector.get('message')).toEqual('Hello');\n * ```\n *\n * @publicApi\n */\nexport interface ResolvedReflectiveProvider {\n    /**\n     * A key, usually a `Type<any>`.\n     */\n    key: ReflectiveKey;\n    /**\n     * Factory function which can return an instance of an object represented by a key.\n     */\n    resolvedFactories: ResolvedReflectiveFactory[];\n    /**\n     * Indicates if the provider is a multi-provider or a regular provider.\n     */\n    multiProvider: boolean;\n}\nexport declare class ResolvedReflectiveProvider_ implements ResolvedReflectiveProvider {\n    key: ReflectiveKey;\n    resolvedFactories: ResolvedReflectiveFactory[];\n    multiProvider: boolean;\n    readonly resolvedFactory: ResolvedReflectiveFactory;\n    constructor(key: ReflectiveKey, resolvedFactories: ResolvedReflectiveFactory[], multiProvider: boolean);\n}\n/**\n * An internal resolved representation of a factory function created by resolving `Provider`.\n * @publicApi\n */\nexport declare class ResolvedReflectiveFactory {\n    /**\n     * Factory function which can return an instance of an object represented by a key.\n     */\n    factory: Function;\n    /**\n     * Arguments (dependencies) to the `factory` function.\n     */\n    dependencies: ReflectiveDependency[];\n    constructor(\n    /**\n     * Factory function which can return an instance of an object represented by a key.\n     */\n    factory: Function, \n    /**\n     * Arguments (dependencies) to the `factory` function.\n     */\n    dependencies: ReflectiveDependency[]);\n}\n/**\n * Resolve a list of Providers.\n */\nexport declare function resolveReflectiveProviders(providers: Provider[]): ResolvedReflectiveProvider[];\n/**\n * Merges a list of ResolvedProviders into a list where each key is contained exactly once and\n * multi providers have been merged.\n */\nexport declare function mergeResolvedReflectiveProviders(providers: ResolvedReflectiveProvider[], normalizedProvidersMap: Map<number, ResolvedReflectiveProvider>): Map<number, ResolvedReflectiveProvider>;\nexport declare function constructDependencies(typeOrFunc: any, dependencies?: any[]): ReflectiveDependency[];\n"
  },
  {
    "path": "node_modules/@angular/core/src/di/scope.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { InjectionToken } from './injection_token';\n/**\n * An internal token whose presence in an injector indicates that the injector should treat itself\n * as a root scoped injector when processing requests for unknown tokens which may indicate\n * they are provided in the root scope.\n */\nexport declare const APP_ROOT: InjectionToken<boolean>;\n"
  },
  {
    "path": "node_modules/@angular/core/src/di/util.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { Type } from '../type';\nimport { ClassSansProvider, ConstructorSansProvider, ExistingSansProvider, FactorySansProvider, StaticClassSansProvider, ValueSansProvider } from './provider';\nexport declare function convertInjectableProviderToFactory(type: Type<any>, provider?: ValueSansProvider | ExistingSansProvider | StaticClassSansProvider | ConstructorSansProvider | FactorySansProvider | ClassSansProvider): () => any;\n"
  },
  {
    "path": "node_modules/@angular/core/src/error_handler.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Provides a hook for centralized exception handling.\n *\n * The default implementation of `ErrorHandler` prints error messages to the `console`. To\n * intercept error handling, write a custom exception handler that replaces this default as\n * appropriate for your app.\n *\n * @usageNotes\n * ### Example\n *\n * ```\n * class MyErrorHandler implements ErrorHandler {\n *   handleError(error) {\n *     // do something with the exception\n *   }\n * }\n *\n * @NgModule({\n *   providers: [{provide: ErrorHandler, useClass: MyErrorHandler}]\n * })\n * class MyModule {}\n * ```\n *\n * @publicApi\n */\nexport declare class ErrorHandler {\n    handleError(error: any): void;\n}\nexport declare function wrappedError(message: string, originalError: any): Error;\n"
  },
  {
    "path": "node_modules/@angular/core/src/errors.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { DebugContext } from './view';\nexport declare const ERROR_TYPE = \"ngType\";\nexport declare const ERROR_DEBUG_CONTEXT = \"ngDebugContext\";\nexport declare const ERROR_ORIGINAL_ERROR = \"ngOriginalError\";\nexport declare const ERROR_LOGGER = \"ngErrorLogger\";\nexport declare function getType(error: Error): Function;\nexport declare function getDebugContext(error: Error): DebugContext;\nexport declare function getOriginalError(error: Error): Error;\nexport declare function getErrorLogger(error: Error): (console: Console, ...values: any[]) => void;\n"
  },
  {
    "path": "node_modules/@angular/core/src/event_emitter.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { Subject } from 'rxjs';\n/**\n * Use in directives and components to emit custom events synchronously\n * or asynchronously, and register handlers for those events by subscribing\n * to an instance.\n *\n * @usageNotes\n *\n * In the following example, a component defines two output properties\n * that create event emitters. When the title is clicked, the emitter\n * emits an open or close event to toggle the current visibility state.\n *\n * ```\n * @Component({\n *   selector: 'zippy',\n *   template: `\n *   <div class=\"zippy\">\n *     <div (click)=\"toggle()\">Toggle</div>\n *     <div [hidden]=\"!visible\">\n *       <ng-content></ng-content>\n *     </div>\n *  </div>`})\n * export class Zippy {\n *   visible: boolean = true;\n *   @Output() open: EventEmitter<any> = new EventEmitter();\n *   @Output() close: EventEmitter<any> = new EventEmitter();\n *\n *   toggle() {\n *     this.visible = !this.visible;\n *     if (this.visible) {\n *       this.open.emit(null);\n *     } else {\n *       this.close.emit(null);\n *     }\n *   }\n * }\n * ```\n *\n * Access the event object with the `$event` argument passed to the output event\n * handler:\n *\n * ```\n * <zippy (open)=\"onOpen($event)\" (close)=\"onClose($event)\"></zippy>\n * ```\n *\n * ### Notes\n *\n * Uses Rx.Observable but provides an adapter to make it work as specified here:\n * https://github.com/jhusain/observable-spec\n *\n * Once a reference implementation of the spec is available, switch to it.\n *\n * @publicApi\n */\nexport declare class EventEmitter<T> extends Subject<T> {\n    /**\n     * Internal\n     */\n    __isAsync: boolean;\n    /**\n     * Creates an instance of this class that can\n     * deliver events synchronously or asynchronously.\n     *\n     * @param isAsync When true, deliver events asynchronously.\n     *\n     */\n    constructor(isAsync?: boolean);\n    /**\n     * Emits an event containing a given value.\n     * @param value The value to emit.\n     */\n    emit(value?: T): void;\n    /**\n     * Registers handlers for events emitted by this instance.\n     * @param generatorOrNext When supplied, a custom handler for emitted events.\n     * @param error When supplied, a custom handler for an error notification\n     * from this emitter.\n     * @param complete When supplied, a custom handler for a completion\n     * notification from this emitter.\n     */\n    subscribe(generatorOrNext?: any, error?: any, complete?: any): any;\n}\n"
  },
  {
    "path": "node_modules/@angular/core/src/i18n/tokens.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { InjectionToken } from '../di/injection_token';\n/**\n * Provide this token to set the locale of your application.\n * It is used for i18n extraction, by i18n pipes (DatePipe, I18nPluralPipe, CurrencyPipe,\n * DecimalPipe and PercentPipe) and by ICU expressions.\n *\n * See the [i18n guide](guide/i18n#setting-up-locale) for more information.\n *\n * @usageNotes\n * ### Example\n *\n * ```typescript\n * import { LOCALE_ID } from '@angular/core';\n * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n * import { AppModule } from './app/app.module';\n *\n * platformBrowserDynamic().bootstrapModule(AppModule, {\n *   providers: [{provide: LOCALE_ID, useValue: 'en-US' }]\n * });\n * ```\n *\n * @publicApi\n */\nexport declare const LOCALE_ID: InjectionToken<string>;\n/**\n * Use this token at bootstrap to provide the content of your translation file (`xtb`,\n * `xlf` or `xlf2`) when you want to translate your application in another language.\n *\n * See the [i18n guide](guide/i18n#merge) for more information.\n *\n * @usageNotes\n * ### Example\n *\n * ```typescript\n * import { TRANSLATIONS } from '@angular/core';\n * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n * import { AppModule } from './app/app.module';\n *\n * // content of your translation file\n * const translations = '....';\n *\n * platformBrowserDynamic().bootstrapModule(AppModule, {\n *   providers: [{provide: TRANSLATIONS, useValue: translations }]\n * });\n * ```\n *\n * @publicApi\n */\nexport declare const TRANSLATIONS: InjectionToken<string>;\n/**\n * Provide this token at bootstrap to set the format of your {@link TRANSLATIONS}: `xtb`,\n * `xlf` or `xlf2`.\n *\n * See the [i18n guide](guide/i18n#merge) for more information.\n *\n * @usageNotes\n * ### Example\n *\n * ```typescript\n * import { TRANSLATIONS_FORMAT } from '@angular/core';\n * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n * import { AppModule } from './app/app.module';\n *\n * platformBrowserDynamic().bootstrapModule(AppModule, {\n *   providers: [{provide: TRANSLATIONS_FORMAT, useValue: 'xlf' }]\n * });\n * ```\n *\n * @publicApi\n */\nexport declare const TRANSLATIONS_FORMAT: InjectionToken<string>;\n/**\n * Use this enum at bootstrap as an option of `bootstrapModule` to define the strategy\n * that the compiler should use in case of missing translations:\n * - Error: throw if you have missing translations.\n * - Warning (default): show a warning in the console and/or shell.\n * - Ignore: do nothing.\n *\n * See the [i18n guide](guide/i18n#missing-translation) for more information.\n *\n * @usageNotes\n * ### Example\n * ```typescript\n * import { MissingTranslationStrategy } from '@angular/core';\n * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n * import { AppModule } from './app/app.module';\n *\n * platformBrowserDynamic().bootstrapModule(AppModule, {\n *   missingTranslation: MissingTranslationStrategy.Error\n * });\n * ```\n *\n * @publicApi\n */\nexport declare enum MissingTranslationStrategy {\n    Error = 0,\n    Warning = 1,\n    Ignore = 2\n}\n"
  },
  {
    "path": "node_modules/@angular/core/src/is_dev_mode.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Returns whether Angular is in development mode. After called once,\n * the value is locked and won't change any more.\n *\n * By default, this is true, unless a user calls `enableProdMode` before calling this.\n *\n * @publicApi\n */\nexport declare function isDevMode(): boolean;\n/**\n * Disable Angular's development mode, which turns off assertions and other\n * checks within the framework.\n *\n * One important assertion this disables verifies that a change detection pass\n * does not result in additional changes to any bindings (also known as\n * unidirectional data flow).\n *\n * @publicApi\n */\nexport declare function enableProdMode(): void;\n"
  },
  {
    "path": "node_modules/@angular/core/src/ivy_switch.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nexport declare const SWITCH_IVY_ENABLED__POST_R3__ = true;\nexport declare const ivyEnabled = false;\n"
  },
  {
    "path": "node_modules/@angular/core/src/linker.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nexport { COMPILER_OPTIONS, Compiler, CompilerFactory, CompilerOptions, ModuleWithComponentFactories } from './linker/compiler';\nexport { ComponentFactory, ComponentRef } from './linker/component_factory';\nexport { ComponentFactoryResolver } from './linker/component_factory_resolver';\nexport { ElementRef } from './linker/element_ref';\nexport { NgModuleFactory, NgModuleRef } from './linker/ng_module_factory';\nexport { NgModuleFactoryLoader, getModuleFactory } from './linker/ng_module_factory_loader';\nexport { QueryList } from './linker/query_list';\nexport { SystemJsNgModuleLoader, SystemJsNgModuleLoaderConfig } from './linker/system_js_ng_module_factory_loader';\nexport { TemplateRef } from './linker/template_ref';\nexport { ViewContainerRef } from './linker/view_container_ref';\nexport { EmbeddedViewRef, ViewRef } from './linker/view_ref';\n"
  },
  {
    "path": "node_modules/@angular/core/src/linker/compiler.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { InjectionToken } from '../di/injection_token';\nimport { StaticProvider } from '../di/provider';\nimport { MissingTranslationStrategy } from '../i18n/tokens';\nimport { ViewEncapsulation } from '../metadata';\nimport { Type } from '../type';\nimport { ComponentFactory } from './component_factory';\nimport { NgModuleFactory } from './ng_module_factory';\n/**\n * Combination of NgModuleFactory and ComponentFactorys.\n *\n * @publicApi\n */\nexport declare class ModuleWithComponentFactories<T> {\n    ngModuleFactory: NgModuleFactory<T>;\n    componentFactories: ComponentFactory<any>[];\n    constructor(ngModuleFactory: NgModuleFactory<T>, componentFactories: ComponentFactory<any>[]);\n}\n/**\n * Low-level service for running the angular compiler during runtime\n * to create {@link ComponentFactory}s, which\n * can later be used to create and render a Component instance.\n *\n * Each `@NgModule` provides an own `Compiler` to its injector,\n * that will use the directives/pipes of the ng module for compilation\n * of components.\n *\n * @publicApi\n */\nexport declare class Compiler {\n    /**\n     * Compiles the given NgModule and all of its components. All templates of the components listed\n     * in `entryComponents` have to be inlined.\n     */\n    compileModuleSync<T>(moduleType: Type<T>): NgModuleFactory<T>;\n    /**\n     * Compiles the given NgModule and all of its components\n     */\n    compileModuleAsync<T>(moduleType: Type<T>): Promise<NgModuleFactory<T>>;\n    /**\n     * Same as {@link #compileModuleSync} but also creates ComponentFactories for all components.\n     */\n    compileModuleAndAllComponentsSync<T>(moduleType: Type<T>): ModuleWithComponentFactories<T>;\n    /**\n     * Same as {@link #compileModuleAsync} but also creates ComponentFactories for all components.\n     */\n    compileModuleAndAllComponentsAsync<T>(moduleType: Type<T>): Promise<ModuleWithComponentFactories<T>>;\n    /**\n     * Clears all caches.\n     */\n    clearCache(): void;\n    /**\n     * Clears the cache for the given component/ngModule.\n     */\n    clearCacheFor(type: Type<any>): void;\n    /**\n     * Returns the id for a given NgModule, if one is defined and known to the compiler.\n     */\n    getModuleId(moduleType: Type<any>): string | undefined;\n}\n/**\n * Options for creating a compiler\n *\n * @publicApi\n */\nexport declare type CompilerOptions = {\n    useJit?: boolean;\n    defaultEncapsulation?: ViewEncapsulation;\n    providers?: StaticProvider[];\n    missingTranslation?: MissingTranslationStrategy;\n    preserveWhitespaces?: boolean;\n};\n/**\n * Token to provide CompilerOptions in the platform injector.\n *\n * @publicApi\n */\nexport declare const COMPILER_OPTIONS: InjectionToken<CompilerOptions[]>;\n/**\n * A factory for creating a Compiler\n *\n * @publicApi\n */\nexport declare abstract class CompilerFactory {\n    abstract createCompiler(options?: CompilerOptions[]): Compiler;\n}\n"
  },
  {
    "path": "node_modules/@angular/core/src/linker/component_factory_resolver.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { Injector } from '../di/injector';\nimport { Type } from '../type';\nimport { ComponentFactory, ComponentRef } from './component_factory';\nimport { NgModuleRef } from './ng_module_factory';\nexport declare function noComponentFactoryError(component: Function): Error;\nexport declare function getComponent(error: Error): Type<any>;\n/**\n * @publicApi\n */\nexport declare abstract class ComponentFactoryResolver {\n    static NULL: ComponentFactoryResolver;\n    abstract resolveComponentFactory<T>(component: Type<T>): ComponentFactory<T>;\n}\nexport declare class CodegenComponentFactoryResolver implements ComponentFactoryResolver {\n    private _parent;\n    private _ngModule;\n    private _factories;\n    constructor(factories: ComponentFactory<any>[], _parent: ComponentFactoryResolver, _ngModule: NgModuleRef<any>);\n    resolveComponentFactory<T>(component: {\n        new (...args: any[]): T;\n    }): ComponentFactory<T>;\n}\nexport declare class ComponentFactoryBoundToModule<C> extends ComponentFactory<C> {\n    private factory;\n    private ngModule;\n    readonly selector: string;\n    readonly componentType: Type<any>;\n    readonly ngContentSelectors: string[];\n    readonly inputs: {\n        propName: string;\n        templateName: string;\n    }[];\n    readonly outputs: {\n        propName: string;\n        templateName: string;\n    }[];\n    constructor(factory: ComponentFactory<C>, ngModule: NgModuleRef<any>);\n    create(injector: Injector, projectableNodes?: any[][], rootSelectorOrNode?: string | any, ngModule?: NgModuleRef<any>): ComponentRef<C>;\n}\n"
  },
  {
    "path": "node_modules/@angular/core/src/linker/component_factory.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { ChangeDetectorRef } from '../change_detection/change_detection';\nimport { Injector } from '../di/injector';\nimport { Type } from '../type';\nimport { ElementRef } from './element_ref';\nimport { NgModuleRef } from './ng_module_factory';\nimport { ViewRef } from './view_ref';\n/**\n * Represents a component created by a `ComponentFactory`.\n * Provides access to the component instance and related objects,\n * and provides the means of destroying the instance.\n *\n * @publicApi\n */\nexport declare abstract class ComponentRef<C> {\n    /**\n     * The host or anchor [element](guide/glossary#element) for this component instance.\n     */\n    abstract readonly location: ElementRef;\n    /**\n     * The [dependency injector](guide/glossary#injector) for this component instance.\n     */\n    abstract readonly injector: Injector;\n    /**\n     * This component instance.\n     */\n    abstract readonly instance: C;\n    /**\n     * The [host view](guide/glossary#view-tree) defined by the template\n     * for this component instance.\n     */\n    abstract readonly hostView: ViewRef;\n    /**\n     * The change detector for this component instance.\n     */\n    abstract readonly changeDetectorRef: ChangeDetectorRef;\n    /**\n     * The component type.\n     */\n    abstract readonly componentType: Type<any>;\n    /**\n     * Destroys the component instance and all of the data structures associated with it.\n     */\n    abstract destroy(): void;\n    /**\n     * A lifecycle hook that provides additional developer-defined cleanup\n     * functionality for the component.\n     * @param callback A handler function that cleans up developer-defined data\n     * associated with this component. Called when the `destroy()` method is invoked.\n     */\n    abstract onDestroy(callback: Function): void;\n}\n/**\n * @publicApi\n */\nexport declare abstract class ComponentFactory<C> {\n    /**\n     * The component's HTML selector.\n     */\n    abstract readonly selector: string;\n    /**\n     * The component's type\n     */\n    abstract readonly componentType: Type<any>;\n    /**\n     * Selector for all <ng-content> elements in the component.\n     */\n    abstract readonly ngContentSelectors: string[];\n    /**\n     * The inputs of the component.\n     */\n    abstract readonly inputs: {\n        propName: string;\n        templateName: string;\n    }[];\n    /**\n     * The outputs of the component.\n     */\n    abstract readonly outputs: {\n        propName: string;\n        templateName: string;\n    }[];\n    /**\n     * Creates a new component.\n     */\n    abstract create(injector: Injector, projectableNodes?: any[][], rootSelectorOrNode?: string | any, ngModule?: NgModuleRef<any>): ComponentRef<C>;\n}\n"
  },
  {
    "path": "node_modules/@angular/core/src/linker/element_ref.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { injectElementRef as render3InjectElementRef } from '../render3/view_engine_compatibility';\n/**\n * A wrapper around a native element inside of a View.\n *\n * An `ElementRef` is backed by a render-specific element. In the browser, this is usually a DOM\n * element.\n *\n * @security Permitting direct access to the DOM can make your application more vulnerable to\n * XSS attacks. Carefully review any use of `ElementRef` in your code. For more detail, see the\n * [Security Guide](http://g.co/ng/security).\n *\n * @publicApi\n */\nexport declare class ElementRef<T = any> {\n    /**\n     * The underlying native element or `null` if direct access to native elements is not supported\n     * (e.g. when the application runs in a web worker).\n     *\n     * <div class=\"callout is-critical\">\n     *   <header>Use with caution</header>\n     *   <p>\n     *    Use this API as the last resort when direct access to DOM is needed. Use templating and\n     *    data-binding provided by Angular instead. Alternatively you can take a look at {@link\n     * Renderer2}\n     *    which provides API that can safely be used even when direct access to native elements is not\n     *    supported.\n     *   </p>\n     *   <p>\n     *    Relying on direct DOM access creates tight coupling between your application and rendering\n     *    layers which will make it impossible to separate the two and deploy your application into a\n     *    web worker.\n     *   </p>\n     * </div>\n     *\n     */\n    nativeElement: T;\n    constructor(nativeElement: T);\n}\nexport declare const SWITCH_ELEMENT_REF_FACTORY__POST_R3__: typeof render3InjectElementRef;\n"
  },
  {
    "path": "node_modules/@angular/core/src/linker/ng_module_factory_loader.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { NgModuleFactory } from './ng_module_factory';\n/**\n * Used to load ng module factories.\n *\n * @publicApi\n */\nexport declare abstract class NgModuleFactoryLoader {\n    abstract load(path: string): Promise<NgModuleFactory<any>>;\n}\n/**\n * Registers a loaded module. Should only be called from generated NgModuleFactory code.\n * @publicApi\n */\nexport declare function registerModuleFactory(id: string, factory: NgModuleFactory<any>): void;\nexport declare function clearModulesForTest(): void;\n/**\n * Returns the NgModuleFactory with the given id, if it exists and has been loaded.\n * Factories for modules that do not specify an `id` cannot be retrieved. Throws if the module\n * cannot be found.\n * @publicApi\n */\nexport declare function getModuleFactory(id: string): NgModuleFactory<any>;\n"
  },
  {
    "path": "node_modules/@angular/core/src/linker/ng_module_factory.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { Injector } from '../di/injector';\nimport { Type } from '../type';\nimport { ComponentFactoryResolver } from './component_factory_resolver';\n/**\n * Represents an instance of an NgModule created via a {@link NgModuleFactory}.\n *\n * `NgModuleRef` provides access to the NgModule Instance as well other objects related to this\n * NgModule Instance.\n *\n * @publicApi\n */\nexport declare abstract class NgModuleRef<T> {\n    /**\n     * The injector that contains all of the providers of the NgModule.\n     */\n    abstract readonly injector: Injector;\n    /**\n     * The ComponentFactoryResolver to get hold of the ComponentFactories\n     * declared in the `entryComponents` property of the module.\n     */\n    abstract readonly componentFactoryResolver: ComponentFactoryResolver;\n    /**\n     * The NgModule instance.\n     */\n    abstract readonly instance: T;\n    /**\n     * Destroys the module instance and all of the data structures associated with it.\n     */\n    abstract destroy(): void;\n    /**\n     * Allows to register a callback that will be called when the module is destroyed.\n     */\n    abstract onDestroy(callback: () => void): void;\n}\nexport interface InternalNgModuleRef<T> extends NgModuleRef<T> {\n    _bootstrapComponents: Type<any>[];\n}\n/**\n * @publicApi\n */\nexport declare abstract class NgModuleFactory<T> {\n    abstract readonly moduleType: Type<T>;\n    abstract create(parentInjector: Injector | null): NgModuleRef<T>;\n}\n"
  },
  {
    "path": "node_modules/@angular/core/src/linker/query_list.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { Observable } from 'rxjs';\n/**\n * An unmodifiable list of items that Angular keeps up to date when the state\n * of the application changes.\n *\n * The type of object that {@link ViewChildren}, {@link ContentChildren}, and {@link QueryList}\n * provide.\n *\n * Implements an iterable interface, therefore it can be used in both ES6\n * javascript `for (var i of items)` loops as well as in Angular templates with\n * `*ngFor=\"let i of myList\"`.\n *\n * Changes can be observed by subscribing to the changes `Observable`.\n *\n * NOTE: In the future this class will implement an `Observable` interface.\n *\n * @usageNotes\n * ### Example\n * ```typescript\n * @Component({...})\n * class Container {\n *   @ViewChildren(Item) items:QueryList<Item>;\n * }\n * ```\n *\n * @publicApi\n */\nexport declare class QueryList<T> {\n    readonly dirty = true;\n    private _results;\n    readonly changes: Observable<any>;\n    readonly length: number;\n    readonly first: T;\n    readonly last: T;\n    /**\n     * See\n     * [Array.map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map)\n     */\n    map<U>(fn: (item: T, index: number, array: T[]) => U): U[];\n    /**\n     * See\n     * [Array.filter](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter)\n     */\n    filter(fn: (item: T, index: number, array: T[]) => boolean): T[];\n    /**\n     * See\n     * [Array.find](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find)\n     */\n    find(fn: (item: T, index: number, array: T[]) => boolean): T | undefined;\n    /**\n     * See\n     * [Array.reduce](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce)\n     */\n    reduce<U>(fn: (prevValue: U, curValue: T, curIndex: number, array: T[]) => U, init: U): U;\n    /**\n     * See\n     * [Array.forEach](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach)\n     */\n    forEach(fn: (item: T, index: number, array: T[]) => void): void;\n    /**\n     * See\n     * [Array.some](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some)\n     */\n    some(fn: (value: T, index: number, array: T[]) => boolean): boolean;\n    toArray(): T[];\n    toString(): string;\n    reset(res: Array<T | any[]>): void;\n    notifyOnChanges(): void;\n    /** internal */\n    setDirty(): void;\n    /** internal */\n    destroy(): void;\n}\n"
  },
  {
    "path": "node_modules/@angular/core/src/linker/system_js_ng_module_factory_loader.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { Compiler } from './compiler';\nimport { NgModuleFactory } from './ng_module_factory';\nimport { NgModuleFactoryLoader } from './ng_module_factory_loader';\n/**\n * Configuration for SystemJsNgModuleLoader.\n * token.\n *\n * @publicApi\n */\nexport declare abstract class SystemJsNgModuleLoaderConfig {\n    /**\n     * Prefix to add when computing the name of the factory module for a given module name.\n     */\n    factoryPathPrefix: string;\n    /**\n     * Suffix to add when computing the name of the factory module for a given module name.\n     */\n    factoryPathSuffix: string;\n}\n/**\n * NgModuleFactoryLoader that uses SystemJS to load NgModuleFactory\n * @publicApi\n */\nexport declare class SystemJsNgModuleLoader implements NgModuleFactoryLoader {\n    private _compiler;\n    private _config;\n    constructor(_compiler: Compiler, config?: SystemJsNgModuleLoaderConfig);\n    load(path: string): Promise<NgModuleFactory<any>>;\n    private loadAndCompile;\n    private loadFactory;\n}\n"
  },
  {
    "path": "node_modules/@angular/core/src/linker/template_ref.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { injectTemplateRef as render3InjectTemplateRef } from '../render3/view_engine_compatibility';\nimport { ElementRef } from './element_ref';\nimport { EmbeddedViewRef } from './view_ref';\n/**\n * Represents an embedded template that can be used to instantiate embedded views.\n * To instantiate embedded views based on a template, use the `ViewContainerRef`\n * method `createEmbeddedView()`.\n *\n * Access a `TemplateRef` instance by placing a directive on an `<ng-template>`\n * element (or directive prefixed with `*`). The `TemplateRef` for the embedded view\n * is injected into the constructor of the directive,\n * using the `TemplateRef` token.\n *\n * You can also use a `Query` to find a `TemplateRef` associated with\n * a component or a directive.\n *\n * @see `ViewContainerRef`\n * @see [Navigate the Component Tree with DI](guide/dependency-injection-navtree)\n *\n * @publicApi\n */\nexport declare abstract class TemplateRef<C> {\n    /**\n     * The anchor element in the parent view for this embedded view.\n     *\n     * The data-binding and injection contexts of embedded views created from this `TemplateRef`\n     * inherit from the contexts of this location.\n     *\n     * Typically new embedded views are attached to the view container of this location, but in\n     * advanced use-cases, the view can be attached to a different container while keeping the\n     * data-binding and injection context from the original location.\n     *\n     */\n    abstract readonly elementRef: ElementRef;\n    /**\n     * Creates a view object and attaches it to the view container of the parent view.\n     * @param context The context for the new view, inherited from the anchor element.\n     * @returns The new view object.\n     */\n    abstract createEmbeddedView(context: C): EmbeddedViewRef<C>;\n}\nexport declare const SWITCH_TEMPLATE_REF_FACTORY__POST_R3__: typeof render3InjectTemplateRef;\n"
  },
  {
    "path": "node_modules/@angular/core/src/linker/view_container_ref.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { Injector } from '../di/injector';\nimport { injectViewContainerRef as render3InjectViewContainerRef } from '../render3/view_engine_compatibility';\nimport { ComponentFactory, ComponentRef } from './component_factory';\nimport { ElementRef } from './element_ref';\nimport { NgModuleRef } from './ng_module_factory';\nimport { TemplateRef } from './template_ref';\nimport { EmbeddedViewRef, ViewRef } from './view_ref';\n/**\n * Represents a container where one or more views can be attached to a component.\n *\n * Can contain *host views* (created by instantiating a\n * component with the `createComponent()` method), and *embedded views*\n * (created by instantiating a `TemplateRef` with the `createEmbeddedView()` method).\n *\n * A view container instance can contain other view containers,\n * creating a [view hierarchy](guide/glossary#view-tree).\n *\n * @see `ComponentRef`\n * @see `EmbeddedViewRef`\n *\n * @publicApi\n */\nexport declare abstract class ViewContainerRef {\n    /**\n     * Anchor element that specifies the location of this container in the containing view.\n     * Each view container can have only one anchor element, and each anchor element\n     * can have only a single view container.\n     *\n     * Root elements of views attached to this container become siblings of the anchor element in\n     * the rendered view.\n     *\n     * Access the `ViewContainerRef` of an element by placing a `Directive` injected\n     * with `ViewContainerRef` on the element, or use a `ViewChild` query.\n     *\n     * <!-- TODO: rename to anchorElement -->\n     */\n    abstract readonly element: ElementRef;\n    /**\n     * The [dependency injector](guide/glossary#injector) for this view container.\n     */\n    abstract readonly injector: Injector;\n    /** @deprecated No replacement */\n    abstract readonly parentInjector: Injector;\n    /**\n     * Destroys all views in this container.\n     */\n    abstract clear(): void;\n    /**\n     * Retrieves a view from this container.\n     * @param index The 0-based index of the view to retrieve.\n     * @returns The `ViewRef` instance, or null if the index is out of range.\n     */\n    abstract get(index: number): ViewRef | null;\n    /**\n     * Reports how many views are currently attached to this container.\n     * @returns The number of views.\n     */\n    abstract readonly length: number;\n    /**\n     * Instantiates an embedded view and inserts it\n     * into this container.\n     * @param templateRef The HTML template that defines the view.\n     * @param index The 0-based index at which to insert the new view into this container.\n     * If not specified, appends the new view as the last entry.\n     *\n     * @returns The `ViewRef` instance for the newly created view.\n     */\n    abstract createEmbeddedView<C>(templateRef: TemplateRef<C>, context?: C, index?: number): EmbeddedViewRef<C>;\n    /**\n     * Instantiates a single component and inserts its host view into this container.\n     *\n     * @param componentFactory The factory to use.\n     * @param index The index at which to insert the new component's host view into this container.\n     * If not specified, appends the new view as the last entry.\n     * @param injector The injector to use as the parent for the new component.\n     * @param projectableNodes\n     * @param ngModule\n     *\n     * @returns The new component instance, containing the host view.\n     *\n     */\n    abstract createComponent<C>(componentFactory: ComponentFactory<C>, index?: number, injector?: Injector, projectableNodes?: any[][], ngModule?: NgModuleRef<any>): ComponentRef<C>;\n    /**\n     * Inserts a view into this container.\n     * @param viewRef The view to insert.\n     * @param index The 0-based index at which to insert the view.\n     * If not specified, appends the new view as the last entry.\n     * @returns The inserted `ViewRef` instance.\n     *\n     */\n    abstract insert(viewRef: ViewRef, index?: number): ViewRef;\n    /**\n     * Moves a view to a new location in this container.\n     * @param viewRef The view to move.\n     * @param index The 0-based index of the new location.\n     * @returns The moved `ViewRef` instance.\n     */\n    abstract move(viewRef: ViewRef, currentIndex: number): ViewRef;\n    /**\n     * Returns the index of a view within the current container.\n     * @param viewRef The view to query.\n     * @returns The 0-based index of the view's position in this container,\n     * or `-1` if this container doesn't contain the view.\n     */\n    abstract indexOf(viewRef: ViewRef): number;\n    /**\n     * Destroys a view attached to this container\n     * @param index The 0-based index of the view to destroy.\n     * If not specified, the last view in the container is removed.\n     */\n    abstract remove(index?: number): void;\n    /**\n     * Detaches a view from this container without destroying it.\n     * Use along with `insert()` to move a view within the current container.\n     * @param index The 0-based index of the view to detach.\n     * If not specified, the last view in the container is detached.\n     */\n    abstract detach(index?: number): ViewRef | null;\n}\nexport declare const SWITCH_VIEW_CONTAINER_REF_FACTORY__POST_R3__: typeof render3InjectViewContainerRef;\n"
  },
  {
    "path": "node_modules/@angular/core/src/linker/view_ref.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { ApplicationRef } from '../application_ref';\nimport { ChangeDetectorRef } from '../change_detection/change_detector_ref';\n/**\n * Represents an Angular [view](guide/glossary#view),\n * specifically the [host view](guide/glossary#view-tree) that is defined by a component.\n * Also serves as the base class\n * that adds destroy methods for [embedded views](guide/glossary#view-tree).\n *\n * @see `EmbeddedViewRef`\n *\n * @publicApi\n */\nexport declare abstract class ViewRef extends ChangeDetectorRef {\n    /**\n     * Destroys this view and all of the data structures associated with it.\n     */\n    abstract destroy(): void;\n    /**\n     * Reports whether this view has been destroyed.\n     * @returns True after the `destroy()` method has been called, false otherwise.\n     */\n    abstract readonly destroyed: boolean;\n    /**\n     * A lifecycle hook that provides additional developer-defined cleanup\n     * functionality for views.\n     * @param callback A handler function that cleans up developer-defined data\n     * associated with a view. Called when the `destroy()` method is invoked.\n     */\n    abstract onDestroy(callback: Function): any /** TODO #9100 */;\n}\n/**\n * Represents an Angular [view](guide/glossary#view) in a view container.\n * An [embedded view](guide/glossary#view-tree) can be referenced from a component\n * other than the hosting component whose template defines it, or it can be defined\n * independently by a `TemplateRef`.\n *\n * Properties of elements in a view can change, but the structure (number and order) of elements in\n * a view cannot. Change the structure of elements by inserting, moving, or\n * removing nested views in a view container.\n *\n * @see `ViewContainerRef`\n *\n * @usageNotes\n *\n * The following template breaks down into two separate `TemplateRef` instances,\n * an outer one and an inner one.\n *\n * ```\n * Count: {{items.length}}\n * <ul>\n *   <li *ngFor=\"let  item of items\">{{item}}</li>\n * </ul>\n * ```\n *\n * This is the outer `TemplateRef`:\n *\n * ```\n * Count: {{items.length}}\n * <ul>\n *   <ng-template ngFor let-item [ngForOf]=\"items\"></ng-template>\n * </ul>\n * ```\n *\n * This is the inner `TemplateRef`:\n *\n * ```\n *   <li>{{item}}</li>\n * ```\n *\n * The outer and inner `TemplateRef` instances are assembled into views as follows:\n *\n * ```\n * <!-- ViewRef: outer-0 -->\n * Count: 2\n * <ul>\n *   <ng-template view-container-ref></ng-template>\n *   <!-- ViewRef: inner-1 --><li>first</li><!-- /ViewRef: inner-1 -->\n *   <!-- ViewRef: inner-2 --><li>second</li><!-- /ViewRef: inner-2 -->\n * </ul>\n * <!-- /ViewRef: outer-0 -->\n * ```\n * @publicApi\n */\nexport declare abstract class EmbeddedViewRef<C> extends ViewRef {\n    /**\n     * The context for this view, inherited from the anchor element.\n     */\n    abstract readonly context: C;\n    /**\n     * The root nodes for this embedded view.\n     */\n    abstract readonly rootNodes: any[];\n}\nexport interface InternalViewRef extends ViewRef {\n    detachFromAppRef(): void;\n    attachToAppRef(appRef: ApplicationRef): void;\n}\n"
  },
  {
    "path": "node_modules/@angular/core/src/metadata.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nexport { ANALYZE_FOR_ENTRY_COMPONENTS, Attribute, ContentChild, ContentChildDecorator, ContentChildren, ContentChildrenDecorator, Query, ViewChild, ViewChildDecorator, ViewChildren, ViewChildrenDecorator } from './metadata/di';\nexport { Component, ComponentDecorator, Directive, DirectiveDecorator, HostBinding, HostListener, Input, Output, Pipe } from './metadata/directives';\nexport { AfterContentChecked, AfterContentInit, AfterViewChecked, AfterViewInit, DoCheck, OnChanges, OnDestroy, OnInit } from './metadata/lifecycle_hooks';\nexport { CUSTOM_ELEMENTS_SCHEMA, DoBootstrap, ModuleWithProviders, NO_ERRORS_SCHEMA, NgModule, SchemaMetadata } from './metadata/ng_module';\nexport { ViewEncapsulation } from './metadata/view';\n"
  },
  {
    "path": "node_modules/@angular/core/src/metadata/di.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { InjectionToken } from '../di/injection_token';\nimport { Type } from '../type';\n/**\n * This token can be used to create a virtual provider that will populate the\n * `entryComponents` fields of components and ng modules based on its `useValue`.\n * All components that are referenced in the `useValue` value (either directly\n * or in a nested array or map) will be added to the `entryComponents` property.\n *\n * @usageNotes\n * ### Example\n * The following example shows how the router can populate the `entryComponents`\n * field of an NgModule based on the router configuration which refers\n * to components.\n *\n * ```typescript\n * // helper function inside the router\n * function provideRoutes(routes) {\n *   return [\n *     {provide: ROUTES, useValue: routes},\n *     {provide: ANALYZE_FOR_ENTRY_COMPONENTS, useValue: routes, multi: true}\n *   ];\n * }\n *\n * // user code\n * let routes = [\n *   {path: '/root', component: RootComp},\n *   {path: '/teams', component: TeamsComp}\n * ];\n *\n * @NgModule({\n *   providers: [provideRoutes(routes)]\n * })\n * class ModuleWithRoutes {}\n * ```\n *\n * @publicApi\n */\nexport declare const ANALYZE_FOR_ENTRY_COMPONENTS: InjectionToken<any>;\n/**\n * Type of the Attribute decorator / constructor function.\n *\n *\n */\nexport interface AttributeDecorator {\n    /**\n     * Specifies that a constant attribute value should be injected.\n     *\n     * The directive can inject constant string literals of host element attributes.\n     *\n     * @usageNotes\n     * ### Example\n     *\n     * Suppose we have an `<input>` element and want to know its `type`.\n     *\n     * ```html\n     * <input type=\"text\">\n     * ```\n     *\n     * A decorator can inject string literal `text` like so:\n     *\n     * {@example core/ts/metadata/metadata.ts region='attributeMetadata'}\n     *\n     * ### Example as TypeScript Decorator\n     *\n     * {@example core/ts/metadata/metadata.ts region='attributeFactory'}\n     *\n     * ### Example as ES5 annotation\n     *\n     * ```\n     * var MyComponent = function(title) {\n     *   ...\n     * };\n     *\n     * MyComponent.annotations = [\n     *   new ng.Component({...})\n     * ]\n     * MyComponent.parameters = [\n     *   [new ng.Attribute('title')]\n     * ]\n     * ```\n     *\n     *\n     */\n    (name: string): any;\n    new (name: string): Attribute;\n}\n/**\n * Type of the Attribute metadata.\n */\nexport interface Attribute {\n    attributeName?: string;\n}\n/**\n * Attribute decorator and metadata.\n *\n * @Annotation\n * @publicApi\n */\nexport declare const Attribute: AttributeDecorator;\n/**\n * Type of the Query metadata.\n */\nexport interface Query {\n    descendants: boolean;\n    first: boolean;\n    read: any;\n    isViewQuery: boolean;\n    selector: any;\n}\n/**\n * Base class for query metadata.\n *\n * @see `ContentChildren`.\n * @see `ContentChild`.\n * @see `ViewChildren`.\n * @see `ViewChild`.\n *\n * @publicApi\n */\nexport declare abstract class Query {\n}\n/**\n * Type of the ContentChildren decorator / constructor function.\n *\n * @see `ContentChildren`.\n * @publicApi\n */\nexport interface ContentChildrenDecorator {\n    /**\n     * Configures a content query.\n     *\n     * You can use ContentChildren to get the `QueryList` of elements or directives from the\n     * content DOM. Any time a child element is added, removed, or moved, the query list will be\n     * updated, and the changes observable of the query list will emit a new value.\n     *\n     * Content queries are set before the `ngAfterContentInit` callback is called.\n     *\n     * **Metadata Properties**:\n     *\n     * * **selector** - the directive type or the name used for querying.\n     * * **descendants** - include only direct children or all descendants.\n     * * **read** - read a different token from the queried elements.\n     *\n     * @usageNotes\n     * ### Basic Example\n     *\n     * Here is a simple demonstration of how the `ContentChildren` decorator can be used.\n     *\n     * {@example core/di/ts/contentChildren/content_children_howto.ts region='HowTo'}\n     *\n     * ### Tab-pane Example\n     *\n     * Here is a slightly more realistic example that shows how `ContentChildren` decorators\n     * can be used to implement a tab pane component.\n     *\n     * {@example core/di/ts/contentChildren/content_children_example.ts region='Component'}\n     *\n     * @Annotation\n     */\n    (selector: Type<any> | Function | string, opts?: {\n        descendants?: boolean;\n        read?: any;\n    }): any;\n    new (selector: Type<any> | Function | string, opts?: {\n        descendants?: boolean;\n        read?: any;\n    }): Query;\n}\n/**\n * Type of the ContentChildren metadata.\n *\n *\n * @Annotation\n */\nexport declare type ContentChildren = Query;\n/**\n * ContentChildren decorator and metadata.\n *\n *\n * @Annotation\n * @publicApi\n */\nexport declare const ContentChildren: ContentChildrenDecorator;\n/**\n * Type of the ContentChild decorator / constructor function.\n *\n * @publicApi\n */\nexport interface ContentChildDecorator {\n    /**\n     * Configures a content query.\n     *\n     * You can use ContentChild to get the first element or the directive matching the selector from\n     * the content DOM. If the content DOM changes, and a new child matches the selector,\n     * the property will be updated.\n     *\n     * Content queries are set before the `ngAfterContentInit` callback is called.\n     *\n     * **Metadata Properties**:\n     *\n     * * **selector** - the directive type or the name used for querying.\n     * * **read** - read a different token from the queried element.\n     *\n     * @usageNotes\n     * ### Example\n     *\n     * {@example core/di/ts/contentChild/content_child_howto.ts region='HowTo'}\n     *\n     * ### Example\n     *\n     * {@example core/di/ts/contentChild/content_child_example.ts region='Component'}\n     *\n     * @Annotation\n     */\n    (selector: Type<any> | Function | string, opts?: {\n        read?: any;\n    }): any;\n    new (selector: Type<any> | Function | string, opts?: {\n        read?: any;\n    }): ContentChild;\n}\n/**\n * Type of the ContentChild metadata.\n *\n * @see `ContentChild`.\n *\n *\n */\nexport declare type ContentChild = Query;\n/**\n * ContentChild decorator and metadata.\n *\n *\n * @Annotation\n * @publicApi\n */\nexport declare const ContentChild: ContentChildDecorator;\n/**\n * Type of the ViewChildren decorator / constructor function.\n *\n * @see `ViewChildren`.\n *\n * @publicApi\n */\nexport interface ViewChildrenDecorator {\n    /**\n     * Configures a view query.\n     *\n     * You can use ViewChildren to get the `QueryList` of elements or directives from the\n     * view DOM. Any time a child element is added, removed, or moved, the query list will be updated,\n     * and the changes observable of the query list will emit a new value.\n     *\n     * View queries are set before the `ngAfterViewInit` callback is called.\n     *\n     * **Metadata Properties**:\n     *\n     * * **selector** - the directive type or the name used for querying.\n     * * **read** - read a different token from the queried elements.\n     *\n     * @usageNotes\n     *\n     * ### Example\n     *\n     * {@example core/di/ts/viewChildren/view_children_howto.ts region='HowTo'}\n     *\n     * ### Example\n     *\n     * {@example core/di/ts/viewChildren/view_children_example.ts region='Component'}\n     *\n     * @Annotation\n     */\n    (selector: Type<any> | Function | string, opts?: {\n        read?: any;\n    }): any;\n    new (selector: Type<any> | Function | string, opts?: {\n        read?: any;\n    }): ViewChildren;\n}\n/**\n * Type of the ViewChildren metadata.\n */\nexport declare type ViewChildren = Query;\n/**\n * ViewChildren decorator and metadata.\n *\n * @Annotation\n * @publicApi\n */\nexport declare const ViewChildren: ViewChildrenDecorator;\n/**\n * Type of the ViewChild decorator / constructor function.\n *\n * @see `ViewChild`.\n * @publicApi\n */\nexport interface ViewChildDecorator {\n    /**\n     * @description\n     * Property decorator that configures a view query.\n     * The change detector looks for the first element or the directive matching the selector\n     * in the view DOM. If the view DOM changes, and a new child matches the selector,\n     * the property is updated.\n     *\n     * View queries are set before the `ngAfterViewInit` callback is called.\n     *\n     * **Metadata Properties**:\n     *\n     * * **selector** - the directive type or the name used for querying.\n     * * **read** - read a different token from the queried elements.\n     *\n     * Supported selectors include:\n     *   * any class with the `@Component` or `@Directive` decorator\n     *   * a template reference variable as a string (e.g. query `<my-component #cmp></my-component>\n     * with `@ViewChild('cmp')`)\n     *   * any provider defined in the child component tree of the current component (e.g.\n     * `@ViewChild(SomeService) someService: SomeService`)\n     *   * any provider defined through a string token (e.g. `@ViewChild('someToken') someTokenVal:\n     * any`)\n     *   * a `TemplateRef` (e.g. query `<ng-template></ng-template>` with `@ViewChild(TemplateRef)\n     * template;`)\n     *\n     * @usageNotes\n     *\n     * {@example core/di/ts/viewChild/view_child_example.ts region='Component'}\n     *\n     * ### Example\n     *\n     * {@example core/di/ts/viewChild/view_child_howto.ts region='HowTo'}\n     *\n     * ### Example\n     *\n     * {@example core/di/ts/viewChild/view_child_example.ts region='Component'}\n     *\n     * @Annotation\n     */\n    (selector: Type<any> | Function | string, opts?: {\n        read?: any;\n    }): any;\n    new (selector: Type<any> | Function | string, opts?: {\n        read?: any;\n    }): ViewChild;\n}\n/**\n * Type of the ViewChild metadata.\n */\nexport declare type ViewChild = Query;\n/**\n * ViewChild decorator and metadata.\n *\n * @Annotation\n * @publicApi\n */\nexport declare const ViewChild: ViewChildDecorator;\n"
  },
  {
    "path": "node_modules/@angular/core/src/metadata/directives.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { ChangeDetectionStrategy } from '../change_detection/constants';\nimport { Provider } from '../di';\nimport { compileComponent as render3CompileComponent, compileDirective as render3CompileDirective } from '../render3/jit/directive';\nimport { compilePipe as render3CompilePipe } from '../render3/jit/pipe';\nimport { Type } from '../type';\nimport { TypeDecorator } from '../util/decorators';\nimport { ViewEncapsulation } from './view';\n/**\n * Type of the Directive decorator / constructor function.\n * @publicApi\n */\nexport interface DirectiveDecorator {\n    /**\n     * Marks a class as an Angular directive. You can define your own\n     * directives to attach custom behavior to elements in the DOM.\n     * The options provide configuration metadata that determines\n     * how the directive should be processed, instantiated and used at\n     * runtime.\n     *\n     * Directive classes, like component classes, can implement\n     * [life-cycle hooks](guide/lifecycle-hooks) to influence their configuration and behavior.\n     *\n     *\n     * @usageNotes\n     * To define a directive, mark the class with the decorator and provide metadata.\n     *\n     * ```\n     * import {Directive} from '@angular/core';\n     *\n     * @Directive({\n     *   selector: 'my-directive',\n     * })\n     * export class MyDirective {\n     * ...\n     * }\n     * ```\n     *\n     * ### Declaring directives\n     *\n     * Directives are [declarables](guide/glossary#declarable).\n     * They must be declared by an NgModule\n     * in order to be usable in an app.\n     *\n     * A directive must belong to exactly one NgModule. Do not re-declare\n     * a directive imported from another module.\n     * List the directive class in the `declarations` field of an NgModule.\n     *\n     * ```\n     * declarations: [\n     *  AppComponent,\n     *  MyDirective\n     * ],\n     * ```\n     *\n     * @Annotation\n     */\n    (obj: Directive): TypeDecorator;\n    /**\n     * See the `Directive` decorator.\n     */\n    new (obj: Directive): Directive;\n}\nexport interface Directive {\n    /**\n     * The CSS selector that triggers the instantiation of a directive.\n     *\n     * Declare as one of the following:\n     *\n     * - `element-name`: select by element name.\n     * - `.class`: select by class name.\n     * - `[attribute]`: select by attribute name.\n     * - `[attribute=value]`: select by attribute name and value.\n     * - `:not(sub_selector)`: select only if the element does not match the `sub_selector`.\n     * - `selector1, selector2`: select if either `selector1` or `selector2` matches.\n     *\n     * Angular only allows directives to trigger on CSS selectors that do not cross element\n     * boundaries. For example, consider a directive with an `input[type=text]` selector.\n     * For the following HTML, the directive is instantiated only on the\n     * `<input type=\"text\">` element.\n     *\n     * ```html\n     * <form>\n     *   <input type=\"text\">\n     *   <input type=\"radio\">\n     * <form>\n     * ```\n     *\n     */\n    selector?: string;\n    /**\n     * Enumerates the set of data-bound input properties for a directive\n     *\n     * Angular automatically updates input properties during change detection.\n     * The `inputs` property defines a set of `directiveProperty` to `bindingProperty`\n     * configuration:\n     *\n     * - `directiveProperty` specifies the component property where the value is written.\n     * - `bindingProperty` specifies the DOM property where the value is read from.\n     *\n     * When `bindingProperty` is not provided, it is assumed to be equal to `directiveProperty`.\n     * @usageNotes\n     *\n     * ### Example\n     *\n     * The following example creates a component with two data-bound properties.\n     *\n     * ```typescript\n     * @Component({\n     *   selector: 'bank-account',\n     *   inputs: ['bankName', 'id: account-id'],\n     *   template: `\n     *     Bank Name: {{bankName}}\n     *     Account Id: {{id}}\n     *   `\n     * })\n     * class BankAccount {\n     *   bankName: string;\n     *   id: string;\n     *\n     * ```\n     *\n     */\n    inputs?: string[];\n    /**\n     * Enumerates the set of event-bound output properties.\n     *\n     * When an output property emits an event, an event handler attached to that event\n     * in the template is invoked.\n     *\n     * The `outputs` property defines a set of `directiveProperty` to `bindingProperty`\n     * configuration:\n     *\n     * - `directiveProperty` specifies the component property that emits events.\n     * - `bindingProperty` specifies the DOM property the event handler is attached to.\n     *\n     * @usageNotes\n     *\n     * ### Example\n     *\n     * ```typescript\n     * @Directive({\n     *   selector: 'child-dir',\n     *   exportAs: 'child'\n     * })\n     * class ChildDir {\n     * }\n     *\n     * @Component({\n     *   selector: 'main',\n     *   template: `<child-dir #c=\"child\"></child-dir>`\n     * })\n     * class MainComponent {\n     * }\n     * ```\n     *\n     */\n    outputs?: string[];\n    /**\n     * A set of injection tokens that allow the DI system to\n     * provide a dependency to this directive or component.\n     */\n    providers?: Provider[];\n    /**\n     * Defines the name that can be used in the template to assign this directive to a variable.\n     *\n     * @usageNotes\n     *\n     * ### Simple Example\n     *\n     * ```\n     * @Directive({\n     *   selector: 'child-dir',\n     *   exportAs: 'child'\n     * })\n     * class ChildDir {\n     * }\n     *\n     * @Component({\n     *   selector: 'main',\n     *   template: `<child-dir #c=\"child\"></child-dir>`\n     * })\n     * class MainComponent {\n     * }\n     * ```\n     *\n     */\n    exportAs?: string;\n    /**\n     * Configures the queries that will be injected into the directive.\n     *\n     * Content queries are set before the `ngAfterContentInit` callback is called.\n     * View queries are set before the `ngAfterViewInit` callback is called.\n     *\n     * @usageNotes\n     *\n     * ### Example\n     *\n     * The following example shows how queries are defined\n     * and when their results are available in lifecycle hooks:\n     *\n     * ```\n     * @Component({\n     *   selector: 'someDir',\n     *   queries: {\n     *     contentChildren: new ContentChildren(ChildDirective),\n     *     viewChildren: new ViewChildren(ChildDirective)\n     *   },\n     *   template: '<child-directive></child-directive>'\n     * })\n     * class SomeDir {\n     *   contentChildren: QueryList<ChildDirective>,\n     *   viewChildren: QueryList<ChildDirective>\n     *\n     *   ngAfterContentInit() {\n     *     // contentChildren is set\n     *   }\n     *\n     *   ngAfterViewInit() {\n     *     // viewChildren is set\n     *   }\n     * }\n     * ```\n     *\n     * @Annotation\n     */\n    queries?: {\n        [key: string]: any;\n    };\n    /**\n     * If true, this directive/component will be skipped by the AOT compiler and so will always be\n     * compiled using JIT.\n     *\n     * This exists to support future Ivy work and has no effect currently.\n     */\n    jit?: true;\n}\n/**\n * Directive decorator and metadata.\n *\n * @Annotation\n */\nexport interface Directive {\n    /**\n     * The CSS selector that identifies this directive in a template\n     * and triggers instantiation of the directive.\n     *\n     * Declare as one of the following:\n     *\n     * - `element-name`: Select by element name.\n     * - `.class`: Select by class name.\n     * - `[attribute]`: Select by attribute name.\n     * - `[attribute=value]`: Select by attribute name and value.\n     * - `:not(sub_selector)`: Select only if the element does not match the `sub_selector`.\n     * - `selector1, selector2`: Select if either `selector1` or `selector2` matches.\n     *\n     * Angular only allows directives to apply on CSS selectors that do not cross\n     * element boundaries.\n     *\n     * For the following template HTML, a directive with an `input[type=text]` selector,\n     * would be instantiated only on the `<input type=\"text\">` element.\n     *\n     * ```html\n     * <form>\n     *   <input type=\"text\">\n     *   <input type=\"radio\">\n     * <form>\n     * ```\n     *\n     */\n    selector?: string;\n    /**\n     * The set of event-bound output properties.\n     * When an output property emits an event, an event handler attached\n     * to that event in the template is invoked.\n     *\n     * Each output property maps a `directiveProperty` to a `bindingProperty`:\n     * - `directiveProperty` specifies the component property that emits events.\n     * - `bindingProperty` specifies the HTML attribute the event handler is attached to.\n     *\n     */\n    outputs?: string[];\n    /**\n     * Maps class properties to host element bindings for properties,\n     * attributes, and events, using a set of key-value pairs.\n     *\n     * Angular automatically checks host property bindings during change detection.\n     * If a binding changes, Angular updates the directive's host element.\n     *\n     * When the key is a property of the host element, the property value is\n     * the propagated to the specified DOM property.\n     *\n     * When the key is a static attribute in the DOM, the attribute value\n     * is propagated to the specified property in the host element.\n     *\n     * For event handling:\n     * - The key is the DOM event that the directive listens to.\n     * To listen to global events, add the target to the event name.\n     * The target can be `window`, `document` or `body`.\n     * - The value is the statement to execute when the event occurs. If the\n     * statement evalueates to `false`, then `preventDefault` is applied on the DOM\n     * event. A handler method can refer to the `$event` local variable.\n     *\n     */\n    host?: {\n        [key: string]: string;\n    };\n    /**\n     * Configures the [injector](guide/glossary#injector) of this\n     * directive or component with a [token](guide/glossary#di-token)\n     * that maps to a [provider](guide/glossary#provider) of a dependency.\n     */\n    providers?: Provider[];\n    /**\n     * The name or names that can be used in the template to assign this directive to a variable.\n     * For multiple names, use a comma-separated string.\n     *\n     */\n    exportAs?: string;\n    /**\n     * Configures the queries that will be injected into the directive.\n     *\n     * Content queries are set before the `ngAfterContentInit` callback is called.\n     * View queries are set before the `ngAfterViewInit` callback is called.\n     *\n     */\n    queries?: {\n        [key: string]: any;\n    };\n}\n/**\n * Type of the Directive metadata.\n *\n * @publicApi\n */\nexport declare const Directive: DirectiveDecorator;\n/**\n * Component decorator interface\n *\n * @publicApi\n */\nexport interface ComponentDecorator {\n    /**\n     * Decorator that marks a class as an Angular component and provides configuration\n     * metadata that determines how the component should be processed,\n     * instantiated, and used at runtime.\n     *\n     * Components are the most basic UI building block of an Angular app.\n     * An Angular app contains a tree of Angular components.\n     *\n     * Angular components are a subset of directives, always associated with a template.\n     * Unlike other directives, only one component can be instantiated per an element in a template.\n     *\n     * A component must belong to an NgModule in order for it to be available\n     * to another component or application. To make it a member of an NgModule,\n     * list it in the `declarations` field of the `@NgModule` metadata.\n     *\n     * Note that, in addition to these options for configuring a directive,\n     * you can control a component's runtime behavior by implementing\n     * life-cycle hooks. For more information, see the\n     * [Lifecycle Hooks](guide/lifecycle-hooks) guide.\n     *\n     * @usageNotes\n     *\n     * ### Setting component inputs\n     *\n     * The following example creates a component with two data-bound properties,\n     * specified by the `inputs` value.\n     *\n     * <code-example path=\"core/ts/metadata/directives.ts\" region=\"component-input\">\n     * </code-example>\n     *\n     *\n     * ### Setting component outputs\n     *\n     * The following example shows two event emitters that emit on an interval. One\n     * emits an output every second, while the other emits every five seconds.\n     *\n     * {@example core/ts/metadata/directives.ts region='component-output-interval'}\n     *\n     * ### Injecting a class with a view provider\n     *\n     * The following simple example injects a class into a component\n     * using the view provider specified in component metadata:\n     *\n     * ```\n     * class Greeter {\n     *    greet(name:string) {\n     *      return 'Hello ' + name + '!';\n     *    }\n     * }\n     *\n     * @Directive({\n     *   selector: 'needs-greeter'\n     * })\n     * class NeedsGreeter {\n     *   greeter:Greeter;\n     *\n     *   constructor(greeter:Greeter) {\n     *     this.greeter = greeter;\n     *   }\n     * }\n     *\n     * @Component({\n     *   selector: 'greet',\n     *   viewProviders: [\n     *     Greeter\n     *   ],\n     *   template: `<needs-greeter></needs-greeter>`\n     * })\n     * class HelloWorld {\n     * }\n     *\n     * ```\n     *\n     * ### Preserving whitespace\n     *\n     * Removing whitespace can greatly reduce AOT-generated code size and speed up view creation.\n     * As of Angular 6, the default for `preserveWhitespaces` is false (whitespace is removed).\n     * To change the default setting for all components in your application, set\n     * the `preserveWhitespaces` option of the AOT compiler.\n     *\n     * By default, the AOT compiler removes whitespace characters as follows:\n     * * Trims all whitespaces at the beginning and the end of a template.\n     * * Removes whitespace-only text nodes. For example,\n     *\n     * ```\n     * <button>Action 1</button>  <button>Action 2</button>\n     * ```\n     *\n     * becomes:\n     *\n     * ```\n     * <button>Action 1</button><button>Action 2</button>\n     * ```\n     *\n     * * Replaces a series of whitespace characters in text nodes with a single space.\n     * For example, `<span>\\n some text\\n</span>` becomes `<span> some text </span>`.\n     * * Does NOT alter text nodes inside HTML tags such as `<pre>` or `<textarea>`,\n     * where whitespace characters are significant.\n     *\n     * Note that these transformations can influence DOM nodes layout, although impact\n     * should be minimal.\n     *\n     * You can override the default behavior to preserve whitespace characters\n     * in certain fragments of a template. For example, you can exclude an entire\n     * DOM sub-tree by using the `ngPreserveWhitespaces` attribute:\n     *\n     * ```html\n     * <div ngPreserveWhitespaces>\n     *     whitespaces are preserved here\n     *     <span>    and here </span>\n     * </div>\n     * ```\n     *\n     * You can force a single space to be preserved in a text node by using `&ngsp;`,\n     * which is replaced with a space character by Angular's template\n     * compiler:\n     *\n     * ```html\n     * <a>Spaces</a>&ngsp;<a>between</a>&ngsp;<a>links.</a>\n     * <!-->compiled to be equivalent to:</>\n     *  <a>Spaces</a> <a>between</a> <a>links.</a>\n     * ```\n     *\n     * Note that sequences of `&ngsp;` are still collapsed to just one space character when\n     * the `preserveWhitespaces` option is set to `false`.\n     *\n     * ```html\n     * <a>before</a>&ngsp;&ngsp;&ngsp;<a>after</a>\n     * <!-->compiled to be equivalent to:</>\n     *  <a>Spaces</a> <a>between</a> <a>links.</a>\n     * ```\n     *\n     * To preserve sequences of whitespace characters, use the\n     * `ngPreserveWhitespaces` attribute.\n     *\n     * @Annotation\n     */\n    (obj: Component): TypeDecorator;\n    /**\n     * See the `@Component` decorator.\n     */\n    new (obj: Component): Component;\n}\n/**\n * Supplies configuration metadata for an Angular component.\n */\nexport interface Component extends Directive {\n    /**\n     * The change-detection strategy to use for this component.\n     *\n     * When a component is instantiated, Angular creates a change detector,\n     * which is responsible for propagating the component's bindings.\n     * The strategy is one of:\n     * - `ChangeDetectionStrategy#OnPush` sets the strategy to `CheckOnce` (on demand).\n     * - `ChangeDetectionStrategy#Default` sets the strategy to `CheckAlways`.\n     */\n    changeDetection?: ChangeDetectionStrategy;\n    /**\n     * Defines the set of injectable objects that are visible to its view DOM children.\n     * See [example](#injecting-a-class-with-a-view-provider).\n     *\n     */\n    viewProviders?: Provider[];\n    /**\n     * The module ID of the module that contains the component.\n     * The component must be able to resolve relative URLs for templates and styles.\n     * SystemJS exposes the `__moduleName` variable within each module.\n     * In CommonJS, this can  be set to `module.id`.\n     *\n     */\n    moduleId?: string;\n    /**\n     * The URL of a template file for an Angular component. If provided,\n     * do not supply an inline template using `template`.\n     *\n     */\n    templateUrl?: string;\n    /**\n     * An inline template for an Angular component. If provided,\n     * do not supply a template file using `templateUrl`.\n     *\n     */\n    template?: string;\n    /**\n     * One or more URLs for files containing CSS stylesheets to use\n     * in this component.\n     */\n    styleUrls?: string[];\n    /**\n     * One or more inline CSS stylesheets to use\n     * in this component.\n     */\n    styles?: string[];\n    /**\n     * One or more animation `trigger()` calls, containing\n     * `state()` and `transition()` definitions.\n     * See the [Animations guide](/guide/animations) and animations API documentation.\n     *\n     */\n    animations?: any[];\n    /**\n     * An encapsulation policy for the template and CSS styles. One of:\n     * - `ViewEncapsulation.Native`: Use shadow roots. This works\n     * only if natively available on the platform.\n     * - `ViewEncapsulation.Emulated`: Use shimmed CSS that\n     * emulates the native behavior.\n     * - `ViewEncapsulation.None`: Use global CSS without any\n     * encapsulation.\n     *\n     * If not supplied, the value is taken from `CompilerOptions`. The default compiler option is\n     * `ViewEncapsulation.Emulated`.\n     *\n     * If the policy is set to `ViewEncapsulation.Emulated` and the component has no `styles`\n     * or `styleUrls` specified, the policy is automatically switched to `ViewEncapsulation.None`.\n     */\n    encapsulation?: ViewEncapsulation;\n    /**\n     * Overrides the default encapsulation start and end delimiters (`{{` and `}}`)\n     */\n    interpolation?: [string, string];\n    /**\n     * A set of components that should be compiled along with\n     * this component. For each component listed here,\n     * Angular creates a {@link ComponentFactory} and stores it in the\n     * {@link ComponentFactoryResolver}.\n     */\n    entryComponents?: Array<Type<any> | any[]>;\n    /**\n     * True to preserve or false to remove potentially superfluous whitespace characters\n     * from the compiled template. Whitespace characters are those matching the `\\s`\n     * character class in JavaScript regular expressions. Default is false, unless\n     * overridden in compiler options.\n     */\n    preserveWhitespaces?: boolean;\n}\n/**\n * Component decorator and metadata.\n *\n * @Annotation\n * @publicApi\n */\nexport declare const Component: ComponentDecorator;\n/**\n * Type of the Pipe decorator / constructor function.\n *\n * @publicApi\n */\nexport interface PipeDecorator {\n    /**\n     * Declares a reusable pipe function, and supplies configuration metadata.\n     *\n     */\n    (obj: Pipe): TypeDecorator;\n    /**\n     * See the `Pipe` decorator.\n     */\n    new (obj: Pipe): Pipe;\n}\n/**\n * Type of the Pipe metadata.\n */\nexport interface Pipe {\n    /**\n     * The pipe name to use in template bindings.\n     *\n     */\n    name: string;\n    /**\n     * When true, the pipe is pure, meaning that the\n     * `transform()` method is invoked only when its input arguments\n     * change. Pipes are pure by default.\n     *\n     * If the pipe has internal state (that is, the result\n     * depends on state other than its arguments), set `pure` to false.\n     * In this case, the pipe is invoked on each change-detection cycle,\n     * even if the arguments have not changed.\n     */\n    pure?: boolean;\n}\n/**\n * @Annotation\n * @publicApi\n */\nexport declare const Pipe: PipeDecorator;\n/**\n * @publicApi\n */\nexport interface InputDecorator {\n    /**\n     * Decorator that marks a class as pipe and supplies configuration metadata.\n     *\n     * A pipe class must implement the `PipeTransform` interface.\n     * For example, if the name is \"myPipe\", use a template binding expression\n     * such as the following:\n     *\n     * ```\n     * {{ exp | myPipe }}\n     * ```\n     *\n     * The result of the expression is passed to the pipe's `transform()` method.\n     *\n     * A pipe must belong to an NgModule in order for it to be available\n     * to a template. To make it a member of an NgModule,\n     * list it in the `declarations` field of the `@NgModule` metadata.\n     *\n     */\n    (bindingPropertyName?: string): any;\n    new (bindingPropertyName?: string): any;\n}\n/**\n * Type of metadata for an `Input` property.\n *\n *\n */\nexport interface Input {\n    /**\n     * Decorator that marks a class field as an input property and supplies configuration metadata.\n     * Declares a data-bound input property, which Angular automatically updates\n     * during change detection.\n     *\n     * @usageNotes\n     *\n     * You can supply an optional name to use in templates when the\n     * component is instantiated, that maps to the\n     * name of the bound property. By default, the original\n     * name of the bound property is used for input binding.\n     *\n     * The following example creates a component with two input properties,\n     * one of which is given a special binding name.\n     *\n     * ```typescript\n     * @Component({\n     *   selector: 'bank-account',\n     *   template: `\n     *     Bank Name: {{bankName}}\n     *     Account Id: {{id}}\n     *   `\n     * })\n     * class BankAccount {\n     *   // This property is bound using its original name.\n     *   @Input() bankName: string;\n     *   // this property value is bound to a different property name\n     *   // when this component is instantiated in a template.\n     *   @Input('account-id') id: string;\n     *\n     *   // this property is not bound, and is not automatically updated by Angular\n     *   normalizedBankName: string;\n     * }\n     *\n     * @Component({\n     *   selector: 'app',\n     *   template: `\n     *     <bank-account bankName=\"RBC\" account-id=\"4747\"></bank-account>\n     *   `\n     * })\n     *\n     * class App {}\n     * ```\n     *\n     */\n    bindingPropertyName?: string;\n}\n/**\n * @Annotation\n * @publicApi\n */\nexport declare const Input: InputDecorator;\n/**\n * Type of the Output decorator / constructor function.\n *\n * @publicApi\n */\nexport interface OutputDecorator {\n    /**\n    * Decorator that marks a class field as an output property and supplies configuration metadata.\n    * Declares a data-bound output property, which Angular automatically updates\n    * during change detection.\n    *\n    * @usageNotes\n    *\n    * You can supply an optional name to use in templates when the\n    * component is instantiated, that maps to the\n    * name of the bound property. By default, the original\n    * name of the bound property is used for output binding.\n    *\n    * See `@Input` decorator for an example of providing a binding name.\n    *\n    */\n    (bindingPropertyName?: string): any;\n    new (bindingPropertyName?: string): any;\n}\n/**\n * Type of the Output metadata.\n */\nexport interface Output {\n    bindingPropertyName?: string;\n}\n/**\n * @Annotation\n * @publicApi\n */\nexport declare const Output: OutputDecorator;\n/**\n * Type of the HostBinding decorator / constructor function.\n *\n * @publicApi\n */\nexport interface HostBindingDecorator {\n    /**\n     * Decorator that marks a DOM property as a host-binding property and supplies configuration\n     * metadata.\n     * Angular automatically checks host property bindings during change detection, and\n     * if a binding changes it updates the host element of the directive.\n     *\n     * @usageNotes\n     *\n     * The following example creates a directive that sets the `valid` and `invalid`\n     * properties on the DOM element that has an `ngModel` directive on it.\n     *\n     * ```typescript\n     * @Directive({selector: '[ngModel]'})\n     * class NgModelStatus {\n     *   constructor(public control: NgModel) {}\n     *   @HostBinding('class.valid') get valid() { return this.control.valid; }\n     *   @HostBinding('class.invalid') get invalid() { return this.control.invalid; }\n     * }\n     *\n     * @Component({\n     *   selector: 'app',\n     *   template: `<input [(ngModel)]=\"prop\">`,\n     * })\n     * class App {\n     *   prop;\n     * }\n     * ```\n     *\n     */\n    (hostPropertyName?: string): any;\n    new (hostPropertyName?: string): any;\n}\n/**\n * Type of the HostBinding metadata.\n *\n */\nexport interface HostBinding {\n    hostPropertyName?: string;\n}\n/**\n * @Annotation\n * @publicApi\n */\nexport declare const HostBinding: HostBindingDecorator;\n/**\n * Type of the HostListener decorator / constructor function.\n *\n * @publicApi\n */\nexport interface HostListenerDecorator {\n    (eventName: string, args?: string[]): any;\n    new (eventName: string, args?: string[]): any;\n}\n/**\n * Type of the HostListener metadata.\n */\nexport interface HostListener {\n    /**\n     * The CSS event to listen for.\n     */\n    eventName?: string;\n    /**\n     * A set of arguments to pass to the handler method when the event occurs.\n     */\n    args?: string[];\n}\n/**\n * Binds a CSS event to a host listener and supplies configuration metadata.\n * Angular invokes the supplied handler method when the host element emits the specified event,\n * and updates the bound element with the result.\n * If the handler method returns false, applies `preventDefault` on the bound element.\n *\n * @usageNotes\n *\n * The following example declares a directive\n * that attaches a click listener to a button and counts clicks.\n *\n * ```\n * @Directive({selector: 'button[counting]'})\n * class CountClicks {\n *   numberOfClicks = 0;\n *\n *   @HostListener('click', ['$event.target'])\n *   onClick(btn) {\n *     console.log('button', btn, 'number of clicks:', this.numberOfClicks++);\n *  }\n * }\n *\n * @Component({\n *   selector: 'app',\n *   template: '<button counting>Increment</button>',\n * })\n * class App {}\n * ```\n *\n * @Annotation\n * @publicApi\n */\nexport declare const HostListener: HostListenerDecorator;\nexport declare const SWITCH_COMPILE_COMPONENT__POST_R3__: typeof render3CompileComponent;\nexport declare const SWITCH_COMPILE_DIRECTIVE__POST_R3__: typeof render3CompileDirective;\nexport declare const SWITCH_COMPILE_PIPE__POST_R3__: typeof render3CompilePipe;\n"
  },
  {
    "path": "node_modules/@angular/core/src/metadata/lifecycle_hooks.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { SimpleChange } from '../change_detection/change_detection_util';\n/**\n * Defines an object that associates properties with\n * instances of `SimpleChange`.\n *\n * @see `OnChanges`\n *\n * @publicApi\n */\nexport interface SimpleChanges {\n    [propName: string]: SimpleChange;\n}\n/**\n * @description\n * A lifecycle hook that is called when any data-bound property of a directive changes.\n * Define an `ngOnChanges()` method to handle the changes.\n *\n * @see `DoCheck`\n * @see `OnInit`\n * @see [Lifecycle Hooks](guide/lifecycle-hooks#onchanges) guide\n *\n * @usageNotes\n * The following snippet shows how a component can implement this interface to\n * define an on-changes handler for an input property.\n *\n * {@example core/ts/metadata/lifecycle_hooks_spec.ts region='OnChanges'}\n *\n * @publicApi\n */\nexport interface OnChanges {\n    /**\n     * A callback method that is invoked immediately after the\n     * default change detector has checked data-bound properties\n     * if at least one has changed, and before the view and content\n     * children are checked.\n     * @param changes The changed properties.\n     */\n    ngOnChanges(changes: SimpleChanges): void;\n}\n/**\n * @description\n * A lifecycle hook that is called after Angular has initialized\n * all data-bound properties of a directive.\n * Define an `ngOnInit()` method to handle any additional initialization tasks.\n *\n * @see `AfterContentInit`\n * @see [Lifecycle Hooks](guide/lifecycle-hooks#onchanges) guide\n *\n * @usageNotes\n * The following snippet shows how a component can implement this interface to\n * define its own initialization method.\n *\n * {@example core/ts/metadata/lifecycle_hooks_spec.ts region='OnInit'}\n *\n * @publicApi\n */\nexport interface OnInit {\n    /**\n     * A callback method that is invoked immediately after the\n     * default change detector has checked the directive's\n     * data-bound properties for the first time,\n     * and before any of the view or content children have been checked.\n     * It is invoked only once when the directive is instantiated.\n     */\n    ngOnInit(): void;\n}\n/**\n * A lifecycle hook that invokes a custom change-detection function for a directive,\n * in addition to the check performed by the default change-detector.\n *\n * The default change-detection algorithm looks for differences by comparing\n * bound-property values by reference across change detection runs. You can use this\n * hook to check for and respond to changes by some other means.\n *\n * When the default change detector detects changes, it invokes `ngOnChanges()` if supplied,\n * regardless of whether you perform additional change detection.\n * Typically, you should not use both `DoCheck` and `OnChanges` to respond to\n * changes on the same input.\n *\n * @see `OnChanges`\n * @see [Lifecycle Hooks](guide/lifecycle-hooks#onchanges) guide\n *\n * @usageNotes\n * The following snippet shows how a component can implement this interface\n * to invoke it own change-detection cycle.\n *\n * {@example core/ts/metadata/lifecycle_hooks_spec.ts region='DoCheck'}\n *\n * @publicApi\n */\nexport interface DoCheck {\n    /**\n       * A callback method that performs change-detection, invoked\n       * after the default change-detector runs.\n       * See `KeyValueDiffers` and `IterableDiffers` for implementing\n       * custom change checking for collections.\n       *\n       */\n    ngDoCheck(): void;\n}\n/**\n * A lifecycle hook that is called when a directive, pipe, or service is destroyed.\n * Use for any custom cleanup that needs to occur when the\n * instance is destroyed.\n * @see [Lifecycle Hooks](guide/lifecycle-hooks#onchanges) guide\n *\n * @usageNotes\n * The following snippet shows how a component can implement this interface\n * to define its own custom clean-up method.\n *\n * {@example core/ts/metadata/lifecycle_hooks_spec.ts region='OnDestroy'}\n *\n * @publicApi\n */\nexport interface OnDestroy {\n    /**\n     * A callback method that performs custom clean-up, invoked immediately\n     * after a directive, pipe, or service instance is destroyed.\n     */\n    ngOnDestroy(): void;\n}\n/**\n * @description\n * A lifecycle hook that is called after Angular has fully initialized\n * all content of a directive.\n * Define an `ngAfterContentInit()` method to handle any additional initialization tasks.\n *\n * @see `OnInit`\n * @see `AfterViewInit`\n * @see [Lifecycle Hooks](guide/lifecycle-hooks#onchanges) guide\n *\n * @usageNotes\n * The following snippet shows how a component can implement this interface to\n * define its own content initialization method.\n *\n * {@example core/ts/metadata/lifecycle_hooks_spec.ts region='AfterContentInit'}\n *\n * @publicApi\n */\nexport interface AfterContentInit {\n    /**\n     * A callback method that is invoked immediately after\n     * Angular has completed initialization of all of the directive's\n     * content.\n     * It is invoked only once when the directive is instantiated.\n     */\n    ngAfterContentInit(): void;\n}\n/**\n * @description\n * A lifecycle hook that is called after the default change detector has\n * completed checking all content of a directive.\n *\n * @see `AfterViewChecked`\n * @see [Lifecycle Hooks](guide/lifecycle-hooks#onchanges) guide\n *\n * @usageNotes\n * The following snippet shows how a component can implement this interface to\n * define its own after-check functionality.\n *\n * {@example core/ts/metadata/lifecycle_hooks_spec.ts region='AfterContentChecked'}\n *\n * @publicApi\n */\nexport interface AfterContentChecked {\n    /**\n     * A callback method that is invoked immediately after the\n     * default change detector has completed checking all of the directive's\n     * content.\n     */\n    ngAfterContentChecked(): void;\n}\n/**\n * @description\n * A lifecycle hook that is called after Angular has fully initialized\n * a component's view.\n * Define an `ngAfterViewInit()` method to handle any additional initialization tasks.\n *\n * @see `OnInit`\n * @see `AfterContentInit`\n * @see [Lifecycle Hooks](guide/lifecycle-hooks#onchanges) guide\n *\n * @usageNotes\n * The following snippet shows how a component can implement this interface to\n * define its own view initialization method.\n *\n * {@example core/ts/metadata/lifecycle_hooks_spec.ts region='AfterViewInit'}\n *\n * @publicApi\n */\nexport interface AfterViewInit {\n    /**\n     * A callback method that is invoked immediately after\n     * Angular has completed initialization of a component's view.\n     * It is invoked only once when the view is instantiated.\n     *\n     */\n    ngAfterViewInit(): void;\n}\n/**\n * @description\n * A lifecycle hook that is called after the default change detector has\n * completed checking a component's view for changes.\n *\n * @see `AfterContentChecked`\n * @see [Lifecycle Hooks](guide/lifecycle-hooks#onchanges) guide\n *\n * @usageNotes\n * The following snippet shows how a component can implement this interface to\n * define its own after-check functionality.\n *\n * {@example core/ts/metadata/lifecycle_hooks_spec.ts region='AfterViewChecked'}\n *\n * @publicApi\n */\nexport interface AfterViewChecked {\n    /**\n     * A callback method that is invoked immediately after the\n     * default change detector has completed one change-check cycle\n     * for a component's view.\n     */\n    ngAfterViewChecked(): void;\n}\n"
  },
  {
    "path": "node_modules/@angular/core/src/metadata/ng_module.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { ApplicationRef } from '../application_ref';\nimport { Provider } from '../di/provider';\nimport { compileNgModule as render3CompileNgModule } from '../render3/jit/module';\nimport { Type } from '../type';\nimport { TypeDecorator } from '../util/decorators';\n/**\n * Represents the expansion of an `NgModule` into its scopes.\n *\n * A scope is a set of directives and pipes that are visible in a particular context. Each\n * `NgModule` has two scopes. The `compilation` scope is the set of directives and pipes that will\n * be recognized in the templates of components declared by the module. The `exported` scope is the\n * set of directives and pipes exported by a module (that is, module B's exported scope gets added\n * to module A's compilation scope when module A imports B).\n */\nexport interface NgModuleTransitiveScopes {\n    compilation: {\n        directives: Set<any>;\n        pipes: Set<any>;\n    };\n    exported: {\n        directives: Set<any>;\n        pipes: Set<any>;\n    };\n}\nexport declare type NgModuleDefWithMeta<T, Declarations, Imports, Exports> = NgModuleDef<T>;\n/**\n * Runtime link information for NgModules.\n *\n * This is the internal data structure used by the runtime to assemble components, directives,\n * pipes, and injectors.\n *\n * NOTE: Always use `defineNgModule` function to create this object,\n * never create the object directly since the shape of this object\n * can change between versions.\n */\nexport interface NgModuleDef<T> {\n    /** Token representing the module. Used by DI. */\n    type: T;\n    /** List of components to bootstrap. */\n    bootstrap: Type<any>[];\n    /** List of components, directives, and pipes declared by this module. */\n    declarations: Type<any>[];\n    /** List of modules or `ModuleWithProviders` imported by this module. */\n    imports: Type<any>[];\n    /**\n     * List of modules, `ModuleWithProviders`, components, directives, or pipes exported by this\n     * module.\n     */\n    exports: Type<any>[];\n    /**\n     * Cached value of computed `transitiveCompileScopes` for this module.\n     *\n     * This should never be read directly, but accessed via `transitiveScopesFor`.\n     */\n    transitiveCompileScopes: NgModuleTransitiveScopes | null;\n}\n/**\n * A wrapper around an NgModule that associates it with the providers.\n *\n * @param T the module type. In Ivy applications, this must be explicitly\n * provided.\n *\n * @publicApi\n */\nexport interface ModuleWithProviders<T = any /** TODO(alxhub): remove default when callers pass explicit type param */> {\n    ngModule: Type<T>;\n    providers?: Provider[];\n}\n/**\n * A schema definition associated with an NgModule.\n *\n * @see `@NgModule`, `CUSTOM_ELEMENTS_SCHEMA`, `NO_ERRORS_SCHEMA`\n *\n * @param name The name of a defined schema.\n *\n * @publicApi\n */\nexport interface SchemaMetadata {\n    name: string;\n}\n/**\n * Defines a schema that allows an NgModule to contain the following:\n * - Non-Angular elements named with dash case (`-`).\n * - Element properties named with dash case (`-`).\n * Dash case is the naming convention for custom elements.\n *\n * @publicApi\n */\nexport declare const CUSTOM_ELEMENTS_SCHEMA: SchemaMetadata;\n/**\n * Defines a schema that allows any property on any element.\n *\n * @publicApi\n */\nexport declare const NO_ERRORS_SCHEMA: SchemaMetadata;\n/**\n * Type of the NgModule decorator / constructor function.\n */\nexport interface NgModuleDecorator {\n    /**\n     * Marks a class as an NgModule and supplies configuration metadata.\n     */\n    (obj?: NgModule): TypeDecorator;\n    new (obj?: NgModule): NgModule;\n}\n/**\n * Type of the NgModule metadata.\n */\nexport interface NgModule {\n    /**\n     * The set of injectable objects that are available in the injector\n     * of this module.\n     *\n     * @see [Dependency Injection guide](guide/dependency-injection)\n     * @see [NgModule guide](guide/providers)\n     *\n     * @usageNotes\n     *\n     * Dependencies whose providers are listed here become available for injection\n     * into any component, directive, pipe or service that is a child of this injector.\n     * The NgModule used for bootstrapping uses the root injector, and can provide dependencies\n     * to any part of the app.\n     *\n     * A lazy-loaded module has its own injector, typically a child of the app root injector.\n     * Lazy-loaded services are scoped to the lazy-loaded module's injector.\n     * If a lazy-loaded module also provides the `UserService`, any component created\n     * within that module's context (such as by router navigation) gets the local instance\n     * of the service, not the instance in the root injector.\n     * Components in external modules continue to receive the instance provided by their injectors.\n     *\n     * ### Example\n     *\n     * The following example defines a class that is injected in\n     * the HelloWorld NgModule:\n     *\n     * ```\n     * class Greeter {\n     *    greet(name:string) {\n     *      return 'Hello ' + name + '!';\n     *    }\n     * }\n     *\n     * @NgModule({\n     *   providers: [\n     *     Greeter\n     *   ]\n     * })\n     * class HelloWorld {\n     *   greeter:Greeter;\n     *\n     *   constructor(greeter:Greeter) {\n     *     this.greeter = greeter;\n     *   }\n     * }\n     * ```\n     */\n    providers?: Provider[];\n    /**\n     * The set of components, directives, and pipes ([declarables](guide/glossary#declarable))\n     * that belong to this module.\n     *\n     * @usageNotes\n     *\n     * The set of selectors that are available to a template include those declared here, and\n     * those that are exported from imported NgModules.\n     *\n     * Declarables must belong to exactly one module.\n     * The compiler emits an error if you try to declare the same class in more than one module.\n     * Be careful not to declare a class that is imported from another module.\n     *\n     * ### Example\n     *\n     * The following example allows the CommonModule to use the `NgFor`\n     * directive.\n     *\n     * ```javascript\n     * @NgModule({\n     *   declarations: [NgFor]\n     * })\n     * class CommonModule {\n     * }\n     * ```\n     */\n    declarations?: Array<Type<any> | any[]>;\n    /**\n     * The set of NgModules whose exported [declarables](guide/glossary#declarable)\n     * are available to templates in this module.\n     *\n     * @usageNotes\n     *\n     * A template can use exported declarables from any\n     * imported module, including those from modules that are imported indirectly\n     * and re-exported.\n     * For example, `ModuleA` imports `ModuleB`, and also exports\n     * it, which makes the declarables from `ModuleB` available\n     * wherever `ModuleA` is imported.\n     *\n     * ### Example\n     *\n     * The following example allows MainModule to use anthing exported by\n     * `CommonModule`:\n     *\n     * ```javascript\n     * @NgModule({\n     *   imports: [CommonModule]\n     * })\n     * class MainModule {\n     * }\n     * ```\n     *\n     */\n    imports?: Array<Type<any> | ModuleWithProviders<{}> | any[]>;\n    /**\n     * The set of components, directives, and pipes declared in this\n     * NgModule that can be used in the template of any component that is part of an\n     * NgModule that imports this NgModule. Exported declarations are the module's public API.\n     *\n     * A declarable belongs to one and only one NgModule.\n     * A module can list another module among its exports, in which case all of that module's\n     * public declaration are exported.\n     *\n     * @usageNotes\n     *\n     * Declarations are private by default.\n     * If this ModuleA does not export UserComponent, then only the components within this\n     * ModuleA can use UserComponent.\n     *\n     * ModuleA can import ModuleB and also export it, making exports from ModuleB\n     * available to an NgModule that imports ModuleA.\n     *\n     * ### Example\n     *\n     * The following example exports the `NgFor` directive from CommonModule.\n     *\n     * ```javascript\n     * @NgModule({\n     *   exports: [NgFor]\n     * })\n     * class CommonModule {\n     * }\n     * ```\n     */\n    exports?: Array<Type<any> | any[]>;\n    /**\n     * The set of components to compile when this NgModule is defined,\n     * so that they can be dynamically loaded into the view.\n     *\n     * For each component listed here, Angular creates a `ComponentFactory`\n     * and stores it in the `ComponentFactoryResolver`.\n     *\n     * Angular automatically adds components in the module's bootstrap\n     * and route definitions into the `entryComponents` list. Use this\n     * option to add components that are bootstrapped\n     * using one of the imperative techniques, such as `ViewContainerRef.createComponent()`.\n     *\n     * @see [Entry Components](guide/entry-components)\n     */\n    entryComponents?: Array<Type<any> | any[]>;\n    /**\n     * The set of components that are bootstrapped when\n     * this module is bootstrapped. The components listed here\n     * are automatically added to `entryComponents`.\n     */\n    bootstrap?: Array<Type<any> | any[]>;\n    /**\n     * The set of schemas that declare elements to be allowed in the NgModule.\n     * Elements and properties that are neither Angular components nor directives\n     * must be declared in a schema.\n     *\n     * Allowed value are `NO_ERRORS_SCHEMA` and `CUSTOM_ELEMENTS_SCHEMA`.\n     *\n     * @security When using one of `NO_ERRORS_SCHEMA` or `CUSTOM_ELEMENTS_SCHEMA`\n     * you must ensure that allowed elements and properties securely escape inputs.\n     */\n    schemas?: Array<SchemaMetadata | any[]>;\n    /**\n     * A name or path that uniquely identifies this NgModule in `getModuleFactory`.\n     * If left `undefined`, the NgModule is not registered with\n     * `getModuleFactory`.\n     */\n    id?: string;\n    /**\n     * If true, this module will be skipped by the AOT compiler and so will always be compiled\n     * using JIT.\n     *\n     * This exists to support future Ivy work and has no effect currently.\n     */\n    jit?: true;\n}\n/**\n * @Annotation\n * @publicApi\n */\nexport declare const NgModule: NgModuleDecorator;\n/**\n * @description\n * Hook for manual bootstrapping of the application instead of using bootstrap array in @NgModule\n * annotation.\n *\n * Reference to the current application is provided as a parameter.\n *\n * See [\"Bootstrapping\"](guide/bootstrapping) and [\"Entry components\"](guide/entry-components).\n *\n * @usageNotes\n * ```typescript\n * class AppModule implements DoBootstrap {\n *   ngDoBootstrap(appRef: ApplicationRef) {\n *     appRef.bootstrap(AppComponent); // Or some other component\n *   }\n * }\n * ```\n *\n * @publicApi\n */\nexport interface DoBootstrap {\n    ngDoBootstrap(appRef: ApplicationRef): void;\n}\nexport declare const SWITCH_COMPILE_NGMODULE__POST_R3__: typeof render3CompileNgModule;\n"
  },
  {
    "path": "node_modules/@angular/core/src/metadata/resource_loading.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { Component } from './directives';\n/**\n * Used to resolve resource URLs on `@Component` when used with JIT compilation.\n *\n * Example:\n * ```\n * @Component({\n *   selector: 'my-comp',\n *   templateUrl: 'my-comp.html', // This requires asynchronous resolution\n * })\n * class MyComponnent{\n * }\n *\n * // Calling `renderComponent` will fail because `MyComponent`'s `@Compenent.templateUrl`\n * // needs to be resolved because `renderComponent` is synchronous process.\n * // renderComponent(MyComponent);\n *\n * // Calling `resolveComponentResources` will resolve `@Compenent.templateUrl` into\n * // `@Compenent.template`, which would allow `renderComponent` to proceed in synchronous manner.\n * // Use browser's `fetch` function as the default resource resolution strategy.\n * resolveComponentResources(fetch).then(() => {\n *   // After resolution all URLs have been converted into strings.\n *   renderComponent(MyComponent);\n * });\n *\n * ```\n *\n * NOTE: In AOT the resolution happens during compilation, and so there should be no need\n * to call this method outside JIT mode.\n *\n * @param resourceResolver a function which is responsible to returning a `Promise` of the resolved\n * URL. Browser's `fetch` method is a good default implementation.\n */\nexport declare function resolveComponentResources(resourceResolver: (url: string) => (Promise<string | {\n    text(): Promise<string>;\n}>)): Promise<null>;\nexport declare function maybeQueueResolutionOfComponentResources(metadata: Component): void;\nexport declare function componentNeedsResolution(component: Component): string | number | undefined;\nexport declare function clearResolutionOfComponentResourcesQueue(): void;\n"
  },
  {
    "path": "node_modules/@angular/core/src/metadata/view.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Defines template and style encapsulation options available for Component's {@link Component}.\n *\n * See {@link Component#encapsulation encapsulation}.\n *\n * @usageNotes\n * ### Example\n *\n * {@example core/ts/metadata/encapsulation.ts region='longform'}\n *\n * @publicApi\n */\nexport declare enum ViewEncapsulation {\n    /**\n     * Emulate `Native` scoping of styles by adding an attribute containing surrogate id to the Host\n     * Element and pre-processing the style rules provided via {@link Component#styles styles} or\n     * {@link Component#styleUrls styleUrls}, and adding the new Host Element attribute to all\n     * selectors.\n     *\n     * This is the default option.\n     */\n    Emulated = 0,\n    /**\n     * @deprecated v6.1.0 - use {ViewEncapsulation.ShadowDom} instead.\n     * Use the native encapsulation mechanism of the renderer.\n     *\n     * For the DOM this means using the deprecated [Shadow DOM\n     * v0](https://w3c.github.io/webcomponents/spec/shadow/) and\n     * creating a ShadowRoot for Component's Host Element.\n     */\n    Native = 1,\n    /**\n     * Don't provide any template or style encapsulation.\n     */\n    None = 2,\n    /**\n     * Use Shadow DOM to encapsulate styles.\n     *\n     * For the DOM this means using modern [Shadow\n     * DOM](https://w3c.github.io/webcomponents/spec/shadow/) and\n     * creating a ShadowRoot for Component's Host Element.\n     */\n    ShadowDom = 3\n}\n"
  },
  {
    "path": "node_modules/@angular/core/src/platform_core_providers.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { PlatformRef } from './application_ref';\nimport { StaticProvider } from './di';\n/**\n * This platform has to be included in any other platform\n *\n * @publicApi\n */\nexport declare const platformCore: (extraProviders?: StaticProvider[] | undefined) => PlatformRef;\n"
  },
  {
    "path": "node_modules/@angular/core/src/profile/profile.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { WtfScopeFn } from './wtf_impl';\nexport { WtfScopeFn } from './wtf_impl';\n/**\n * True if WTF is enabled.\n */\nexport declare const wtfEnabled: boolean;\n/**\n * Create trace scope.\n *\n * Scopes must be strictly nested and are analogous to stack frames, but\n * do not have to follow the stack frames. Instead it is recommended that they follow logical\n * nesting. You may want to use\n * [Event\n * Signatures](http://google.github.io/tracing-framework/instrumenting-code.html#custom-events)\n * as they are defined in WTF.\n *\n * Used to mark scope entry. The return value is used to leave the scope.\n *\n *     var myScope = wtfCreateScope('MyClass#myMethod(ascii someVal)');\n *\n *     someMethod() {\n *        var s = myScope('Foo'); // 'Foo' gets stored in tracing UI\n *        // DO SOME WORK HERE\n *        return wtfLeave(s, 123); // Return value 123\n *     }\n *\n * Note, adding try-finally block around the work to ensure that `wtfLeave` gets called can\n * negatively impact the performance of your application. For this reason we recommend that\n * you don't add them to ensure that `wtfLeave` gets called. In production `wtfLeave` is a noop and\n * so try-finally block has no value. When debugging perf issues, skipping `wtfLeave`, do to\n * exception, will produce incorrect trace, but presence of exception signifies logic error which\n * needs to be fixed before the app should be profiled. Add try-finally only when you expect that\n * an exception is expected during normal execution while profiling.\n *\n * @publicApi\n */\nexport declare const wtfCreateScope: (signature: string, flags?: any) => WtfScopeFn;\n/**\n * Used to mark end of Scope.\n *\n * - `scope` to end.\n * - `returnValue` (optional) to be passed to the WTF.\n *\n * Returns the `returnValue for easy chaining.\n * @publicApi\n */\nexport declare const wtfLeave: <T>(scope: any, returnValue?: T) => T;\n/**\n * Used to mark Async start. Async are similar to scope but they don't have to be strictly nested.\n * The return value is used in the call to [endAsync]. Async ranges only work if WTF has been\n * enabled.\n *\n *     someMethod() {\n *        var s = wtfStartTimeRange('HTTP:GET', 'some.url');\n *        var future = new Future.delay(5).then((_) {\n *          wtfEndTimeRange(s);\n *        });\n *     }\n * @publicApi\n */\nexport declare const wtfStartTimeRange: (rangeType: string, action: string) => any;\n/**\n * Ends a async time range operation.\n * [range] is the return value from [wtfStartTimeRange] Async ranges only work if WTF has been\n * enabled.\n * @publicApi\n */\nexport declare const wtfEndTimeRange: (range: any) => void;\n"
  },
  {
    "path": "node_modules/@angular/core/src/profile/wtf_impl.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * A scope function for the Web Tracing Framework (WTF).\n *\n * @publicApi\n */\nexport interface WtfScopeFn {\n    (arg0?: any, arg1?: any): any;\n}\nexport interface Range {\n}\nexport interface Scope {\n    (...args: any[] /** TODO #9100 */): any;\n}\nexport declare function detectWTF(): boolean;\nexport declare function createScope(signature: string, flags?: any): any;\nexport declare function leave<T>(scope: Scope): void;\nexport declare function leave<T>(scope: Scope, returnValue?: T): T;\nexport declare function startTimeRange(rangeType: string, action: string): Range;\nexport declare function endTimeRange(range: Range): void;\n"
  },
  {
    "path": "node_modules/@angular/core/src/r3_symbols.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nexport { InjectableDef, InjectorDef, defineInjectable, defineInjector } from './di/defs';\nexport { inject } from './di/injector_compatibility';\nexport { NgModuleDef, NgModuleDefWithMeta } from './metadata/ng_module';\nexport { defineNgModule } from './render3/definition';\nexport { setClassMetadata } from './render3/metadata';\nexport { NgModuleFactory } from './render3/ng_module_ref';\n/**\n * The existence of this constant (in this particular file) informs the Angular compiler that the\n * current program is actually @angular/core, which needs to be compiled specially.\n */\nexport declare const ITS_JUST_ANGULAR = true;\n"
  },
  {
    "path": "node_modules/@angular/core/src/reflection/platform_reflection_capabilities.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { Type } from '../type';\nimport { GetterFn, MethodFn, SetterFn } from './types';\nexport interface PlatformReflectionCapabilities {\n    isReflectionEnabled(): boolean;\n    factory(type: Type<any>): Function;\n    hasLifecycleHook(type: any, lcProperty: string): boolean;\n    guards(type: any): {\n        [key: string]: any;\n    };\n    /**\n     * Return a list of annotations/types for constructor parameters\n     */\n    parameters(type: Type<any>): any[][];\n    /**\n     * Return a list of annotations declared on the class\n     */\n    annotations(type: Type<any>): any[];\n    /**\n     * Return a object literal which describes the annotations on Class fields/properties.\n     */\n    propMetadata(typeOrFunc: Type<any>): {\n        [key: string]: any[];\n    };\n    getter(name: string): GetterFn;\n    setter(name: string): SetterFn;\n    method(name: string): MethodFn;\n    importUri(type: Type<any>): string;\n    resourceUri(type: Type<any>): string;\n    resolveIdentifier(name: string, moduleUrl: string, members: string[], runtime: any): any;\n    resolveEnum(enumIdentifier: any, name: string): any;\n}\n"
  },
  {
    "path": "node_modules/@angular/core/src/reflection/reflection_capabilities.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { Type } from '../type';\nimport { PlatformReflectionCapabilities } from './platform_reflection_capabilities';\nimport { GetterFn, MethodFn, SetterFn } from './types';\n/**\n * Attention: These regex has to hold even if the code is minified!\n */\nexport declare const DELEGATE_CTOR: RegExp;\nexport declare const INHERITED_CLASS: RegExp;\nexport declare const INHERITED_CLASS_WITH_CTOR: RegExp;\nexport declare class ReflectionCapabilities implements PlatformReflectionCapabilities {\n    private _reflect;\n    constructor(reflect?: any);\n    isReflectionEnabled(): boolean;\n    factory<T>(t: Type<T>): (args: any[]) => T;\n    private _ownParameters;\n    parameters(type: Type<any>): any[][];\n    private _ownAnnotations;\n    annotations(typeOrFunc: Type<any>): any[];\n    private _ownPropMetadata;\n    propMetadata(typeOrFunc: any): {\n        [key: string]: any[];\n    };\n    hasLifecycleHook(type: any, lcProperty: string): boolean;\n    guards(type: any): {\n        [key: string]: any;\n    };\n    getter(name: string): GetterFn;\n    setter(name: string): SetterFn;\n    method(name: string): MethodFn;\n    importUri(type: any): string;\n    resourceUri(type: any): string;\n    resolveIdentifier(name: string, moduleUrl: string, members: string[], runtime: any): any;\n    resolveEnum(enumIdentifier: any, name: string): any;\n}\n"
  },
  {
    "path": "node_modules/@angular/core/src/reflection/reflection.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { Reflector } from './reflector';\nexport { Reflector } from './reflector';\n/**\n * The {@link Reflector} used internally in Angular to access metadata\n * about symbols.\n */\nexport declare const reflector: Reflector;\n"
  },
  {
    "path": "node_modules/@angular/core/src/reflection/reflector.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { Type } from '../type';\nimport { PlatformReflectionCapabilities } from './platform_reflection_capabilities';\nimport { GetterFn, MethodFn, SetterFn } from './types';\nexport { PlatformReflectionCapabilities };\nexport { GetterFn, MethodFn, SetterFn };\n/**\n * Provides access to reflection data about symbols. Used internally by Angular\n * to power dependency injection and compilation.\n */\nexport declare class Reflector {\n    reflectionCapabilities: PlatformReflectionCapabilities;\n    constructor(reflectionCapabilities: PlatformReflectionCapabilities);\n    updateCapabilities(caps: PlatformReflectionCapabilities): void;\n    factory(type: Type<any>): Function;\n    parameters(typeOrFunc: Type<any>): any[][];\n    annotations(typeOrFunc: Type<any>): any[];\n    propMetadata(typeOrFunc: Type<any>): {\n        [key: string]: any[];\n    };\n    hasLifecycleHook(type: any, lcProperty: string): boolean;\n    getter(name: string): GetterFn;\n    setter(name: string): SetterFn;\n    method(name: string): MethodFn;\n    importUri(type: any): string;\n    resourceUri(type: any): string;\n    resolveIdentifier(name: string, moduleUrl: string, members: string[], runtime: any): any;\n    resolveEnum(identifier: any, name: string): any;\n}\n"
  },
  {
    "path": "node_modules/@angular/core/src/reflection/types.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nexport declare type SetterFn = (obj: any, value: any) => void;\nexport declare type GetterFn = (obj: any) => any;\nexport declare type MethodFn = (obj: any, args: any[]) => any;\n"
  },
  {
    "path": "node_modules/@angular/core/src/render.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nexport { RenderComponentType, Renderer, Renderer2, RendererFactory2, RendererStyleFlags2, RendererType2, RootRenderer } from './render/api';\n"
  },
  {
    "path": "node_modules/@angular/core/src/render/api.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { InjectionToken } from '../di/injection_token';\nimport { Injector } from '../di/injector';\nimport { ViewEncapsulation } from '../metadata/view';\nimport { injectRenderer2 as render3InjectRenderer2 } from '../render3/view_engine_compatibility';\n/**\n * @deprecated Use `RendererType2` (and `Renderer2`) instead.\n * @publicApi\n */\nexport declare class RenderComponentType {\n    id: string;\n    templateUrl: string;\n    slotCount: number;\n    encapsulation: ViewEncapsulation;\n    styles: Array<string | any[]>;\n    animations: any;\n    constructor(id: string, templateUrl: string, slotCount: number, encapsulation: ViewEncapsulation, styles: Array<string | any[]>, animations: any);\n}\n/**\n * @deprecated Debug info is handled internally in the view engine now.\n */\nexport declare abstract class RenderDebugInfo {\n    abstract readonly injector: Injector;\n    abstract readonly component: any;\n    abstract readonly providerTokens: any[];\n    abstract readonly references: {\n        [key: string]: any;\n    };\n    abstract readonly context: any;\n    abstract readonly source: string;\n}\n/**\n * @deprecated Use the `Renderer2` instead.\n */\nexport interface DirectRenderer {\n    remove(node: any): void;\n    appendChild(node: any, parent: any): void;\n    insertBefore(node: any, refNode: any): void;\n    nextSibling(node: any): any;\n    parentElement(node: any): any;\n}\n/**\n * @deprecated Use the `Renderer2` instead.\n * @publicApi\n */\nexport declare abstract class Renderer {\n    abstract selectRootElement(selectorOrNode: string | any, debugInfo?: RenderDebugInfo): any;\n    abstract createElement(parentElement: any, name: string, debugInfo?: RenderDebugInfo): any;\n    abstract createViewRoot(hostElement: any): any;\n    abstract createTemplateAnchor(parentElement: any, debugInfo?: RenderDebugInfo): any;\n    abstract createText(parentElement: any, value: string, debugInfo?: RenderDebugInfo): any;\n    abstract projectNodes(parentElement: any, nodes: any[]): void;\n    abstract attachViewAfter(node: any, viewRootNodes: any[]): void;\n    abstract detachView(viewRootNodes: any[]): void;\n    abstract destroyView(hostElement: any, viewAllNodes: any[]): void;\n    abstract listen(renderElement: any, name: string, callback: Function): Function;\n    abstract listenGlobal(target: string, name: string, callback: Function): Function;\n    abstract setElementProperty(renderElement: any, propertyName: string, propertyValue: any): void;\n    abstract setElementAttribute(renderElement: any, attributeName: string, attributeValue?: string): void;\n    /**\n     * Used only in debug mode to serialize property changes to dom nodes as attributes.\n     */\n    abstract setBindingDebugInfo(renderElement: any, propertyName: string, propertyValue: string): void;\n    abstract setElementClass(renderElement: any, className: string, isAdd: boolean): void;\n    abstract setElementStyle(renderElement: any, styleName: string, styleValue?: string): void;\n    abstract invokeElementMethod(renderElement: any, methodName: string, args?: any[]): void;\n    abstract setText(renderNode: any, text: string): void;\n    abstract animate(element: any, startingStyles: any, keyframes: any[], duration: number, delay: number, easing: string, previousPlayers?: any[]): any;\n}\nexport declare const Renderer2Interceptor: InjectionToken<Renderer2[]>;\n/**\n * Injectable service that provides a low-level interface for modifying the UI.\n *\n * Use this service to bypass Angular's templating and make custom UI changes that can't be\n * expressed declaratively. For example if you need to set a property or an attribute whose name is\n * not statically known, use {@link Renderer#setElementProperty setElementProperty} or\n * {@link Renderer#setElementAttribute setElementAttribute} respectively.\n *\n * If you are implementing a custom renderer, you must implement this interface.\n *\n * The default Renderer implementation is `DomRenderer`. Also available is `WebWorkerRenderer`.\n *\n * @deprecated Use `RendererFactory2` instead.\n * @publicApi\n */\nexport declare abstract class RootRenderer {\n    abstract renderComponent(componentType: RenderComponentType): Renderer;\n}\n/**\n * Used by `RendererFactory2` to associate custom rendering data and styles\n * with a rendering implementation.\n *  @publicApi\n */\nexport interface RendererType2 {\n    /**\n     * A unique identifying string for the new renderer, used when creating\n     * unique styles for encapsulation.\n     */\n    id: string;\n    /**\n     * The view encapsulation type, which determines how styles are applied to\n     * DOM elements. One of\n     * - `Emulated` (default): Emulate native scoping of styles.\n     * - `Native`: Use the native encapsulation mechanism of the renderer.\n     * - `ShadowDom`: Use modern [Shadow\n     * DOM](https://w3c.github.io/webcomponents/spec/shadow/) and\n     * create a ShadowRoot for component's host element.\n     * - `None`: Do not provide any template or style encapsulation.\n     */\n    encapsulation: ViewEncapsulation;\n    /**\n     * Defines CSS styles to be stored on a renderer instance.\n     */\n    styles: (string | any[])[];\n    /**\n     * Defines arbitrary developer-defined data to be stored on a renderer instance.\n     * This is useful for renderers that delegate to other renderers.\n     */\n    data: {\n        [kind: string]: any;\n    };\n}\n/**\n * Creates and initializes a custom renderer that implements the `Renderer2` base class.\n *\n * @publicApi\n */\nexport declare abstract class RendererFactory2 {\n    /**\n     * Creates and initializes a custom renderer for a host DOM element.\n     * @param hostElement The element to render.\n     * @param type The base class to implement.\n     * @returns The new custom renderer instance.\n     */\n    abstract createRenderer(hostElement: any, type: RendererType2 | null): Renderer2;\n    /**\n     * A callback invoked when rendering has begun.\n     */\n    abstract begin?(): void;\n    /**\n     * A callback invoked when rendering has completed.\n     */\n    abstract end?(): void;\n    /**\n     * Use with animations test-only mode. Notifies the test when rendering has completed.\n     * @returns The asynchronous result of the developer-defined function.\n     */\n    abstract whenRenderingDone?(): Promise<any>;\n}\n/**\n * Flags for renderer-specific style modifiers.\n * @publicApi\n */\nexport declare enum RendererStyleFlags2 {\n    /**\n     * Marks a style as important.\n     */\n    Important = 1,\n    /**\n     * Marks a style as using dash case naming (this-is-dash-case).\n     */\n    DashCase = 2\n}\n/**\n * Extend this base class to implement custom rendering. By default, Angular\n * renders a template into DOM. You can use custom rendering to intercept\n * rendering calls, or to render to something other than DOM.\n *\n * Create your custom renderer using `RendererFactory2`.\n *\n * Use a custom renderer to bypass Angular's templating and\n * make custom UI changes that can't be expressed declaratively.\n * For example if you need to set a property or an attribute whose name is\n * not statically known, use the `setProperty()` or\n * `setAttribute()` method.\n *\n * @publicApi\n */\nexport declare abstract class Renderer2 {\n    /**\n     * Use to store arbitrary developer-defined data on a renderer instance,\n     * as an object containing key-value pairs.\n     * This is useful for renderers that delegate to other renderers.\n     */\n    abstract readonly data: {\n        [key: string]: any;\n    };\n    /**\n     * Implement this callback to destroy the renderer or the host element.\n     */\n    abstract destroy(): void;\n    /**\n     * Implement this callback to create an instance of the host element.\n     * @param name An identifying name for the new element, unique within the namespace.\n     * @param namespace The namespace for the new element.\n     * @returns The new element.\n     */\n    abstract createElement(name: string, namespace?: string | null): any;\n    /**\n     * Implement this callback to add a comment to the DOM of the host element.\n     * @param value The comment text.\n     * @returns The modified element.\n     */\n    abstract createComment(value: string): any;\n    /**\n     * Implement this callback to add text to the DOM of the host element.\n     * @param value The text string.\n     * @returns The modified element.\n     */\n    abstract createText(value: string): any;\n    /**\n     * If null or undefined, the view engine won't call it.\n     * This is used as a performance optimization for production mode.\n     */\n    destroyNode: ((node: any) => void) | null;\n    /**\n     * Appends a child to a given parent node in the host element DOM.\n     * @param parent The parent node.\n     * @param newChild The new child node.\n     */\n    abstract appendChild(parent: any, newChild: any): void;\n    /**\n     * Implement this callback to insert a child node at a given position in a parent node\n     * in the host element DOM.\n     * @param parent The parent node.\n     * @param newChild The new child nodes.\n     * @param refChild The existing child node that should precede the new node.\n     */\n    abstract insertBefore(parent: any, newChild: any, refChild: any): void;\n    /**\n     * Implement this callback to remove a child node from the host element's DOM.\n     * @param parent The parent node.\n     * @param oldChild The child node to remove.\n     */\n    abstract removeChild(parent: any, oldChild: any): void;\n    /**\n     * Implement this callback to prepare an element to be bootstrapped\n     * as a root element, and return the element instance.\n     * @param selectorOrNode The DOM element.\n     * @param preserveContent Whether the contents of the root element\n     * should be preserved, or cleared upon bootstrap (default behavior).\n     * Use with `ViewEncapsulation.ShadowDom` to allow simple native\n     * content projection via `<slot>` elements.\n     * @returns The root element.\n     */\n    abstract selectRootElement(selectorOrNode: string | any, preserveContent?: boolean): any;\n    /**\n     * Implement this callback to get the parent of a given node\n     * in the host element's DOM.\n     * @param node The child node to query.\n     * @returns The parent node, or null if there is no parent.\n     * For WebWorkers, always returns true.\n     * This is because the check is synchronous,\n     * and the caller can't rely on checking for null.\n     */\n    abstract parentNode(node: any): any;\n    /**\n     * Implement this callback to get the next sibling node of a given node\n     * in the host element's DOM.\n     * @returns The sibling node, or null if there is no sibling.\n     * For WebWorkers, always returns a value.\n     * This is because the check is synchronous,\n     * and the caller can't rely on checking for null.\n     */\n    abstract nextSibling(node: any): any;\n    /**\n     * Implement this callback to set an attribute value for an element in the DOM.\n     * @param el The element.\n     * @param name The attribute name.\n     * @param value The new value.\n     * @param namespace The namespace.\n     */\n    abstract setAttribute(el: any, name: string, value: string, namespace?: string | null): void;\n    /**\n     * Implement this callback to remove an attribute from an element in the DOM.\n     * @param el The element.\n     * @param name The attribute name.\n     * @param namespace The namespace.\n     */\n    abstract removeAttribute(el: any, name: string, namespace?: string | null): void;\n    /**\n     * Implement this callback to add a class to an element in the DOM.\n     * @param el The element.\n     * @param name The class name.\n     */\n    abstract addClass(el: any, name: string): void;\n    /**\n     * Implement this callback to remove a class from an element in the DOM.\n     * @param el The element.\n     * @param name The class name.\n     */\n    abstract removeClass(el: any, name: string): void;\n    /**\n     * Implement this callback to set a CSS style for an element in the DOM.\n     * @param el The element.\n     * @param style The name of the style.\n     * @param value The new value.\n     * @param flags Flags for style variations. No flags are set by default.\n     */\n    abstract setStyle(el: any, style: string, value: any, flags?: RendererStyleFlags2): void;\n    /**\n     * Implement this callback to remove the value from a CSS style for an element in the DOM.\n     * @param el The element.\n     * @param style The name of the style.\n     * @param flags Flags for style variations to remove, if set. ???\n     */\n    abstract removeStyle(el: any, style: string, flags?: RendererStyleFlags2): void;\n    /**\n     * Implement this callback to set the value of a property of an element in the DOM.\n     * @param el The element.\n     * @param name The property name.\n     * @param value The new value.\n     */\n    abstract setProperty(el: any, name: string, value: any): void;\n    /**\n     * Implement this callback to set the value of a node in the host element.\n     * @param node The node.\n     * @param value The new value.\n     */\n    abstract setValue(node: any, value: string): void;\n    /**\n     * Implement this callback to start an event listener.\n     * @param target The context in which to listen for events. Can be\n     * the entire window or document, the body of the document, or a specific\n     * DOM element.\n     * @param eventName The event to listen for.\n     * @param callback A handler function to invoke when the event occurs.\n     * @returns An \"unlisten\" function for disposing of this handler.\n     */\n    abstract listen(target: 'window' | 'document' | 'body' | any, eventName: string, callback: (event: any) => boolean | void): () => void;\n}\nexport declare const SWITCH_RENDERER2_FACTORY__POST_R3__: typeof render3InjectRenderer2;\n"
  },
  {
    "path": "node_modules/@angular/core/src/render3/assert.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nexport declare function assertNumber(actual: any, msg: string): void;\nexport declare function assertEqual<T>(actual: T, expected: T, msg: string): void;\nexport declare function assertNotEqual<T>(actual: T, expected: T, msg: string): void;\nexport declare function assertSame<T>(actual: T, expected: T, msg: string): void;\nexport declare function assertLessThan<T>(actual: T, expected: T, msg: string): void;\nexport declare function assertGreaterThan<T>(actual: T, expected: T, msg: string): void;\nexport declare function assertNotDefined<T>(actual: T, msg: string): void;\nexport declare function assertDefined<T>(actual: T, msg: string): void;\nexport declare function assertComponentType(actual: any, msg?: string): void;\nexport declare function assertNgModuleType(actual: any, msg?: string): void;\n"
  },
  {
    "path": "node_modules/@angular/core/src/render3/component_ref.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { ChangeDetectorRef as ViewEngine_ChangeDetectorRef } from '../change_detection/change_detector_ref';\nimport { InjectionToken } from '../di/injection_token';\nimport { Injector } from '../di/injector';\nimport { ComponentFactory as viewEngine_ComponentFactory, ComponentRef as viewEngine_ComponentRef } from '../linker/component_factory';\nimport { ComponentFactoryResolver as viewEngine_ComponentFactoryResolver } from '../linker/component_factory_resolver';\nimport { ElementRef as viewEngine_ElementRef } from '../linker/element_ref';\nimport { NgModuleRef as viewEngine_NgModuleRef } from '../linker/ng_module_factory';\nimport { RendererFactory2 } from '../render/api';\nimport { Type } from '../type';\nimport { ComponentDef } from './interfaces/definition';\nimport { TContainerNode, TElementContainerNode, TElementNode } from './interfaces/node';\nimport { LViewData, RootContext } from './interfaces/view';\nimport { ViewRef } from './view_ref';\nexport declare class ComponentFactoryResolver extends viewEngine_ComponentFactoryResolver {\n    resolveComponentFactory<T>(component: Type<T>): viewEngine_ComponentFactory<T>;\n}\n/**\n * Default {@link RootContext} for all components rendered with {@link renderComponent}.\n */\nexport declare const ROOT_CONTEXT: InjectionToken<RootContext>;\n/**\n * A change detection scheduler token for {@link RootContext}. This token is the default value used\n * for the default `RootContext` found in the {@link ROOT_CONTEXT} token.\n */\nexport declare const SCHEDULER: InjectionToken<(fn: () => void) => void>;\n/**\n * A function used to wrap the `RendererFactory2`.\n * Used in tests to change the `RendererFactory2` into a `DebugRendererFactory2`.\n */\nexport declare const WRAP_RENDERER_FACTORY2: InjectionToken<(rf: RendererFactory2) => RendererFactory2>;\n/**\n * Render3 implementation of {@link viewEngine_ComponentFactory}.\n */\nexport declare class ComponentFactory<T> extends viewEngine_ComponentFactory<T> {\n    private componentDef;\n    selector: string;\n    componentType: Type<any>;\n    ngContentSelectors: string[];\n    readonly inputs: {\n        propName: string;\n        templateName: string;\n    }[];\n    readonly outputs: {\n        propName: string;\n        templateName: string;\n    }[];\n    constructor(componentDef: ComponentDef<any>);\n    create(injector: Injector, projectableNodes?: any[][] | undefined, rootSelectorOrNode?: any, ngModule?: viewEngine_NgModuleRef<any> | undefined): viewEngine_ComponentRef<T>;\n}\n/**\n * Creates a ComponentFactoryResolver and stores it on the injector. Or, if the\n * ComponentFactoryResolver\n * already exists, retrieves the existing ComponentFactoryResolver.\n *\n * @returns The ComponentFactoryResolver instance to use\n */\nexport declare function injectComponentFactoryResolver(): viewEngine_ComponentFactoryResolver;\n/**\n * Represents an instance of a Component created via a {@link ComponentFactory}.\n *\n * `ComponentRef` provides access to the Component Instance as well other objects related to this\n * Component Instance and allows you to destroy the Component Instance via the {@link #destroy}\n * method.\n *\n */\nexport declare class ComponentRef<T> extends viewEngine_ComponentRef<T> {\n    location: viewEngine_ElementRef;\n    private _rootView;\n    private _tNode;\n    destroyCbs: (() => void)[] | null;\n    instance: T;\n    hostView: ViewRef<T>;\n    changeDetectorRef: ViewEngine_ChangeDetectorRef;\n    componentType: Type<T>;\n    constructor(componentType: Type<T>, instance: T, location: viewEngine_ElementRef, _rootView: LViewData, _tNode: TElementNode | TContainerNode | TElementContainerNode);\n    readonly injector: Injector;\n    destroy(): void;\n    onDestroy(callback: () => void): void;\n}\n"
  },
  {
    "path": "node_modules/@angular/core/src/render3/component.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { Type } from '../core';\nimport { Injector } from '../di/injector';\nimport { Sanitizer } from '../sanitization/security';\nimport { ComponentDef, ComponentType } from './interfaces/definition';\nimport { PlayerHandler } from './interfaces/player';\nimport { RElement, Renderer3, RendererFactory3 } from './interfaces/renderer';\nimport { LViewData, RootContext } from './interfaces/view';\n/** Options that control how the component should be bootstrapped. */\nexport interface CreateComponentOptions {\n    /** Which renderer factory to use. */\n    rendererFactory?: RendererFactory3;\n    /** A custom sanitizer instance */\n    sanitizer?: Sanitizer;\n    /** A custom animation player handler */\n    playerHandler?: PlayerHandler;\n    /**\n     * Host element on which the component will be bootstrapped. If not specified,\n     * the component definition's `tag` is used to query the existing DOM for the\n     * element to bootstrap.\n     */\n    host?: RElement | string;\n    /** Module injector for the component. If unspecified, the injector will be NULL_INJECTOR. */\n    injector?: Injector;\n    /**\n     * List of features to be applied to the created component. Features are simply\n     * functions that decorate a component with a certain behavior.\n     *\n     * Typically, the features in this list are features that cannot be added to the\n     * other features list in the component definition because they rely on other factors.\n     *\n     * Example: `RootLifecycleHooks` is a function that adds lifecycle hook capabilities\n     * to root components in a tree-shakable way. It cannot be added to the component\n     * features list because there's no way of knowing when the component will be used as\n     * a root component.\n     */\n    hostFeatures?: HostFeature[];\n    /**\n     * A function which is used to schedule change detection work in the future.\n     *\n     * When marking components as dirty, it is necessary to schedule the work of\n     * change detection in the future. This is done to coalesce multiple\n     * {@link markDirty} calls into a single changed detection processing.\n     *\n     * The default value of the scheduler is the `requestAnimationFrame` function.\n     *\n     * It is also useful to override this function for testing purposes.\n     */\n    scheduler?: (work: () => void) => void;\n}\n/** See CreateComponentOptions.hostFeatures */\ndeclare type HostFeature = (<T>(component: T, componentDef: ComponentDef<T>) => void);\nexport declare const NULL_INJECTOR: Injector;\n/**\n * Bootstraps a Component into an existing host element and returns an instance\n * of the component.\n *\n * Use this function to bootstrap a component into the DOM tree. Each invocation\n * of this function will create a separate tree of components, injectors and\n * change detection cycles and lifetimes. To dynamically insert a new component\n * into an existing tree such that it shares the same injection, change detection\n * and object lifetime, use {@link ViewContainer#createComponent}.\n *\n * @param componentType Component to bootstrap\n * @param options Optional parameters which control bootstrapping\n */\nexport declare function renderComponent<T>(componentType: ComponentType<T> | Type<T>, opts?: CreateComponentOptions): T;\n/**\n * Creates the root component view and the root component node.\n *\n * @param rNode Render host element.\n * @param def ComponentDef\n * @param rootView The parent view where the host node is stored\n * @param renderer The current renderer\n * @param sanitizer The sanitizer, if provided\n *\n * @returns Component view created\n */\nexport declare function createRootComponentView(rNode: RElement | null, def: ComponentDef<any>, rootView: LViewData, renderer: Renderer3, sanitizer?: Sanitizer | null): LViewData;\n/**\n * Creates a root component and sets it up with features and host bindings. Shared by\n * renderComponent() and ViewContainerRef.createComponent().\n */\nexport declare function createRootComponent<T>(componentView: LViewData, componentDef: ComponentDef<T>, rootView: LViewData, rootContext: RootContext, hostFeatures: HostFeature[] | null): any;\nexport declare function createRootContext(scheduler?: (workFn: () => void) => void, playerHandler?: PlayerHandler | null): RootContext;\n/**\n * Used to enable lifecycle hooks on the root component.\n *\n * Include this feature when calling `renderComponent` if the root component\n * you are rendering has lifecycle hooks defined. Otherwise, the hooks won't\n * be called properly.\n *\n * Example:\n *\n * ```\n * renderComponent(AppComponent, {features: [RootLifecycleHooks]});\n * ```\n */\nexport declare function LifecycleHooksFeature(component: any, def: ComponentDef<any>): void;\n/**\n * Wait on component until it is rendered.\n *\n * This function returns a `Promise` which is resolved when the component's\n * change detection is executed. This is determined by finding the scheduler\n * associated with the `component`'s render tree and waiting until the scheduler\n * flushes. If nothing is scheduled, the function returns a resolved promise.\n *\n * Example:\n * ```\n * await whenRendered(myComponent);\n * ```\n *\n * @param component Component to wait upon\n * @returns Promise which resolves when the component is rendered.\n */\nexport declare function whenRendered(component: any): Promise<null>;\nexport {};\n"
  },
  {
    "path": "node_modules/@angular/core/src/render3/context_discovery.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport './ng_dev_mode';\nimport { LContext } from './interfaces/context';\nimport { LViewData } from './interfaces/view';\n/** Returns the matching `LContext` data for a given DOM node, directive or component instance.\n *\n * This function will examine the provided DOM element, component, or directive instance\\'s\n * monkey-patched property to derive the `LContext` data. Once called then the monkey-patched\n * value will be that of the newly created `LContext`.\n *\n * If the monkey-patched value is the `LViewData` instance then the context value for that\n * target will be created and the monkey-patch reference will be updated. Therefore when this\n * function is called it may mutate the provided element\\'s, component\\'s or any of the associated\n * directive\\'s monkey-patch values.\n *\n * If the monkey-patch value is not detected then the code will walk up the DOM until an element\n * is found which contains a monkey-patch reference. When that occurs then the provided element\n * will be updated with a new context (which is then returned). If the monkey-patch value is not\n * detected for a component/directive instance then it will throw an error (all components and\n * directives should be automatically monkey-patched by ivy).\n *\n * @param target Component, Directive or DOM Node.\n */\nexport declare function getContext(target: any): LContext | null;\n/**\n * Takes a component instance and returns the view for that component.\n *\n * @param componentInstance\n * @returns The component's view\n */\nexport declare function getComponentViewByInstance(componentInstance: {}): LViewData;\n/**\n * Assigns the given data to the given target (which could be a component,\n * directive or DOM node instance) using monkey-patching.\n */\nexport declare function attachPatchData(target: any, data: LViewData | LContext): void;\nexport declare function isComponentInstance(instance: any): boolean;\nexport declare function isDirectiveInstance(instance: any): boolean;\n/**\n * Returns a list of directives extracted from the given view based on the\n * provided list of directive index values.\n *\n * @param nodeIndex The node index\n * @param lViewData The target view data\n * @param includeComponents Whether or not to include components in returned directives\n */\nexport declare function getDirectivesAtNodeIndex(nodeIndex: number, lViewData: LViewData, includeComponents: boolean): any[] | null;\nexport declare function getComponentAtNodeIndex(nodeIndex: number, lViewData: LViewData): {} | null;\n/**\n * Returns a map of local references (local reference name => element or directive instance) that\n * exist on a given element.\n */\nexport declare function discoverLocalRefs(lViewData: LViewData, nodeIndex: number): {\n    [key: string]: any;\n} | null;\n"
  },
  {
    "path": "node_modules/@angular/core/src/render3/debug.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { Renderer2, RendererType2 } from '../render/api';\nimport { DebugRendererFactory2 } from '../view/services';\n/**\n * Adapts the DebugRendererFactory2 to create a DebugRenderer2 specific for IVY.\n *\n * The created DebugRenderer know how to create a Debug Context specific to IVY.\n */\nexport declare class Render3DebugRendererFactory2 extends DebugRendererFactory2 {\n    createRenderer(element: any, renderData: RendererType2 | null): Renderer2;\n}\n"
  },
  {
    "path": "node_modules/@angular/core/src/render3/definition.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport './ng_dev_mode';\nimport { ChangeDetectionStrategy } from '../change_detection/constants';\nimport { NgModuleDef } from '../metadata/ng_module';\nimport { ViewEncapsulation } from '../metadata/view';\nimport { Type } from '../type';\nimport { BaseDef, ComponentDef, ComponentDefFeature, ComponentQuery, ComponentTemplate, ComponentType, DirectiveDef, DirectiveDefFeature, DirectiveType, DirectiveTypesOrFactory, PipeDef, PipeType, PipeTypesOrFactory } from './interfaces/definition';\nimport { CssSelectorList, SelectorFlags } from './interfaces/projection';\nexport declare const EMPTY: {};\nexport declare const EMPTY_ARRAY: any[];\n/**\n * Create a component definition object.\n *\n *\n * # Example\n * ```\n * class MyDirective {\n *   // Generated by Angular Template Compiler\n *   // [Symbol] syntax will not be supported by TypeScript until v2.7\n *   static ngComponentDef = defineComponent({\n *     ...\n *   });\n * }\n * ```\n */\nexport declare function defineComponent<T>(componentDefinition: {\n    /**\n     * Directive type, needed to configure the injector.\n     */\n    type: Type<T>;\n    /** The selectors that will be used to match nodes to this component. */\n    selectors: CssSelectorList;\n    /**\n     * Factory method used to create an instance of directive.\n     */\n    factory: (t: Type<T> | null) => T;\n    /**\n     * The number of nodes, local refs, and pipes in this component template.\n     *\n     * Used to calculate the length of this component's LViewData array, so we\n     * can pre-fill the array and set the binding start index.\n     */\n    consts: number;\n    /**\n     * The number of bindings in this component template (including pure fn bindings).\n     *\n     * Used to calculate the length of this component's LViewData array, so we\n     * can pre-fill the array and set the host binding start index.\n     */\n    vars: number;\n    /**\n     * The number of host bindings (including pure fn bindings) in this component.\n     *\n     * Used to calculate the length of the LViewData array for the *parent* component\n     * of this component.\n     */\n    hostVars?: number;\n    /**\n     * Static attributes to set on host element.\n     *\n     * Even indices: attribute name\n     * Odd indices: attribute value\n     */\n    attributes?: string[];\n    /**\n     * A map of input names.\n     *\n     * The format is in: `{[actualPropertyName: string]:(string|[string, string])}`.\n     *\n     * Given:\n     * ```\n     * class MyComponent {\n     *   @Input()\n     *   publicInput1: string;\n     *\n     *   @Input('publicInput2')\n     *   declaredInput2: string;\n     * }\n     * ```\n     *\n     * is described as:\n     * ```\n     * {\n     *   publicInput1: 'publicInput1',\n     *   declaredInput2: ['declaredInput2', 'publicInput2'],\n     * }\n     * ```\n     *\n     * Which the minifier may translate to:\n     * ```\n     * {\n     *   minifiedPublicInput1: 'publicInput1',\n     *   minifiedDeclaredInput2: [ 'publicInput2', 'declaredInput2'],\n     * }\n     * ```\n     *\n     * This allows the render to re-construct the minified, public, and declared names\n     * of properties.\n     *\n     * NOTE:\n     *  - Because declared and public name are usually same we only generate the array\n     *    `['declared', 'public']` format when they differ.\n     *  - The reason why this API and `outputs` API is not the same is that `NgOnChanges` has\n     *    inconsistent behavior in that it uses declared names rather than minified or public. For\n     *    this reason `NgOnChanges` will be deprecated and removed in future version and this\n     *    API will be simplified to be consistent with `output`.\n     */\n    inputs?: {\n        [P in keyof T]?: string | [string, string];\n    };\n    /**\n     * A map of output names.\n     *\n     * The format is in: `{[actualPropertyName: string]:string}`.\n     *\n     * Which the minifier may translate to: `{[minifiedPropertyName: string]:string}`.\n     *\n     * This allows the render to re-construct the minified and non-minified names\n     * of properties.\n     */\n    outputs?: {\n        [P in keyof T]?: string;\n    };\n    /**\n     * Function executed by the parent template to allow child directive to apply host bindings.\n     */\n    hostBindings?: (directiveIndex: number, elementIndex: number) => void;\n    /**\n     * Function to create instances of content queries associated with a given directive.\n     */\n    contentQueries?: ((dirIndex: number) => void);\n    /** Refreshes content queries associated with directives in a given view */\n    contentQueriesRefresh?: ((directiveIndex: number, queryIndex: number) => void);\n    /**\n     * Defines the name that can be used in the template to assign this directive to a variable.\n     *\n     * See: {@link Directive.exportAs}\n     */\n    exportAs?: string;\n    /**\n     * Template function use for rendering DOM.\n     *\n     * This function has following structure.\n     *\n     * ```\n     * function Template<T>(ctx:T, creationMode: boolean) {\n     *   if (creationMode) {\n     *     // Contains creation mode instructions.\n     *   }\n     *   // Contains binding update instructions\n     * }\n     * ```\n     *\n     * Common instructions are:\n     * Creation mode instructions:\n     *  - `elementStart`, `elementEnd`\n     *  - `text`\n     *  - `container`\n     *  - `listener`\n     *\n     * Binding update instructions:\n     * - `bind`\n     * - `elementAttribute`\n     * - `elementProperty`\n     * - `elementClass`\n     * - `elementStyle`\n     *\n     */\n    template: ComponentTemplate<T>;\n    /**\n     * Additional set of instructions specific to view query processing. This could be seen as a\n     * set of instruction to be inserted into the template function.\n     *\n     * Query-related instructions need to be pulled out to a specific function as a timing of\n     * execution is different as compared to all other instructions (after change detection hooks but\n     * before view hooks).\n     */\n    viewQuery?: ComponentQuery<T> | null;\n    /**\n     * A list of optional features to apply.\n     *\n     * See: {@link NgOnChangesFeature}, {@link ProvidersFeature}\n     */\n    features?: ComponentDefFeature[];\n    /**\n     * Defines template and style encapsulation options available for Component's {@link Component}.\n     */\n    encapsulation?: ViewEncapsulation;\n    /**\n     * Defines arbitrary developer-defined data to be stored on a renderer instance.\n     * This is useful for renderers that delegate to other renderers.\n     *\n     * see: animation\n     */\n    data?: {\n        [kind: string]: any;\n    };\n    /**\n     * A set of styles that the component needs to be present for component to render correctly.\n     */\n    styles?: string[];\n    /**\n     * The strategy that the default change detector uses to detect changes.\n     * When set, takes effect the next time change detection is triggered.\n     */\n    changeDetection?: ChangeDetectionStrategy;\n    /**\n     * Registry of directives and components that may be found in this component's view.\n     *\n     * The property is either an array of `DirectiveDef`s or a function which returns the array of\n     * `DirectiveDef`s. The function is necessary to be able to support forward declarations.\n     */\n    directives?: DirectiveTypesOrFactory | null;\n    /**\n     * Registry of pipes that may be found in this component's view.\n     *\n     * The property is either an array of `PipeDefs`s or a function which returns the array of\n     * `PipeDefs`s. The function is necessary to be able to support forward declarations.\n     */\n    pipes?: PipeTypesOrFactory | null;\n}): never;\nexport declare function extractDirectiveDef(type: DirectiveType<any> & ComponentType<any>): DirectiveDef<any> | ComponentDef<any>;\nexport declare function extractPipeDef(type: PipeType<any>): PipeDef<any>;\nexport declare function defineNgModule<T>(def: {\n    type: T;\n} & Partial<NgModuleDef<T>>): never;\n/**\n * Create a base definition\n *\n * # Example\n * ```\n * class ShouldBeInherited {\n *   static ngBaseDef = defineBase({\n *      ...\n *   })\n * }\n * @param baseDefinition The base definition parameters\n */\nexport declare function defineBase<T>(baseDefinition: {\n    /**\n     * A map of input names.\n     *\n     * The format is in: `{[actualPropertyName: string]:(string|[string, string])}`.\n     *\n     * Given:\n     * ```\n     * class MyComponent {\n     *   @Input()\n     *   publicInput1: string;\n     *\n     *   @Input('publicInput2')\n     *   declaredInput2: string;\n     * }\n     * ```\n     *\n     * is described as:\n     * ```\n     * {\n     *   publicInput1: 'publicInput1',\n     *   declaredInput2: ['declaredInput2', 'publicInput2'],\n     * }\n     * ```\n     *\n     * Which the minifier may translate to:\n     * ```\n     * {\n     *   minifiedPublicInput1: 'publicInput1',\n     *   minifiedDeclaredInput2: [ 'declaredInput2', 'publicInput2'],\n     * }\n     * ```\n     *\n     * This allows the render to re-construct the minified, public, and declared names\n     * of properties.\n     *\n     * NOTE:\n     *  - Because declared and public name are usually same we only generate the array\n     *    `['declared', 'public']` format when they differ.\n     *  - The reason why this API and `outputs` API is not the same is that `NgOnChanges` has\n     *    inconsistent behavior in that it uses declared names rather than minified or public. For\n     *    this reason `NgOnChanges` will be deprecated and removed in future version and this\n     *    API will be simplified to be consistent with `outputs`.\n     */\n    inputs?: {\n        [P in keyof T]?: string | [string, string];\n    };\n    /**\n     * A map of output names.\n     *\n     * The format is in: `{[actualPropertyName: string]:string}`.\n     *\n     * Which the minifier may translate to: `{[minifiedPropertyName: string]:string}`.\n     *\n     * This allows the render to re-construct the minified and non-minified names\n     * of properties.\n     */\n    outputs?: {\n        [P in keyof T]?: string;\n    };\n}): BaseDef<T>;\n/**\n * Create a directive definition object.\n *\n * # Example\n * ```\n * class MyDirective {\n *   // Generated by Angular Template Compiler\n *   // [Symbol] syntax will not be supported by TypeScript until v2.7\n *   static ngDirectiveDef = defineDirective({\n *     ...\n *   });\n * }\n * ```\n */\nexport declare const defineDirective: <T>(directiveDefinition: {\n    /**\n     * Directive type, needed to configure the injector.\n     */\n    type: Type<T>;\n    /** The selectors that will be used to match nodes to this directive. */\n    selectors: (string | SelectorFlags)[][];\n    /**\n     * Factory method used to create an instance of directive.\n     */\n    factory: (t: Type<T> | null) => T;\n    /**\n     * Static attributes to set on host element.\n     *\n     * Even indices: attribute name\n     * Odd indices: attribute value\n     */\n    attributes?: string[] | undefined;\n    /**\n     * A map of input names.\n     *\n     * The format is in: `{[actualPropertyName: string]:(string|[string, string])}`.\n     *\n     * Given:\n     * ```\n     * class MyComponent {\n     *   @Input()\n     *   publicInput1: string;\n     *\n     *   @Input('publicInput2')\n     *   declaredInput2: string;\n     * }\n     * ```\n     *\n     * is described as:\n     * ```\n     * {\n     *   publicInput1: 'publicInput1',\n     *   declaredInput2: ['declaredInput2', 'publicInput2'],\n     * }\n     * ```\n     *\n     * Which the minifier may translate to:\n     * ```\n     * {\n     *   minifiedPublicInput1: 'publicInput1',\n     *   minifiedDeclaredInput2: [ 'publicInput2', 'declaredInput2'],\n     * }\n     * ```\n     *\n     * This allows the render to re-construct the minified, public, and declared names\n     * of properties.\n     *\n     * NOTE:\n     *  - Because declared and public name are usually same we only generate the array\n     *    `['declared', 'public']` format when they differ.\n     *  - The reason why this API and `outputs` API is not the same is that `NgOnChanges` has\n     *    inconsistent behavior in that it uses declared names rather than minified or public. For\n     *    this reason `NgOnChanges` will be deprecated and removed in future version and this\n     *    API will be simplified to be consistent with `output`.\n     */\n    inputs?: { [P in keyof T]?: string | [string, string] | undefined; } | undefined;\n    /**\n     * A map of output names.\n     *\n     * The format is in: `{[actualPropertyName: string]:string}`.\n     *\n     * Which the minifier may translate to: `{[minifiedPropertyName: string]:string}`.\n     *\n     * This allows the render to re-construct the minified and non-minified names\n     * of properties.\n     */\n    outputs?: { [P in keyof T]?: string | undefined; } | undefined;\n    /**\n     * A list of optional features to apply.\n     *\n     * See: {@link NgOnChangesFeature}, {@link ProvidersFeature}, {@link InheritDefinitionFeature}\n     */\n    features?: DirectiveDefFeature[] | undefined;\n    /**\n     * The number of host bindings (including pure fn bindings) in this directive.\n     *\n     * Used to calculate the length of the LViewData array for the *parent* component\n     * of this directive.\n     */\n    hostVars?: number | undefined;\n    /**\n     * Function executed by the parent template to allow child directive to apply host bindings.\n     */\n    hostBindings?: ((directiveIndex: number, elementIndex: number) => void) | undefined;\n    /**\n     * Function to create instances of content queries associated with a given directive.\n     */\n    contentQueries?: ((directiveIndex: number) => void) | undefined;\n    /** Refreshes content queries associated with directives in a given view */\n    contentQueriesRefresh?: ((directiveIndex: number, queryIndex: number) => void) | undefined;\n    /**\n     * Defines the name that can be used in the template to assign this directive to a variable.\n     *\n     * See: {@link Directive.exportAs}\n     */\n    exportAs?: string | undefined;\n}) => never;\n/**\n * Create a pipe definition object.\n *\n * # Example\n * ```\n * class MyPipe implements PipeTransform {\n *   // Generated by Angular Template Compiler\n *   static ngPipeDef = definePipe({\n *     ...\n *   });\n * }\n * ```\n * @param pipeDef Pipe definition generated by the compiler\n */\nexport declare function definePipe<T>(pipeDef: {\n    /** Name of the pipe. Used for matching pipes in template to pipe defs. */\n    name: string;\n    /** Pipe class reference. Needed to extract pipe lifecycle hooks. */\n    type: Type<T>;\n    /** A factory for creating a pipe instance. */\n    factory: (t: Type<T> | null) => T;\n    /** Whether the pipe is pure. */\n    pure?: boolean;\n}): never;\n/**\n * The following getter methods retrieve the definition form the type. Currently the retrieval\n * honors inheritance, but in the future we may change the rule to require that definitions are\n * explicit. This would require some sort of migration strategy.\n */\nexport declare function getComponentDef<T>(type: any): ComponentDef<T> | null;\nexport declare function getDirectiveDef<T>(type: any): DirectiveDef<T> | null;\nexport declare function getPipeDef<T>(type: any): PipeDef<T> | null;\nexport declare function getNgModuleDef<T>(type: any): NgModuleDef<T> | null;\n"
  },
  {
    "path": "node_modules/@angular/core/src/render3/di_setup.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { Provider } from '../di/provider';\nimport { DirectiveDef } from '.';\n/**\n * Resolves the providers which are defined in the DirectiveDef.\n *\n * When inserting the tokens and the factories in their respective arrays, we can assume that\n * this method is called first for the component (if any), and then for other directives on the same\n * node.\n * As a consequence,the providers are always processed in that order:\n * 1) The view providers of the component\n * 2) The providers of the component\n * 3) The providers of the other directives\n * This matches the structure of the injectables arrays of a view (for each node).\n * So the tokens and the factories can be pushed at the end of the arrays, except\n * in one case for multi providers.\n *\n * @param def the directive definition\n * @param providers: Array of `providers`.\n * @param viewProviders: Array of `viewProviders`.\n */\nexport declare function providersResolver<T>(def: DirectiveDef<T>, providers: Provider[], viewProviders: Provider[]): void;\n"
  },
  {
    "path": "node_modules/@angular/core/src/render3/di.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { InjectionToken } from '../di/injection_token';\nimport { Injector } from '../di/injector';\nimport { InjectFlags } from '../di/injector_compatibility';\nimport { Type } from '../type';\nimport { RelativeInjectorLocation } from './interfaces/injector';\nimport { TContainerNode, TElementContainerNode, TElementNode, TNode } from './interfaces/node';\nimport { LViewData, TData, TView } from './interfaces/view';\n/**\n * Registers this directive as present in its node's injector by flipping the directive's\n * corresponding bit in the injector's bloom filter.\n *\n * @param injectorIndex The index of the node injector where this token should be registered\n * @param tView The TView for the injector's bloom filters\n * @param type The directive token to register\n */\nexport declare function bloomAdd(injectorIndex: number, tView: TView, type: Type<any> | InjectionToken<any>): void;\n/**\n * Creates (or gets an existing) injector for a given element or container.\n *\n * @param tNode for which an injector should be retrieved / created.\n * @param hostView View where the node is stored\n * @returns Node injector\n */\nexport declare function getOrCreateNodeInjectorForNode(tNode: TElementNode | TContainerNode | TElementContainerNode, hostView: LViewData): number;\nexport declare function getInjectorIndex(tNode: TNode, hostView: LViewData): number;\n/**\n * Finds the index of the parent injector, with a view offset if applicable. Used to set the\n * parent injector initially.\n *\n * Returns a combination of number of `ViewData` we have to go up and index in that `Viewdata`\n */\nexport declare function getParentInjectorLocation(tNode: TNode, view: LViewData): RelativeInjectorLocation;\n/**\n * Makes a type or an injection token public to the DI system by adding it to an\n * injector's bloom filter.\n *\n * @param di The node injector in which a directive will be added\n * @param token The type or the injection token to be made public\n */\nexport declare function diPublicInInjector(injectorIndex: number, view: LViewData, token: InjectionToken<any> | Type<any>): void;\n/**\n * Inject static attribute value into directive constructor.\n *\n * This method is used with `factory` functions which are generated as part of\n * `defineDirective` or `defineComponent`. The method retrieves the static value\n * of an attribute. (Dynamic attributes are not supported since they are not resolved\n *  at the time of injection and can change over time.)\n *\n * # Example\n * Given:\n * ```\n * @Component(...)\n * class MyComponent {\n *   constructor(@Attribute('title') title: string) { ... }\n * }\n * ```\n * When instantiated with\n * ```\n * <my-component title=\"Hello\"></my-component>\n * ```\n *\n * Then factory method generated is:\n * ```\n * MyComponent.ngComponentDef = defineComponent({\n *   factory: () => new MyComponent(injectAttribute('title'))\n *   ...\n * })\n * ```\n *\n * @publicApi\n */\nexport declare function injectAttributeImpl(tNode: TNode, attrNameToInject: string): string | undefined;\n/**\n * Returns the value associated to the given token from the NodeInjectors => ModuleInjector.\n *\n * Look for the injector providing the token by walking up the node injector tree and then\n * the module injector tree.\n *\n * @param nodeInjector Node injector where the search should start\n * @param token The token to look for\n * @param flags Injection flags\n * @returns the value from the injector or `null` when not found\n */\nexport declare function getOrCreateInjectable<T>(tNode: TElementNode | TContainerNode | TElementContainerNode, lViewData: LViewData, token: Type<T> | InjectionToken<T>, flags?: InjectFlags, notFoundValue?: any): T | null;\n/**\n* Retrieve or instantiate the injectable from the `lData` at particular `index`.\n*\n* This function checks to see if the value has already been instantiated and if so returns the\n* cached `injectable`. Otherwise if it detects that the value is still a factory it\n* instantiates the `injectable` and caches the value.\n*/\nexport declare function getNodeInjectable(tData: TData, lData: LViewData, index: number, tNode: TElementNode): any;\n/**\n * Returns the bit in an injector's bloom filter that should be used to determine whether or not\n * the directive might be provided by the injector.\n *\n * When a directive is public, it is added to the bloom filter and given a unique ID that can be\n * retrieved on the Type. When the directive isn't public or the token is not a directive `null`\n * is returned as the node injector can not possibly provide that token.\n *\n * @param token the injection token\n * @returns the matching bit to check in the bloom filter or `null` if the token is not known.\n */\nexport declare function bloomHashBitOrFactory(token: Type<any> | InjectionToken<any>): number | Function | undefined;\nexport declare function bloomHasToken(bloomHash: number, injectorIndex: number, injectorView: LViewData | TData): boolean;\nexport declare function injectInjector(): NodeInjector;\nexport declare class NodeInjector implements Injector {\n    private _tNode;\n    private _hostView;\n    private _injectorIndex;\n    constructor(_tNode: TElementNode | TContainerNode | TElementContainerNode, _hostView: LViewData);\n    get(token: any): any;\n}\nexport declare function getFactoryOf<T>(type: Type<any>): ((type: Type<T> | null) => T) | null;\nexport declare function getInheritedFactory<T>(type: Type<any>): (type: Type<T>) => T;\n"
  },
  {
    "path": "node_modules/@angular/core/src/render3/discovery_utils.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { Injector } from '../di/injector';\nimport { LContext } from './interfaces/context';\nimport { LViewData, RootContext } from './interfaces/view';\n/**\n * Returns the component instance associated with a given DOM host element.\n * Elements which don't represent components return `null`.\n *\n * @param element Host DOM element from which the component should be retrieved for.\n *\n * ```\n * <my-app>\n *   #VIEW\n *     <div>\n *       <child-comp></child-comp>\n *     </div>\n * </mp-app>\n *\n * expect(getComponent(<child-comp>) instanceof ChildComponent).toBeTruthy();\n * expect(getComponent(<my-app>) instanceof MyApp).toBeTruthy();\n * ```\n *\n * @publicApi\n */\nexport declare function getComponent<T = {}>(element: Element): T | null;\n/**\n * Returns the component instance associated with view which owns the DOM element (`null`\n * otherwise).\n *\n * @param element DOM element which is owned by an existing component's view.\n *\n * ```\n * <my-app>\n *   #VIEW\n *     <div>\n *       <child-comp></child-comp>\n *     </div>\n * </mp-app>\n *\n * expect(getViewComponent(<child-comp>) instanceof MyApp).toBeTruthy();\n * expect(getViewComponent(<my-app>)).toEqual(null);\n * ```\n *\n * @publicApi\n */\nexport declare function getViewComponent<T = {}>(element: Element | {}): T | null;\n/**\n * Returns the `RootContext` instance that is associated with\n * the application where the target is situated.\n *\n */\nexport declare function getRootContext(target: LViewData | {}): RootContext;\n/**\n * Retrieve all root components.\n *\n * Root components are those which have been bootstrapped by Angular.\n *\n * @param target A DOM element, component or directive instance.\n *\n * @publicApi\n */\nexport declare function getRootComponents(target: {}): any[];\n/**\n * Retrieves an `Injector` associated with the element, component or directive.\n *\n * @param target A DOM element, component or directive instance.\n *\n * @publicApi\n */\nexport declare function getInjector(target: {}): Injector;\n/**\n * Retrieves directives associated with a given DOM host element.\n *\n * @param target A DOM element, component or directive instance.\n *\n * @publicApi\n */\nexport declare function getDirectives(target: {}): Array<{}>;\n/**\n * Returns LContext associated with a target passed as an argument.\n * Throws if a given target doesn't have associated LContext.\n *\n */\nexport declare function loadContext(target: {}): LContext;\n/**\n * Retrieve the root view from any component by walking the parent `LViewData` until\n * reaching the root `LViewData`.\n *\n * @param componentOrView any component or view\n *\n */\nexport declare function getRootView(componentOrView: LViewData | {}): LViewData;\n/**\n * Retrieve map of local references.\n *\n * The references are retrieved as a map of local reference name to element or directive instance.\n *\n * @param target A DOM element, component or directive instance.\n *\n * @publicApi\n */\nexport declare function getLocalRefs(target: {}): {\n    [key: string]: any;\n};\n/**\n * Retrieve the host element of the component.\n *\n * Use this function to retrieve the host element of the component. The host\n * element is the element which the component is associated with.\n *\n * @param directive Component or Directive for which the host element should be retrieved.\n *\n * @publicApi\n */\nexport declare function getHostElement<T>(directive: T): Element;\n/**\n * Retrieves the rendered text for a given component.\n *\n * This function retrieves the host element of a component and\n * and then returns the `textContent` for that element. This implies\n * that the text returned will include re-projected content of\n * the component as well.\n *\n * @param component The component to return the content text for.\n */\nexport declare function getRenderedText(component: any): string;\n"
  },
  {
    "path": "node_modules/@angular/core/src/render3/errors.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { TNode } from './interfaces/node';\n/** Called when directives inject each other (creating a circular dependency) */\nexport declare function throwCyclicDependencyError(token: any): never;\n/** Called when there are multiple component selectors that match a given node */\nexport declare function throwMultipleComponentError(tNode: TNode): never;\n/** Throws an ExpressionChangedAfterChecked error if checkNoChanges mode is on. */\nexport declare function throwErrorIfNoChangesMode(creationMode: boolean, checkNoChangesMode: boolean, oldValue: any, currValue: any): never | void;\n"
  },
  {
    "path": "node_modules/@angular/core/src/render3/features/inherit_definition_feature.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { ComponentDef, DirectiveDef } from '../interfaces/definition';\n/**\n * Merges the definition from a super class to a sub class.\n * @param definition The definition that is a SubClass of another directive of component\n */\nexport declare function InheritDefinitionFeature(definition: DirectiveDef<any> | ComponentDef<any>): void;\n"
  },
  {
    "path": "node_modules/@angular/core/src/render3/features/ng_onchanges_feature.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { DirectiveDef } from '../interfaces/definition';\n/**\n * The NgOnChangesFeature decorates a component with support for the ngOnChanges\n * lifecycle hook, so it should be included in any component that implements\n * that hook.\n *\n * If the component or directive uses inheritance, the NgOnChangesFeature MUST\n * be included as a feature AFTER {@link InheritDefinitionFeature}, otherwise\n * inherited properties will not be propagated to the ngOnChanges lifecycle\n * hook.\n *\n * Example usage:\n *\n * ```\n * static ngComponentDef = defineComponent({\n *   ...\n *   inputs: {name: 'publicName'},\n *   features: [NgOnChangesFeature]\n * });\n * ```\n */\nexport declare function NgOnChangesFeature<T>(definition: DirectiveDef<T>): void;\n"
  },
  {
    "path": "node_modules/@angular/core/src/render3/features/providers_feature.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { Provider } from '../../di/provider';\nimport { DirectiveDef } from '../interfaces/definition';\n/**\n * This feature resolves the providers of a directive (or component),\n * and publish them into the DI system, making it visible to others for injection.\n *\n * For example:\n * class ComponentWithProviders {\n *   constructor(private greeter: GreeterDE) {}\n *\n *   static ngComponentDef = defineComponent({\n *     type: ComponentWithProviders,\n *     selectors: [['component-with-providers']],\n *    factory: () => new ComponentWithProviders(directiveInject(GreeterDE as any)),\n *    consts: 1,\n *    vars: 1,\n *    template: function(fs: RenderFlags, ctx: ComponentWithProviders) {\n *      if (fs & RenderFlags.Create) {\n *        text(0);\n *      }\n *      if (fs & RenderFlags.Update) {\n *        textBinding(0, bind(ctx.greeter.greet()));\n *      }\n *    },\n *    features: [ProvidersFeature([GreeterDE])]\n *  });\n * }\n *\n * @param definition\n */\nexport declare function ProvidersFeature<T>(providers: Provider[], viewProviders?: Provider[]): (definition: DirectiveDef<T>) => void;\n"
  },
  {
    "path": "node_modules/@angular/core/src/render3/fields.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nexport declare const NG_COMPONENT_DEF: string;\nexport declare const NG_DIRECTIVE_DEF: string;\nexport declare const NG_INJECTABLE_DEF: string;\nexport declare const NG_INJECTOR_DEF: string;\nexport declare const NG_PIPE_DEF: string;\nexport declare const NG_MODULE_DEF: string;\nexport declare const NG_BASE_DEF: string;\n/**\n * If a directive is diPublic, bloomAdd sets a property on the type with this constant as\n * the key and the directive's unique ID as the value. This allows us to map directives to their\n * bloom filter bit for DI.\n */\nexport declare const NG_ELEMENT_ID: string;\n"
  },
  {
    "path": "node_modules/@angular/core/src/render3/global_utils_api.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * @fileoverview\n * This file is the index file collecting all of the symbols published on the global.ng namespace.\n *\n * The reason why this file/module is separate global_utils.ts file is that we use this file\n * to generate a d.ts file containing all the published symbols that is then compared to the golden\n * file in the public_api_guard test.\n */\nexport { getComponent, getDirectives, getHostElement, getInjector, getRootComponents, getViewComponent } from './discovery_utils';\nexport { markDirty } from './instructions';\nexport { getPlayers } from './players';\n"
  },
  {
    "path": "node_modules/@angular/core/src/render3/global_utils.d.ts",
    "content": "/**\n * This file introduces series of globally accessible debug tools\n * to allow for the Angular debugging story to function.\n *\n * To see this in action run the following command:\n *\n *   bazel run --define=compile=aot\n *   //packages/core/test/bundling/todo:devserver\n *\n *  Then load `localhost:5432` and start using the console tools.\n */\n/**\n * This value reflects the property on the window where the dev\n * tools are patched (window.ng).\n * */\nexport declare const GLOBAL_PUBLISH_EXPANDO_KEY = \"ng\";\nexport declare function publishDefaultGlobalUtils(): void;\nexport declare type GlobalDevModeContainer = {\n    [GLOBAL_PUBLISH_EXPANDO_KEY]: {\n        [fnName: string]: Function;\n    };\n};\n/**\n * Publishes the given function to `window.ngDevMode` so that it can be\n * used from the browser console when an application is not in production.\n */\nexport declare function publishGlobalUtil(name: string, fn: Function): void;\n"
  },
  {
    "path": "node_modules/@angular/core/src/render3/hooks.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { HookData, LViewData, TView } from './interfaces/view';\n/**\n * If this is the first template pass, any ngOnInit or ngDoCheck hooks will be queued into\n * TView.initHooks during directiveCreate.\n *\n * The directive index and hook type are encoded into one number (1st bit: type, remaining bits:\n * directive index), then saved in the even indices of the initHooks array. The odd indices\n * hold the hook functions themselves.\n *\n * @param index The index of the directive in LViewData\n * @param hooks The static hooks map on the directive def\n * @param tView The current TView\n */\nexport declare function queueInitHooks(index: number, onInit: (() => void) | null, doCheck: (() => void) | null, tView: TView): void;\n/**\n * Loops through the directives on a node and queues all their hooks except ngOnInit\n * and ngDoCheck, which are queued separately in directiveCreate.\n */\nexport declare function queueLifecycleHooks(flags: number, tView: TView): void;\n/**\n * Calls onInit and doCheck calls if they haven't already been called.\n *\n * @param currentView The current view\n */\nexport declare function executeInitHooks(currentView: LViewData, tView: TView, creationMode: boolean): void;\n/**\n * Iterates over afterViewInit and afterViewChecked functions and calls them.\n *\n * @param currentView The current view\n */\nexport declare function executeHooks(data: LViewData, allHooks: HookData | null, checkHooks: HookData | null, creationMode: boolean): void;\n/**\n * Calls lifecycle hooks with their contexts, skipping init hooks if it's not\n * creation mode.\n *\n * @param currentView The current view\n * @param arr The array in which the hooks are found\n */\nexport declare function callHooks(currentView: any[], arr: HookData): void;\n"
  },
  {
    "path": "node_modules/@angular/core/src/render3/i18n.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { NO_CHANGE } from './tokens';\n/**\n * Extracts a part of a message and removes the rest.\n *\n * This method is used for extracting a part of the message associated with a template. A translated\n * message can span multiple templates.\n *\n * Example:\n * ```\n * <div i18n>Translate <span *ngIf>me</span>!</div>\n * ```\n *\n * @param message The message to crop\n * @param subTemplateIndex Index of the sub-template to extract. If undefined it returns the\n * external template and removes all sub-templates.\n */\nexport declare function getTranslationForTemplate(message: string, subTemplateIndex?: number): string;\n/**\n * Marks a block of text as translatable.\n *\n * The instructions `i18nStart` and `i18nEnd` mark the translation block in the template.\n * The translation `message` is the value which is locale specific. The translation string may\n * contain placeholders which associate inner elements and sub-templates within the translation.\n *\n * The translation `message` placeholders are:\n * - `�{index}(:{block})�`: *Binding Placeholder*: Marks a location where an expression will be\n *   interpolated into. The placeholder `index` points to the expression binding index. An optional\n *   `block` that matches the sub-template in which it was declared.\n * - `�#{index}(:{block})�`/`�/#{index}(:{block})�`: *Element Placeholder*:  Marks the beginning\n *   and end of DOM element that were embedded in the original translation block. The placeholder\n *   `index` points to the element index in the template instructions set. An optional `block` that\n *   matches the sub-template in which it was declared.\n * - `�*{index}:{block}�`/`�/*{index}:{block}�`: *Sub-template Placeholder*: Sub-templates must be\n *   split up and translated separately in each angular template function. The `index` points to the\n *   `template` instruction index. A `block` that matches the sub-template in which it was declared.\n *\n * @param index A unique index of the translation in the static block.\n * @param message The translation message.\n * @param subTemplateIndex Optional sub-template index in the `message`.\n */\nexport declare function i18nStart(index: number, message: string, subTemplateIndex?: number): void;\n/**\n * Handles message string post-processing for internationalization.\n *\n * Handles message string post-processing by transforming it from intermediate\n * format (that might contain some markers that we need to replace) to the final\n * form, consumable by i18nStart instruction. Post processing steps include:\n *\n * 1. Resolve all multi-value cases (like [�*1:1��#2:1�|�#4:1�|�5�])\n * 2. Replace all ICU vars (like \"VAR_PLURAL\")\n * 3. Replace all ICU references with corresponding values (like �ICU_EXP_ICU_1�)\n *    in case multiple ICUs have the same placeholder name\n *\n * @param message Raw translation string for post processing\n * @param replacements Set of replacements that should be applied\n *\n * @returns Transformed string that can be consumed by i18nStart instruction\n *\n * @publicAPI\n */\nexport declare function i18nPostprocess(message: string, replacements: {\n    [key: string]: (string | string[]);\n}): string;\n/**\n * Translates a translation block marked by `i18nStart` and `i18nEnd`. It inserts the text/ICU nodes\n * into the render tree, moves the placeholder nodes and removes the deleted nodes.\n */\nexport declare function i18nEnd(): void;\n/**\n *\n * Use this instruction to create a translation block that doesn't contain any placeholder.\n * It calls both {@link i18nStart} and {@link i18nEnd} in one instruction.\n *\n * The translation `message` is the value which is locale specific. The translation string may\n * contain placeholders which associate inner elements and sub-templates within the translation.\n *\n * The translation `message` placeholders are:\n * - `�{index}(:{block})�`: *Binding Placeholder*: Marks a location where an expression will be\n *   interpolated into. The placeholder `index` points to the expression binding index. An optional\n *   `block` that matches the sub-template in which it was declared.\n * - `�#{index}(:{block})�`/`�/#{index}(:{block})�`: *Element Placeholder*:  Marks the beginning\n *   and end of DOM element that were embedded in the original translation block. The placeholder\n *   `index` points to the element index in the template instructions set. An optional `block` that\n *   matches the sub-template in which it was declared.\n * - `�*{index}:{block}�`/`�/*{index}:{block}�`: *Sub-template Placeholder*: Sub-templates must be\n *   split up and translated separately in each angular template function. The `index` points to the\n *   `template` instruction index. A `block` that matches the sub-template in which it was declared.\n *\n * @param index A unique index of the translation in the static block.\n * @param message The translation message.\n * @param subTemplateIndex Optional sub-template index in the `message`.\n */\nexport declare function i18n(index: number, message: string, subTemplateIndex?: number): void;\n/**\n * Marks a list of attributes as translatable.\n *\n * @param index A unique index in the static block\n * @param values\n */\nexport declare function i18nAttributes(index: number, values: string[]): void;\n/**\n * Stores the values of the bindings during each update cycle in order to determine if we need to\n * update the translated nodes.\n *\n * @param expression The binding's new value or NO_CHANGE\n */\nexport declare function i18nExp<T>(expression: T | NO_CHANGE): void;\n/**\n * Updates a translation block or an i18n attribute when the bindings have changed.\n *\n * @param index Index of either {@link i18nStart} (translation block) or {@link i18nAttributes}\n * (i18n attribute) on which it should update the content.\n */\nexport declare function i18nApply(index: number): void;\n"
  },
  {
    "path": "node_modules/@angular/core/src/render3/index.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { LifecycleHooksFeature, renderComponent, whenRendered } from './component';\nimport { defineBase, defineComponent, defineDirective, defineNgModule, definePipe } from './definition';\nimport { getHostElement, getRenderedText } from './discovery_utils';\nimport { InheritDefinitionFeature } from './features/inherit_definition_feature';\nimport { NgOnChangesFeature } from './features/ng_onchanges_feature';\nimport { ProvidersFeature } from './features/providers_feature';\nimport { BaseDef, ComponentDef, ComponentDefWithMeta, ComponentTemplate, ComponentType, DirectiveDef, DirectiveDefFlags, DirectiveDefWithMeta, DirectiveType, PipeDef, PipeDefWithMeta } from './interfaces/definition';\nexport { ComponentFactory, ComponentFactoryResolver, ComponentRef, WRAP_RENDERER_FACTORY2, injectComponentFactoryResolver } from './component_ref';\nexport { getFactoryOf, getInheritedFactory } from './di';\nexport { RenderFlags } from './interfaces/definition';\nexport { CssSelectorList } from './interfaces/projection';\nexport { bind, interpolation1, interpolation2, interpolation3, interpolation4, interpolation5, interpolation6, interpolation7, interpolation8, interpolationV, container, containerRefreshStart, containerRefreshEnd, nextContext, element, elementAttribute, elementClassProp, elementEnd, elementProperty, elementStart, elementContainerStart, elementContainerEnd, elementStyling, elementStylingMap, elementStyleProp, elementStylingApply, listener, store, load, namespaceHTML, namespaceMathML, namespaceSVG, projection, projectionDef, text, textBinding, template, reference, embeddedViewStart, embeddedViewEnd, detectChanges, markDirty, tick, directiveInject, injectAttribute, } from './instructions';\nexport { getCurrentView, restoreView, enableBindings, disableBindings, } from './state';\nexport { i18n, i18nAttributes, i18nExp, i18nStart, i18nEnd, i18nApply, i18nPostprocess } from './i18n';\nexport { NgModuleFactory, NgModuleRef, NgModuleType } from './ng_module_ref';\nexport { AttributeMarker } from './interfaces/node';\nexport { setClassMetadata, } from './metadata';\nexport { pipe, pipeBind1, pipeBind2, pipeBind3, pipeBind4, pipeBindV, } from './pipe';\nexport { QueryList, query, queryRefresh, } from './query';\nexport { registerContentQuery, loadQueryList, } from './instructions';\nexport { pureFunction0, pureFunction1, pureFunction2, pureFunction3, pureFunction4, pureFunction5, pureFunction6, pureFunction7, pureFunction8, pureFunctionV, } from './pure_function';\nexport { templateRefExtractor } from './view_engine_compatibility_prebound';\nexport { BaseDef, ComponentDef, ComponentDefWithMeta, ComponentTemplate, ComponentType, DirectiveDef, DirectiveDefFlags, DirectiveDefWithMeta, DirectiveType, NgOnChangesFeature, InheritDefinitionFeature, ProvidersFeature, PipeDef, PipeDefWithMeta, LifecycleHooksFeature, defineComponent, defineDirective, defineNgModule, defineBase, definePipe, getHostElement, getRenderedText, renderComponent, whenRendered, };\nexport { NO_CHANGE } from './tokens';\n"
  },
  {
    "path": "node_modules/@angular/core/src/render3/instructions.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { InjectionToken } from '../di/injection_token';\nimport { Injector } from '../di/injector';\nimport { InjectFlags } from '../di/injector_compatibility';\nimport { QueryList } from '../linker';\nimport { Sanitizer } from '../sanitization/security';\nimport { StyleSanitizeFn } from '../sanitization/style_sanitizer';\nimport { Type } from '../type';\nimport { LContainer } from './interfaces/container';\nimport { ComponentDef, ComponentQuery, ComponentTemplate, DirectiveDefListOrFactory, InitialStylingFlags, PipeDefListOrFactory, RenderFlags } from './interfaces/definition';\nimport { LocalRefExtractor, TAttributes, TContainerNode, TElementContainerNode, TElementNode, TNode, TNodeType, TProjectionNode, TViewNode } from './interfaces/node';\nimport { PlayerFactory } from './interfaces/player';\nimport { CssSelectorList } from './interfaces/projection';\nimport { LQueries } from './interfaces/query';\nimport { RComment, RElement, RText, Renderer3, RendererFactory3 } from './interfaces/renderer';\nimport { SanitizerFn } from './interfaces/sanitization';\nimport { LViewData, LViewFlags, RootContext, RootContextFlags, TView } from './interfaces/view';\nimport { NO_CHANGE } from './tokens';\n/**\n * Refreshes the view, executing the following steps in that order:\n * triggers init hooks, refreshes dynamic embedded views, triggers content hooks, sets host\n * bindings, refreshes child components.\n * Note: view hooks are triggered later when leaving the view.\n */\nexport declare function refreshDescendantViews(viewData: LViewData, rf: RenderFlags | null): void;\n/** Sets the host bindings for the current view. */\nexport declare function setHostBindings(tView: TView, viewData: LViewData): void;\nexport declare function createLViewData<T>(parentViewData: LViewData | null, renderer: Renderer3, tView: TView, context: T | null, flags: LViewFlags, sanitizer?: Sanitizer | null, injector?: Injector | null): LViewData;\n/**\n * Create and stores the TNode, and hooks it up to the tree.\n *\n * @param index The index at which the TNode should be saved (null if view, since they are not\n * saved).\n * @param type The type of TNode to create\n * @param native The native element for this node, if applicable\n * @param name The tag name of the associated native element, if applicable\n * @param attrs Any attrs for the native element, if applicable\n */\nexport declare function createNodeAtIndex(index: number, type: TNodeType.Element, native: RElement | RText | null, name: string | null, attrs: TAttributes | null): TElementNode;\nexport declare function createNodeAtIndex(index: number, type: TNodeType.Container, native: RComment, name: string | null, attrs: TAttributes | null): TContainerNode;\nexport declare function createNodeAtIndex(index: number, type: TNodeType.Projection, native: null, name: null, attrs: TAttributes | null): TProjectionNode;\nexport declare function createNodeAtIndex(index: number, type: TNodeType.ElementContainer, native: RComment, name: null, attrs: TAttributes | null): TElementContainerNode;\nexport declare function createNodeAtIndex(index: number, type: TNodeType.IcuContainer, native: RComment, name: null, attrs: TAttributes | null): TElementContainerNode;\nexport declare function createViewNode(index: number, view: LViewData): TViewNode;\n/**\n * When elements are created dynamically after a view blueprint is created (e.g. through\n * i18nApply() or ComponentFactory.create), we need to adjust the blueprint for future\n * template passes.\n */\nexport declare function allocExpando(view: LViewData): void;\n/**\n *\n * @param hostNode Existing node to render into.\n * @param templateFn Template function with the instructions.\n * @param consts The number of nodes, local refs, and pipes in this template\n * @param context to pass into the template.\n * @param providedRendererFactory renderer factory to use\n * @param host The host element node to use\n * @param directives Directive defs that should be used for matching\n * @param pipes Pipe defs that should be used for matching\n */\nexport declare function renderTemplate<T>(hostNode: RElement, templateFn: ComponentTemplate<T>, consts: number, vars: number, context: T, providedRendererFactory: RendererFactory3, hostView: LViewData | null, directives?: DirectiveDefListOrFactory | null, pipes?: PipeDefListOrFactory | null, sanitizer?: Sanitizer | null): LViewData;\n/**\n * Used for creating the LViewNode of a dynamic embedded view,\n * either through ViewContainerRef.createEmbeddedView() or TemplateRef.createEmbeddedView().\n * Such lViewNode will then be renderer with renderEmbeddedTemplate() (see below).\n */\nexport declare function createEmbeddedViewAndNode<T>(tView: TView, context: T, declarationView: LViewData, renderer: Renderer3, queries: LQueries | null, injectorIndex: number): LViewData;\n/**\n * Used for rendering embedded views (e.g. dynamically created views)\n *\n * Dynamically created views must store/retrieve their TViews differently from component views\n * because their template functions are nested in the template functions of their hosts, creating\n * closures. If their host template happens to be an embedded template in a loop (e.g. ngFor inside\n * an ngFor), the nesting would mean we'd have multiple instances of the template function, so we\n * can't store TViews in the template function itself (as we do for comps). Instead, we store the\n * TView for dynamically created views on their host TNode, which only has one instance.\n */\nexport declare function renderEmbeddedTemplate<T>(viewToRender: LViewData, tView: TView, context: T, rf: RenderFlags): void;\n/**\n * Retrieves a context at the level specified and saves it as the global, contextViewData.\n * Will get the next level up if level is not specified.\n *\n * This is used to save contexts of parent views so they can be bound in embedded views, or\n * in conjunction with reference() to bind a ref from a parent view.\n *\n * @param level The relative level of the view from which to grab context compared to contextVewData\n * @returns context\n */\nexport declare function nextContext<T = any>(level?: number): T;\nexport declare function namespaceSVG(): void;\nexport declare function namespaceMathML(): void;\nexport declare function namespaceHTML(): void;\n/**\n * Creates an empty element using {@link elementStart} and {@link elementEnd}\n *\n * @param index Index of the element in the data array\n * @param name Name of the DOM Node\n * @param attrs Statically bound set of attributes to be written into the DOM element on creation.\n * @param localRefs A set of local reference bindings on the element.\n */\nexport declare function element(index: number, name: string, attrs?: TAttributes | null, localRefs?: string[] | null): void;\n/**\n * Creates a logical container for other nodes (<ng-container>) backed by a comment node in the DOM.\n * The instruction must later be followed by `elementContainerEnd()` call.\n *\n * @param index Index of the element in the LViewData array\n * @param attrs Set of attributes to be used when matching directives.\n * @param localRefs A set of local reference bindings on the element.\n *\n * Even if this instruction accepts a set of attributes no actual attribute values are propagated to\n * the DOM (as a comment node can't have attributes). Attributes are here only for directive\n * matching purposes and setting initial inputs of directives.\n */\nexport declare function elementContainerStart(index: number, attrs?: TAttributes | null, localRefs?: string[] | null): void;\n/** Mark the end of the <ng-container>. */\nexport declare function elementContainerEnd(): void;\n/**\n * Create DOM element. The instruction must later be followed by `elementEnd()` call.\n *\n * @param index Index of the element in the LViewData array\n * @param name Name of the DOM Node\n * @param attrs Statically bound set of attributes to be written into the DOM element on creation.\n * @param localRefs A set of local reference bindings on the element.\n *\n * Attributes and localRefs are passed as an array of strings where elements with an even index\n * hold an attribute name and elements with an odd index hold an attribute value, ex.:\n * ['id', 'warning5', 'class', 'alert']\n */\nexport declare function elementStart(index: number, name: string, attrs?: TAttributes | null, localRefs?: string[] | null): void;\n/**\n * Creates a native element from a tag name, using a renderer.\n * @param name the tag name\n * @param overriddenRenderer Optional A renderer to override the default one\n * @returns the element created\n */\nexport declare function elementCreate(name: string, overriddenRenderer?: Renderer3): RElement;\n/**\n * Gets TView from a template function or creates a new TView\n * if it doesn't already exist.\n *\n * @param templateFn The template from which to get static data\n * @param consts The number of nodes, local refs, and pipes in this view\n * @param vars The number of bindings and pure function bindings in this view\n * @param directives Directive defs that should be saved on TView\n * @param pipes Pipe defs that should be saved on TView\n * @returns TView\n */\nexport declare function getOrCreateTView(templateFn: ComponentTemplate<any>, consts: number, vars: number, directives: DirectiveDefListOrFactory | null, pipes: PipeDefListOrFactory | null, viewQuery: ComponentQuery<any> | null): TView;\n/**\n * Creates a TView instance\n *\n * @param viewIndex The viewBlockId for inline views, or -1 if it's a component/dynamic\n * @param templateFn Template function\n * @param consts The number of nodes, local refs, and pipes in this template\n * @param directives Registry of directives for this view\n * @param pipes Registry of pipes for this view\n */\nexport declare function createTView(viewIndex: number, templateFn: ComponentTemplate<any> | null, consts: number, vars: number, directives: DirectiveDefListOrFactory | null, pipes: PipeDefListOrFactory | null, viewQuery: ComponentQuery<any> | null): TView;\nexport declare function createError(text: string, token: any): Error;\n/**\n * Locates the host native element, used for bootstrapping existing nodes into rendering pipeline.\n *\n * @param elementOrSelector Render element or CSS selector to locate the element.\n */\nexport declare function locateHostElement(factory: RendererFactory3, elementOrSelector: RElement | string): RElement | null;\n/**\n * Adds an event listener to the current node.\n *\n * If an output exists on one of the node's directives, it also subscribes to the output\n * and saves the subscription for later cleanup.\n *\n * @param eventName Name of the event\n * @param listenerFn The function to be called when event emits\n * @param useCapture Whether or not to use capture in event listener.\n */\nexport declare function listener(eventName: string, listenerFn: (e?: any) => any, useCapture?: boolean): void;\n/**\n * Saves context for this cleanup function in LView.cleanupInstances.\n *\n * On the first template pass, saves in TView:\n * - Cleanup function\n * - Index of context we just saved in LView.cleanupInstances\n */\nexport declare function storeCleanupWithContext(view: LViewData | null, context: any, cleanupFn: Function): void;\n/**\n * Saves the cleanup function itself in LView.cleanupInstances.\n *\n * This is necessary for functions that are wrapped with their contexts, like in renderer2\n * listeners.\n *\n * On the first template pass, the index of the cleanup function is saved in TView.\n */\nexport declare function storeCleanupFn(view: LViewData, cleanupFn: Function): void;\n/** Mark the end of the element. */\nexport declare function elementEnd(): void;\n/**\n * Updates the value of removes an attribute on an Element.\n *\n * @param number index The index of the element in the data array\n * @param name name The name of the attribute.\n * @param value value The attribute is removed when value is `null` or `undefined`.\n *                  Otherwise the attribute value is set to the stringified value.\n * @param sanitizer An optional function used to sanitize the value.\n */\nexport declare function elementAttribute(index: number, name: string, value: any, sanitizer?: SanitizerFn | null): void;\n/**\n * Update a property on an Element.\n *\n * If the property name also exists as an input property on one of the element's directives,\n * the component property will be set instead of the element property. This check must\n * be conducted at runtime so child components that add new @Inputs don't have to be re-compiled.\n *\n * @param index The index of the element to update in the data array\n * @param propName Name of property. Because it is going to DOM, this is not subject to\n *        renaming as part of minification.\n * @param value New value to write.\n * @param sanitizer An optional function used to sanitize the value.\n */\nexport declare function elementProperty<T>(index: number, propName: string, value: T | NO_CHANGE, sanitizer?: SanitizerFn | null): void;\n/**\n * Constructs a TNode object from the arguments.\n *\n * @param type The type of the node\n * @param adjustedIndex The index of the TNode in TView.data, adjusted for HEADER_OFFSET\n * @param tagName The tag name of the node\n * @param attrs The attributes defined on this node\n * @param tViews Any TViews attached to this node\n * @returns the TNode object\n */\nexport declare function createTNode(viewData: LViewData, type: TNodeType, adjustedIndex: number, tagName: string | null, attrs: TAttributes | null, tViews: TView[] | null): TNode;\n/**\n * Add or remove a class in a `classList` on a DOM element.\n *\n * This instruction is meant to handle the [class.foo]=\"exp\" case\n *\n * @param index The index of the element to update in the data array\n * @param classIndex Index of class to toggle. Because it is going to DOM, this is not subject to\n *        renaming as part of minification.\n * @param value A value indicating if a given class should be added or removed.\n * @param directiveIndex the index for the directive that is attempting to change styling.\n */\nexport declare function elementClassProp(index: number, classIndex: number, value: boolean | PlayerFactory, directiveIndex?: number): void;\n/**\n * Assign any inline style values to the element during creation mode.\n *\n * This instruction is meant to be called during creation mode to apply all styling\n * (e.g. `style=\"...\"`) values to the element. This is also where the provided index\n * value is allocated for the styling details for its corresponding element (the element\n * index is the previous index value from this one).\n *\n * (Note this function calls `elementStylingApply` immediately when called.)\n *\n *\n * @param index Index value which will be allocated to store styling data for the element.\n *        (Note that this is not the element index, but rather an index value allocated\n *        specifically for element styling--the index must be the next index after the element\n *        index.)\n * @param classDeclarations A key/value array of CSS classes that will be registered on the element.\n *   Each individual style will be used on the element as long as it is not overridden\n *   by any classes placed on the element by multiple (`[class]`) or singular (`[class.named]`)\n *   bindings. If a class binding changes its value to a falsy value then the matching initial\n *   class value that are passed in here will be applied to the element (if matched).\n * @param styleDeclarations A key/value array of CSS styles that will be registered on the element.\n *   Each individual style will be used on the element as long as it is not overridden\n *   by any styles placed on the element by multiple (`[style]`) or singular (`[style.prop]`)\n *   bindings. If a style binding changes its value to null then the initial styling\n *   values that are passed in here will be applied to the element (if matched).\n * @param styleSanitizer An optional sanitizer function that will be used (if provided)\n *   to sanitize the any CSS property values that are applied to the element (during rendering).\n * @param directiveIndex the index for the directive that is attempting to change styling.\n */\nexport declare function elementStyling(classDeclarations?: (string | boolean | InitialStylingFlags)[] | null, styleDeclarations?: (string | boolean | InitialStylingFlags)[] | null, styleSanitizer?: StyleSanitizeFn | null, directiveIndex?: number): void;\n/**\n * Apply all styling values to the element which have been queued by any styling instructions.\n *\n * This instruction is meant to be run once one or more `elementStyle` and/or `elementStyleProp`\n * have been issued against the element. This function will also determine if any styles have\n * changed and will then skip the operation if there is nothing new to render.\n *\n * Once called then all queued styles will be flushed.\n *\n * @param index Index of the element's styling storage that will be rendered.\n *        (Note that this is not the element index, but rather an index value allocated\n *        specifically for element styling--the index must be the next index after the element\n *        index.)\n * @param directiveIndex the index for the directive that is attempting to change styling.\n */\nexport declare function elementStylingApply(index: number, directiveIndex?: number): void;\n/**\n * Queue a given style to be rendered on an Element.\n *\n * If the style value is `null` then it will be removed from the element\n * (or assigned a different value depending if there are any styles placed\n * on the element with `elementStyle` or any styles that are present\n * from when the element was created (with `elementStyling`).\n *\n * (Note that the styling instruction will not be applied until `elementStylingApply` is called.)\n *\n * @param index Index of the element's styling storage to change in the data array.\n *        (Note that this is not the element index, but rather an index value allocated\n *        specifically for element styling--the index must be the next index after the element\n *        index.)\n * @param styleIndex Index of the style property on this element. (Monotonically increasing.)\n * @param value New value to write (null to remove).\n * @param suffix Optional suffix. Used with scalar values to add unit such as `px`.\n *        Note that when a suffix is provided then the underlying sanitizer will\n *        be ignored.\n * @param directiveIndex the index for the directive that is attempting to change styling.\n */\nexport declare function elementStyleProp(index: number, styleIndex: number, value: string | number | String | PlayerFactory | null, suffix?: string, directiveIndex?: number): void;\n/**\n * Queue a key/value map of styles to be rendered on an Element.\n *\n * This instruction is meant to handle the `[style]=\"exp\"` usage. When styles are applied to\n * the Element they will then be placed with respect to any styles set with `elementStyleProp`.\n * If any styles are set to `null` then they will be removed from the element (unless the same\n * style properties have been assigned to the element during creation using `elementStyling`).\n *\n * (Note that the styling instruction will not be applied until `elementStylingApply` is called.)\n *\n * @param index Index of the element's styling storage to change in the data array.\n *        (Note that this is not the element index, but rather an index value allocated\n *        specifically for element styling--the index must be the next index after the element\n *        index.)\n * @param classes A key/value style map of CSS classes that will be added to the given element.\n *        Any missing classes (that have already been applied to the element beforehand) will be\n *        removed (unset) from the element's list of CSS classes.\n * @param styles A key/value style map of the styles that will be applied to the given element.\n *        Any missing styles (that have already been applied to the element beforehand) will be\n *        removed (unset) from the element's styling.\n * @param directiveIndex the index for the directive that is attempting to change styling.\n */\nexport declare function elementStylingMap<T>(index: number, classes: {\n    [key: string]: any;\n} | string | NO_CHANGE | null, styles?: {\n    [styleName: string]: any;\n} | NO_CHANGE | null, directiveIndex?: number): void;\n/**\n * Create static text node\n *\n * @param index Index of the node in the data array\n * @param value Value to write. This value will be stringified.\n */\nexport declare function text(index: number, value?: any): void;\n/**\n * Create text node with binding\n * Bindings should be handled externally with the proper interpolation(1-8) method\n *\n * @param index Index of the node in the data array.\n * @param value Stringified value to write.\n */\nexport declare function textBinding<T>(index: number, value: T | NO_CHANGE): void;\n/**\n * Instantiate a root component.\n */\nexport declare function instantiateRootComponent<T>(tView: TView, viewData: LViewData, def: ComponentDef<T>): T;\n/**\n* Generates a new block in TView.expandoInstructions for this node.\n*\n* Each expando block starts with the element index (turned negative so we can distinguish\n* it from the hostVar count) and the directive count. See more in VIEW_DATA.md.\n*/\nexport declare function generateExpandoInstructionBlock(tView: TView, tNode: TNode, directiveCount: number): void;\n/**\n* On the first template pass, we need to reserve space for host binding values\n* after directives are matched (so all directives are saved, then bindings).\n* Because we are updating the blueprint, we only need to do this once.\n*/\nexport declare function prefillHostVars(tView: TView, viewData: LViewData, totalHostVars: number): void;\n/** Stores index of component's host element so it will be queued for view refresh during CD. */\nexport declare function queueComponentIndexForCheck(previousOrParentTNode: TNode): void;\n/**\n * Initializes the flags on the current node, setting all indices to the initial index,\n * the directive count to 0, and adding the isComponent flag.\n * @param index the initial index\n */\nexport declare function initNodeFlags(tNode: TNode, index: number, numberOfDirectives: number): void;\n/**\n * Creates a LContainer, either from a container instruction, or for a ViewContainerRef.\n *\n * @param hostNative The host element for the LContainer\n * @param hostTNode The host TNode for the LContainer\n * @param currentView The parent view of the LContainer\n * @param native The native comment element\n * @param isForViewContainerRef Optional a flag indicating the ViewContainerRef case\n * @returns LContainer\n */\nexport declare function createLContainer(hostNative: RElement | RComment, hostTNode: TElementNode | TContainerNode | TElementContainerNode, currentView: LViewData, native: RComment, isForViewContainerRef?: boolean): LContainer;\n/**\n * Creates an LContainer for an ng-template (dynamically-inserted view), e.g.\n *\n * <ng-template #foo>\n *    <div></div>\n * </ng-template>\n *\n * @param index The index of the container in the data array\n * @param templateFn Inline template\n * @param consts The number of nodes, local refs, and pipes for this template\n * @param vars The number of bindings for this template\n * @param tagName The name of the container element, if applicable\n * @param attrs The attrs attached to the container, if applicable\n * @param localRefs A set of local reference bindings on the element.\n * @param localRefExtractor A function which extracts local-refs values from the template.\n *        Defaults to the current element associated with the local-ref.\n */\nexport declare function template(index: number, templateFn: ComponentTemplate<any> | null, consts: number, vars: number, tagName?: string | null, attrs?: TAttributes | null, localRefs?: string[] | null, localRefExtractor?: LocalRefExtractor): void;\n/**\n * Creates an LContainer for inline views, e.g.\n *\n * % if (showing) {\n *   <div></div>\n * % }\n *\n * @param index The index of the container in the data array\n */\nexport declare function container(index: number): void;\n/**\n * Sets a container up to receive views.\n *\n * @param index The index of the container in the data array\n */\nexport declare function containerRefreshStart(index: number): void;\n/**\n * Marks the end of the LContainer.\n *\n * Marking the end of LContainer is the time when to child views get inserted or removed.\n */\nexport declare function containerRefreshEnd(): void;\n/**\n * Marks the start of an embedded view.\n *\n * @param viewBlockId The ID of this view\n * @return boolean Whether or not this view is in creation mode\n */\nexport declare function embeddedViewStart(viewBlockId: number, consts: number, vars: number): RenderFlags;\n/** Marks the end of an embedded view. */\nexport declare function embeddedViewEnd(): void;\n/**\n * Refreshes components by entering the component view and processing its bindings, queries, etc.\n *\n * @param adjustedElementIndex  Element index in LViewData[] (adjusted for HEADER_OFFSET)\n */\nexport declare function componentRefresh<T>(adjustedElementIndex: number, parentFirstTemplatePass: boolean, rf: RenderFlags | null): void;\n/** Returns a boolean for whether the view is attached */\nexport declare function viewAttached(view: LViewData): boolean;\n/**\n * Instruction to distribute projectable nodes among <ng-content> occurrences in a given template.\n * It takes all the selectors from the entire component's template and decides where\n * each projected node belongs (it re-distributes nodes among \"buckets\" where each \"bucket\" is\n * backed by a selector).\n *\n * This function requires CSS selectors to be provided in 2 forms: parsed (by a compiler) and text,\n * un-parsed form.\n *\n * The parsed form is needed for efficient matching of a node against a given CSS selector.\n * The un-parsed, textual form is needed for support of the ngProjectAs attribute.\n *\n * Having a CSS selector in 2 different formats is not ideal, but alternatives have even more\n * drawbacks:\n * - having only a textual form would require runtime parsing of CSS selectors;\n * - we can't have only a parsed as we can't re-construct textual form from it (as entered by a\n * template author).\n *\n * @param selectors A collection of parsed CSS selectors\n * @param rawSelectors A collection of CSS selectors in the raw, un-parsed form\n */\nexport declare function projectionDef(selectors?: CssSelectorList[], textSelectors?: string[]): void;\n/**\n * Inserts previously re-distributed projected nodes. This instruction must be preceded by a call\n * to the projectionDef instruction.\n *\n * @param nodeIndex\n * @param selectorIndex:\n *        - 0 when the selector is `*` (or unspecified as this is the default value),\n *        - 1 based index of the selector from the {@link projectionDef}\n */\nexport declare function projection(nodeIndex: number, selectorIndex?: number, attrs?: string[]): void;\n/**\n * Adds LViewData or LContainer to the end of the current view tree.\n *\n * This structure will be used to traverse through nested views to remove listeners\n * and call onDestroy callbacks.\n *\n * @param currentView The view where LViewData or LContainer should be added\n * @param adjustedHostIndex Index of the view's host node in LViewData[], adjusted for header\n * @param state The LViewData or LContainer to add to the view tree\n * @returns The state passed in\n */\nexport declare function addToViewTree<T extends LViewData | LContainer>(currentView: LViewData, adjustedHostIndex: number, state: T): T;\n/** Marks current view and all ancestors dirty */\nexport declare function markViewDirty(view: LViewData): void;\n/**\n * Used to schedule change detection on the whole application.\n *\n * Unlike `tick`, `scheduleTick` coalesces multiple calls into one change detection run.\n * It is usually called indirectly by calling `markDirty` when the view needs to be\n * re-rendered.\n *\n * Typically `scheduleTick` uses `requestAnimationFrame` to coalesce multiple\n * `scheduleTick` requests. The scheduling function can be overridden in\n * `renderComponent`'s `scheduler` option.\n */\nexport declare function scheduleTick<T>(rootContext: RootContext, flags: RootContextFlags): void;\n/**\n * Used to perform change detection on the whole application.\n *\n * This is equivalent to `detectChanges`, but invoked on root component. Additionally, `tick`\n * executes lifecycle hooks and conditionally checks components based on their\n * `ChangeDetectionStrategy` and dirtiness.\n *\n * The preferred way to trigger change detection is to call `markDirty`. `markDirty` internally\n * schedules `tick` using a scheduler in order to coalesce multiple `markDirty` calls into a\n * single change detection run. By default, the scheduler is `requestAnimationFrame`, but can\n * be changed when calling `renderComponent` and providing the `scheduler` option.\n */\nexport declare function tick<T>(component: T): void;\n/**\n * Synchronously perform change detection on a component (and possibly its sub-components).\n *\n * This function triggers change detection in a synchronous way on a component. There should\n * be very little reason to call this function directly since a preferred way to do change\n * detection is to {@link markDirty} the component and wait for the scheduler to call this method\n * at some future point in time. This is because a single user action often results in many\n * components being invalidated and calling change detection on each component synchronously\n * would be inefficient. It is better to wait until all components are marked as dirty and\n * then perform single change detection across all of the components\n *\n * @param component The component which the change detection should be performed on.\n */\nexport declare function detectChanges<T>(component: T): void;\n/**\n * Synchronously perform change detection on a root view and its components.\n *\n * @param lViewData The view which the change detection should be performed on.\n */\nexport declare function detectChangesInRootView(lViewData: LViewData): void;\n/**\n * Checks the change detector and its children, and throws if any changes are detected.\n *\n * This is used in development mode to verify that running change detection doesn't\n * introduce other changes.\n */\nexport declare function checkNoChanges<T>(component: T): void;\n/**\n * Checks the change detector on a root view and its components, and throws if any changes are\n * detected.\n *\n * This is used in development mode to verify that running change detection doesn't\n * introduce other changes.\n *\n * @param lViewData The view which the change detection should be checked on.\n */\nexport declare function checkNoChangesInRootView(lViewData: LViewData): void;\n/**\n * Mark the component as dirty (needing change detection).\n *\n * Marking a component dirty will schedule a change detection on this\n * component at some point in the future. Marking an already dirty\n * component as dirty is a noop. Only one outstanding change detection\n * can be scheduled per component tree. (Two components bootstrapped with\n * separate `renderComponent` will have separate schedulers)\n *\n * When the root component is bootstrapped with `renderComponent`, a scheduler\n * can be provided.\n *\n * @param component Component to mark as dirty.\n *\n * @publicApi\n */\nexport declare function markDirty<T>(component: T): void;\n/**\n * Creates a single value binding.\n *\n * @param value Value to diff\n */\nexport declare function bind<T>(value: T): T | NO_CHANGE;\n/**\n * Create interpolation bindings with a variable number of expressions.\n *\n * If there are 1 to 8 expressions `interpolation1()` to `interpolation8()` should be used instead.\n * Those are faster because there is no need to create an array of expressions and iterate over it.\n *\n * `values`:\n * - has static text at even indexes,\n * - has evaluated expressions at odd indexes.\n *\n * Returns the concatenated string when any of the arguments changes, `NO_CHANGE` otherwise.\n */\nexport declare function interpolationV(values: any[]): string | NO_CHANGE;\n/**\n * Creates an interpolation binding with 1 expression.\n *\n * @param prefix static value used for concatenation only.\n * @param v0 value checked for change.\n * @param suffix static value used for concatenation only.\n */\nexport declare function interpolation1(prefix: string, v0: any, suffix: string): string | NO_CHANGE;\n/** Creates an interpolation binding with 2 expressions. */\nexport declare function interpolation2(prefix: string, v0: any, i0: string, v1: any, suffix: string): string | NO_CHANGE;\n/** Creates an interpolation binding with 3 expressions. */\nexport declare function interpolation3(prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, suffix: string): string | NO_CHANGE;\n/** Create an interpolation binding with 4 expressions. */\nexport declare function interpolation4(prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string, v3: any, suffix: string): string | NO_CHANGE;\n/** Creates an interpolation binding with 5 expressions. */\nexport declare function interpolation5(prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string, v3: any, i3: string, v4: any, suffix: string): string | NO_CHANGE;\n/** Creates an interpolation binding with 6 expressions. */\nexport declare function interpolation6(prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string, v3: any, i3: string, v4: any, i4: string, v5: any, suffix: string): string | NO_CHANGE;\n/** Creates an interpolation binding with 7 expressions. */\nexport declare function interpolation7(prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string, v3: any, i3: string, v4: any, i4: string, v5: any, i5: string, v6: any, suffix: string): string | NO_CHANGE;\n/** Creates an interpolation binding with 8 expressions. */\nexport declare function interpolation8(prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string, v3: any, i3: string, v4: any, i4: string, v5: any, i5: string, v6: any, i6: string, v7: any, suffix: string): string | NO_CHANGE;\n/** Store a value in the `data` at a given `index`. */\nexport declare function store<T>(index: number, value: T): void;\n/**\n * Retrieves a local reference from the current contextViewData.\n *\n * If the reference to retrieve is in a parent view, this instruction is used in conjunction\n * with a nextContext() call, which walks up the tree and updates the contextViewData instance.\n *\n * @param index The index of the local ref in contextViewData.\n */\nexport declare function reference<T>(index: number): T;\nexport declare function loadQueryList<T>(queryListIdx: number): QueryList<T>;\n/** Retrieves a value from current `viewData`. */\nexport declare function load<T>(index: number): T;\n/** Gets the current binding value. */\nexport declare function getBinding(bindingIndex: number): any;\n/** Updates binding if changed, then returns whether it was updated. */\nexport declare function bindingUpdated(bindingIndex: number, value: any): boolean;\n/** Updates binding and returns the value. */\nexport declare function updateBinding(bindingIndex: number, value: any): any;\n/** Updates 2 bindings if changed, then returns whether either was updated. */\nexport declare function bindingUpdated2(bindingIndex: number, exp1: any, exp2: any): boolean;\n/** Updates 3 bindings if changed, then returns whether any was updated. */\nexport declare function bindingUpdated3(bindingIndex: number, exp1: any, exp2: any, exp3: any): boolean;\n/** Updates 4 bindings if changed, then returns whether any was updated. */\nexport declare function bindingUpdated4(bindingIndex: number, exp1: any, exp2: any, exp3: any, exp4: any): boolean;\n/**\n * Returns the value associated to the given token from the injectors.\n *\n * `directiveInject` is intended to be used for directive, component and pipe factories.\n *  All other injection use `inject` which does not walk the node injector tree.\n *\n * Usage example (in factory function):\n *\n * class SomeDirective {\n *   constructor(directive: DirectiveA) {}\n *\n *   static ngDirectiveDef = defineDirective({\n *     type: SomeDirective,\n *     factory: () => new SomeDirective(directiveInject(DirectiveA))\n *   });\n * }\n *\n * @param token the type or token to inject\n * @param flags Injection flags\n * @returns the value from the injector or `null` when not found\n */\nexport declare function directiveInject<T>(token: Type<T> | InjectionToken<T>): T;\nexport declare function directiveInject<T>(token: Type<T> | InjectionToken<T>, flags: InjectFlags): T;\n/**\n * Facade for the attribute injection from DI.\n */\nexport declare function injectAttribute(attrNameToInject: string): string | undefined;\n/**\n * Registers a QueryList, associated with a content query, for later refresh (part of a view\n * refresh).\n */\nexport declare function registerContentQuery<Q>(queryList: QueryList<Q>, currentDirectiveIndex: number): void;\nexport declare const CLEAN_PROMISE: Promise<null>;\nexport declare function delegateToClassInput(tNode: TNode): number;\n"
  },
  {
    "path": "node_modules/@angular/core/src/render3/interfaces/container.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { LQueries } from './query';\nimport { RComment, RElement } from './renderer';\nimport { StylingContext } from './styling';\nimport { HOST, LViewData, NEXT, PARENT, QUERIES } from './view';\n/**\n * Below are constants for LContainer indices to help us look up LContainer members\n * without having to remember the specific indices.\n * Uglify will inline these when minifying so there shouldn't be a cost.\n */\nexport declare const ACTIVE_INDEX = 0;\nexport declare const VIEWS = 1;\nexport declare const NATIVE = 6;\nexport declare const RENDER_PARENT = 7;\n/**\n * The state associated with a container.\n *\n * This is an array so that its structure is closer to LViewData. This helps\n * when traversing the view tree (which is a mix of containers and component\n * views), so we can jump to viewOrContainer[NEXT] in the same way regardless\n * of type.\n */\nexport interface LContainer extends Array<any> {\n    /**\n     * The next active index in the views array to read or write to. This helps us\n     * keep track of where we are in the views array.\n     * In the case the LContainer is created for a ViewContainerRef,\n     * it is set to null to identify this scenario, as indices are \"absolute\" in that case,\n     * i.e. provided directly by the user of the ViewContainerRef API.\n     */\n    [ACTIVE_INDEX]: number;\n    /**\n     * A list of the container's currently active child views. Views will be inserted\n     * here as they are added and spliced from here when they are removed. We need\n     * to keep a record of current views so we know which views are already in the DOM\n     * (and don't need to be re-added) and so we can remove views from the DOM when they\n     * are no longer required.\n     */\n    [VIEWS]: LViewData[];\n    /**\n     * Access to the parent view is necessary so we can propagate back\n     * up from inside a container to parent[NEXT].\n     */\n    [PARENT]: LViewData | null;\n    /**\n     * This allows us to jump from a container to a sibling container or component\n     * view with the same parent, so we can remove listeners efficiently.\n     */\n    [NEXT]: LViewData | LContainer | null;\n    /**\n     * Queries active for this container - all the views inserted to / removed from\n     * this container are reported to queries referenced here.\n     */\n    [QUERIES]: LQueries | null;\n    /**\n     * The host element of this LContainer.\n     *\n     * The host could be an LViewData if this container is on a component node.\n     * In that case, the component LViewData is its HOST.\n     *\n     * It could also be a styling context if this is a node with a style/class\n     * binding.\n     */\n    [HOST]: RElement | RComment | StylingContext | LViewData;\n    /** The comment element that serves as an anchor for this LContainer. */\n    [NATIVE]: RComment;\n    /**\n     * Parent Element which will contain the location where all of the views will be\n     * inserted into to.\n     *\n     * If `renderParent` is `null` it is headless. This means that it is contained\n     * in another view which in turn is contained in another container and\n     * therefore it does not yet have its own parent.\n     *\n     * If `renderParent` is not `null` then it may be:\n     * - same as `tContainerNode.parent` in which case it is just a normal container.\n     * - different from `tContainerNode.parent` in which case it has been re-projected.\n     *   In other words `tContainerNode.parent` is logical parent where as\n     *   `tContainerNode.projectedParent` is render parent.\n     *\n     * When views are inserted into `LContainer` then `renderParent` is:\n     * - `null`, we are in a view, keep going up a hierarchy until actual\n     *   `renderParent` is found.\n     * - not `null`, then use the `projectedParent.native` as the `RElement` to insert\n     * views into.\n     */\n    [RENDER_PARENT]: RElement | null;\n}\nexport declare const unusedValueExportToPlacateAjd = 1;\n"
  },
  {
    "path": "node_modules/@angular/core/src/render3/interfaces/context.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { RElement } from './renderer';\nimport { LViewData } from './view';\n/**\n * This property will be monkey-patched on elements, components and directives\n */\nexport declare const MONKEY_PATCH_KEY_NAME = \"__ngContext__\";\n/**\n * The internal view context which is specific to a given DOM element, directive or\n * component instance. Each value in here (besides the LViewData and element node details)\n * can be present, null or undefined. If undefined then it implies the value has not been\n * looked up yet, otherwise, if null, then a lookup was executed and nothing was found.\n *\n * Each value will get filled when the respective value is examined within the getContext\n * function. The component, element and each directive instance will share the same instance\n * of the context.\n */\nexport interface LContext {\n    /**\n     * The component's parent view data.\n     */\n    lViewData: LViewData;\n    /**\n     * The index instance of the node.\n     */\n    nodeIndex: number;\n    /**\n     * The instance of the DOM node that is attached to the lNode.\n     */\n    native: RElement;\n    /**\n     * The instance of the Component node.\n     */\n    component: {} | null | undefined;\n    /**\n     * The list of active directives that exist on this element.\n     */\n    directives: any[] | null | undefined;\n    /**\n     * The map of local references (local reference name => element or directive instance) that exist\n     * on this element.\n     */\n    localRefs: {\n        [key: string]: any;\n    } | null | undefined;\n}\n"
  },
  {
    "path": "node_modules/@angular/core/src/render3/interfaces/definition.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { ViewEncapsulation } from '../../core';\nimport { Type } from '../../type';\nimport { CssSelectorList } from './projection';\n/**\n * Definition of what a template rendering function should look like for a component.\n */\nexport declare type ComponentTemplate<T> = {\n    (rf: RenderFlags, ctx: T): void;\n    ngPrivateData?: never;\n};\n/**\n * Definition of what a query function should look like.\n */\nexport declare type ComponentQuery<T> = ComponentTemplate<T>;\n/**\n * Flags passed into template functions to determine which blocks (i.e. creation, update)\n * should be executed.\n *\n * Typically, a template runs both the creation block and the update block on initialization and\n * subsequent runs only execute the update block. However, dynamically created views require that\n * the creation block be executed separately from the update block (for backwards compat).\n */\nexport declare const enum RenderFlags {\n    Create = 1,\n    Update = 2\n}\n/**\n * A subclass of `Type` which has a static `ngComponentDef`:`ComponentDef` field making it\n * consumable for rendering.\n */\nexport interface ComponentType<T> extends Type<T> {\n    ngComponentDef: never;\n}\n/**\n * A subclass of `Type` which has a static `ngDirectiveDef`:`DirectiveDef` field making it\n * consumable for rendering.\n */\nexport interface DirectiveType<T> extends Type<T> {\n    ngDirectiveDef: never;\n}\nexport declare const enum DirectiveDefFlags {\n    ContentQuery = 2\n}\n/**\n * A subclass of `Type` which has a static `ngPipeDef`:`PipeDef` field making it\n * consumable for rendering.\n */\nexport interface PipeType<T> extends Type<T> {\n    ngPipeDef: never;\n}\nexport declare type DirectiveDefWithMeta<T, Selector extends string, ExportAs extends string, InputMap extends {\n    [key: string]: string;\n}, OutputMap extends {\n    [key: string]: string;\n}, QueryFields extends string[]> = DirectiveDef<T>;\n/**\n * Runtime information for classes that are inherited by components or directives\n * that aren't defined as components or directives.\n *\n * This is an internal data structure used by the render to determine what inputs\n * and outputs should be inherited.\n *\n * See: {@link defineBase}\n */\nexport interface BaseDef<T> {\n    /**\n     * A dictionary mapping the inputs' minified property names to their public API names, which\n     * are their aliases if any, or their original unminified property names\n     * (as in `@Input('alias') propertyName: any;`).\n     */\n    readonly inputs: {\n        [P in keyof T]: string;\n    };\n    /**\n     * @deprecated This is only here because `NgOnChanges` incorrectly uses declared name instead of\n     * public or minified name.\n     */\n    readonly declaredInputs: {\n        [P in keyof T]: P;\n    };\n    /**\n     * A dictionary mapping the outputs' minified property names to their public API names, which\n     * are their aliases if any, or their original unminified property names\n     * (as in `@Output('alias') propertyName: any;`).\n     */\n    readonly outputs: {\n        [P in keyof T]: P;\n    };\n}\n/**\n * Runtime link information for Directives.\n *\n * This is internal data structure used by the render to link\n * directives into templates.\n *\n * NOTE: Always use `defineDirective` function to create this object,\n * never create the object directly since the shape of this object\n * can change between versions.\n *\n * @param Selector type metadata specifying the selector of the directive or component\n *\n * See: {@link defineDirective}\n */\nexport interface DirectiveDef<T> extends BaseDef<T> {\n    /** Token representing the directive. Used by DI. */\n    type: Type<T>;\n    /** Function that resolves providers and publishes them into the DI system. */\n    providersResolver: ((def: DirectiveDef<T>) => void) | null;\n    /** The selectors that will be used to match nodes to this directive. */\n    readonly selectors: CssSelectorList;\n    /**\n     * Name under which the directive is exported (for use with local references in template)\n     */\n    readonly exportAs: string | null;\n    /**\n     * Factory function used to create a new directive instance.\n     */\n    factory: (t: Type<T> | null) => T;\n    /**\n     * Function to create instances of content queries associated with a given directive.\n     */\n    contentQueries: ((directiveIndex: number) => void) | null;\n    /** Refreshes content queries associated with directives in a given view */\n    contentQueriesRefresh: ((directiveIndex: number, queryIndex: number) => void) | null;\n    /**\n     * The number of host bindings (including pure fn bindings) in this directive/component.\n     *\n     * Used to calculate the length of the LViewData array for the *parent* component\n     * of this directive/component.\n     */\n    readonly hostVars: number;\n    /** Refreshes host bindings on the associated directive. */\n    hostBindings: HostBindingsFunction | null;\n    /**\n     * Static attributes to set on host element.\n     *\n     * Even indices: attribute name\n     * Odd indices: attribute value\n     */\n    readonly attributes: string[] | null;\n    onInit: (() => void) | null;\n    doCheck: (() => void) | null;\n    afterContentInit: (() => void) | null;\n    afterContentChecked: (() => void) | null;\n    afterViewInit: (() => void) | null;\n    afterViewChecked: (() => void) | null;\n    onDestroy: (() => void) | null;\n    /**\n     * The features applied to this directive\n     */\n    readonly features: DirectiveDefFeature[] | null;\n}\nexport declare type ComponentDefWithMeta<T, Selector extends String, ExportAs extends string, InputMap extends {\n    [key: string]: string;\n}, OutputMap extends {\n    [key: string]: string;\n}, QueryFields extends string[]> = ComponentDef<T>;\n/**\n * Runtime link information for Components.\n *\n * This is internal data structure used by the render to link\n * components into templates.\n *\n * NOTE: Always use `defineComponent` function to create this object,\n * never create the object directly since the shape of this object\n * can change between versions.\n *\n * See: {@link defineComponent}\n */\nexport interface ComponentDef<T> extends DirectiveDef<T> {\n    /**\n     * Runtime unique component ID.\n     */\n    readonly id: string;\n    /**\n     * The View template of the component.\n     */\n    readonly template: ComponentTemplate<T>;\n    /**\n     * A set of styles that the component needs to be present for component to render correctly.\n     */\n    readonly styles: string[];\n    /**\n     * The number of nodes, local refs, and pipes in this component template.\n     *\n     * Used to calculate the length of the component's LViewData array, so we\n     * can pre-fill the array and set the binding start index.\n     */\n    readonly consts: number;\n    /**\n     * The number of bindings in this component template (including pure fn bindings).\n     *\n     * Used to calculate the length of the component's LViewData array, so we\n     * can pre-fill the array and set the host binding start index.\n     */\n    readonly vars: number;\n    /**\n     * Query-related instructions for a component.\n     */\n    viewQuery: ComponentQuery<T> | null;\n    /**\n     * The view encapsulation type, which determines how styles are applied to\n     * DOM elements. One of\n     * - `Emulated` (default): Emulate native scoping of styles.\n     * - `Native`: Use the native encapsulation mechanism of the renderer.\n     * - `ShadowDom`: Use modern [ShadowDOM](https://w3c.github.io/webcomponents/spec/shadow/) and\n     *   create a ShadowRoot for component's host element.\n     * - `None`: Do not provide any template or style encapsulation.\n     */\n    readonly encapsulation: ViewEncapsulation;\n    /**\n     * Defines arbitrary developer-defined data to be stored on a renderer instance.\n     * This is useful for renderers that delegate to other renderers.\n     */\n    readonly data: {\n        [kind: string]: any;\n    };\n    /** Whether or not this component's ChangeDetectionStrategy is OnPush */\n    readonly onPush: boolean;\n    /**\n  \n     * Registry of directives and components that may be found in this view.\n     *\n     * The property is either an array of `DirectiveDef`s or a function which returns the array of\n     * `DirectiveDef`s. The function is necessary to be able to support forward declarations.\n     */\n    directiveDefs: DirectiveDefListOrFactory | null;\n    /**\n     * Registry of pipes that may be found in this view.\n     *\n     * The property is either an array of `PipeDefs`s or a function which returns the array of\n     * `PipeDefs`s. The function is necessary to be able to support forward declarations.\n     */\n    pipeDefs: PipeDefListOrFactory | null;\n    /**\n     * Used to store the result of `noSideEffects` function so that it is not removed by closure\n     * compiler. The property should never be read.\n     */\n    readonly _?: never;\n}\n/**\n * Runtime link information for Pipes.\n *\n * This is internal data structure used by the renderer to link\n * pipes into templates.\n *\n * NOTE: Always use `definePipe` function to create this object,\n * never create the object directly since the shape of this object\n * can change between versions.\n *\n * See: {@link definePipe}\n */\nexport interface PipeDef<T> {\n    /**\n     * Pipe name.\n     *\n     * Used to resolve pipe in templates.\n     */\n    readonly name: string;\n    /**\n     * Factory function used to create a new pipe instance.\n     */\n    factory: (t: Type<T> | null) => T;\n    /**\n     * Whether or not the pipe is pure.\n     *\n     * Pure pipes result only depends on the pipe input and not on internal\n     * state of the pipe.\n     */\n    readonly pure: boolean;\n    onDestroy: (() => void) | null;\n}\nexport declare type PipeDefWithMeta<T, Name extends string> = PipeDef<T>;\nexport interface DirectiveDefFeature {\n    <T>(directiveDef: DirectiveDef<T>): void;\n    ngInherit?: true;\n}\nexport interface ComponentDefFeature {\n    <T>(componentDef: ComponentDef<T>): void;\n    ngInherit?: true;\n}\n/**\n * Type used for directiveDefs on component definition.\n *\n * The function is necessary to be able to support forward declarations.\n */\nexport declare type DirectiveDefListOrFactory = (() => DirectiveDefList) | DirectiveDefList;\nexport declare type DirectiveDefList = (DirectiveDef<any> | ComponentDef<any>)[];\nexport declare type DirectiveTypesOrFactory = (() => DirectiveTypeList) | DirectiveTypeList;\nexport declare type DirectiveTypeList = (DirectiveDef<any> | ComponentDef<any> | Type<any>)[];\nexport declare type HostBindingsFunction = (directiveIndex: number, elementIndex: number) => void;\n/**\n * Type used for PipeDefs on component definition.\n *\n * The function is necessary to be able to support forward declarations.\n */\nexport declare type PipeDefListOrFactory = (() => PipeDefList) | PipeDefList;\nexport declare type PipeDefList = PipeDef<any>[];\nexport declare type PipeTypesOrFactory = (() => DirectiveTypeList) | DirectiveTypeList;\nexport declare type PipeTypeList = (PipeDef<any> | Type<any>)[];\nexport declare const unusedValueExportToPlacateAjd = 1;\nexport declare const enum InitialStylingFlags {\n    VALUES_MODE = 1\n}\n"
  },
  {
    "path": "node_modules/@angular/core/src/render3/interfaces/i18n.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * `I18nMutateOpCode` defines OpCodes for `I18nMutateOpCodes` array.\n *\n * OpCodes contain three parts:\n *  1) Parent node index offset.\n *  2) Reference node index offset.\n *  3) The OpCode to execute.\n *\n * See: `I18nCreateOpCodes` for example of usage.\n */\nimport { SanitizerFn } from './sanitization';\nexport declare const enum I18nMutateOpCode {\n    SHIFT_REF = 3,\n    SHIFT_PARENT = 17,\n    MASK_OPCODE = 7,\n    MASK_REF = 136,\n    Select = 0,\n    AppendChild = 1,\n    InsertBefore = 2,\n    Remove = 3,\n    Attr = 4,\n    ElementEnd = 5,\n    RemoveNestedIcu = 6\n}\n/**\n * Marks that the next string is for element.\n *\n * See `I18nMutateOpCodes` documentation.\n */\nexport declare const ELEMENT_MARKER: ELEMENT_MARKER;\nexport interface ELEMENT_MARKER {\n    marker: 'element';\n}\n/**\n * Marks that the next string is for comment.\n *\n * See `I18nMutateOpCodes` documentation.\n */\nexport declare const COMMENT_MARKER: COMMENT_MARKER;\nexport interface COMMENT_MARKER {\n    marker: 'comment';\n}\n/**\n * Array storing OpCode for dynamically creating `i18n` blocks.\n *\n * Example:\n * ```\n * <I18nCreateOpCode>[\n *   // For adding text nodes\n *   // ---------------------\n *   // Equivalent to:\n *   //   const node = lViewData[index++] = document.createTextNode('abc');\n *   //   lViewData[1].insertBefore(node, lViewData[2]);\n *   'abc', 1 << SHIFT_PARENT | 2 << SHIFT_REF | InsertBefore,\n *\n *   // Equivalent to:\n *   //   const node = lViewData[index++] = document.createTextNode('xyz');\n *   //   lViewData[1].appendChild(node);\n *   'xyz', 1 << SHIFT_PARENT | AppendChild,\n *\n *   // For adding element nodes\n *   // ---------------------\n *   // Equivalent to:\n *   //   const node = lViewData[index++] = document.createElement('div');\n *   //   lViewData[1].insertBefore(node, lViewData[2]);\n *   ELEMENT_MARKER, 'div', 1 << SHIFT_PARENT | 2 << SHIFT_REF | InsertBefore,\n *\n *   // Equivalent to:\n *   //   const node = lViewData[index++] = document.createElement('div');\n *   //   lViewData[1].appendChild(node);\n *   ELEMENT_MARKER, 'div', 1 << SHIFT_PARENT | AppendChild,\n *\n *   // For adding comment nodes\n *   // ---------------------\n *   // Equivalent to:\n *   //   const node = lViewData[index++] = document.createComment('');\n *   //   lViewData[1].insertBefore(node, lViewData[2]);\n *   COMMENT_MARKER, '', 1 << SHIFT_PARENT | 2 << SHIFT_REF | InsertBefore,\n *\n *   // Equivalent to:\n *   //   const node = lViewData[index++] = document.createComment('');\n *   //   lViewData[1].appendChild(node);\n *   COMMENT_MARKER, '', 1 << SHIFT_PARENT | AppendChild,\n *\n *   // For moving existing nodes to a different location\n *   // --------------------------------------------------\n *   // Equivalent to:\n *   //   const node = lViewData[1];\n *   //   lViewData[2].insertBefore(node, lViewData[3]);\n *   1 << SHIFT_REF | Select, 2 << SHIFT_PARENT | 3 << SHIFT_REF | InsertBefore,\n *\n *   // Equivalent to:\n *   //   const node = lViewData[1];\n *   //   lViewData[2].appendChild(node);\n *   1 << SHIFT_REF | Select, 2 << SHIFT_PARENT | AppendChild,\n *\n *   // For removing existing nodes\n *   // --------------------------------------------------\n *   //   const node = lViewData[1];\n *   //   removeChild(tView.data(1), node, lViewData);\n *   1 << SHIFT_REF | Remove,\n *\n *   // For writing attributes\n *   // --------------------------------------------------\n *   //   const node = lViewData[1];\n *   //   node.setAttribute('attr', 'value');\n *   1 << SHIFT_REF | Select, 'attr', 'value'\n *            // NOTE: Select followed by two string (vs select followed by OpCode)\n * ];\n * ```\n * NOTE:\n *   - `index` is initial location where the extra nodes should be stored in the EXPANDO section of\n * `LVIewData`.\n *\n * See: `applyI18nCreateOpCodes`;\n */\nexport interface I18nMutateOpCodes extends Array<number | string | ELEMENT_MARKER | COMMENT_MARKER | null> {\n}\nexport declare const enum I18nUpdateOpCode {\n    SHIFT_REF = 2,\n    SHIFT_ICU = 17,\n    MASK_OPCODE = 3,\n    MASK_REF = 68,\n    Text = 0,\n    Attr = 1,\n    IcuSwitch = 2,\n    IcuUpdate = 3\n}\n/**\n * Stores DOM operations which need to be applied to update DOM render tree due to changes in\n * expressions.\n *\n * The basic idea is that `i18nExp` OpCodes capture expression changes and update a change\n * mask bit. (Bit 1 for expression 1, bit 2 for expression 2 etc..., bit 32 for expression 32 and\n * higher.) The OpCodes then compare its own change mask against the expression change mask to\n * determine if the OpCodes should execute.\n *\n * These OpCodes can be used by both the i18n block as well as ICU sub-block.\n *\n * ## Example\n *\n * Assume\n * ```\n *   if (rf & RenderFlags.Update) {\n *    i18nExp(bind(ctx.exp1)); // If changed set mask bit 1\n *    i18nExp(bind(ctx.exp2)); // If changed set mask bit 2\n *    i18nExp(bind(ctx.exp3)); // If changed set mask bit 3\n *    i18nExp(bind(ctx.exp4)); // If changed set mask bit 4\n *    i18nApply(0);            // Apply all changes by executing the OpCodes.\n *  }\n * ```\n * We can assume that each call to `i18nExp` sets an internal `changeMask` bit depending on the\n * index of `i18nExp`.\n *\n * OpCodes\n * ```\n * <I18nUpdateOpCodes>[\n *   // The following OpCodes represent: `<div i18n-title=\"pre{{exp1}}in{{exp2}}post\">`\n *   // If `changeMask & 0b11`\n *   //        has changed then execute update OpCodes.\n *   //        has NOT changed then skip `7` values and start processing next OpCodes.\n *   0b11, 7,\n *   // Concatenate `newValue = 'pre'+lViewData[bindIndex-4]+'in'+lViewData[bindIndex-3]+'post';`.\n *   'pre', -4, 'in', -3, 'post',\n *   // Update attribute: `elementAttribute(1, 'title', sanitizerFn(newValue));`\n *   1 << SHIFT_REF | Attr, 'title', sanitizerFn,\n *\n *   // The following OpCodes represent: `<div i18n>Hello {{exp3}}!\">`\n *   // If `changeMask & 0b100`\n *   //        has changed then execute update OpCodes.\n *   //        has NOT changed then skip `4` values and start processing next OpCodes.\n *   0b100, 4,\n *   // Concatenate `newValue = 'Hello ' + lViewData[bindIndex -2] + '!';`.\n *   'Hello ', -2, '!',\n *   // Update text: `lViewData[1].textContent = newValue;`\n *   1 << SHIFT_REF | Text,\n *\n *   // The following OpCodes represent: `<div i18n>{exp4, plural, ... }\">`\n *   // If `changeMask & 0b1000`\n *   //        has changed then execute update OpCodes.\n *   //        has NOT changed then skip `4` values and start processing next OpCodes.\n *   0b1000, 4,\n *   // Concatenate `newValue = lViewData[bindIndex -1];`.\n *   -1,\n *   // Switch ICU: `icuSwitchCase(lViewData[1], 0, newValue);`\n *   0 << SHIFT_ICU | 1 << SHIFT_REF | IcuSwitch,\n *\n *   // Note `changeMask & -1` is always true, so the IcuUpdate will always execute.\n *   -1, 1,\n *   // Update ICU: `icuUpdateCase(lViewData[1], 0);`\n *   0 << SHIFT_ICU | 1 << SHIFT_REF | IcuUpdate,\n *\n * ];\n * ```\n *\n */\nexport interface I18nUpdateOpCodes extends Array<string | number | SanitizerFn | null> {\n}\n/**\n * Store information for the i18n translation block.\n */\nexport interface TI18n {\n    /**\n     * Number of slots to allocate in expando.\n     *\n     * This is the max number of DOM elements which will be created by this i18n + ICU blocks. When\n     * the DOM elements are being created they are stored in the EXPANDO, so that update OpCodes can\n     * write into them.\n     */\n    vars: number;\n    /**\n     * Index in EXPANDO where the i18n stores its DOM nodes.\n     *\n     * When the bindings are processed by the `i18nEnd` instruction it is necessary to know where the\n     * newly created DOM nodes will be inserted.\n     */\n    expandoStartIndex: number;\n    /**\n     * A set of OpCodes which will create the Text Nodes and ICU anchors for the translation blocks.\n     *\n     * NOTE: The ICU anchors are filled in with ICU Update OpCode.\n     */\n    create: I18nMutateOpCodes;\n    /**\n     * A set of OpCodes which will be executed on each change detection to determine if any changes to\n     * DOM are required.\n     */\n    update: I18nUpdateOpCodes;\n    /**\n     * A list of ICUs in a translation block (or `null` if block has no ICUs).\n     *\n     * Example:\n     * Given: `<div i18n>You have {count, plural, ...} and {state, switch, ...}</div>`\n     * There would be 2 ICUs in this array.\n     *   1. `{count, plural, ...}`\n     *   2. `{state, switch, ...}`\n     */\n    icus: TIcu[] | null;\n}\n/**\n * Defines the ICU type of `select` or `plural`\n */\nexport declare const enum IcuType {\n    select = 0,\n    plural = 1\n}\nexport interface TIcu {\n    /**\n     * Defines the ICU type of `select` or `plural`\n     */\n    type: IcuType;\n    /**\n     * Number of slots to allocate in expando for each case.\n     *\n     * This is the max number of DOM elements which will be created by this i18n + ICU blocks. When\n     * the DOM elements are being created they are stored in the EXPANDO, so that update OpCodes can\n     * write into them.\n     */\n    vars: number[];\n    /**\n     * An optional array of child/sub ICUs.\n     *\n     * In case of nested ICUs such as:\n     * ```\n     * {�0�, plural,\n     *   =0 {zero}\n     *   other {�0� {�1�, select,\n     *                     cat {cats}\n     *                     dog {dogs}\n     *                     other {animals}\n     *                   }!\n     *   }\n     * }\n     * ```\n     * When the parent ICU is changing it must clean up child ICUs as well. For this reason it needs\n     * to know which child ICUs to run clean up for as well.\n     *\n     * In the above example this would be:\n     * ```\n     * [\n     *   [],   // `=0` has no sub ICUs\n     *   [1],  // `other` has one subICU at `1`st index.\n     * ]\n     * ```\n     *\n     * The reason why it is Array of Arrays is because first array represents the case, and second\n     * represents the child ICUs to clean up. There may be more than one child ICUs per case.\n     */\n    childIcus: number[][];\n    /**\n     * Index in EXPANDO where the i18n stores its DOM nodes.\n     *\n     * When the bindings are processed by the `i18nEnd` instruction it is necessary to know where the\n     * newly created DOM nodes will be inserted.\n     */\n    expandoStartIndex: number;\n    /**\n     * A list of case values which the current ICU will try to match.\n     *\n     * The last value is `other`\n     */\n    cases: any[];\n    /**\n     * A set of OpCodes to apply in order to build up the DOM render tree for the ICU\n     */\n    create: I18nMutateOpCodes[];\n    /**\n     * A set of OpCodes to apply in order to destroy the DOM render tree for the ICU.\n     */\n    remove: I18nMutateOpCodes[];\n    /**\n     * A set of OpCodes to apply in order to update the DOM render tree for the ICU bindings.\n     */\n    update: I18nUpdateOpCodes[];\n}\nexport declare const unusedValueExportToPlacateAjd = 1;\n"
  },
  {
    "path": "node_modules/@angular/core/src/render3/interfaces/injector.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { InjectionToken } from '../../di/injection_token';\nimport { InjectFlags } from '../../di/injector_compatibility';\nimport { Type } from '../../type';\nimport { TElementNode } from './node';\nimport { LViewData, TData } from './view';\nexport declare const TNODE = 8;\nexport declare const PARENT_INJECTOR = 8;\nexport declare const INJECTOR_SIZE = 9;\n/**\n * Represents a relative location of parent injector.\n *\n * The interfaces encodes number of parents `LViewData`s to traverse and index in the `LViewData`\n * pointing to the parent injector.\n */\nexport interface RelativeInjectorLocation {\n    __brand__: 'RelativeInjectorLocationFlags';\n}\nexport declare const enum RelativeInjectorLocationFlags {\n    InjectorIndexMask = 32767,\n    AcrossHostBoundary = 32768,\n    ViewOffsetShift = 16,\n    NO_PARENT = -1\n}\nexport declare const NO_PARENT_INJECTOR: RelativeInjectorLocation;\n/**\n * Each injector is saved in 9 contiguous slots in `LViewData` and 9 contiguous slots in\n * `TView.data`. This allows us to store information about the current node's tokens (which\n * can be shared in `TView`) as well as the tokens of its ancestor nodes (which cannot be\n * shared, so they live in `LViewData`).\n *\n * Each of these slots (aside from the last slot) contains a bloom filter. This bloom filter\n * determines whether a directive is available on the associated node or not. This prevents us\n * from searching the directives array at this level unless it's probable the directive is in it.\n *\n * See: https://en.wikipedia.org/wiki/Bloom_filter for more about bloom filters.\n *\n * Because all injectors have been flattened into `LViewData` and `TViewData`, they cannot typed\n * using interfaces as they were previously. The start index of each `LInjector` and `TInjector`\n * will differ based on where it is flattened into the main array, so it's not possible to know\n * the indices ahead of time and save their types here. The interfaces are still included here\n * for documentation purposes.\n *\n * export interface LInjector extends Array<any> {\n *\n *    // Cumulative bloom for directive IDs 0-31  (IDs are % BLOOM_SIZE)\n *    [0]: number;\n *\n *    // Cumulative bloom for directive IDs 32-63\n *    [1]: number;\n *\n *    // Cumulative bloom for directive IDs 64-95\n *    [2]: number;\n *\n *    // Cumulative bloom for directive IDs 96-127\n *    [3]: number;\n *\n *    // Cumulative bloom for directive IDs 128-159\n *    [4]: number;\n *\n *    // Cumulative bloom for directive IDs 160 - 191\n *    [5]: number;\n *\n *    // Cumulative bloom for directive IDs 192 - 223\n *    [6]: number;\n *\n *    // Cumulative bloom for directive IDs 224 - 255\n *    [7]: number;\n *\n *    // We need to store a reference to the injector's parent so DI can keep looking up\n *    // the injector tree until it finds the dependency it's looking for.\n *    [PARENT_INJECTOR]: number;\n * }\n *\n * export interface TInjector extends Array<any> {\n *\n *    // Shared node bloom for directive IDs 0-31  (IDs are % BLOOM_SIZE)\n *    [0]: number;\n *\n *    // Shared node bloom for directive IDs 32-63\n *    [1]: number;\n *\n *    // Shared node bloom for directive IDs 64-95\n *    [2]: number;\n *\n *    // Shared node bloom for directive IDs 96-127\n *    [3]: number;\n *\n *    // Shared node bloom for directive IDs 128-159\n *    [4]: number;\n *\n *    // Shared node bloom for directive IDs 160 - 191\n *    [5]: number;\n *\n *    // Shared node bloom for directive IDs 192 - 223\n *    [6]: number;\n *\n *    // Shared node bloom for directive IDs 224 - 255\n *    [7]: number;\n *\n *    // Necessary to find directive indices for a particular node.\n *    [TNODE]: TElementNode|TElementContainerNode|TContainerNode;\n *  }\n */\n/**\n* Factory for creating instances of injectors in the NodeInjector.\n*\n* This factory is complicated by the fact that it can resolve `multi` factories as well.\n*\n* NOTE: Some of the fields are optional which means that this class has two hidden classes.\n* - One without `multi` support (most common)\n* - One with `multi` values, (rare).\n*\n* Since VMs can cache up to 4 inline hidden classes this is OK.\n*\n* - Single factory: Only `resolving` and `factory` is defined.\n* - `providers` factory: `componentProviders` is a number and `index = -1`.\n* - `viewProviders` factory: `componentProviders` is a number and `index` points to `providers`.\n*/\nexport declare class NodeInjectorFactory {\n    /**\n     * Factory to invoke in order to create a new instance.\n     */\n    factory: (this: NodeInjectorFactory, _: null, \n    /**\n     * array where injectables tokens are stored. This is used in\n     * case of an error reporting to produce friendlier errors.\n     */\n    tData: TData, \n    /**\n     * array where existing instances of injectables are stored. This is used in case\n     * of multi shadow is needed. See `multi` field documentation.\n     */\n    lData: LViewData, \n    /**\n     * The TNode of the same element injector.\n     */\n    tNode: TElementNode) => any;\n    /**\n     * The inject implementation to be activated when using the factory.\n     */\n    injectImpl: null | (<T>(token: Type<T> | InjectionToken<T>, flags: InjectFlags) => T);\n    /**\n     * Marker set to true during factory invocation to see if we get into recursive loop.\n     * Recursive loop causes an error to be displayed.\n     */\n    resolving: boolean;\n    /**\n     * Marks that the token can see other Tokens declared in `viewProviders` on the same node.\n     */\n    canSeeViewProviders: boolean;\n    /**\n     * An array of factories to use in case of `multi` provider.\n     */\n    multi?: Array<() => any>;\n    /**\n     * Number of `multi`-providers which belong to the component.\n     *\n     * This is needed because when multiple components and directives declare the `multi` provider\n     * they have to be concatenated in the correct order.\n     *\n     * Example:\n     *\n     * If we have a component and directive active an a single element as declared here\n     * ```\n     * component:\n     *   provides: [ {provide: String, useValue: 'component', multi: true} ],\n     *   viewProvides: [ {provide: String, useValue: 'componentView', multi: true} ],\n     *\n     * directive:\n     *   provides: [ {provide: String, useValue: 'directive', multi: true} ],\n     * ```\n     *\n     * Then the expected results are:\n     *\n     * ```\n     * providers: ['component', 'directive']\n     * viewProviders: ['component', 'componentView', 'directive']\n     * ```\n     *\n     * The way to think about it is that the `viewProviders` have been inserted after the component\n     * but before the directives, which is why we need to know how many `multi`s have been declared by\n     * the component.\n     */\n    componentProviders?: number;\n    /**\n     * Current index of the Factory in the `data`. Needed for `viewProviders` and `providers` merging.\n     * See `providerFactory`.\n     */\n    index?: number;\n    /**\n     * Because the same `multi` provider can be declared in `provides` and `viewProvides` it is\n     * possible for `viewProvides` to shadow the `provides`. For this reason we store the\n     * `provideFactory` of the `providers` so that `providers` can be extended with `viewProviders`.\n     *\n     * Example:\n     *\n     * Given:\n     * ```\n     * provides: [ {provide: String, useValue: 'all', multi: true} ],\n     * viewProvides: [ {provide: String, useValue: 'viewOnly', multi: true} ],\n     * ```\n     *\n     * We have to return `['all']` in case of content injection, but `['all', 'viewOnly']` in case\n     * of view injection. We further have to make sure that the shared instances (in our case\n     * `all`) are the exact same instance in both the content as well as the view injection. (We\n     * have to make sure that we don't double instantiate.) For this reason the `viewProvides`\n     * `Factory` has a pointer to the shadowed `provides` factory so that it can instantiate the\n     * `providers` (`['all']`) and then extend it with `viewProviders` (`['all'] + ['viewOnly'] =\n     * ['all', 'viewOnly']`).\n     */\n    providerFactory?: NodeInjectorFactory | null;\n    constructor(\n    /**\n     * Factory to invoke in order to create a new instance.\n     */\n    factory: (this: NodeInjectorFactory, _: null, \n    /**\n     * array where injectables tokens are stored. This is used in\n     * case of an error reporting to produce friendlier errors.\n     */\n    tData: TData, \n    /**\n     * array where existing instances of injectables are stored. This is used in case\n     * of multi shadow is needed. See `multi` field documentation.\n     */\n    lData: LViewData, \n    /**\n     * The TNode of the same element injector.\n     */\n    tNode: TElementNode) => any, \n    /**\n     * Set to `true` if the token is declared in `viewProviders` (or if it is component).\n     */\n    isViewProvider: boolean, injectImplementation: null | (<T>(token: Type<T> | InjectionToken<T>, flags: InjectFlags) => T));\n}\nexport declare function isFactory(obj: any): obj is NodeInjectorFactory;\nexport declare const unusedValueExportToPlacateAjd = 1;\n"
  },
  {
    "path": "node_modules/@angular/core/src/render3/interfaces/node.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { StylingContext } from './styling';\nimport { LViewData, TView } from './view';\n/**\n * TNodeType corresponds to the TNode.type property. It contains information\n * on how to map a particular set of bits in TNode.flags to the node type.\n */\nexport declare const enum TNodeType {\n    Container = 0,\n    Projection = 1,\n    View = 2,\n    Element = 3,\n    ViewOrElement = 2,\n    ElementContainer = 4,\n    IcuContainer = 5\n}\n/**\n * Corresponds to the TNode.flags property.\n */\nexport declare const enum TNodeFlags {\n    /** The number of directives on this node is encoded on the least significant bits */\n    DirectiveCountMask = 4095,\n    /** This bit is set if the node is a component */\n    isComponent = 4096,\n    /** This bit is set if the node has been projected */\n    isProjected = 8192,\n    /** This bit is set if the node has any content queries */\n    hasContentQuery = 16384,\n    /** This bit is set if the node has any directives that contain [class properties */\n    hasClassInput = 32768,\n    /** The index of the first directive on this node is encoded on the most significant bits  */\n    DirectiveStartingIndexShift = 16\n}\n/**\n * Corresponds to the TNode.providerIndexes property.\n */\nexport declare const enum TNodeProviderIndexes {\n    /** The index of the first provider on this node is encoded on the least significant bits */\n    ProvidersStartIndexMask = 65535,\n    /** The count of view providers from the component on this node is encoded on the 16 most\n       significant bits */\n    CptViewProvidersCountShift = 16,\n    CptViewProvidersCountShifter = 65536\n}\n/**\n * A set of marker values to be used in the attributes arrays. Those markers indicate that some\n * items are not regular attributes and the processing should be adapted accordingly.\n */\nexport declare const enum AttributeMarker {\n    /**\n     * Marker indicates that the following 3 values in the attributes array are:\n     * namespaceUri, attributeName, attributeValue\n     * in that order.\n     */\n    NamespaceURI = 0,\n    /**\n     * This marker indicates that the following attribute names were extracted from bindings (ex.:\n     * [foo]=\"exp\") and / or event handlers (ex. (bar)=\"doSth()\").\n     * Taking the above bindings and outputs as an example an attributes array could look as follows:\n     * ['class', 'fade in', AttributeMarker.SelectOnly, 'foo', 'bar']\n     */\n    SelectOnly = 1\n}\n/**\n * A combination of:\n * - attribute names and values\n * - special markers acting as flags to alter attributes processing.\n */\nexport declare type TAttributes = (string | AttributeMarker)[];\n/**\n * Binding data (flyweight) for a particular node that is shared between all templates\n * of a specific type.\n *\n * If a property is:\n *    - PropertyAliases: that property's data was generated and this is it\n *    - Null: that property's data was already generated and nothing was found.\n *    - Undefined: that property's data has not yet been generated\n *\n * see: https://en.wikipedia.org/wiki/Flyweight_pattern for more on the Flyweight pattern\n */\nexport interface TNode {\n    /** The type of the TNode. See TNodeType. */\n    type: TNodeType;\n    /**\n     * Index of the TNode in TView.data and corresponding native element in LViewData.\n     *\n     * This is necessary to get from any TNode to its corresponding native element when\n     * traversing the node tree.\n     *\n     * If index is -1, this is a dynamically created container node or embedded view node.\n     */\n    index: number;\n    /**\n     * The index of the closest injector in this node's LViewData.\n     *\n     * If the index === -1, there is no injector on this node or any ancestor node in this view.\n     *\n     * If the index !== -1, it is the index of this node's injector OR the index of a parent injector\n     * in the same view. We pass the parent injector index down the node tree of a view so it's\n     * possible to find the parent injector without walking a potentially deep node tree. Injector\n     * indices are not set across view boundaries because there could be multiple component hosts.\n     *\n     * If tNode.injectorIndex === tNode.parent.injectorIndex, then the index belongs to a parent\n     * injector.\n     */\n    injectorIndex: number;\n    /**\n     * This number stores two values using its bits:\n     *\n     * - the number of directives on that node (first 12 bits)\n     * - the starting index of the node's directives in the directives array (last 20 bits).\n     *\n     * These two values are necessary so DI can effectively search the directives associated\n     * with a node without searching the whole directives array.\n     */\n    flags: TNodeFlags;\n    /**\n     * This number stores two values using its bits:\n     *\n     * - the index of the first provider on that node (first 16 bits)\n     * - the count of view providers from the component on this node (last 16 bits)\n     */\n    providerIndexes: TNodeProviderIndexes;\n    /** The tag name associated with this node. */\n    tagName: string | null;\n    /**\n     * Attributes associated with an element. We need to store attributes to support various use-cases\n     * (attribute injection, content projection with selectors, directives matching).\n     * Attributes are stored statically because reading them from the DOM would be way too slow for\n     * content projection and queries.\n     *\n     * Since attrs will always be calculated first, they will never need to be marked undefined by\n     * other instructions.\n     *\n     * For regular attributes a name of an attribute and its value alternate in the array.\n     * e.g. ['role', 'checkbox']\n     * This array can contain flags that will indicate \"special attributes\" (attributes with\n     * namespaces, attributes extracted from bindings and outputs).\n     */\n    attrs: TAttributes | null;\n    /**\n     * A set of local names under which a given element is exported in a template and\n     * visible to queries. An entry in this array can be created for different reasons:\n     * - an element itself is referenced, ex.: `<div #foo>`\n     * - a component is referenced, ex.: `<my-cmpt #foo>`\n     * - a directive is referenced, ex.: `<my-cmpt #foo=\"directiveExportAs\">`.\n     *\n     * A given element might have different local names and those names can be associated\n     * with a directive. We store local names at even indexes while odd indexes are reserved\n     * for directive index in a view (or `-1` if there is no associated directive).\n     *\n     * Some examples:\n     * - `<div #foo>` => `[\"foo\", -1]`\n     * - `<my-cmpt #foo>` => `[\"foo\", myCmptIdx]`\n     * - `<my-cmpt #foo #bar=\"directiveExportAs\">` => `[\"foo\", myCmptIdx, \"bar\", directiveIdx]`\n     * - `<div #foo #bar=\"directiveExportAs\">` => `[\"foo\", -1, \"bar\", directiveIdx]`\n     */\n    localNames: (string | number)[] | null;\n    /** Information about input properties that need to be set once from attribute data. */\n    initialInputs: InitialInputData | null | undefined;\n    /**\n     * Input data for all directives on this node.\n     *\n     * - `undefined` means that the prop has not been initialized yet,\n     * - `null` means that the prop has been initialized but no inputs have been found.\n     */\n    inputs: PropertyAliases | null | undefined;\n    /**\n     * Output data for all directives on this node.\n     *\n     * - `undefined` means that the prop has not been initialized yet,\n     * - `null` means that the prop has been initialized but no outputs have been found.\n     */\n    outputs: PropertyAliases | null | undefined;\n    /**\n     * The TView or TViews attached to this node.\n     *\n     * If this TNode corresponds to an LContainer with inline views, the container will\n     * need to store separate static data for each of its view blocks (TView[]). Otherwise,\n     * nodes in inline views with the same index as nodes in their parent views will overwrite\n     * each other, as they are in the same template.\n     *\n     * Each index in this array corresponds to the static data for a certain\n     * view. So if you had V(0) and V(1) in a container, you might have:\n     *\n     * [\n     *   [{tagName: 'div', attrs: ...}, null],     // V(0) TView\n     *   [{tagName: 'button', attrs ...}, null]    // V(1) TView\n     *\n     * If this TNode corresponds to an LContainer with a template (e.g. structural\n     * directive), the template's TView will be stored here.\n     *\n     * If this TNode corresponds to an element, tViews will be null .\n     */\n    tViews: TView | TView[] | null;\n    /**\n     * The next sibling node. Necessary so we can propagate through the root nodes of a view\n     * to insert them or remove them from the DOM.\n     */\n    next: TNode | null;\n    /**\n     * First child of the current node.\n     *\n     * For component nodes, the child will always be a ContentChild (in same view).\n     * For embedded view nodes, the child will be in their child view.\n     */\n    child: TNode | null;\n    /**\n     * Parent node (in the same view only).\n     *\n     * We need a reference to a node's parent so we can append the node to its parent's native\n     * element at the appropriate time.\n     *\n     * If the parent would be in a different view (e.g. component host), this property will be null.\n     * It's important that we don't try to cross component boundaries when retrieving the parent\n     * because the parent will change (e.g. index, attrs) depending on where the component was\n     * used (and thus shouldn't be stored on TNode). In these cases, we retrieve the parent through\n     * LView.node instead (which will be instance-specific).\n     *\n     * If this is an inline view node (V), the parent will be its container.\n     */\n    parent: TElementNode | TContainerNode | null;\n    /**\n     * If this node is part of an i18n block, it indicates whether this node is part of the DOM.\n     * If this node is not part of an i18n block, this field is null.\n     */\n    detached: boolean | null;\n    stylingTemplate: StylingContext | null;\n    /**\n     * List of projected TNodes for a given component host element OR index into the said nodes.\n     *\n     * For easier discussion assume this example:\n     * `<parent>`'s view definition:\n     * ```\n     * <child id=\"c1\">content1</child>\n     * <child id=\"c2\"><span>content2</span></child>\n     * ```\n     * `<child>`'s view definition:\n     * ```\n     * <ng-content id=\"cont1\"></ng-content>\n     * ```\n     *\n     * If `Array.isArray(projection)` then `TNode` is a host element:\n     * - `projection` stores the content nodes which are to be projected.\n     *    - The nodes represent categories defined by the selector: For example:\n     *      `<ng-content/><ng-content select=\"abc\"/>` would represent the heads for `<ng-content/>`\n     *      and `<ng-content select=\"abc\"/>` respectively.\n     *    - The nodes we store in `projection` are heads only, we used `.next` to get their\n     *      siblings.\n     *    - The nodes `.next` is sorted/rewritten as part of the projection setup.\n     *    - `projection` size is equal to the number of projections `<ng-content>`. The size of\n     *      `c1` will be `1` because `<child>` has only one `<ng-content>`.\n     * - we store `projection` with the host (`c1`, `c2`) rather than the `<ng-content>` (`cont1`)\n     *   because the same component (`<child>`) can be used in multiple locations (`c1`, `c2`) and as\n     *   a result have different set of nodes to project.\n     * - without `projection` it would be difficult to efficiently traverse nodes to be projected.\n     *\n     * If `typeof projection == 'number'` then `TNode` is a `<ng-content>` element:\n     * - `projection` is an index of the host's `projection`Nodes.\n     *   - This would return the first head node to project:\n     *     `getHost(currentTNode).projection[currentTNode.projection]`.\n     * - When projecting nodes the parent node retrieved may be a `<ng-content>` node, in which case\n     *   the process is recursive in nature (not implementation).\n     */\n    projection: (TNode | null)[] | number | null;\n}\n/** Static data for an element  */\nexport interface TElementNode extends TNode {\n    /** Index in the data[] array */\n    index: number;\n    child: TElementNode | TTextNode | TElementContainerNode | TContainerNode | TProjectionNode | null;\n    /**\n     * Element nodes will have parents unless they are the first node of a component or\n     * embedded view (which means their parent is in a different view and must be\n     * retrieved using viewData[HOST_NODE]).\n     */\n    parent: TElementNode | TElementContainerNode | null;\n    tViews: null;\n    /**\n     * If this is a component TNode with projection, this will be an array of projected\n     * TNodes (see TNode.projection for more info). If it's a regular element node or a\n     * component without projection, it will be null.\n     */\n    projection: (TNode | null)[] | null;\n}\n/** Static data for a text node */\nexport interface TTextNode extends TNode {\n    /** Index in the data[] array */\n    index: number;\n    child: null;\n    /**\n     * Text nodes will have parents unless they are the first node of a component or\n     * embedded view (which means their parent is in a different view and must be\n     * retrieved using LView.node).\n     */\n    parent: TElementNode | TElementContainerNode | null;\n    tViews: null;\n    projection: null;\n}\n/** Static data for an LContainer */\nexport interface TContainerNode extends TNode {\n    /**\n     * Index in the data[] array.\n     *\n     * If it's -1, this is a dynamically created container node that isn't stored in\n     * data[] (e.g. when you inject ViewContainerRef) .\n     */\n    index: number;\n    child: null;\n    /**\n     * Container nodes will have parents unless:\n     *\n     * - They are the first node of a component or embedded view\n     * - They are dynamically created\n     */\n    parent: TElementNode | TElementContainerNode | null;\n    tViews: TView | TView[] | null;\n    projection: null;\n}\n/** Static data for an <ng-container> */\nexport interface TElementContainerNode extends TNode {\n    /** Index in the LViewData[] array. */\n    index: number;\n    child: TElementNode | TTextNode | TContainerNode | TElementContainerNode | TProjectionNode | null;\n    parent: TElementNode | TElementContainerNode | null;\n    tViews: null;\n    projection: null;\n}\n/** Static data for an ICU expression */\nexport interface TIcuContainerNode extends TNode {\n    /** Index in the LViewData[] array. */\n    index: number;\n    child: TElementNode | TTextNode | null;\n    parent: TElementNode | TElementContainerNode | null;\n    tViews: null;\n    projection: null;\n    /**\n     * Indicates the current active case for an ICU expression.\n     * It is null when there is no active case.\n     */\n    activeCaseIndex: number | null;\n}\n/** Static data for a view  */\nexport interface TViewNode extends TNode {\n    /** If -1, it's a dynamically created view. Otherwise, it is the view block ID. */\n    index: number;\n    child: TElementNode | TTextNode | TElementContainerNode | TContainerNode | TProjectionNode | null;\n    parent: TContainerNode | null;\n    tViews: null;\n    projection: null;\n}\n/** Static data for an LProjectionNode  */\nexport interface TProjectionNode extends TNode {\n    /** Index in the data[] array */\n    child: null;\n    /**\n     * Projection nodes will have parents unless they are the first node of a component\n     * or embedded view (which means their parent is in a different view and must be\n     * retrieved using LView.node).\n     */\n    parent: TElementNode | TElementContainerNode | null;\n    tViews: null;\n    /** Index of the projection node. (See TNode.projection for more info.) */\n    projection: number;\n}\n/**\n * This mapping is necessary so we can set input properties and output listeners\n * properly at runtime when property names are minified or aliased.\n *\n * Key: unminified / public input or output name\n * Value: array containing minified / internal name and related directive index\n *\n * The value must be an array to support inputs and outputs with the same name\n * on the same node.\n */\nexport declare type PropertyAliases = {\n    [key: string]: PropertyAliasValue;\n};\n/**\n * Store the runtime input or output names for all the directives.\n *\n * - Even indices: directive index\n * - Odd indices: minified / internal name\n *\n * e.g. [0, 'change-minified']\n */\nexport declare type PropertyAliasValue = (number | string)[];\n/**\n * This array contains information about input properties that\n * need to be set once from attribute data. It's ordered by\n * directive index (relative to element) so it's simple to\n * look up a specific directive's initial input data.\n *\n * Within each sub-array:\n *\n * Even indices: minified/internal input name\n * Odd indices: initial value\n *\n * If a directive on a node does not have any input properties\n * that should be set from attributes, its index is set to null\n * to avoid a sparse array.\n *\n * e.g. [null, ['role-min', 'button']]\n */\nexport declare type InitialInputData = (InitialInputs | null)[];\n/**\n * Used by InitialInputData to store input properties\n * that should be set once from attributes.\n *\n * Even indices: minified/internal input name\n * Odd indices: initial value\n *\n * e.g. ['role-min', 'button']\n */\nexport declare type InitialInputs = string[];\nexport declare const unusedValueExportToPlacateAjd = 1;\n/**\n * Type representing a set of TNodes that can have local refs (`#foo`) placed on them.\n */\nexport declare type TNodeWithLocalRefs = TContainerNode | TElementNode | TElementContainerNode;\n/**\n * Type for a function that extracts a value for a local refs.\n * Example:\n * - `<div #nativeDivEl>` - `nativeDivEl` should point to the native `<div>` element;\n * - `<ng-template #tplRef>` - `tplRef` should point to the `TemplateRef` instance;\n */\nexport declare type LocalRefExtractor = (tNode: TNodeWithLocalRefs, currentView: LViewData) => any;\n"
  },
  {
    "path": "node_modules/@angular/core/src/render3/interfaces/player.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * A shared interface which contains an animation player\n */\nexport interface Player {\n    parent?: Player | null;\n    state: PlayState;\n    play(): void;\n    pause(): void;\n    finish(): void;\n    destroy(): void;\n    addEventListener(state: PlayState | string, cb: (data?: any) => any): void;\n}\nexport declare const enum BindingType {\n    Unset = 0,\n    Class = 1,\n    Style = 2\n}\nexport interface BindingStore {\n    setValue(prop: string, value: any): void;\n}\n/**\n * Defines the shape which produces the Player.\n *\n * Used to produce a player that will be placed on an element that contains\n * styling bindings that make use of the player. This function is designed\n * to be used with `PlayerFactory`.\n */\nexport interface PlayerFactoryBuildFn {\n    (element: HTMLElement, type: BindingType, values: {\n        [key: string]: any;\n    }, isFirstRender: boolean, currentPlayer: Player | null): Player | null;\n}\n/**\n * Used as a reference to build a player from a styling template binding\n * (`[style]` and `[class]`).\n *\n * The `fn` function will be called once any styling-related changes are\n * evaluated on an element and is expected to return a player that will\n * be then run on the element.\n *\n * `[style]`, `[style.prop]`, `[class]` and `[class.name]` template bindings\n * all accept a `PlayerFactory` as input and this player factories.\n */\nexport interface PlayerFactory {\n    '__brand__': 'Brand for PlayerFactory that nothing will match';\n}\nexport interface PlayerBuilder extends BindingStore {\n    buildPlayer(currentPlayer: Player | null, isFirstRender: boolean): Player | undefined | null;\n}\n/**\n * The state of a given player\n *\n * Do not change the increasing nature of the numbers since the player\n * code may compare state by checking if a number is higher or lower than\n * a certain numeric value.\n */\nexport declare const enum PlayState {\n    Pending = 0,\n    Running = 1,\n    Paused = 2,\n    Finished = 100,\n    Destroyed = 200\n}\n/**\n * The context that stores all the active players and queued player factories present on an element.\n */\nexport interface PlayerContext extends Array<null | number | Player | PlayerBuilder> {\n    [PlayerIndex.NonBuilderPlayersStart]: number;\n    [PlayerIndex.ClassMapPlayerBuilderPosition]: PlayerBuilder | null;\n    [PlayerIndex.ClassMapPlayerPosition]: Player | null;\n    [PlayerIndex.StyleMapPlayerBuilderPosition]: PlayerBuilder | null;\n    [PlayerIndex.StyleMapPlayerPosition]: Player | null;\n}\n/**\n * Designed to be used as an injection service to capture all animation players.\n *\n * When present all animation players will be passed into the flush method below.\n * This feature is designed to service application-wide animation testing, live\n * debugging as well as custom animation choreographing tools.\n */\nexport interface PlayerHandler {\n    /**\n     * Designed to kick off the player at the end of change detection\n     */\n    flushPlayers(): void;\n    /**\n     * @param player The player that has been scheduled to run within the application.\n     * @param context The context as to where the player was bound to\n     */\n    queuePlayer(player: Player, context: ComponentInstance | DirectiveInstance | HTMLElement): void;\n}\nexport declare const enum PlayerIndex {\n    NonBuilderPlayersStart = 0,\n    ClassMapPlayerBuilderPosition = 1,\n    ClassMapPlayerPosition = 2,\n    StyleMapPlayerBuilderPosition = 3,\n    StyleMapPlayerPosition = 4,\n    PlayerBuildersStartPosition = 1,\n    SinglePlayerBuildersStartPosition = 5,\n    PlayerAndPlayerBuildersTupleSize = 2,\n    PlayerOffsetPosition = 1\n}\nexport declare type ComponentInstance = {};\nexport declare type DirectiveInstance = {};\n"
  },
  {
    "path": "node_modules/@angular/core/src/render3/interfaces/projection.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Expresses a single CSS Selector.\n *\n * Beginning of array\n * - First index: element name\n * - Subsequent odd indices: attr keys\n * - Subsequent even indices: attr values\n *\n * After SelectorFlags.CLASS flag\n * - Class name values\n *\n * SelectorFlags.NOT flag\n * - Changes the mode to NOT\n * - Can be combined with other flags to set the element / attr / class mode\n *\n * e.g. SelectorFlags.NOT | SelectorFlags.ELEMENT\n *\n * Example:\n * Original: `div.foo.bar[attr1=val1][attr2]`\n * Parsed: ['div', 'attr1', 'val1', 'attr2', '', SelectorFlags.CLASS, 'foo', 'bar']\n *\n * Original: 'div[attr1]:not(.foo[attr2])\n * Parsed: [\n *  'div', 'attr1', '',\n *  SelectorFlags.NOT | SelectorFlags.ATTRIBUTE 'attr2', '', SelectorFlags.CLASS, 'foo'\n * ]\n *\n * See more examples in node_selector_matcher_spec.ts\n */\nexport declare type CssSelector = (string | SelectorFlags)[];\n/**\n * A list of CssSelectors.\n *\n * A directive or component can have multiple selectors. This type is used for\n * directive defs so any of the selectors in the list will match that directive.\n *\n * Original: 'form, [ngForm]'\n * Parsed: [['form'], ['', 'ngForm', '']]\n */\nexport declare type CssSelectorList = CssSelector[];\n/** Flags used to build up CssSelectors */\nexport declare const enum SelectorFlags {\n    /** Indicates this is the beginning of a new negative selector */\n    NOT = 1,\n    /** Mode for matching attributes */\n    ATTRIBUTE = 2,\n    /** Mode for matching tag names */\n    ELEMENT = 4,\n    /** Mode for matching class names */\n    CLASS = 8\n}\nexport declare const NG_PROJECT_AS_ATTR_NAME = \"ngProjectAs\";\nexport declare const unusedValueExportToPlacateAjd = 1;\n"
  },
  {
    "path": "node_modules/@angular/core/src/render3/interfaces/query.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { QueryList } from '../../linker';\nimport { Type } from '../../type';\nimport { TContainerNode, TElementContainerNode, TElementNode } from './node';\n/** Used for tracking queries (e.g. ViewChild, ContentChild). */\nexport interface LQueries {\n    /**\n     * The parent LQueries instance.\n     *\n     * When there is a content query, a new LQueries instance is created to avoid mutating any\n     * existing LQueries. After we are done searching content children, the parent property allows\n     * us to traverse back up to the original LQueries instance to continue to search for matches\n     * in the main view.\n     */\n    parent: LQueries | null;\n    /**\n     * Ask queries to prepare copy of itself. This assures that tracking new queries on content nodes\n     * doesn't mutate list of queries tracked on a parent node. We will clone LQueries before\n     * constructing content queries.\n     */\n    clone(): LQueries;\n    /**\n     * Notify `LQueries` that a new `TNode` has been created and needs to be added to query results\n     * if matching query predicate.\n     */\n    addNode(tNode: TElementNode | TContainerNode | TElementContainerNode): LQueries | null;\n    /**\n     * Notify `LQueries` that a new LContainer was added to ivy data structures. As a result we need\n     * to prepare room for views that might be inserted into this container.\n     */\n    container(): LQueries | null;\n    /**\n     * Notify `LQueries` that a new `LView` has been created. As a result we need to prepare room\n     * and collect nodes that match query predicate.\n     */\n    createView(): LQueries | null;\n    /**\n     * Notify `LQueries` that a new `LView` has been added to `LContainer`. As a result all\n     * the matching nodes from this view should be added to container's queries.\n     */\n    insertView(newViewIndex: number): void;\n    /**\n     * Notify `LQueries` that an `LView` has been removed from `LContainer`. As a result all\n     * the matching nodes from this view should be removed from container's queries.\n     */\n    removeView(): void;\n    /**\n     * Add additional `QueryList` to track.\n     *\n     * @param queryList `QueryList` to update with changes.\n     * @param predicate Either `Type` or selector array of [key, value] predicates.\n     * @param descend If true the query will recursively apply to the children.\n     * @param read Indicates which token should be read from DI for this query.\n     */\n    track<T>(queryList: QueryList<T>, predicate: Type<any> | string[], descend?: boolean, read?: Type<T>): void;\n}\nexport declare const unusedValueExportToPlacateAjd = 1;\n"
  },
  {
    "path": "node_modules/@angular/core/src/render3/interfaces/renderer.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * The goal here is to make sure that the browser DOM API is the Renderer.\n * We do this by defining a subset of DOM API to be the renderer and than\n * use that time for rendering.\n *\n * At runtime we can than use the DOM api directly, in server or web-worker\n * it will be easy to implement such API.\n */\nimport { RendererStyleFlags2, RendererType2 } from '../../render/api';\nexport declare enum RendererStyleFlags3 {\n    Important = 1,\n    DashCase = 2\n}\nexport declare type Renderer3 = ObjectOrientedRenderer3 | ProceduralRenderer3;\n/**\n * Object Oriented style of API needed to create elements and text nodes.\n *\n * This is the native browser API style, e.g. operations are methods on individual objects\n * like HTMLElement. With this style, no additional code is needed as a facade\n * (reducing payload size).\n * */\nexport interface ObjectOrientedRenderer3 {\n    createComment(data: string): RComment;\n    createElement(tagName: string): RElement;\n    createElementNS(namespace: string, tagName: string): RElement;\n    createTextNode(data: string): RText;\n    querySelector(selectors: string): RElement | null;\n}\n/** Returns whether the `renderer` is a `ProceduralRenderer3` */\nexport declare function isProceduralRenderer(renderer: ProceduralRenderer3 | ObjectOrientedRenderer3): renderer is ProceduralRenderer3;\n/**\n * Procedural style of API needed to create elements and text nodes.\n *\n * In non-native browser environments (e.g. platforms such as web-workers), this is the\n * facade that enables element manipulation. This also facilitates backwards compatibility\n * with Renderer2.\n */\nexport interface ProceduralRenderer3 {\n    destroy(): void;\n    createComment(value: string): RComment;\n    createElement(name: string, namespace?: string | null): RElement;\n    createText(value: string): RText;\n    /**\n     * This property is allowed to be null / undefined,\n     * in which case the view engine won't call it.\n     * This is used as a performance optimization for production mode.\n     */\n    destroyNode?: ((node: RNode) => void) | null;\n    appendChild(parent: RElement, newChild: RNode): void;\n    insertBefore(parent: RNode, newChild: RNode, refChild: RNode | null): void;\n    removeChild(parent: RElement, oldChild: RNode): void;\n    selectRootElement(selectorOrNode: string | any): RElement;\n    parentNode(node: RNode): RElement | null;\n    nextSibling(node: RNode): RNode | null;\n    setAttribute(el: RElement, name: string, value: string, namespace?: string | null): void;\n    removeAttribute(el: RElement, name: string, namespace?: string | null): void;\n    addClass(el: RElement, name: string): void;\n    removeClass(el: RElement, name: string): void;\n    setStyle(el: RElement, style: string, value: any, flags?: RendererStyleFlags2 | RendererStyleFlags3): void;\n    removeStyle(el: RElement, style: string, flags?: RendererStyleFlags2 | RendererStyleFlags3): void;\n    setProperty(el: RElement, name: string, value: any): void;\n    setValue(node: RText, value: string): void;\n    listen(target: RNode, eventName: string, callback: (event: any) => boolean | void): () => void;\n}\nexport interface RendererFactory3 {\n    createRenderer(hostElement: RElement | null, rendererType: RendererType2 | null): Renderer3;\n    begin?(): void;\n    end?(): void;\n}\nexport declare const domRendererFactory3: RendererFactory3;\n/** Subset of API needed for appending elements and text nodes. */\nexport interface RNode {\n    parentNode: RNode | null;\n    nextSibling: RNode | null;\n    removeChild(oldChild: RNode): void;\n    /**\n     * Insert a child node.\n     *\n     * Used exclusively for adding View root nodes into ViewAnchor location.\n     */\n    insertBefore(newChild: RNode, refChild: RNode | null, isViewRoot: boolean): void;\n    /**\n     * Append a child node.\n     *\n     * Used exclusively for building up DOM which are static (ie not View roots)\n     */\n    appendChild(newChild: RNode): RNode;\n}\n/**\n * Subset of API needed for writing attributes, properties, and setting up\n * listeners on Element.\n */\nexport interface RElement extends RNode {\n    style: RCssStyleDeclaration;\n    classList: RDomTokenList;\n    className: string;\n    setAttribute(name: string, value: string): void;\n    removeAttribute(name: string): void;\n    setAttributeNS(namespaceURI: string, qualifiedName: string, value: string): void;\n    addEventListener(type: string, listener: EventListener, useCapture?: boolean): void;\n    removeEventListener(type: string, listener?: EventListener, options?: boolean): void;\n    setProperty?(name: string, value: any): void;\n}\nexport interface RCssStyleDeclaration {\n    removeProperty(propertyName: string): string;\n    setProperty(propertyName: string, value: string | null, priority?: string): void;\n}\nexport interface RDomTokenList {\n    add(token: string): void;\n    remove(token: string): void;\n}\nexport interface RText extends RNode {\n    textContent: string | null;\n}\nexport interface RComment extends RNode {\n}\nexport declare const unusedValueExportToPlacateAjd = 1;\n"
  },
  {
    "path": "node_modules/@angular/core/src/render3/interfaces/sanitization.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Function used to sanitize the value before writing it into the renderer.\n */\nexport declare type SanitizerFn = (value: any) => string;\n"
  },
  {
    "path": "node_modules/@angular/core/src/render3/interfaces/styling.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { StyleSanitizeFn } from '../../sanitization/style_sanitizer';\nimport { RElement } from '../interfaces/renderer';\nimport { PlayerContext } from './player';\n/**\n * The styling context acts as a styling manifest (shaped as an array) for determining which\n * styling properties have been assigned via the provided `updateStylingMap`, `updateStyleProp`\n * and `updateClassProp` functions. There are also two initialization functions\n * `allocStylingContext` and `createStylingContextTemplate` which are used to initialize\n * and/or clone the context.\n *\n * The context is an array where the first two cells are used for static data (initial styling)\n * and dirty flags / index offsets). The remaining set of cells is used for multi (map) and single\n * (prop) style values.\n *\n * each value from here onwards is mapped as so:\n * [i] = mutation/type flag for the style/class value\n * [i + 1] = prop string (or null incase it has been removed)\n * [i + 2] = value string (or null incase it has been removed)\n *\n * There are three types of styling types stored in this context:\n *   initial: any styles that are passed in once the context is created\n *            (these are stored in the first cell of the array and the first\n *             value of this array is always `null` even if no initial styling exists.\n *             the `null` value is there so that any new styles have a parent to point\n *             to. This way we can always assume that there is a parent.)\n *\n *   single: any styles that are updated using `updateStyleProp` or `updateClassProp` (fixed set)\n *\n *   multi: any styles that are updated using `updateStylingMap` (dynamic set)\n *\n * Note that context is only used to collect style information. Only when `renderStyling`\n * is called is when the styling payload will be rendered (or built as a key/value map).\n *\n * When the context is created, depending on what initial styling values are passed in, the\n * context itself will be pre-filled with slots based on the initial style properties. Say\n * for example we have a series of initial styles that look like so:\n *\n *   style=\"width:100px; height:200px;\"\n *   class=\"foo\"\n *\n * Then the initial state of the context (once initialized) will look like so:\n *\n * ```\n * context = [\n *   element,\n *   playerContext | null,\n *   styleSanitizer | null,\n *   [null, '100px', '200px', true],  // property names are not needed since they have already been\n * written to DOM.\n *\n *   configMasterVal,\n *   1, // this instructs how many `style` values there are so that class index values can be\n * offsetted\n *   { classOne: true, classTwo: false } | 'classOne classTwo' | null // last class value provided\n * into updateStylingMap\n *   { styleOne: '100px', styleTwo: 0 } | null // last style value provided into updateStylingMap\n *\n *   // 8\n *   'width',\n *   pointers(1, 15);  // Point to static `width`: `100px` and multi `width`.\n *   null,\n *\n *   // 11\n *   'height',\n *   pointers(2, 18); // Point to static `height`: `200px` and multi `height`.\n *   null,\n *\n *   // 14\n *   'foo',\n *   pointers(1, 21);  // Point to static `foo`: `true` and multi `foo`.\n *   null,\n *\n *   // 17\n *   'width',\n *   pointers(1, 6);  // Point to static `width`: `100px` and single `width`.\n *   null,\n *\n *   // 21\n *   'height',\n *   pointers(2, 9);  // Point to static `height`: `200px` and single `height`.\n *   null,\n *\n *   // 24\n *   'foo',\n *   pointers(3, 12);  // Point to static `foo`: `true` and single `foo`.\n *   null,\n * ]\n *\n * function pointers(staticIndex: number, dynamicIndex: number) {\n *   // combine the two indices into a single word.\n *   return (staticIndex << StylingFlags.BitCountSize) |\n *     (dynamicIndex << (StylingIndex.BitCountSize + StylingFlags.BitCountSize));\n * }\n * ```\n *\n * The values are duplicated so that space is set aside for both multi ([style] and [class])\n * and single ([style.prop] or [class.named]) values. The respective config values\n * (configValA, configValB, etc...) are a combination of the StylingFlags with two index\n * values: the `initialIndex` (which points to the index location of the style value in\n * the initial styles array in slot 0) and the `dynamicIndex` (which points to the\n * matching single/multi index position in the context array for the same prop).\n *\n * This means that every time `updateStyleProp` or `updateClassProp` are called then they\n * must be called using an index value (not a property string) which references the index\n * value of the initial style prop/class when the context was created. This also means that\n * `updateStyleProp` or `updateClassProp` cannot be called with a new property (only\n * `updateStylingMap` can include new CSS properties that will be added to the context).\n */\nexport interface StylingContext extends Array<InitialStyles | {\n    [key: string]: any;\n} | number | string | boolean | RElement | StyleSanitizeFn | PlayerContext | null> {\n    /**\n     * Location of animation context (which contains the active players) for this element styling\n     * context.\n     */\n    [StylingIndex.PlayerContext]: PlayerContext | null;\n    /**\n     * The style sanitizer that is used within this context\n     */\n    [StylingIndex.StyleSanitizerPosition]: StyleSanitizeFn | null;\n    /**\n     * Location of initial data shared by all instances of this style.\n     */\n    [StylingIndex.InitialStylesPosition]: InitialStyles;\n    /**\n     * A numeric value representing the configuration status (whether the context is dirty or not)\n     * mixed together (using bit shifting) with a index value which tells the starting index value\n     * of where the multi style entries begin.\n     */\n    [StylingIndex.MasterFlagPosition]: number;\n    /**\n     * A numeric value representing the class index offset value. Whenever a single class is\n     * applied (using `elementClassProp`) it should have an styling index value that doesn't\n     * need to take into account any style values that exist in the context.\n     */\n    [StylingIndex.ClassOffsetPosition]: number;\n    /**\n     * Location of element that is used as a target for this context.\n     */\n    [StylingIndex.ElementPosition]: RElement | null;\n    /**\n     * The last class value that was interpreted by elementStylingMap. This is cached\n     * So that the algorithm can exit early incase the value has not changed.\n     */\n    [StylingIndex.PreviousOrCachedMultiClassValue]: {\n        [key: string]: any;\n    } | string | null;\n    /**\n     * The last style value that was interpreted by elementStylingMap. This is cached\n     * So that the algorithm can exit early incase the value has not changed.\n     */\n    [StylingIndex.PreviousMultiStyleValue]: {\n        [key: string]: any;\n    } | null;\n}\n/**\n * The initial styles is populated whether or not there are any initial styles passed into\n * the context during allocation. The 0th value must be null so that index values of `0` within\n * the context flags can always point to a null value safely when nothing is set.\n *\n * All other entries in this array are of `string` value and correspond to the values that\n * were extracted from the `style=\"\"` attribute in the HTML code for the provided template.\n */\nexport interface InitialStyles extends Array<string | null | boolean> {\n    [0]: null;\n}\n/**\n * Used to set the context to be dirty or not both on the master flag (position 1)\n * or for each single/multi property that exists in the context.\n */\nexport declare const enum StylingFlags {\n    None = 0,\n    Dirty = 1,\n    Class = 2,\n    Sanitize = 4,\n    PlayerBuildersDirty = 8,\n    OnlyProcessSingleClasses = 16,\n    BitCountSize = 5,\n    BitMask = 31\n}\n/** Used as numeric pointer values to determine what cells to update in the `StylingContext` */\nexport declare const enum StylingIndex {\n    PlayerContext = 0,\n    StyleSanitizerPosition = 1,\n    InitialStylesPosition = 2,\n    MasterFlagPosition = 3,\n    ClassOffsetPosition = 4,\n    ElementPosition = 5,\n    PreviousOrCachedMultiClassValue = 6,\n    PreviousMultiStyleValue = 7,\n    SingleStylesStartPosition = 8,\n    FlagsOffset = 0,\n    PropertyOffset = 1,\n    ValueOffset = 2,\n    PlayerBuilderIndexOffset = 3,\n    Size = 4,\n    BitCountSize = 14,\n    BitMask = 16383\n}\n"
  },
  {
    "path": "node_modules/@angular/core/src/render3/interfaces/view.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { InjectionToken } from '../../di/injection_token';\nimport { Injector } from '../../di/injector';\nimport { QueryList } from '../../linker';\nimport { Sanitizer } from '../../sanitization/security';\nimport { Type } from '../../type';\nimport { LContainer } from './container';\nimport { ComponentDef, ComponentQuery, ComponentTemplate, DirectiveDef, DirectiveDefList, HostBindingsFunction, PipeDef, PipeDefList } from './definition';\nimport { I18nUpdateOpCodes, TI18n } from './i18n';\nimport { TElementNode, TNode, TViewNode } from './node';\nimport { PlayerHandler } from './player';\nimport { LQueries } from './query';\nimport { RElement, Renderer3 } from './renderer';\nimport { StylingContext } from './styling';\n/** Size of LViewData's header. Necessary to adjust for it when setting slots.  */\nexport declare const HEADER_OFFSET = 17;\nexport declare const TVIEW = 0;\nexport declare const FLAGS = 1;\nexport declare const PARENT = 2;\nexport declare const NEXT = 3;\nexport declare const QUERIES = 4;\nexport declare const HOST = 5;\nexport declare const HOST_NODE = 6;\nexport declare const BINDING_INDEX = 7;\nexport declare const CLEANUP = 8;\nexport declare const CONTEXT = 9;\nexport declare const INJECTOR = 10;\nexport declare const RENDERER = 11;\nexport declare const SANITIZER = 12;\nexport declare const TAIL = 13;\nexport declare const CONTAINER_INDEX = 14;\nexport declare const CONTENT_QUERIES = 15;\nexport declare const DECLARATION_VIEW = 16;\nexport interface OpaqueViewState {\n    '__brand__': 'Brand for OpaqueViewState that nothing will match';\n}\n/**\n * `LViewData` stores all of the information needed to process the instructions as\n * they are invoked from the template. Each embedded view and component view has its\n * own `LViewData`. When processing a particular view, we set the `viewData` to that\n * `LViewData`. When that view is done processing, the `viewData` is set back to\n * whatever the original `viewData` was before (the parent `LViewData`).\n *\n * Keeping separate state for each view facilities view insertion / deletion, so we\n * don't have to edit the data array based on which views are present.\n */\nexport interface LViewData extends Array<any> {\n    /**\n     * The static data for this view. We need a reference to this so we can easily walk up the\n     * node tree in DI and get the TView.data array associated with a node (where the\n     * directive defs are stored).\n     */\n    readonly [TVIEW]: TView;\n    /** Flags for this view. See LViewFlags for more info. */\n    [FLAGS]: LViewFlags;\n    /**\n     * The parent view is needed when we exit the view and must restore the previous\n     * `LViewData`. Without this, the render method would have to keep a stack of\n     * views as it is recursively rendering templates.\n     *\n     * This is the \"insertion\" view for embedded views. This allows us to properly\n     * destroy embedded views.\n     */\n    [PARENT]: LViewData | null;\n    /**\n     *\n     * The next sibling LViewData or LContainer.\n     *\n     * Allows us to propagate between sibling view states that aren't in the same\n     * container. Embedded views already have a node.next, but it is only set for\n     * views in the same container. We need a way to link component views and views\n     * across containers as well.\n     */\n    [NEXT]: LViewData | LContainer | null;\n    /** Queries active for this view - nodes from a view are reported to those queries. */\n    [QUERIES]: LQueries | null;\n    /**\n     * The host node for this LViewData instance, if this is a component view.\n     *\n     * If this is an embedded view, HOST will be null.\n     */\n    [HOST]: RElement | StylingContext | null;\n    /**\n     * Pointer to the `TViewNode` or `TElementNode` which represents the root of the view.\n     *\n     * If `TViewNode`, this is an embedded view of a container. We need this to be able to\n     * efficiently find the `LViewNode` when inserting the view into an anchor.\n     *\n     * If `TElementNode`, this is the LView of a component.\n     *\n     * If null, this is the root view of an application (root component is in this view).\n     */\n    [HOST_NODE]: TViewNode | TElementNode | null;\n    /**\n     * The binding index we should access next.\n     *\n     * This is stored so that bindings can continue where they left off\n     * if a view is left midway through processing bindings (e.g. if there is\n     * a setter that creates an embedded view, like in ngIf).\n     */\n    [BINDING_INDEX]: number;\n    /**\n     * When a view is destroyed, listeners need to be released and outputs need to be\n     * unsubscribed. This context array stores both listener functions wrapped with\n     * their context and output subscription instances for a particular view.\n     *\n     * These change per LView instance, so they cannot be stored on TView. Instead,\n     * TView.cleanup saves an index to the necessary context in this array.\n     */\n    [CLEANUP]: any[] | null;\n    /**\n     * - For dynamic views, this is the context with which to render the template (e.g.\n     *   `NgForContext`), or `{}` if not defined explicitly.\n     * - For root view of the root component the context contains change detection data.\n     * - For non-root components, the context is the component instance,\n     * - For inline views, the context is null.\n     */\n    [CONTEXT]: {} | RootContext | null;\n    /** An optional Module Injector to be used as fall back after Element Injectors are consulted. */\n    readonly [INJECTOR]: Injector | null;\n    /** Renderer to be used for this view. */\n    [RENDERER]: Renderer3;\n    /** An optional custom sanitizer. */\n    [SANITIZER]: Sanitizer | null;\n    /**\n     * The last LViewData or LContainer beneath this LViewData in the hierarchy.\n     *\n     * The tail allows us to quickly add a new state to the end of the view list\n     * without having to propagate starting from the first child.\n     */\n    [TAIL]: LViewData | LContainer | null;\n    /**\n     * The index of the parent container's host node. Applicable only to embedded views that\n     * have been inserted dynamically. Will be -1 for component views and inline views.\n     *\n     * This is necessary to jump from dynamically created embedded views to their parent\n     * containers because their parent cannot be stored on the TViewNode (views may be inserted\n     * in multiple containers, so the parent cannot be shared between view instances).\n     */\n    [CONTAINER_INDEX]: number;\n    /**\n     * Stores QueryLists associated with content queries of a directive. This data structure is\n     * filled-in as part of a directive creation process and is later used to retrieve a QueryList to\n     * be refreshed.\n     */\n    [CONTENT_QUERIES]: QueryList<any>[] | null;\n    /**\n     * View where this view's template was declared.\n     *\n     * Only applicable for dynamically created views. Will be null for inline/component views.\n     *\n     * The template for a dynamically created view may be declared in a different view than\n     * it is inserted. We already track the \"insertion view\" (view where the template was\n     * inserted) in LViewData[PARENT], but we also need access to the \"declaration view\"\n     * (view where the template was declared). Otherwise, we wouldn't be able to call the\n     * view's template function with the proper contexts. Context should be inherited from\n     * the declaration view tree, not the insertion view tree.\n     *\n     * Example (AppComponent template):\n     *\n     * <ng-template #foo></ng-template>       <-- declared here -->\n     * <some-comp [tpl]=\"foo\"></some-comp>    <-- inserted inside this component -->\n     *\n     * The <ng-template> above is declared in the AppComponent template, but it will be passed into\n     * SomeComp and inserted there. In this case, the declaration view would be the AppComponent,\n     * but the insertion view would be SomeComp. When we are removing views, we would want to\n     * traverse through the insertion view to clean up listeners. When we are calling the\n     * template function during change detection, we need the declaration view to get inherited\n     * context.\n     */\n    [DECLARATION_VIEW]: LViewData | null;\n}\n/** Flags associated with an LView (saved in LViewData[FLAGS]) */\nexport declare const enum LViewFlags {\n    /**\n     * Whether or not the view is in creationMode.\n     *\n     * This must be stored in the view rather than using `data` as a marker so that\n     * we can properly support embedded views. Otherwise, when exiting a child view\n     * back into the parent view, `data` will be defined and `creationMode` will be\n     * improperly reported as false.\n     */\n    CreationMode = 1,\n    /** Whether this view has default change detection strategy (checks always) or onPush */\n    CheckAlways = 2,\n    /** Whether or not this view is currently dirty (needing check) */\n    Dirty = 4,\n    /** Whether or not this view is currently attached to change detection tree. */\n    Attached = 8,\n    /**\n     *  Whether or not the init hooks have run.\n     *\n     * If on, the init hooks haven't yet been run and should be executed by the first component that\n     * runs OR the first cR() instruction that runs (so inits are run for the top level view before\n     * any embedded views).\n     */\n    RunInit = 16,\n    /** Whether or not this view is destroyed. */\n    Destroyed = 32,\n    /** Whether or not this view is the root view */\n    IsRoot = 64\n}\n/**\n * The static data for an LView (shared between all templates of a\n * given type).\n *\n * Stored on the template function as ngPrivateData.\n */\nexport interface TView {\n    /**\n     * ID for inline views to determine whether a view is the same as the previous view\n     * in a certain position. If it's not, we know the new view needs to be inserted\n     * and the one that exists needs to be removed (e.g. if/else statements)\n     *\n     * If this is -1, then this is a component view or a dynamically created view.\n     */\n    readonly id: number;\n    /**\n     * This is a blueprint used to generate LViewData instances for this TView. Copying this\n     * blueprint is faster than creating a new LViewData from scratch.\n     */\n    blueprint: LViewData;\n    /**\n     * The template function used to refresh the view of dynamically created views\n     * and components. Will be null for inline views.\n     */\n    template: ComponentTemplate<{}> | null;\n    /**\n     * A function containing query-related instructions.\n     */\n    viewQuery: ComponentQuery<{}> | null;\n    /**\n     * Pointer to the `TNode` that represents the root of the view.\n     *\n     * If this is a `TNode` for an `LViewNode`, this is an embedded view of a container.\n     * We need this pointer to be able to efficiently find this node when inserting the view\n     * into an anchor.\n     *\n     * If this is a `TElementNode`, this is the view of a root component. It has exactly one\n     * root TNode.\n     *\n     * If this is null, this is the view of a component that is not at root. We do not store\n     * the host TNodes for child component views because they can potentially have several\n     * different host TNodes, depending on where the component is being used. These host\n     * TNodes cannot be shared (due to different indices, etc).\n     */\n    node: TViewNode | TElementNode | null;\n    /** Whether or not this template has been processed. */\n    firstTemplatePass: boolean;\n    /** Static data equivalent of LView.data[]. Contains TNodes, PipeDefInternal or TI18n. */\n    data: TData;\n    /**\n     * The binding start index is the index at which the data array\n     * starts to store bindings only. Saving this value ensures that we\n     * will begin reading bindings at the correct point in the array when\n     * we are in update mode.\n     */\n    bindingStartIndex: number;\n    /**\n     * The index where the \"expando\" section of `LViewData` begins. The expando\n     * section contains injectors, directive instances, and host binding values.\n     * Unlike the \"consts\" and \"vars\" sections of `LViewData`, the length of this\n     * section cannot be calculated at compile-time because directives are matched\n     * at runtime to preserve locality.\n     *\n     * We store this start index so we know where to start checking host bindings\n     * in `setHostBindings`.\n     */\n    expandoStartIndex: number;\n    /**\n     * Index of the host node of the first LView or LContainer beneath this LView in\n     * the hierarchy.\n     *\n     * Necessary to store this so views can traverse through their nested views\n     * to remove listeners and call onDestroy callbacks.\n     *\n     * For embedded views, we store the index of an LContainer's host rather than the first\n     * LView to avoid managing splicing when views are added/removed.\n     */\n    childIndex: number;\n    /**\n     * A reference to the first child node located in the view.\n     */\n    firstChild: TNode | null;\n    /**\n     * Set of instructions used to process host bindings efficiently.\n     *\n     * See VIEW_DATA.md for more information.\n     */\n    expandoInstructions: (number | HostBindingsFunction)[] | null;\n    /**\n     * Full registry of directives and components that may be found in this view.\n     *\n     * It's necessary to keep a copy of the full def list on the TView so it's possible\n     * to render template functions without a host component.\n     */\n    directiveRegistry: DirectiveDefList | null;\n    /**\n     * Full registry of pipes that may be found in this view.\n     *\n     * The property is either an array of `PipeDefs`s or a function which returns the array of\n     * `PipeDefs`s. The function is necessary to be able to support forward declarations.\n     *\n     * It's necessary to keep a copy of the full def list on the TView so it's possible\n     * to render template functions without a host component.\n     */\n    pipeRegistry: PipeDefList | null;\n    /**\n     * Array of ngOnInit and ngDoCheck hooks that should be executed for this view in\n     * creation mode.\n     *\n     * Even indices: Directive index\n     * Odd indices: Hook function\n     */\n    initHooks: HookData | null;\n    /**\n     * Array of ngDoCheck hooks that should be executed for this view in update mode.\n     *\n     * Even indices: Directive index\n     * Odd indices: Hook function\n     */\n    checkHooks: HookData | null;\n    /**\n     * Array of ngAfterContentInit and ngAfterContentChecked hooks that should be executed\n     * for this view in creation mode.\n     *\n     * Even indices: Directive index\n     * Odd indices: Hook function\n     */\n    contentHooks: HookData | null;\n    /**\n     * Array of ngAfterContentChecked hooks that should be executed for this view in update\n     * mode.\n     *\n     * Even indices: Directive index\n     * Odd indices: Hook function\n     */\n    contentCheckHooks: HookData | null;\n    /**\n     * Array of ngAfterViewInit and ngAfterViewChecked hooks that should be executed for\n     * this view in creation mode.\n     *\n     * Even indices: Directive index\n     * Odd indices: Hook function\n     */\n    viewHooks: HookData | null;\n    /**\n     * Array of ngAfterViewChecked hooks that should be executed for this view in\n     * update mode.\n     *\n     * Even indices: Directive index\n     * Odd indices: Hook function\n     */\n    viewCheckHooks: HookData | null;\n    /**\n     * Array of ngOnDestroy hooks that should be executed when this view is destroyed.\n     *\n     * Even indices: Directive index\n     * Odd indices: Hook function\n     */\n    destroyHooks: HookData | null;\n    /**\n     * Array of pipe ngOnDestroy hooks that should be executed when this view is destroyed.\n     *\n     * Even indices: Index of pipe in data\n     * Odd indices: Hook function\n     *\n     * These must be stored separately from directive destroy hooks because their contexts\n     * are stored in data.\n     */\n    pipeDestroyHooks: HookData | null;\n    /**\n     * When a view is destroyed, listeners need to be released and outputs need to be\n     * unsubscribed. This cleanup array stores both listener data (in chunks of 4)\n     * and output data (in chunks of 2) for a particular view. Combining the arrays\n     * saves on memory (70 bytes per array) and on a few bytes of code size (for two\n     * separate for loops).\n     *\n     * If it's a native DOM listener being stored:\n     * 1st index is: event name to remove\n     * 2nd index is: index of native element in LView.data[]\n     * 3rd index is: index of wrapped listener function in LView.cleanupInstances[]\n     * 4th index is: useCapture boolean\n     *\n     * If it's a renderer2 style listener or ViewRef destroy hook being stored:\n     * 1st index is: index of the cleanup function in LView.cleanupInstances[]\n     * 2nd index is: null\n     *\n     * If it's an output subscription or query list destroy hook:\n     * 1st index is: output unsubscribe function / query list destroy function\n     * 2nd index is: index of function context in LView.cleanupInstances[]\n     */\n    cleanup: any[] | null;\n    /**\n     * A list of element indices for child components that will need to be\n     * refreshed when the current view has finished its check. These indices have\n     * already been adjusted for the HEADER_OFFSET.\n     *\n     */\n    components: number[] | null;\n    /**\n     * A list of indices for child directives that have content queries.\n     *\n     * Even indices: Directive indices\n     * Odd indices: Starting index of content queries (stored in CONTENT_QUERIES) for this directive\n     */\n    contentQueries: number[] | null;\n}\nexport declare const enum RootContextFlags {\n    Empty = 0,\n    DetectChanges = 1,\n    FlushPlayers = 2\n}\n/**\n * RootContext contains information which is shared for all components which\n * were bootstrapped with {@link renderComponent}.\n */\nexport interface RootContext {\n    /**\n     * A function used for scheduling change detection in the future. Usually\n     * this is `requestAnimationFrame`.\n     */\n    scheduler: (workFn: () => void) => void;\n    /**\n     * A promise which is resolved when all components are considered clean (not dirty).\n     *\n     * This promise is overwritten every time a first call to {@link markDirty} is invoked.\n     */\n    clean: Promise<null>;\n    /**\n     * RootComponents - The components that were instantiated by the call to\n     * {@link renderComponent}.\n     */\n    components: {}[];\n    /**\n     * The player flushing handler to kick off all animations\n     */\n    playerHandler: PlayerHandler | null;\n    /**\n     * What render-related operations to run once a scheduler has been set\n     */\n    flags: RootContextFlags;\n}\n/**\n * Array of hooks that should be executed for a view and their directive indices.\n *\n * Even indices: Directive index\n * Odd indices: Hook function\n */\nexport declare type HookData = (number | (() => void))[];\n/**\n * Static data that corresponds to the instance-specific data array on an LView.\n *\n * Each node's static data is stored in tData at the same index that it's stored\n * in the data array.  Any nodes that do not have static data store a null value in\n * tData to avoid a sparse array.\n *\n * Each pipe's definition is stored here at the same index as its pipe instance in\n * the data array.\n *\n * Injector bloom filters are also stored here.\n */\nexport declare type TData = (TNode | PipeDef<any> | DirectiveDef<any> | ComponentDef<any> | number | Type<any> | InjectionToken<any> | TI18n | I18nUpdateOpCodes | null)[];\nexport declare const unusedValueExportToPlacateAjd = 1;\n"
  },
  {
    "path": "node_modules/@angular/core/src/render3/jit/compiler_facade_interface.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * A set of interfaces which are shared between `@angular/core` and `@angular/compiler` to allow\n * for late binding of `@angular/compiler` for JIT purposes.\n *\n * This file has two copies. Please ensure that they are in sync:\n *  - packages/compiler/src/compiler_facade_interface.ts             (master)\n *  - packages/core/src/render3/jit/compiler_facade_interface.ts     (copy)\n *\n * Please ensure that the two files are in sync using this command:\n * ```\n * cp packages/compiler/src/compiler_facade_interface.ts \\\n *    packages/core/src/render3/jit/compiler_facade_interface.ts\n * ```\n */\nexport interface ExportedCompilerFacade {\n    ɵcompilerFacade: CompilerFacade;\n}\nexport interface CompilerFacade {\n    compilePipe(angularCoreEnv: CoreEnvironment, sourceMapUrl: string, meta: R3PipeMetadataFacade): any;\n    compileInjectable(angularCoreEnv: CoreEnvironment, sourceMapUrl: string, meta: R3InjectableMetadataFacade): any;\n    compileInjector(angularCoreEnv: CoreEnvironment, sourceMapUrl: string, meta: R3InjectorMetadataFacade): any;\n    compileNgModule(angularCoreEnv: CoreEnvironment, sourceMapUrl: string, meta: R3NgModuleMetadataFacade): any;\n    compileDirective(angularCoreEnv: CoreEnvironment, sourceMapUrl: string, meta: R3DirectiveMetadataFacade): any;\n    compileComponent(angularCoreEnv: CoreEnvironment, sourceMapUrl: string, meta: R3ComponentMetadataFacade): any;\n    R3ResolvedDependencyType: typeof R3ResolvedDependencyType;\n}\nexport interface CoreEnvironment {\n    [name: string]: Function;\n}\nexport declare type StringMap = {\n    [key: string]: string;\n};\nexport declare type StringMapWithRename = {\n    [key: string]: string | [string, string];\n};\nexport declare type Provider = any;\nexport declare enum R3ResolvedDependencyType {\n    Token = 0,\n    Attribute = 1\n}\nexport interface R3DependencyMetadataFacade {\n    token: any;\n    resolved: R3ResolvedDependencyType;\n    host: boolean;\n    optional: boolean;\n    self: boolean;\n    skipSelf: boolean;\n}\nexport interface R3PipeMetadataFacade {\n    name: string;\n    type: any;\n    pipeName: string;\n    deps: R3DependencyMetadataFacade[] | null;\n    pure: boolean;\n}\nexport interface R3InjectableMetadataFacade {\n    name: string;\n    type: any;\n    ctorDeps: R3DependencyMetadataFacade[] | null;\n    providedIn: any;\n    useClass?: any;\n    useFactory?: any;\n    useExisting?: any;\n    useValue?: any;\n    userDeps?: R3DependencyMetadataFacade[];\n}\nexport interface R3NgModuleMetadataFacade {\n    type: any;\n    bootstrap: Function[];\n    declarations: Function[];\n    imports: Function[];\n    exports: Function[];\n    emitInline: boolean;\n}\nexport interface R3InjectorMetadataFacade {\n    name: string;\n    type: any;\n    deps: R3DependencyMetadataFacade[] | null;\n    providers: any;\n    imports: any;\n}\nexport interface R3DirectiveMetadataFacade {\n    name: string;\n    type: any;\n    typeArgumentCount: number;\n    typeSourceSpan: null;\n    deps: R3DependencyMetadataFacade[] | null;\n    selector: string | null;\n    queries: R3QueryMetadataFacade[];\n    host: {\n        [key: string]: string;\n    };\n    propMetadata: {\n        [key: string]: any[];\n    };\n    lifecycle: {\n        usesOnChanges: boolean;\n    };\n    inputs: string[];\n    outputs: string[];\n    usesInheritance: boolean;\n    exportAs: string | null;\n    providers: Provider[] | null;\n}\nexport interface R3ComponentMetadataFacade extends R3DirectiveMetadataFacade {\n    template: string;\n    preserveWhitespaces: boolean;\n    animations: any[] | undefined;\n    viewQueries: R3QueryMetadataFacade[];\n    pipes: Map<string, any>;\n    directives: Map<string, any>;\n    styles: string[];\n    encapsulation: ViewEncapsulation;\n    viewProviders: Provider[] | null;\n}\nexport declare type ViewEncapsulation = number;\nexport interface R3QueryMetadataFacade {\n    propertyName: string;\n    first: boolean;\n    predicate: any | string[];\n    descendants: boolean;\n    read: any | null;\n}\n"
  },
  {
    "path": "node_modules/@angular/core/src/render3/jit/compiler_facade.d.ts",
    "content": "import { CompilerFacade } from './compiler_facade_interface';\nexport * from './compiler_facade_interface';\nexport declare function getCompilerFacade(): CompilerFacade;\n"
  },
  {
    "path": "node_modules/@angular/core/src/render3/jit/directive.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { Query } from '../../metadata/di';\nimport { Component, Directive } from '../../metadata/directives';\nimport { Type } from '../../type';\nimport { R3QueryMetadataFacade } from './compiler_facade_interface';\n/**\n * Compile an Angular component according to its decorator metadata, and patch the resulting\n * ngComponentDef onto the component type.\n *\n * Compilation may be asynchronous (due to the need to resolve URLs for the component template or\n * other resources, for example). In the event that compilation is not immediate, `compileComponent`\n * will enqueue resource resolution into a global queue and will fail to return the `ngComponentDef`\n * until the global queue has been resolved with a call to `resolveComponentResources`.\n */\nexport declare function compileComponent(type: Type<any>, metadata: Component): void;\n/**\n * Compile an Angular directive according to its decorator metadata, and patch the resulting\n * ngDirectiveDef onto the component type.\n *\n * In the event that compilation is not immediate, `compileDirective` will return a `Promise` which\n * will resolve when compilation completes and the directive becomes usable.\n */\nexport declare function compileDirective(type: Type<any>, directive: Directive): void;\nexport declare function extendsDirectlyFromObject(type: Type<any>): boolean;\nexport declare function convertToR3QueryMetadata(propertyName: string, ann: Query): R3QueryMetadataFacade;\n"
  },
  {
    "path": "node_modules/@angular/core/src/render3/jit/environment.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * A mapping of the @angular/core API surface used in generated expressions to the actual symbols.\n *\n * This should be kept up to date with the public exports of @angular/core.\n */\nexport declare const angularCoreEnv: {\n    [name: string]: Function;\n};\n"
  },
  {
    "path": "node_modules/@angular/core/src/render3/jit/injectable.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { Injectable } from '../../di/injectable';\nimport { Type } from '../../type';\n/**\n * Compile an Angular injectable according to its `Injectable` metadata, and patch the resulting\n * `ngInjectableDef` onto the injectable type.\n */\nexport declare function compileInjectable(type: Type<any>, srcMeta?: Injectable): void;\n"
  },
  {
    "path": "node_modules/@angular/core/src/render3/jit/module.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { NgModule, NgModuleTransitiveScopes } from '../../metadata/ng_module';\nimport { Type } from '../../type';\nimport { ComponentDef } from '../interfaces/definition';\n/**\n * Compiles a module in JIT mode.\n *\n * This function automatically gets called when a class has a `@NgModule` decorator.\n */\nexport declare function compileNgModule(moduleType: Type<any>, ngModule: NgModule): void;\n/**\n * Compiles and adds the `ngModuleDef` and `ngInjectorDef` properties to the module class.\n */\nexport declare function compileNgModuleDefs(moduleType: Type<any>, ngModule: NgModule): void;\n/**\n * Patch the definition of a component with directives and pipes from the compilation scope of\n * a given module.\n */\nexport declare function patchComponentDefWithScope<C>(componentDef: ComponentDef<C>, transitiveScopes: NgModuleTransitiveScopes): void;\n/**\n * Compute the pair of transitive scopes (compilation scope and exported scope) for a given module.\n *\n * This operation is memoized and the result is cached on the module's definition. It can be called\n * on modules with components that have not fully compiled yet, but the result should not be used\n * until they have.\n */\nexport declare function transitiveScopesFor<T>(moduleType: Type<T>): NgModuleTransitiveScopes;\n"
  },
  {
    "path": "node_modules/@angular/core/src/render3/jit/pipe.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { Pipe } from '../../metadata/directives';\nimport { Type } from '../../type';\nexport declare function compilePipe(type: Type<any>, meta: Pipe): void;\n"
  },
  {
    "path": "node_modules/@angular/core/src/render3/jit/util.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { ReflectionCapabilities } from '../../reflection/reflection_capabilities';\nimport { Type } from '../../type';\nimport { R3DependencyMetadataFacade } from './compiler_facade';\nexport declare function getReflect(): ReflectionCapabilities;\nexport declare function reflectDependencies(type: Type<any>): R3DependencyMetadataFacade[];\nexport declare function convertDependencies(deps: any[]): R3DependencyMetadataFacade[];\n"
  },
  {
    "path": "node_modules/@angular/core/src/render3/metadata.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { Type } from '../type';\n/**\n * Adds decorator, constructor, and property metadata to a given type via static metadata fields\n * on the type.\n *\n * These metadata fields can later be read with Angular's `ReflectionCapabilities` API.\n *\n * Calls to `setClassMetadata` can be marked as pure, resulting in the metadata assignments being\n * tree-shaken away during production builds.\n */\nexport declare function setClassMetadata(type: Type<any>, decorators: any[] | null, ctorParameters: any[] | null, propDecorators: {\n    [field: string]: any;\n} | null): void;\n"
  },
  {
    "path": "node_modules/@angular/core/src/render3/ng_dev_mode.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\ndeclare global {\n    const ngDevMode: null | NgDevModePerfCounters;\n    interface NgDevModePerfCounters {\n        firstTemplatePass: number;\n        tNode: number;\n        tView: number;\n        rendererCreateTextNode: number;\n        rendererSetText: number;\n        rendererCreateElement: number;\n        rendererAddEventListener: number;\n        rendererSetAttribute: number;\n        rendererRemoveAttribute: number;\n        rendererSetProperty: number;\n        rendererSetClassName: number;\n        rendererAddClass: number;\n        rendererRemoveClass: number;\n        rendererSetStyle: number;\n        rendererRemoveStyle: number;\n        rendererDestroy: number;\n        rendererDestroyNode: number;\n        rendererMoveNode: number;\n        rendererRemoveNode: number;\n        rendererCreateComment: number;\n    }\n}\nexport declare function ngDevModeResetPerfCounters(): NgDevModePerfCounters;\n"
  },
  {
    "path": "node_modules/@angular/core/src/render3/ng_module_ref.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { Injector } from '../di/injector';\nimport { StaticProvider } from '../di/provider';\nimport { ComponentFactoryResolver as viewEngine_ComponentFactoryResolver } from '../linker/component_factory_resolver';\nimport { InternalNgModuleRef, NgModuleFactory as viewEngine_NgModuleFactory, NgModuleRef as viewEngine_NgModuleRef } from '../linker/ng_module_factory';\nimport { NgModuleDef } from '../metadata/ng_module';\nimport { Type } from '../type';\nexport interface NgModuleType {\n    ngModuleDef: NgModuleDef<any>;\n}\nexport declare const COMPONENT_FACTORY_RESOLVER: StaticProvider;\nexport declare class NgModuleRef<T> extends viewEngine_NgModuleRef<T> implements InternalNgModuleRef<T> {\n    _bootstrapComponents: Type<any>[];\n    injector: Injector;\n    componentFactoryResolver: viewEngine_ComponentFactoryResolver;\n    instance: T;\n    destroyCbs: (() => void)[] | null;\n    constructor(ngModuleType: Type<T>, parentInjector: Injector | null);\n    destroy(): void;\n    onDestroy(callback: () => void): void;\n}\nexport declare class NgModuleFactory<T> extends viewEngine_NgModuleFactory<T> {\n    moduleType: Type<T>;\n    constructor(moduleType: Type<T>);\n    create(parentInjector: Injector | null): viewEngine_NgModuleRef<T>;\n}\n"
  },
  {
    "path": "node_modules/@angular/core/src/render3/node_assert.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { TNode, TNodeType } from './interfaces/node';\nexport declare function assertNodeType(tNode: TNode, type: TNodeType): void;\nexport declare function assertNodeOfPossibleTypes(tNode: TNode, ...types: TNodeType[]): void;\n"
  },
  {
    "path": "node_modules/@angular/core/src/render3/node_manipulation.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { LContainer } from './interfaces/container';\nimport { TContainerNode, TElementContainerNode, TElementNode, TNode, TViewNode } from './interfaces/node';\nimport { RComment, RElement, RNode, RText, Renderer3 } from './interfaces/renderer';\nimport { LViewData } from './interfaces/view';\n/** Retrieves the parent element of a given node. */\nexport declare function getParentNative(tNode: TNode, currentView: LViewData): RElement | RComment | null;\n/**\n * Gets the host element given a view. Will return null if the current view is an embedded view,\n * which does not have a host element.\n */\nexport declare function getHostNative(currentView: LViewData): RElement | null;\nexport declare function getLContainer(tNode: TViewNode, embeddedView: LViewData): LContainer | null;\n/**\n * Retrieves render parent for a given view.\n * Might be null if a view is not yet attached to any container.\n */\nexport declare function getContainerRenderParent(tViewNode: TViewNode, view: LViewData): RElement | null;\n/**\n * Given a current view, finds the nearest component's host (LElement).\n *\n * @param lViewData LViewData for which we want a host element node\n * @returns The host node\n */\nexport declare function findComponentView(lViewData: LViewData): LViewData;\nexport declare function createTextNode(value: any, renderer: Renderer3): RText;\n/**\n * Adds or removes all DOM elements associated with a view.\n *\n * Because some root nodes of the view may be containers, we sometimes need\n * to propagate deeply into the nested containers to remove all elements in the\n * views beneath it.\n *\n * @param viewToWalk The view from which elements should be added or removed\n * @param insertMode Whether or not elements should be added (if false, removing)\n * @param beforeNode The node before which elements should be added, if insert mode\n */\nexport declare function addRemoveViewFromContainer(viewToWalk: LViewData, insertMode: true, beforeNode: RNode | null): void;\nexport declare function addRemoveViewFromContainer(viewToWalk: LViewData, insertMode: false): void;\n/**\n * Traverses down and up the tree of views and containers to remove listeners and\n * call onDestroy callbacks.\n *\n * Notes:\n *  - Because it's used for onDestroy calls, it needs to be bottom-up.\n *  - Must process containers instead of their views to avoid splicing\n *  when views are destroyed and re-added.\n *  - Using a while loop because it's faster than recursion\n *  - Destroy only called on movement to sibling or movement to parent (laterally or up)\n *\n *  @param rootView The view to destroy\n */\nexport declare function destroyViewTree(rootView: LViewData): void;\n/**\n * Inserts a view into a container.\n *\n * This adds the view to the container's array of active views in the correct\n * position. It also adds the view's elements to the DOM if the container isn't a\n * root node of another view (in that case, the view's elements will be added when\n * the container's parent view is added later).\n *\n * @param lView The view to insert\n * @param lContainer The container into which the view should be inserted\n * @param parentView The new parent of the inserted view\n * @param index The index at which to insert the view\n * @param containerIndex The index of the container node, if dynamic\n */\nexport declare function insertView(lView: LViewData, lContainer: LContainer, parentView: LViewData, index: number, containerIndex: number): void;\n/**\n * Detaches a view from a container.\n *\n * This method splices the view from the container's array of active views. It also\n * removes the view's elements from the DOM.\n *\n * @param lContainer The container from which to detach a view\n * @param removeIndex The index of the view to detach\n * @param detached Whether or not this view is already detached.\n */\nexport declare function detachView(lContainer: LContainer, removeIndex: number, detached: boolean): void;\n/**\n * Removes a view from a container, i.e. detaches it and then destroys the underlying LView.\n *\n * @param lContainer The container from which to remove a view\n * @param tContainer The TContainer node associated with the LContainer\n * @param removeIndex The index of the view to remove\n */\nexport declare function removeView(lContainer: LContainer, containerHost: TElementNode | TContainerNode | TElementContainerNode, removeIndex: number): void;\n/** Gets the child of the given LViewData */\nexport declare function getLViewChild(viewData: LViewData): LViewData | LContainer | null;\n/**\n * A standalone function which destroys an LView,\n * conducting cleanup (e.g. removing listeners, calling onDestroys).\n *\n * @param view The view to be destroyed.\n */\nexport declare function destroyLView(view: LViewData): void;\n/**\n * Determines which LViewOrLContainer to jump to when traversing back up the\n * tree in destroyViewTree.\n *\n * Normally, the view's parent LView should be checked, but in the case of\n * embedded views, the container (which is the view node's parent, but not the\n * LView's parent) needs to be checked for a possible next property.\n *\n * @param state The LViewOrLContainer for which we need a parent state\n * @param rootView The rootView, so we don't propagate too far up the view tree\n * @returns The correct parent LViewOrLContainer\n */\nexport declare function getParentState(state: LViewData | LContainer, rootView: LViewData): LViewData | LContainer | null;\nexport declare function getRenderParent(tNode: TNode, currentView: LViewData): RElement | null;\n/**\n * Returns whether a native element can be inserted into the given parent.\n *\n * There are two reasons why we may not be able to insert a element immediately.\n * - Projection: When creating a child content element of a component, we have to skip the\n *   insertion because the content of a component will be projected.\n *   `<component><content>delayed due to projection</content></component>`\n * - Parent container is disconnected: This can happen when we are inserting a view into\n *   parent container, which itself is disconnected. For example the parent container is part\n *   of a View which has not be inserted or is mare for projection but has not been inserted\n *   into destination.\n *\n\n *\n * @param tNode The tNode of the node that we want to insert.\n * @param currentView Current LView being processed.\n * @return boolean Whether the node should be inserted now (or delayed until later).\n */\nexport declare function canInsertNativeNode(tNode: TNode, currentView: LViewData): boolean;\n/**\n * Inserts a native node before another native node for a given parent using {@link Renderer3}.\n * This is a utility function that can be used when native nodes were determined - it abstracts an\n * actual renderer being used.\n */\nexport declare function nativeInsertBefore(renderer: Renderer3, parent: RElement, child: RNode, beforeNode: RNode | null): void;\n/**\n * Returns a native parent of a given native node.\n */\nexport declare function nativeParentNode(renderer: Renderer3, node: RNode): RElement | null;\n/**\n * Returns a native sibling of a given native node.\n */\nexport declare function nativeNextSibling(renderer: Renderer3, node: RNode): RNode | null;\n/**\n * Appends the `child` element to the `parent`.\n *\n * The element insertion might be delayed {@link canInsertNativeNode}.\n *\n * @param childEl The child that should be appended\n * @param childTNode The TNode of the child element\n * @param currentView The current LView\n * @returns Whether or not the child was appended\n */\nexport declare function appendChild(childEl: RNode | null | undefined, childTNode: TNode, currentView: LViewData): boolean;\nexport declare function getBeforeNodeForView(index: number, views: LViewData[], containerNative: RComment): RComment;\n/**\n * Removes the `child` element from the DOM if not in view and not projected.\n *\n * @param childTNode The TNode of the child to remove\n * @param childEl The child that should be removed\n * @param currentView The current LView\n * @returns Whether or not the child was removed\n */\nexport declare function removeChild(childTNode: TNode, childEl: RNode | null, currentView: LViewData): boolean;\n/**\n * Appends a projected node to the DOM, or in the case of a projected container,\n * appends the nodes from all of the container's active views to the DOM.\n *\n * @param projectedTNode The TNode to be projected\n * @param tProjectionNode The projection (ng-content) TNode\n * @param currentView Current LView\n * @param projectionView Projection view (view above current)\n */\nexport declare function appendProjectedNode(projectedTNode: TNode, tProjectionNode: TNode, currentView: LViewData, projectionView: LViewData): void;\n"
  },
  {
    "path": "node_modules/@angular/core/src/render3/node_selector_matcher.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport './ng_dev_mode';\nimport { TNode } from './interfaces/node';\nimport { CssSelector, CssSelectorList } from './interfaces/projection';\n/**\n * A utility function to match an Ivy node static data against a simple CSS selector\n *\n * @param node static data to match\n * @param selector\n * @returns true if node matches the selector.\n */\nexport declare function isNodeMatchingSelector(tNode: TNode, selector: CssSelector): boolean;\nexport declare function isNodeMatchingSelectorList(tNode: TNode, selector: CssSelectorList): boolean;\nexport declare function getProjectAsAttrValue(tNode: TNode): string | null;\n/**\n * Checks a given node against matching selectors and returns\n * selector index (or 0 if none matched).\n *\n * This function takes into account the ngProjectAs attribute: if present its value will be compared\n * to the raw (un-parsed) CSS selector instead of using standard selector matching logic.\n */\nexport declare function matchingSelectorIndex(tNode: TNode, selectors: CssSelectorList[], textSelectors: string[]): number;\n"
  },
  {
    "path": "node_modules/@angular/core/src/render3/pipe.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Create a pipe.\n *\n * @param index Pipe index where the pipe will be stored.\n * @param pipeName The name of the pipe\n * @returns T the instance of the pipe.\n */\nexport declare function pipe(index: number, pipeName: string): any;\n/**\n * Invokes a pipe with 1 arguments.\n *\n * This instruction acts as a guard to {@link PipeTransform#transform} invoking\n * the pipe only when an input to the pipe changes.\n *\n * @param index Pipe index where the pipe was stored on creation.\n * @param slotOffset the offset in the reserved slot space\n * @param v1 1st argument to {@link PipeTransform#transform}.\n */\nexport declare function pipeBind1(index: number, slotOffset: number, v1: any): any;\n/**\n * Invokes a pipe with 2 arguments.\n *\n * This instruction acts as a guard to {@link PipeTransform#transform} invoking\n * the pipe only when an input to the pipe changes.\n *\n * @param index Pipe index where the pipe was stored on creation.\n * @param slotOffset the offset in the reserved slot space\n * @param v1 1st argument to {@link PipeTransform#transform}.\n * @param v2 2nd argument to {@link PipeTransform#transform}.\n */\nexport declare function pipeBind2(index: number, slotOffset: number, v1: any, v2: any): any;\n/**\n * Invokes a pipe with 3 arguments.\n *\n * This instruction acts as a guard to {@link PipeTransform#transform} invoking\n * the pipe only when an input to the pipe changes.\n *\n * @param index Pipe index where the pipe was stored on creation.\n * @param slotOffset the offset in the reserved slot space\n * @param v1 1st argument to {@link PipeTransform#transform}.\n * @param v2 2nd argument to {@link PipeTransform#transform}.\n * @param v3 4rd argument to {@link PipeTransform#transform}.\n */\nexport declare function pipeBind3(index: number, slotOffset: number, v1: any, v2: any, v3: any): any;\n/**\n * Invokes a pipe with 4 arguments.\n *\n * This instruction acts as a guard to {@link PipeTransform#transform} invoking\n * the pipe only when an input to the pipe changes.\n *\n * @param index Pipe index where the pipe was stored on creation.\n * @param slotOffset the offset in the reserved slot space\n * @param v1 1st argument to {@link PipeTransform#transform}.\n * @param v2 2nd argument to {@link PipeTransform#transform}.\n * @param v3 3rd argument to {@link PipeTransform#transform}.\n * @param v4 4th argument to {@link PipeTransform#transform}.\n */\nexport declare function pipeBind4(index: number, slotOffset: number, v1: any, v2: any, v3: any, v4: any): any;\n/**\n * Invokes a pipe with variable number of arguments.\n *\n * This instruction acts as a guard to {@link PipeTransform#transform} invoking\n * the pipe only when an input to the pipe changes.\n *\n * @param index Pipe index where the pipe was stored on creation.\n * @param slotOffset the offset in the reserved slot space\n * @param values Array of arguments to pass to {@link PipeTransform#transform} method.\n */\nexport declare function pipeBindV(index: number, slotOffset: number, values: any[]): any;\n"
  },
  {
    "path": "node_modules/@angular/core/src/render3/players.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport './ng_dev_mode';\nimport { ComponentInstance, DirectiveInstance, Player } from './interfaces/player';\n/**\n * Adds a player to an element, directive or component instance that will later be\n * animated once change detection has passed.\n *\n * When a player is added to a reference it will stay active until `player.destroy()`\n * is called. Once called then the player will be removed from the active players\n * present on the associated ref instance.\n *\n * To get a list of all the active players on an element see [getPlayers].\n *\n * @param ref The element, directive or component that the player will be placed on.\n * @param player The player that will be triggered to play once change detection has run.\n */\nexport declare function addPlayer(ref: ComponentInstance | DirectiveInstance | HTMLElement, player: Player): void;\n/**\n * Returns a list of all the active players present on the provided ref instance (which can\n * be an instance of a directive, component or element).\n *\n * This function will only return players that have been added to the ref instance using\n * `addPlayer` or any players that are active through any template styling bindings\n * (`[style]`, `[style.prop]`, `[class]` and `[class.name]`).\n *\n * @publicApi\n */\nexport declare function getPlayers(ref: ComponentInstance | DirectiveInstance | HTMLElement): Player[];\n"
  },
  {
    "path": "node_modules/@angular/core/src/render3/pure_function.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Bindings for pure functions are stored after regular bindings.\n *\n * |------consts------|---------vars---------|                 |----- hostVars (dir1) ------|\n * ------------------------------------------------------------------------------------------\n * | nodes/refs/pipes | bindings | fn slots  | injector | dir1 | host bindings | host slots |\n * ------------------------------------------------------------------------------------------\n *                    ^                      ^\n *      TView.bindingStartIndex      TView.expandoStartIndex\n *\n * Pure function instructions are given an offset from the binding root. Adding the offset to the\n * binding root gives the first index where the bindings are stored. In component views, the binding\n * root is the bindingStartIndex. In host bindings, the binding root is the expandoStartIndex +\n * any directive instances + any hostVars in directives evaluated before it.\n *\n * See VIEW_DATA.md for more information about host binding resolution.\n */\n/**\n * If the value hasn't been saved, calls the pure function to store and return the\n * value. If it has been saved, returns the saved value.\n *\n * @param slotOffset the offset from binding root to the reserved slot\n * @param pureFn Function that returns a value\n * @param thisArg Optional calling context of pureFn\n * @returns value\n */\nexport declare function pureFunction0<T>(slotOffset: number, pureFn: () => T, thisArg?: any): T;\n/**\n * If the value of the provided exp has changed, calls the pure function to return\n * an updated value. Or if the value has not changed, returns cached value.\n *\n * @param slotOffset the offset from binding root to the reserved slot\n * @param pureFn Function that returns an updated value\n * @param exp Updated expression value\n * @param thisArg Optional calling context of pureFn\n * @returns Updated or cached value\n */\nexport declare function pureFunction1(slotOffset: number, pureFn: (v: any) => any, exp: any, thisArg?: any): any;\n/**\n * If the value of any provided exp has changed, calls the pure function to return\n * an updated value. Or if no values have changed, returns cached value.\n *\n * @param slotOffset the offset from binding root to the reserved slot\n * @param pureFn\n * @param exp1\n * @param exp2\n * @param thisArg Optional calling context of pureFn\n * @returns Updated or cached value\n */\nexport declare function pureFunction2(slotOffset: number, pureFn: (v1: any, v2: any) => any, exp1: any, exp2: any, thisArg?: any): any;\n/**\n * If the value of any provided exp has changed, calls the pure function to return\n * an updated value. Or if no values have changed, returns cached value.\n *\n * @param slotOffset the offset from binding root to the reserved slot\n * @param pureFn\n * @param exp1\n * @param exp2\n * @param exp3\n * @param thisArg Optional calling context of pureFn\n * @returns Updated or cached value\n */\nexport declare function pureFunction3(slotOffset: number, pureFn: (v1: any, v2: any, v3: any) => any, exp1: any, exp2: any, exp3: any, thisArg?: any): any;\n/**\n * If the value of any provided exp has changed, calls the pure function to return\n * an updated value. Or if no values have changed, returns cached value.\n *\n * @param slotOffset the offset from binding root to the reserved slot\n * @param pureFn\n * @param exp1\n * @param exp2\n * @param exp3\n * @param exp4\n * @param thisArg Optional calling context of pureFn\n * @returns Updated or cached value\n */\nexport declare function pureFunction4(slotOffset: number, pureFn: (v1: any, v2: any, v3: any, v4: any) => any, exp1: any, exp2: any, exp3: any, exp4: any, thisArg?: any): any;\n/**\n * If the value of any provided exp has changed, calls the pure function to return\n * an updated value. Or if no values have changed, returns cached value.\n *\n * @param slotOffset the offset from binding root to the reserved slot\n * @param pureFn\n * @param exp1\n * @param exp2\n * @param exp3\n * @param exp4\n * @param exp5\n * @param thisArg Optional calling context of pureFn\n * @returns Updated or cached value\n */\nexport declare function pureFunction5(slotOffset: number, pureFn: (v1: any, v2: any, v3: any, v4: any, v5: any) => any, exp1: any, exp2: any, exp3: any, exp4: any, exp5: any, thisArg?: any): any;\n/**\n * If the value of any provided exp has changed, calls the pure function to return\n * an updated value. Or if no values have changed, returns cached value.\n *\n * @param slotOffset the offset from binding root to the reserved slot\n * @param pureFn\n * @param exp1\n * @param exp2\n * @param exp3\n * @param exp4\n * @param exp5\n * @param exp6\n * @param thisArg Optional calling context of pureFn\n * @returns Updated or cached value\n */\nexport declare function pureFunction6(slotOffset: number, pureFn: (v1: any, v2: any, v3: any, v4: any, v5: any, v6: any) => any, exp1: any, exp2: any, exp3: any, exp4: any, exp5: any, exp6: any, thisArg?: any): any;\n/**\n * If the value of any provided exp has changed, calls the pure function to return\n * an updated value. Or if no values have changed, returns cached value.\n *\n * @param slotOffset the offset from binding root to the reserved slot\n * @param pureFn\n * @param exp1\n * @param exp2\n * @param exp3\n * @param exp4\n * @param exp5\n * @param exp6\n * @param exp7\n * @param thisArg Optional calling context of pureFn\n * @returns Updated or cached value\n */\nexport declare function pureFunction7(slotOffset: number, pureFn: (v1: any, v2: any, v3: any, v4: any, v5: any, v6: any, v7: any) => any, exp1: any, exp2: any, exp3: any, exp4: any, exp5: any, exp6: any, exp7: any, thisArg?: any): any;\n/**\n * If the value of any provided exp has changed, calls the pure function to return\n * an updated value. Or if no values have changed, returns cached value.\n *\n * @param slotOffset the offset from binding root to the reserved slot\n * @param pureFn\n * @param exp1\n * @param exp2\n * @param exp3\n * @param exp4\n * @param exp5\n * @param exp6\n * @param exp7\n * @param exp8\n * @param thisArg Optional calling context of pureFn\n * @returns Updated or cached value\n */\nexport declare function pureFunction8(slotOffset: number, pureFn: (v1: any, v2: any, v3: any, v4: any, v5: any, v6: any, v7: any, v8: any) => any, exp1: any, exp2: any, exp3: any, exp4: any, exp5: any, exp6: any, exp7: any, exp8: any, thisArg?: any): any;\n/**\n * pureFunction instruction that can support any number of bindings.\n *\n * If the value of any provided exp has changed, calls the pure function to return\n * an updated value. Or if no values have changed, returns cached value.\n *\n * @param slotOffset the offset from binding root to the reserved slot\n * @param pureFn A pure function that takes binding values and builds an object or array\n * containing those values.\n * @param exps An array of binding values\n * @param thisArg Optional calling context of pureFn\n * @returns Updated or cached value\n */\nexport declare function pureFunctionV(slotOffset: number, pureFn: (...v: any[]) => any, exps: any[], thisArg?: any): any;\n"
  },
  {
    "path": "node_modules/@angular/core/src/render3/query.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { QueryList as viewEngine_QueryList } from '../linker/query_list';\nimport { Type } from '../type';\nimport { TContainerNode, TElementContainerNode, TElementNode } from './interfaces/node';\nimport { LQueries } from './interfaces/query';\n/**\n * A predicate which determines if a given element/directive should be included in the query\n * results.\n */\nexport interface QueryPredicate<T> {\n    /**\n     * If looking for directives then it contains the directive type.\n     */\n    type: Type<T> | null;\n    /**\n     * If selector then contains local names to query for.\n     */\n    selector: string[] | null;\n    /**\n     * Indicates which token should be read from DI for this query.\n     */\n    read: Type<T> | null;\n}\n/**\n * An object representing a query, which is a combination of:\n * - query predicate to determines if a given element/directive should be included in the query\n * - values collected based on a predicate\n * - `QueryList` to which collected values should be reported\n */\nexport interface LQuery<T> {\n    /**\n     * Next query. Used when queries are stored as a linked list in `LQueries`.\n     */\n    next: LQuery<any> | null;\n    /**\n     * Destination to which the value should be added.\n     */\n    list: QueryList<T>;\n    /**\n     * A predicate which determines if a given element/directive should be included in the query\n     * results.\n     */\n    predicate: QueryPredicate<T>;\n    /**\n     * Values which have been located.\n     *\n     * This is what builds up the `QueryList._valuesTree`.\n     */\n    values: any[];\n    /**\n     * A pointer to an array that stores collected values from views. This is necessary so we know a\n     * container into which to insert nodes collected from views.\n     */\n    containerValues: any[] | null;\n}\nexport declare class LQueries_ implements LQueries {\n    parent: LQueries_ | null;\n    private shallow;\n    private deep;\n    constructor(parent: LQueries_ | null, shallow: LQuery<any> | null, deep: LQuery<any> | null);\n    track<T>(queryList: viewEngine_QueryList<T>, predicate: Type<T> | string[], descend?: boolean, read?: Type<T>): void;\n    clone(): LQueries;\n    container(): LQueries | null;\n    createView(): LQueries | null;\n    insertView(index: number): void;\n    addNode(tNode: TElementNode | TContainerNode | TElementContainerNode): LQueries | null;\n    removeView(): void;\n}\nexport declare type QueryList<T> = viewEngine_QueryList<T>;\nexport declare const QueryList: typeof viewEngine_QueryList;\n/**\n * Creates and returns a QueryList.\n *\n * @param memoryIndex The index in memory where the QueryList should be saved. If null,\n * this is is a content query and the QueryList will be saved later through directiveCreate.\n * @param predicate The type for which the query will search\n * @param descend Whether or not to descend into children\n * @param read What to save in the query\n * @returns QueryList<T>\n */\nexport declare function query<T>(memoryIndex: number | null, predicate: Type<any> | string[], descend?: boolean, read?: any): QueryList<T>;\n/**\n * Refreshes a query by combining matches from all active views and removing matches from deleted\n * views.\n * Returns true if a query got dirty during change detection, false otherwise.\n */\nexport declare function queryRefresh(queryList: QueryList<any>): boolean;\n"
  },
  {
    "path": "node_modules/@angular/core/src/render3/state.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { Sanitizer } from '../sanitization/security';\nimport { TElementNode, TNode, TViewNode } from './interfaces/node';\nimport { LQueries } from './interfaces/query';\nimport { Renderer3, RendererFactory3 } from './interfaces/renderer';\nimport { LViewData, OpaqueViewState, TView } from './interfaces/view';\nexport declare function getRenderer(): Renderer3;\nexport declare function setRenderer(r: Renderer3): void;\nexport declare function getRendererFactory(): RendererFactory3;\nexport declare function setRendererFactory(factory: RendererFactory3): void;\nexport declare function getCurrentSanitizer(): Sanitizer | null;\nexport declare function getElementDepthCount(): number;\nexport declare function increaseElementDepthCount(): void;\nexport declare function decreaseElementDepthCount(): void;\nexport declare function getBindingsEnabled(): boolean;\n/**\n * Enables directive matching on elements.\n *\n *  * Example:\n * ```\n * <my-comp my-directive>\n *   Should match component / directive.\n * </my-comp>\n * <div ngNonBindable>\n *   <!-- disabledBindings() -->\n *   <my-comp my-directive>\n *     Should not match component / directive because we are in ngNonBindable.\n *   </my-comp>\n *   <!-- enableBindings() -->\n * </div>\n * ```\n */\nexport declare function enableBindings(): void;\n/**\n * Disables directive matching on element.\n *\n *  * Example:\n * ```\n * <my-comp my-directive>\n *   Should match component / directive.\n * </my-comp>\n * <div ngNonBindable>\n *   <!-- disabledBindings() -->\n *   <my-comp my-directive>\n *     Should not match component / directive because we are in ngNonBindable.\n *   </my-comp>\n *   <!-- enableBindings() -->\n * </div>\n * ```\n */\nexport declare function disableBindings(): void;\n/**\n * Returns the current OpaqueViewState instance.\n *\n * Used in conjunction with the restoreView() instruction to save a snapshot\n * of the current view and restore it when listeners are invoked. This allows\n * walking the declaration view tree in listeners to get vars from parent views.\n */\nexport declare function getCurrentView(): OpaqueViewState;\nexport declare function _getViewData(): LViewData;\n/**\n * Restores `contextViewData` to the given OpaqueViewState instance.\n *\n * Used in conjunction with the getCurrentView() instruction to save a snapshot\n * of the current view and restore it when listeners are invoked. This allows\n * walking the declaration view tree in listeners to get vars from parent views.\n *\n * @param viewToRestore The OpaqueViewState instance to restore.\n */\nexport declare function restoreView(viewToRestore: OpaqueViewState): void;\nexport declare function getPreviousOrParentTNode(): TNode;\nexport declare function setPreviousOrParentTNode(tNode: TNode): void;\nexport declare function setTNodeAndViewData(tNode: TNode, view: LViewData): void;\nexport declare function getIsParent(): boolean;\nexport declare function setIsParent(value: boolean): void;\nexport declare function getTView(): TView;\nexport declare function getCurrentQueries(): LQueries | null;\nexport declare function setCurrentQueries(queries: LQueries | null): void;\n/**\n * Query instructions can ask for \"current queries\" in 2 different cases:\n * - when creating view queries (at the root of a component view, before any node is created - in\n * this case currentQueries points to view queries)\n * - when creating content queries (i.e. this previousOrParentTNode points to a node on which we\n * create content queries).\n */\nexport declare function getOrCreateCurrentQueries(QueryType: {\n    new (parent: null, shallow: null, deep: null): LQueries;\n}): LQueries;\nexport declare function getCreationMode(): boolean;\n/**\n * Internal function that returns the current LViewData instance.\n *\n * The getCurrentView() instruction should be used for anything public.\n */\nexport declare function getViewData(): LViewData;\nexport declare function getContextViewData(): LViewData;\nexport declare function getCleanup(view: LViewData): any[];\nexport declare function getTViewCleanup(view: LViewData): any[];\nexport declare function getCheckNoChangesMode(): boolean;\nexport declare function setCheckNoChangesMode(mode: boolean): void;\nexport declare function getFirstTemplatePass(): boolean;\nexport declare function setFirstTemplatePass(value: boolean): void;\nexport declare function getBindingRoot(): number;\nexport declare function setBindingRoot(value: number): void;\n/**\n * Swap the current state with a new state.\n *\n * For performance reasons we store the state in the top level of the module.\n * This way we minimize the number of properties to read. Whenever a new view\n * is entered we have to store the state for later, and when the view is\n * exited the state has to be restored\n *\n * @param newView New state to become active\n * @param host Element to which the View is a child of\n * @returns the previous state;\n */\nexport declare function enterView(newView: LViewData, hostTNode: TElementNode | TViewNode | null): LViewData;\nexport declare function nextContextImpl<T = any>(level?: number): T;\n/**\n * Resets the application state.\n */\nexport declare function resetComponentState(): void;\n/**\n * Used in lieu of enterView to make it clear when we are exiting a child view. This makes\n * the direction of traversal (up or down the view tree) a bit clearer.\n *\n * @param newView New state to become active\n * @param creationOnly An optional boolean to indicate that the view was processed in creation mode\n * only, i.e. the first update will be done later. Only possible for dynamically created views.\n */\nexport declare function leaveView(newView: LViewData, creationOnly?: boolean): void;\nexport declare function assertPreviousIsParent(): void;\nexport declare function assertHasParent(): void;\nexport declare function assertDataInRange(index: number, arr?: any[]): void;\nexport declare function assertDataNext(index: number, arr?: any[]): void;\n"
  },
  {
    "path": "node_modules/@angular/core/src/render3/styling/class_and_style_bindings.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { StyleSanitizeFn } from '../../sanitization/style_sanitizer';\nimport { InitialStylingFlags } from '../interfaces/definition';\nimport { BindingStore, BindingType, Player, PlayerBuilder, PlayerFactory } from '../interfaces/player';\nimport { Renderer3 } from '../interfaces/renderer';\nimport { StylingContext } from '../interfaces/styling';\nimport { LViewData, RootContext } from '../interfaces/view';\nimport { NO_CHANGE } from '../tokens';\nimport { BoundPlayerFactory } from './player_factory';\n/**\n * Creates a styling context template where styling information is stored.\n * Any styles that are later referenced using `updateStyleProp` must be\n * passed in within this function. Initial values for those styles are to\n * be declared after all initial style properties are declared (this change in\n * mode between declarations and initial styles is made possible using a special\n * enum value found in `definition.ts`).\n *\n * @param initialStyleDeclarations a list of style declarations and initial style values\n *    that are used later within the styling context.\n *\n *    -> ['width', 'height', SPECIAL_ENUM_VAL, 'width', '100px']\n *       This implies that `width` and `height` will be later styled and that the `width`\n *       property has an initial value of `100px`.\n *\n * @param initialClassDeclarations a list of class declarations and initial class values\n *    that are used later within the styling context.\n *\n *    -> ['foo', 'bar', SPECIAL_ENUM_VAL, 'foo', true]\n *       This implies that `foo` and `bar` will be later styled and that the `foo`\n *       class will be applied to the element as an initial class since it's true\n */\nexport declare function createStylingContextTemplate(initialClassDeclarations?: (string | boolean | InitialStylingFlags)[] | null, initialStyleDeclarations?: (string | boolean | InitialStylingFlags)[] | null, styleSanitizer?: StyleSanitizeFn | null, onlyProcessSingleClasses?: boolean): StylingContext;\n/**\n * Sets and resolves all `multi` styling on an `StylingContext` so that they can be\n * applied to the element once `renderStyleAndClassBindings` is called.\n *\n * All missing styles/class (any values that are not provided in the new `styles`\n * or `classes` params) will resolve to `null` within their respective positions\n * in the context.\n *\n * @param context The styling context that will be updated with the\n *    newly provided style values.\n * @param classesInput The key/value map of CSS class names that will be used for the update.\n * @param stylesInput The key/value map of CSS styles that will be used for the update.\n */\nexport declare function updateStylingMap(context: StylingContext, classesInput: {\n    [key: string]: any;\n} | string | BoundPlayerFactory<null | string | {\n    [key: string]: any;\n}> | NO_CHANGE | null, stylesInput?: {\n    [key: string]: any;\n} | BoundPlayerFactory<null | {\n    [key: string]: any;\n}> | NO_CHANGE | null): void;\n/**\n * Sets and resolves a single styling property/value on the provided `StylingContext` so\n * that they can be applied to the element once `renderStyleAndClassBindings` is called.\n *\n * Note that prop-level styling values are considered higher priority than any styling that\n * has been applied using `updateStylingMap`, therefore, when styling values are rendered\n * then any styles/classes that have been applied using this function will be considered first\n * (then multi values second and then initial values as a backup).\n *\n * @param context The styling context that will be updated with the\n *    newly provided style value.\n * @param index The index of the property which is being updated.\n * @param value The CSS style value that will be assigned\n */\nexport declare function updateStyleProp(context: StylingContext, index: number, input: string | boolean | null | BoundPlayerFactory<string | boolean | null>): void;\n/**\n * This method will toggle the referenced CSS class (by the provided index)\n * within the given context.\n *\n * @param context The styling context that will be updated with the\n *    newly provided class value.\n * @param index The index of the CSS class which is being updated.\n * @param addOrRemove Whether or not to add or remove the CSS class\n */\nexport declare function updateClassProp(context: StylingContext, index: number, addOrRemove: boolean | BoundPlayerFactory<boolean>): void;\n/**\n * Renders all queued styling using a renderer onto the given element.\n *\n * This function works by rendering any styles (that have been applied\n * using `updateStylingMap`) and any classes (that have been applied using\n * `updateStyleProp`) onto the provided element using the provided renderer.\n * Just before the styles/classes are rendered a final key/value style map\n * will be assembled (if `styleStore` or `classStore` are provided).\n *\n * @param lElement the element that the styles will be rendered on\n * @param context The styling context that will be used to determine\n *      what styles will be rendered\n * @param renderer the renderer that will be used to apply the styling\n * @param classesStore if provided, the updated class values will be applied\n *    to this key/value map instead of being renderered via the renderer.\n * @param stylesStore if provided, the updated style values will be applied\n *    to this key/value map instead of being renderered via the renderer.\n * @returns number the total amount of players that got queued for animation (if any)\n */\nexport declare function renderStyleAndClassBindings(context: StylingContext, renderer: Renderer3, rootOrView: RootContext | LViewData, isFirstRender: boolean, classesStore?: BindingStore | null, stylesStore?: BindingStore | null): number;\nexport declare function isContextDirty(context: StylingContext): boolean;\nexport declare function limitToSingleClasses(context: StylingContext): number;\nexport declare function setContextDirty(context: StylingContext, isDirtyYes: boolean): void;\nexport declare function setContextPlayersDirty(context: StylingContext, isDirtyYes: boolean): void;\nexport declare class ClassAndStylePlayerBuilder<T> implements PlayerBuilder {\n    private _element;\n    private _type;\n    private _values;\n    private _dirty;\n    private _factory;\n    constructor(factory: PlayerFactory, _element: HTMLElement, _type: BindingType);\n    setValue(prop: string, value: any): void;\n    buildPlayer(currentPlayer: Player | null, isFirstRender: boolean): Player | undefined | null;\n}\n"
  },
  {
    "path": "node_modules/@angular/core/src/render3/styling/core_player_handler.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { Player, PlayerHandler } from '../interfaces/player';\nexport declare class CorePlayerHandler implements PlayerHandler {\n    private _players;\n    flushPlayers(): void;\n    queuePlayer(player: Player): void;\n}\n"
  },
  {
    "path": "node_modules/@angular/core/src/render3/styling/player_factory.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { PlayerFactory, PlayerFactoryBuildFn } from '../interfaces/player';\n/**\n * Combines the binding value and a factory for an animation player.\n *\n * Used to bind a player to an element template binding (currently only\n * `[style]`, `[style.prop]`, `[class]` and `[class.name]` bindings\n * supported). The provided `factoryFn` function will be run once all\n * the associated bindings have been evaluated on the element and is\n * designed to return a player which will then be placed on the element.\n *\n * @param factoryFn The function that is used to create a player\n *   once all the rendering-related (styling values) have been\n *   processed for the element binding.\n * @param value The raw value that will be exposed to the binding\n *   so that the binding can update its internal values when\n *   any changes are evaluated.\n */\nexport declare function bindPlayerFactory<T>(factoryFn: PlayerFactoryBuildFn, value: T): PlayerFactory;\nexport declare class BoundPlayerFactory<T> {\n    fn: PlayerFactoryBuildFn;\n    value: T;\n    '__brand__': 'Brand for PlayerFactory that nothing will match';\n    constructor(fn: PlayerFactoryBuildFn, value: T);\n}\n"
  },
  {
    "path": "node_modules/@angular/core/src/render3/styling/util.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport '../ng_dev_mode';\nimport { StyleSanitizeFn } from '../../sanitization/style_sanitizer';\nimport { LContext } from '../interfaces/context';\nimport { Player, PlayerContext } from '../interfaces/player';\nimport { RElement } from '../interfaces/renderer';\nimport { InitialStyles, StylingContext } from '../interfaces/styling';\nimport { LViewData, RootContext } from '../interfaces/view';\nexport declare function createEmptyStylingContext(element?: RElement | null, sanitizer?: StyleSanitizeFn | null, initialStylingValues?: InitialStyles): StylingContext;\n/**\n * Used clone a copy of a pre-computed template of a styling context.\n *\n * A pre-computed template is designed to be computed once for a given element\n * (instructions.ts has logic for caching this).\n */\nexport declare function allocStylingContext(element: RElement | null, templateStyleContext: StylingContext): StylingContext;\n/**\n * Retrieve the `StylingContext` at a given index.\n *\n * This method lazily creates the `StylingContext`. This is because in most cases\n * we have styling without any bindings. Creating `StylingContext` eagerly would mean that\n * every style declaration such as `<div style=\"color: red\">` would result `StyleContext`\n * which would create unnecessary memory pressure.\n *\n * @param index Index of the style allocation. See: `elementStyling`.\n * @param viewData The view to search for the styling context\n */\nexport declare function getStylingContext(index: number, viewData: LViewData): StylingContext;\nexport declare function addPlayerInternal(playerContext: PlayerContext, rootContext: RootContext, element: HTMLElement, player: Player | null, playerContextIndex: number, ref?: any): boolean;\nexport declare function getPlayersInternal(playerContext: PlayerContext): Player[];\nexport declare function getOrCreatePlayerContext(target: {}, context?: LContext | null): PlayerContext | null;\nexport declare function getPlayerContext(stylingContext: StylingContext): PlayerContext | null;\nexport declare function allocPlayerContext(data: StylingContext): PlayerContext;\nexport declare function throwInvalidRefError(): void;\n"
  },
  {
    "path": "node_modules/@angular/core/src/render3/tokens.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nexport interface NO_CHANGE {\n    brand: 'NO_CHANGE';\n}\n/** A special value which designates that a value has not changed. */\nexport declare const NO_CHANGE: NO_CHANGE;\n"
  },
  {
    "path": "node_modules/@angular/core/src/render3/util.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { LContainer } from './interfaces/container';\nimport { LContext } from './interfaces/context';\nimport { ComponentDef, DirectiveDef } from './interfaces/definition';\nimport { RelativeInjectorLocation } from './interfaces/injector';\nimport { TContainerNode, TElementNode, TNode } from './interfaces/node';\nimport { RComment, RElement, RText } from './interfaces/renderer';\nimport { StylingContext } from './interfaces/styling';\nimport { LViewData, RootContext, TData } from './interfaces/view';\n/**\n * Returns whether the values are different from a change detection stand point.\n *\n * Constraints are relaxed in checkNoChanges mode. See `devModeEqual` for details.\n */\nexport declare function isDifferent(a: any, b: any, checkNoChangesMode: boolean): boolean;\nexport declare function stringify(value: any): string;\n/**\n * Flattens an array in non-recursive way. Input arrays are not modified.\n */\nexport declare function flatten(list: any[]): any[];\n/** Retrieves a value from any `LViewData` or `TData`. */\nexport declare function loadInternal<T>(index: number, arr: LViewData | TData): T;\nexport declare function assertDataInRangeInternal(index: number, arr: any[]): void;\n/**\n * Takes the value of a slot in `LViewData` and returns the element node.\n *\n * Normally, element nodes are stored flat, but if the node has styles/classes on it,\n * it might be wrapped in a styling context. Or if that node has a directive that injects\n * ViewContainerRef, it may be wrapped in an LContainer. Or if that node is a component,\n * it will be wrapped in LViewData. It could even have all three, so we keep looping\n * until we find something that isn't an array.\n *\n * @param value The initial value in `LViewData`\n */\nexport declare function readElementValue(value: RElement | StylingContext | LContainer | LViewData): RElement;\n/**\n * Retrieves an element value from the provided `viewData`, by unwrapping\n * from any containers, component views, or style contexts.\n */\nexport declare function getNativeByIndex(index: number, arr: LViewData): RElement;\nexport declare function getNativeByTNode(tNode: TNode, hostView: LViewData): RElement | RText | RComment;\nexport declare function getTNode(index: number, view: LViewData): TNode;\nexport declare function getComponentViewByIndex(nodeIndex: number, hostView: LViewData): LViewData;\nexport declare function isContentQueryHost(tNode: TNode): boolean;\nexport declare function isComponent(tNode: TNode): boolean;\nexport declare function isComponentDef<T>(def: DirectiveDef<T>): def is ComponentDef<T>;\nexport declare function isLContainer(value: RElement | RComment | LContainer | StylingContext): boolean;\nexport declare function isRootView(target: LViewData): boolean;\n/**\n * Retrieve the root view from any component by walking the parent `LViewData` until\n * reaching the root `LViewData`.\n *\n * @param component any component\n */\nexport declare function getRootView(target: LViewData | {}): LViewData;\nexport declare function getRootContext(viewOrComponent: LViewData | {}): RootContext;\n/**\n * Returns the monkey-patch value data present on the target (which could be\n * a component, directive or a DOM node).\n */\nexport declare function readPatchedData(target: any): LViewData | LContext | null;\nexport declare function readPatchedLViewData(target: any): LViewData | null;\nexport declare function hasParentInjector(parentLocation: RelativeInjectorLocation): boolean;\nexport declare function getParentInjectorIndex(parentLocation: RelativeInjectorLocation): number;\nexport declare function getParentInjectorViewOffset(parentLocation: RelativeInjectorLocation): number;\n/**\n * Unwraps a parent injector location number to find the view offset from the current injector,\n * then walks up the declaration view tree until the view is found that contains the parent\n * injector.\n *\n * @param location The location of the parent injector, which contains the view offset\n * @param startView The LViewData instance from which to start walking up the view tree\n * @returns The LViewData instance that contains the parent injector\n */\nexport declare function getParentInjectorView(location: RelativeInjectorLocation, startView: LViewData): LViewData;\n/**\n * Unwraps a parent injector location number to find the view offset from the current injector,\n * then walks up the declaration view tree until the TNode of the parent injector is found.\n *\n * @param location The location of the parent injector, which contains the view offset\n * @param startView The LViewData instance from which to start walking up the view tree\n * @param startTNode The TNode instance of the starting element\n * @returns The TNode of the parent injector\n */\nexport declare function getParentInjectorTNode(location: RelativeInjectorLocation, startView: LViewData, startTNode: TNode): TElementNode | TContainerNode | null;\nexport declare const defaultScheduler: any;\n/**\n * Equivalent to ES6 spread, add each item to an array.\n *\n * @param items The items to add\n * @param arr The array to which you want to add the items\n */\nexport declare function addAllToArray(items: any[], arr: any[]): void;\n"
  },
  {
    "path": "node_modules/@angular/core/src/render3/view_engine_compatibility_prebound.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { TemplateRef as ViewEngine_TemplateRef } from '../linker/template_ref';\nimport { TNode } from './interfaces/node';\nimport { LViewData } from './interfaces/view';\n/**\n * Retrieves `TemplateRef` instance from `Injector` when a local reference is placed on the\n * `<ng-template>` element.\n */\nexport declare function templateRefExtractor(tNode: TNode, currentView: LViewData): ViewEngine_TemplateRef<{}> | null;\n"
  },
  {
    "path": "node_modules/@angular/core/src/render3/view_engine_compatibility.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { ChangeDetectorRef as ViewEngine_ChangeDetectorRef } from '../change_detection/change_detector_ref';\nimport { Injector } from '../di/injector';\nimport { ElementRef as ViewEngine_ElementRef } from '../linker/element_ref';\nimport { TemplateRef as ViewEngine_TemplateRef } from '../linker/template_ref';\nimport { ViewContainerRef as ViewEngine_ViewContainerRef } from '../linker/view_container_ref';\nimport { Renderer2 } from '../render/api';\nimport { TContainerNode, TElementContainerNode, TElementNode, TNode } from './interfaces/node';\nimport { LViewData } from './interfaces/view';\n/**\n * Creates an ElementRef from the most recent node.\n *\n * @returns The ElementRef instance to use\n */\nexport declare function injectElementRef(ElementRefToken: typeof ViewEngine_ElementRef): ViewEngine_ElementRef;\n/**\n * Creates an ElementRef given a node.\n *\n * @param ElementRefToken The ElementRef type\n * @param tNode The node for which you'd like an ElementRef\n * @param view The view to which the node belongs\n * @returns The ElementRef instance to use\n */\nexport declare function createElementRef(ElementRefToken: typeof ViewEngine_ElementRef, tNode: TNode, view: LViewData): ViewEngine_ElementRef;\n/**\n * Creates a TemplateRef given a node.\n *\n * @returns The TemplateRef instance to use\n */\nexport declare function injectTemplateRef<T>(TemplateRefToken: typeof ViewEngine_TemplateRef, ElementRefToken: typeof ViewEngine_ElementRef): ViewEngine_TemplateRef<T> | null;\n/**\n * Creates a TemplateRef and stores it on the injector.\n *\n * @param TemplateRefToken The TemplateRef type\n * @param ElementRefToken The ElementRef type\n * @param hostTNode The node that is requesting a TemplateRef\n * @param hostView The view to which the node belongs\n * @returns The TemplateRef instance to use\n */\nexport declare function createTemplateRef<T>(TemplateRefToken: typeof ViewEngine_TemplateRef, ElementRefToken: typeof ViewEngine_ElementRef, hostTNode: TNode, hostView: LViewData): ViewEngine_TemplateRef<T> | null;\n/**\n * Creates a ViewContainerRef and stores it on the injector. Or, if the ViewContainerRef\n * already exists, retrieves the existing ViewContainerRef.\n *\n * @returns The ViewContainerRef instance to use\n */\nexport declare function injectViewContainerRef(ViewContainerRefToken: typeof ViewEngine_ViewContainerRef, ElementRefToken: typeof ViewEngine_ElementRef): ViewEngine_ViewContainerRef;\nexport declare class NodeInjector implements Injector {\n    private _tNode;\n    private _hostView;\n    constructor(_tNode: TElementNode | TContainerNode | TElementContainerNode, _hostView: LViewData);\n    get(token: any, notFoundValue?: any): any;\n}\n/**\n * Creates a ViewContainerRef and stores it on the injector.\n *\n * @param ViewContainerRefToken The ViewContainerRef type\n * @param ElementRefToken The ElementRef type\n * @param hostTNode The node that is requesting a ViewContainerRef\n * @param hostView The view to which the node belongs\n * @returns The ViewContainerRef instance to use\n */\nexport declare function createContainerRef(ViewContainerRefToken: typeof ViewEngine_ViewContainerRef, ElementRefToken: typeof ViewEngine_ElementRef, hostTNode: TElementNode | TContainerNode | TElementContainerNode, hostView: LViewData): ViewEngine_ViewContainerRef;\n/** Returns a ChangeDetectorRef (a.k.a. a ViewRef) */\nexport declare function injectChangeDetectorRef(): ViewEngine_ChangeDetectorRef;\n/**\n * Creates a ViewRef and stores it on the injector as ChangeDetectorRef (public alias).\n *\n * @param hostTNode The node that is requesting a ChangeDetectorRef\n * @param hostView The view to which the node belongs\n * @param context The context for this change detector ref\n * @returns The ChangeDetectorRef to use\n */\nexport declare function createViewRef(hostTNode: TNode, hostView: LViewData, context: any): ViewEngine_ChangeDetectorRef;\n/** Returns a Renderer2 (or throws when application was bootstrapped with Renderer3) */\nexport declare function injectRenderer2(): Renderer2;\n"
  },
  {
    "path": "node_modules/@angular/core/src/render3/view_ref.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { ApplicationRef } from '../application_ref';\nimport { ChangeDetectorRef as viewEngine_ChangeDetectorRef } from '../change_detection/change_detector_ref';\nimport { ViewContainerRef as viewEngine_ViewContainerRef } from '../linker/view_container_ref';\nimport { EmbeddedViewRef as viewEngine_EmbeddedViewRef, InternalViewRef as viewEngine_InternalViewRef } from '../linker/view_ref';\nimport { LViewData } from './interfaces/view';\nexport interface viewEngine_ChangeDetectorRef_interface extends viewEngine_ChangeDetectorRef {\n}\nexport declare class ViewRef<T> implements viewEngine_EmbeddedViewRef<T>, viewEngine_InternalViewRef, viewEngine_ChangeDetectorRef_interface {\n    private _context;\n    private _componentIndex;\n    private _appRef;\n    private _viewContainerRef;\n    readonly rootNodes: any[];\n    constructor(_view: LViewData, _context: T | null, _componentIndex: number);\n    readonly context: T;\n    readonly destroyed: boolean;\n    destroy(): void;\n    onDestroy(callback: Function): void;\n    /**\n     * Marks a view and all of its ancestors dirty.\n     *\n     * It also triggers change detection by calling `scheduleTick` internally, which coalesces\n     * multiple `markForCheck` calls to into one change detection run.\n     *\n     * This can be used to ensure an {@link ChangeDetectionStrategy#OnPush OnPush} component is\n     * checked when it needs to be re-rendered but the two normal triggers haven't marked it\n     * dirty (i.e. inputs haven't changed and events haven't fired in the view).\n     *\n     * <!-- TODO: Add a link to a chapter on OnPush components -->\n     *\n     * @usageNotes\n     * ### Example\n     *\n     * ```typescript\n     * @Component({\n     *   selector: 'my-app',\n     *   template: `Number of ticks: {{numberOfTicks}}`\n     *   changeDetection: ChangeDetectionStrategy.OnPush,\n     * })\n     * class AppComponent {\n     *   numberOfTicks = 0;\n     *\n     *   constructor(private ref: ChangeDetectorRef) {\n     *     setInterval(() => {\n     *       this.numberOfTicks++;\n     *       // the following is required, otherwise the view will not be updated\n     *       this.ref.markForCheck();\n     *     }, 1000);\n     *   }\n     * }\n     * ```\n     */\n    markForCheck(): void;\n    /**\n     * Detaches the view from the change detection tree.\n     *\n     * Detached views will not be checked during change detection runs until they are\n     * re-attached, even if they are dirty. `detach` can be used in combination with\n     * {@link ChangeDetectorRef#detectChanges detectChanges} to implement local change\n     * detection checks.\n     *\n     * <!-- TODO: Add a link to a chapter on detach/reattach/local digest -->\n     * <!-- TODO: Add a live demo once ref.detectChanges is merged into master -->\n     *\n     * @usageNotes\n     * ### Example\n     *\n     * The following example defines a component with a large list of readonly data.\n     * Imagine the data changes constantly, many times per second. For performance reasons,\n     * we want to check and update the list every five seconds. We can do that by detaching\n     * the component's change detector and doing a local check every five seconds.\n     *\n     * ```typescript\n     * class DataProvider {\n     *   // in a real application the returned data will be different every time\n     *   get data() {\n     *     return [1,2,3,4,5];\n     *   }\n     * }\n     *\n     * @Component({\n     *   selector: 'giant-list',\n     *   template: `\n     *     <li *ngFor=\"let d of dataProvider.data\">Data {{d}}</li>\n     *   `,\n     * })\n     * class GiantList {\n     *   constructor(private ref: ChangeDetectorRef, private dataProvider: DataProvider) {\n     *     ref.detach();\n     *     setInterval(() => {\n     *       this.ref.detectChanges();\n     *     }, 5000);\n     *   }\n     * }\n     *\n     * @Component({\n     *   selector: 'app',\n     *   providers: [DataProvider],\n     *   template: `\n     *     <giant-list><giant-list>\n     *   `,\n     * })\n     * class App {\n     * }\n     * ```\n     */\n    detach(): void;\n    /**\n     * Re-attaches a view to the change detection tree.\n     *\n     * This can be used to re-attach views that were previously detached from the tree\n     * using {@link ChangeDetectorRef#detach detach}. Views are attached to the tree by default.\n     *\n     * <!-- TODO: Add a link to a chapter on detach/reattach/local digest -->\n     *\n     * @usageNotes\n     * ### Example\n     *\n     * The following example creates a component displaying `live` data. The component will detach\n     * its change detector from the main change detector tree when the component's live property\n     * is set to false.\n     *\n     * ```typescript\n     * class DataProvider {\n     *   data = 1;\n     *\n     *   constructor() {\n     *     setInterval(() => {\n     *       this.data = this.data * 2;\n     *     }, 500);\n     *   }\n     * }\n     *\n     * @Component({\n     *   selector: 'live-data',\n     *   inputs: ['live'],\n     *   template: 'Data: {{dataProvider.data}}'\n     * })\n     * class LiveData {\n     *   constructor(private ref: ChangeDetectorRef, private dataProvider: DataProvider) {}\n     *\n     *   set live(value) {\n     *     if (value) {\n     *       this.ref.reattach();\n     *     } else {\n     *       this.ref.detach();\n     *     }\n     *   }\n     * }\n     *\n     * @Component({\n     *   selector: 'my-app',\n     *   providers: [DataProvider],\n     *   template: `\n     *     Live Update: <input type=\"checkbox\" [(ngModel)]=\"live\">\n     *     <live-data [live]=\"live\"><live-data>\n     *   `,\n     * })\n     * class AppComponent {\n     *   live = true;\n     * }\n     * ```\n     */\n    reattach(): void;\n    /**\n     * Checks the view and its children.\n     *\n     * This can also be used in combination with {@link ChangeDetectorRef#detach detach} to implement\n     * local change detection checks.\n     *\n     * <!-- TODO: Add a link to a chapter on detach/reattach/local digest -->\n     * <!-- TODO: Add a live demo once ref.detectChanges is merged into master -->\n     *\n     * @usageNotes\n     * ### Example\n     *\n     * The following example defines a component with a large list of readonly data.\n     * Imagine, the data changes constantly, many times per second. For performance reasons,\n     * we want to check and update the list every five seconds.\n     *\n     * We can do that by detaching the component's change detector and doing a local change detection\n     * check every five seconds.\n     *\n     * See {@link ChangeDetectorRef#detach detach} for more information.\n     */\n    detectChanges(): void;\n    /**\n     * Checks the change detector and its children, and throws if any changes are detected.\n     *\n     * This is used in development mode to verify that running change detection doesn't\n     * introduce other changes.\n     */\n    checkNoChanges(): void;\n    attachToViewContainerRef(vcRef: viewEngine_ViewContainerRef): void;\n    detachFromAppRef(): void;\n    attachToAppRef(appRef: ApplicationRef): void;\n    private _lookUpContext;\n}\n"
  },
  {
    "path": "node_modules/@angular/core/src/sanitization/bypass.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\ndeclare const BRAND = \"__SANITIZER_TRUSTED_BRAND__\";\nexport declare const enum BypassType {\n    Url = \"Url\",\n    Html = \"Html\",\n    ResourceUrl = \"ResourceUrl\",\n    Script = \"Script\",\n    Style = \"Style\"\n}\n/**\n * A branded trusted string used with sanitization.\n *\n * See: {@link TrustedHtmlString}, {@link TrustedResourceUrlString}, {@link TrustedScriptString},\n * {@link TrustedStyleString}, {@link TrustedUrlString}\n */\nexport interface TrustedString extends String {\n    [BRAND]: BypassType;\n}\n/**\n * A branded trusted string used with sanitization of `html` strings.\n *\n * See: {@link bypassSanitizationTrustHtml} and {@link htmlSanitizer}.\n */\nexport interface TrustedHtmlString extends TrustedString {\n    [BRAND]: BypassType.Html;\n}\n/**\n * A branded trusted string used with sanitization of `style` strings.\n *\n * See: {@link bypassSanitizationTrustStyle} and {@link styleSanitizer}.\n */\nexport interface TrustedStyleString extends TrustedString {\n    [BRAND]: BypassType.Style;\n}\n/**\n * A branded trusted string used with sanitization of `url` strings.\n *\n * See: {@link bypassSanitizationTrustScript} and {@link scriptSanitizer}.\n */\nexport interface TrustedScriptString extends TrustedString {\n    [BRAND]: BypassType.Script;\n}\n/**\n * A branded trusted string used with sanitization of `url` strings.\n *\n * See: {@link bypassSanitizationTrustUrl} and {@link urlSanitizer}.\n */\nexport interface TrustedUrlString extends TrustedString {\n    [BRAND]: BypassType.Url;\n}\n/**\n * A branded trusted string used with sanitization of `resourceUrl` strings.\n *\n * See: {@link bypassSanitizationTrustResourceUrl} and {@link resourceUrlSanitizer}.\n */\nexport interface TrustedResourceUrlString extends TrustedString {\n    [BRAND]: BypassType.ResourceUrl;\n}\nexport declare function allowSanitizationBypass(value: any, type: BypassType): boolean;\n/**\n * Mark `html` string as trusted.\n *\n * This function wraps the trusted string in `String` and brands it in a way which makes it\n * recognizable to {@link htmlSanitizer} to be trusted implicitly.\n *\n * @param trustedHtml `html` string which needs to be implicitly trusted.\n * @returns a `html` `String` which has been branded to be implicitly trusted.\n */\nexport declare function bypassSanitizationTrustHtml(trustedHtml: string): TrustedHtmlString;\n/**\n * Mark `style` string as trusted.\n *\n * This function wraps the trusted string in `String` and brands it in a way which makes it\n * recognizable to {@link styleSanitizer} to be trusted implicitly.\n *\n * @param trustedStyle `style` string which needs to be implicitly trusted.\n * @returns a `style` `String` which has been branded to be implicitly trusted.\n */\nexport declare function bypassSanitizationTrustStyle(trustedStyle: string): TrustedStyleString;\n/**\n * Mark `script` string as trusted.\n *\n * This function wraps the trusted string in `String` and brands it in a way which makes it\n * recognizable to {@link scriptSanitizer} to be trusted implicitly.\n *\n * @param trustedScript `script` string which needs to be implicitly trusted.\n * @returns a `script` `String` which has been branded to be implicitly trusted.\n */\nexport declare function bypassSanitizationTrustScript(trustedScript: string): TrustedScriptString;\n/**\n * Mark `url` string as trusted.\n *\n * This function wraps the trusted string in `String` and brands it in a way which makes it\n * recognizable to {@link urlSanitizer} to be trusted implicitly.\n *\n * @param trustedUrl `url` string which needs to be implicitly trusted.\n * @returns a `url` `String` which has been branded to be implicitly trusted.\n */\nexport declare function bypassSanitizationTrustUrl(trustedUrl: string): TrustedUrlString;\n/**\n * Mark `url` string as trusted.\n *\n * This function wraps the trusted string in `String` and brands it in a way which makes it\n * recognizable to {@link resourceUrlSanitizer} to be trusted implicitly.\n *\n * @param trustedResourceUrl `url` string which needs to be implicitly trusted.\n * @returns a `url` `String` which has been branded to be implicitly trusted.\n */\nexport declare function bypassSanitizationTrustResourceUrl(trustedResourceUrl: string): TrustedResourceUrlString;\nexport {};\n"
  },
  {
    "path": "node_modules/@angular/core/src/sanitization/html_sanitizer.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nexport declare const VALID_ELEMENTS: {\n    [k: string]: boolean;\n};\nexport declare const URI_ATTRS: {\n    [k: string]: boolean;\n};\nexport declare const SRCSET_ATTRS: {\n    [k: string]: boolean;\n};\nexport declare const VALID_ATTRS: {\n    [k: string]: boolean;\n};\n/**\n * Sanitizes the given unsafe, untrusted HTML fragment, and returns HTML text that is safe to add to\n * the DOM in a browser environment.\n */\nexport declare function _sanitizeHtml(defaultDoc: any, unsafeHtmlInput: string): string;\nexport declare function getTemplateContent(el: Node): Node | null;\n"
  },
  {
    "path": "node_modules/@angular/core/src/sanitization/inert_body.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * This helper class is used to get hold of an inert tree of DOM elements containing dirty HTML\n * that needs sanitizing.\n * Depending upon browser support we must use one of three strategies for doing this.\n * Support: Safari 10.x -> XHR strategy\n * Support: Firefox -> DomParser strategy\n * Default: InertDocument strategy\n */\nexport declare class InertBodyHelper {\n    private defaultDoc;\n    private inertBodyElement;\n    private inertDocument;\n    constructor(defaultDoc: Document);\n    /**\n     * Get an inert DOM element containing DOM created from the dirty HTML string provided.\n     * The implementation of this is determined in the constructor, when the class is instantiated.\n     */\n    getInertBodyElement: (html: string) => HTMLElement | null;\n    /**\n     * Use XHR to create and fill an inert body element (on Safari 10.1)\n     * See\n     * https://github.com/cure53/DOMPurify/blob/a992d3a75031cb8bb032e5ea8399ba972bdf9a65/src/purify.js#L439-L449\n     */\n    private getInertBodyElement_XHR;\n    /**\n     * Use DOMParser to create and fill an inert body element (on Firefox)\n     * See https://github.com/cure53/DOMPurify/releases/tag/0.6.7\n     *\n     */\n    private getInertBodyElement_DOMParser;\n    /**\n     * Use an HTML5 `template` element, if supported, or an inert body element created via\n     * `createHtmlDocument` to create and fill an inert DOM element.\n     * This is the default sane strategy to use if the browser does not require one of the specialised\n     * strategies above.\n     */\n    private getInertBodyElement_InertDocument;\n    /**\n     * When IE9-11 comes across an unknown namespaced attribute e.g. 'xlink:foo' it adds 'xmlns:ns1'\n     * attribute to declare ns1 namespace and prefixes the attribute with 'ns1' (e.g.\n     * 'ns1:xlink:foo').\n     *\n     * This is undesirable since we don't want to allow any of these custom attributes. This method\n     * strips them all.\n     */\n    private stripCustomNsAttrs;\n}\n"
  },
  {
    "path": "node_modules/@angular/core/src/sanitization/sanitization.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { StyleSanitizeFn } from './style_sanitizer';\n/**\n * An `html` sanitizer which converts untrusted `html` **string** into trusted string by removing\n * dangerous content.\n *\n * This method parses the `html` and locates potentially dangerous content (such as urls and\n * javascript) and removes it.\n *\n * It is possible to mark a string as trusted by calling {@link bypassSanitizationTrustHtml}.\n *\n * @param unsafeHtml untrusted `html`, typically from the user.\n * @returns `html` string which is safe to display to user, because all of the dangerous javascript\n * and urls have been removed.\n */\nexport declare function sanitizeHtml(unsafeHtml: any): string;\n/**\n * A `style` sanitizer which converts untrusted `style` **string** into trusted string by removing\n * dangerous content.\n *\n * This method parses the `style` and locates potentially dangerous content (such as urls and\n * javascript) and removes it.\n *\n * It is possible to mark a string as trusted by calling {@link bypassSanitizationTrustStyle}.\n *\n * @param unsafeStyle untrusted `style`, typically from the user.\n * @returns `style` string which is safe to bind to the `style` properties, because all of the\n * dangerous javascript and urls have been removed.\n */\nexport declare function sanitizeStyle(unsafeStyle: any): string;\n/**\n * A `url` sanitizer which converts untrusted `url` **string** into trusted string by removing\n * dangerous\n * content.\n *\n * This method parses the `url` and locates potentially dangerous content (such as javascript) and\n * removes it.\n *\n * It is possible to mark a string as trusted by calling {@link bypassSanitizationTrustUrl}.\n *\n * @param unsafeUrl untrusted `url`, typically from the user.\n * @returns `url` string which is safe to bind to the `src` properties such as `<img src>`, because\n * all of the dangerous javascript has been removed.\n */\nexport declare function sanitizeUrl(unsafeUrl: any): string;\n/**\n * A `url` sanitizer which only lets trusted `url`s through.\n *\n * This passes only `url`s marked trusted by calling {@link bypassSanitizationTrustResourceUrl}.\n *\n * @param unsafeResourceUrl untrusted `url`, typically from the user.\n * @returns `url` string which is safe to bind to the `src` properties such as `<img src>`, because\n * only trusted `url`s have been allowed to pass.\n */\nexport declare function sanitizeResourceUrl(unsafeResourceUrl: any): string;\n/**\n * A `script` sanitizer which only lets trusted javascript through.\n *\n * This passes only `script`s marked trusted by calling {@link bypassSanitizationTrustScript}.\n *\n * @param unsafeScript untrusted `script`, typically from the user.\n * @returns `url` string which is safe to bind to the `<script>` element such as `<img src>`,\n * because only trusted `scripts`s have been allowed to pass.\n */\nexport declare function sanitizeScript(unsafeScript: any): string;\n/**\n * The default style sanitizer will handle sanitization for style properties by\n * sanitizing any CSS property that can include a `url` value (usually image-based properties)\n */\nexport declare const defaultStyleSanitizer: StyleSanitizeFn;\n"
  },
  {
    "path": "node_modules/@angular/core/src/sanitization/security.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * A SecurityContext marks a location that has dangerous security implications, e.g. a DOM property\n * like `innerHTML` that could cause Cross Site Scripting (XSS) security bugs when improperly\n * handled.\n *\n * See DomSanitizer for more details on security in Angular applications.\n *\n * @publicApi\n */\nexport declare enum SecurityContext {\n    NONE = 0,\n    HTML = 1,\n    STYLE = 2,\n    SCRIPT = 3,\n    URL = 4,\n    RESOURCE_URL = 5\n}\n/**\n * Sanitizer is used by the views to sanitize potentially dangerous values.\n *\n * @publicApi\n */\nexport declare abstract class Sanitizer {\n    abstract sanitize(context: SecurityContext, value: {} | string | null): string | null;\n}\n"
  },
  {
    "path": "node_modules/@angular/core/src/sanitization/style_sanitizer.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Sanitizes the given untrusted CSS style property value (i.e. not an entire object, just a single\n * value) and returns a value that is safe to use in a browser environment.\n */\nexport declare function _sanitizeStyle(value: string): string;\n/**\n * Used to intercept and sanitize style values before they are written to the renderer.\n *\n * This function is designed to be called in two modes. When a value is not provided\n * then the function will return a boolean whether a property will be sanitized later.\n * If a value is provided then the sanitized version of that will be returned.\n */\nexport interface StyleSanitizeFn {\n    /** This mode is designed to instruct whether the property will be used for sanitization\n     * at a later point */\n    (prop: string): boolean;\n    /** This mode is designed to sanitize the provided value */\n    (prop: string, value: string): string;\n}\n"
  },
  {
    "path": "node_modules/@angular/core/src/sanitization/url_sanitizer.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nexport declare function _sanitizeUrl(url: string): string;\nexport declare function sanitizeSrcset(srcset: string): string;\n"
  },
  {
    "path": "node_modules/@angular/core/src/testability/testability.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { NgZone } from '../zone/ng_zone';\n/**\n * Testability API.\n * `declare` keyword causes tsickle to generate externs, so these methods are\n * not renamed by Closure Compiler.\n * @publicApi\n */\nexport declare interface PublicTestability {\n    isStable(): boolean;\n    whenStable(callback: Function, timeout?: number, updateCallback?: Function): void;\n    findProviders(using: any, provider: string, exactMatch: boolean): any[];\n}\nexport interface PendingMacrotask {\n    source: string;\n    creationLocation: Error;\n    runCount?: number;\n    data: TaskData;\n}\nexport interface TaskData {\n    target?: XMLHttpRequest;\n    delay?: number;\n    isPeriodic?: boolean;\n}\nexport declare type DoneCallback = (didWork: boolean, tasks?: PendingMacrotask[]) => void;\nexport declare type UpdateCallback = (tasks: PendingMacrotask[]) => boolean;\n/**\n * The Testability service provides testing hooks that can be accessed from\n * the browser and by services such as Protractor. Each bootstrapped Angular\n * application on the page will have an instance of Testability.\n * @publicApi\n */\nexport declare class Testability implements PublicTestability {\n    private _ngZone;\n    private _pendingCount;\n    private _isZoneStable;\n    private _callbacks;\n    private taskTrackingZone;\n    constructor(_ngZone: NgZone);\n    private _watchAngularEvents;\n    /**\n     * Increases the number of pending request\n     * @deprecated pending requests are now tracked with zones.\n     */\n    increasePendingRequestCount(): number;\n    /**\n     * Decreases the number of pending request\n     * @deprecated pending requests are now tracked with zones\n     */\n    decreasePendingRequestCount(): number;\n    /**\n     * Whether an associated application is stable\n     */\n    isStable(): boolean;\n    private _runCallbacksIfReady;\n    private getPendingTasks;\n    private addCallback;\n    /**\n     * Wait for the application to be stable with a timeout. If the timeout is reached before that\n     * happens, the callback receives a list of the macro tasks that were pending, otherwise null.\n     *\n     * @param doneCb The callback to invoke when Angular is stable or the timeout expires\n     *    whichever comes first.\n     * @param timeout Optional. The maximum time to wait for Angular to become stable. If not\n     *    specified, whenStable() will wait forever.\n     * @param updateCb Optional. If specified, this callback will be invoked whenever the set of\n     *    pending macrotasks changes. If this callback returns true doneCb will not be invoked\n     *    and no further updates will be issued.\n     */\n    whenStable(doneCb: Function, timeout?: number, updateCb?: Function): void;\n    /**\n     * Get the number of pending requests\n     * @deprecated pending requests are now tracked with zones\n     */\n    getPendingRequestCount(): number;\n    /**\n     * Find providers by name\n     * @param using The root element to search from\n     * @param provider The name of binding variable\n     * @param exactMatch Whether using exactMatch\n     */\n    findProviders(using: any, provider: string, exactMatch: boolean): any[];\n}\n/**\n * A global registry of {@link Testability} instances for specific elements.\n * @publicApi\n */\nexport declare class TestabilityRegistry {\n    constructor();\n    /**\n     * Registers an application with a testability hook so that it can be tracked\n     * @param token token of application, root element\n     * @param testability Testability hook\n     */\n    registerApplication(token: any, testability: Testability): void;\n    /**\n     * Unregisters an application.\n     * @param token token of application, root element\n     */\n    unregisterApplication(token: any): void;\n    /**\n     * Unregisters all applications\n     */\n    unregisterAllApplications(): void;\n    /**\n     * Get a testability hook associated with the application\n     * @param elem root element\n     */\n    getTestability(elem: any): Testability | null;\n    /**\n     * Get all registered testabilities\n     */\n    getAllTestabilities(): Testability[];\n    /**\n     * Get all registered applications(root elements)\n     */\n    getAllRootElements(): any[];\n    /**\n     * Find testability of a node in the Tree\n     * @param elem node\n     * @param findInAncestors whether finding testability in ancestors if testability was not found in\n     * current node\n     */\n    findTestabilityInTree(elem: Node, findInAncestors?: boolean): Testability | null;\n}\n/**\n * Adapter interface for retrieving the `Testability` service associated for a\n * particular context.\n *\n * @publicApi\n */\nexport interface GetTestability {\n    addToWindow(registry: TestabilityRegistry): void;\n    findTestabilityInTree(registry: TestabilityRegistry, elem: any, findInAncestors: boolean): Testability | null;\n}\n/**\n * Set the {@link GetTestability} implementation used by the Angular testing framework.\n * @publicApi\n */\nexport declare function setTestabilityGetter(getter: GetTestability): void;\n"
  },
  {
    "path": "node_modules/@angular/core/src/type.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * @description\n *\n * Represents a type that a Component or other object is instances of.\n *\n * An example of a `Type` is `MyCustomComponent` class, which in JavaScript is be represented by\n * the `MyCustomComponent` constructor function.\n *\n * @publicApi\n */\nexport declare const Type: FunctionConstructor;\nexport declare function isType(v: any): v is Type<any>;\nexport interface Type<T> extends Function {\n    new (...args: any[]): T;\n}\nexport declare type Mutable<T extends {\n    [x: string]: any;\n}, K extends string> = {\n    [P in K]: T[P];\n};\n"
  },
  {
    "path": "node_modules/@angular/core/src/util.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\ndeclare const _global: {\n    [name: string]: any;\n};\n/**\n * Attention: whenever providing a new value, be sure to add an\n * entry into the corresponding `....externs.js` file,\n * so that closure won't use that global for its purposes.\n */\nexport { _global as global };\nexport declare function getSymbolIterator(): string | symbol;\nexport declare function scheduleMicroTask(fn: Function): void;\nexport declare function looseIdentical(a: any, b: any): boolean;\nexport declare function stringify(token: any): string;\n/**\n * Convince closure compiler that the wrapped function has no side-effects.\n *\n * Closure compiler always assumes that `toString` has no side-effects. We use this quirk to\n * allow us to execute a function but have closure compiler mark the call as no-side-effects.\n * It is important that the return value for the `noSideEffects` function be assigned\n * to something which is retained otherwise the call to `noSideEffects` will be removed by closure\n * compiler.\n */\nexport declare function noSideEffects(fn: () => void): string;\n"
  },
  {
    "path": "node_modules/@angular/core/src/util/decorators.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { Type } from '../type';\n/**\n * An interface implemented by all Angular type decorators, which allows them to be used as ES7\n * decorators as well as\n * Angular DSL syntax.\n *\n * ES7 syntax:\n *\n * ```\n * @ng.Component({...})\n * class MyClass {...}\n * ```\n *\n * @publicApi\n */\nexport interface TypeDecorator {\n    /**\n     * Invoke as ES7 decorator.\n     */\n    <T extends Type<any>>(type: T): T;\n    (target: Object, propertyKey?: string | symbol, parameterIndex?: number): void;\n}\nexport declare const ANNOTATIONS = \"__annotations__\";\nexport declare const PARAMETERS = \"__parameters__\";\nexport declare const PROP_METADATA = \"__prop__metadata__\";\n/**\n * @suppress {globalThis}\n */\nexport declare function makeDecorator<T>(name: string, props?: (...args: any[]) => any, parentClass?: any, additionalProcessing?: (type: Type<T>) => void, typeFn?: (type: Type<T>, ...args: any[]) => void): {\n    new (...args: any[]): any;\n    (...args: any[]): any;\n    (...args: any[]): (cls: any) => any;\n};\nexport declare function makeParamDecorator(name: string, props?: (...args: any[]) => any, parentClass?: any): any;\nexport declare function makePropDecorator(name: string, props?: (...args: any[]) => any, parentClass?: any, additionalProcessing?: (target: any, name: string, ...args: any[]) => void): any;\n"
  },
  {
    "path": "node_modules/@angular/core/src/util/lang.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { Observable } from 'rxjs';\n/**\n * Determine if the argument is shaped like a Promise\n */\nexport declare function isPromise(obj: any): obj is Promise<any>;\n/**\n * Determine if the argument is an Observable\n */\nexport declare function isObservable(obj: any | Observable<any>): obj is Observable<any>;\n"
  },
  {
    "path": "node_modules/@angular/core/src/util/noop.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nexport declare function noop(...args: any[]): any;\n"
  },
  {
    "path": "node_modules/@angular/core/src/util/property.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nexport declare function getClosureSafeProperty<T>(objWithPropertyToExtract: T): string;\n/**\n * Sets properties on a target object from a source object, but only if\n * the property doesn't already exist on the target object.\n * @param target The target to set properties on\n * @param source The source of the property keys and values to set\n */\nexport declare function fillProperties(target: {\n    [key: string]: string;\n}, source: {\n    [key: string]: string;\n}): void;\n"
  },
  {
    "path": "node_modules/@angular/core/src/version.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * @description Represents the version of Angular\n *\n * @publicApi\n */\nexport declare class Version {\n    full: string;\n    readonly major: string;\n    readonly minor: string;\n    readonly patch: string;\n    constructor(full: string);\n}\n/**\n * @publicApi\n */\nexport declare const VERSION: Version;\n"
  },
  {
    "path": "node_modules/@angular/core/src/view/element.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { RendererType2 } from '../render/api';\nimport { SecurityContext } from '../sanitization/security';\nimport { BindingFlags, ElementData, ElementHandleEventFn, NodeDef, NodeFlags, QueryValueType, ViewData, ViewDefinitionFactory } from './types';\nexport declare function anchorDef(flags: NodeFlags, matchedQueriesDsl: null | [string | number, QueryValueType][], ngContentIndex: null | number, childCount: number, handleEvent?: null | ElementHandleEventFn, templateFactory?: ViewDefinitionFactory): NodeDef;\nexport declare function elementDef(checkIndex: number, flags: NodeFlags, matchedQueriesDsl: null | [string | number, QueryValueType][], ngContentIndex: null | number, childCount: number, namespaceAndName: string | null, fixedAttrs?: null | [string, string][], bindings?: null | [BindingFlags, string, string | SecurityContext | null][], outputs?: null | ([string, string])[], handleEvent?: null | ElementHandleEventFn, componentView?: null | ViewDefinitionFactory, componentRendererType?: RendererType2 | null): NodeDef;\nexport declare function createElement(view: ViewData, renderHost: any, def: NodeDef): ElementData;\nexport declare function listenToElementOutputs(view: ViewData, compView: ViewData, def: NodeDef, el: any): void;\nexport declare function checkAndUpdateElementInline(view: ViewData, def: NodeDef, v0: any, v1: any, v2: any, v3: any, v4: any, v5: any, v6: any, v7: any, v8: any, v9: any): boolean;\nexport declare function checkAndUpdateElementDynamic(view: ViewData, def: NodeDef, values: any[]): boolean;\n"
  },
  {
    "path": "node_modules/@angular/core/src/view/entrypoint.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { ComponentFactory } from '../linker/component_factory';\nimport { NgModuleFactory } from '../linker/ng_module_factory';\nimport { Type } from '../type';\nimport { NgModuleDefinitionFactory, ProviderOverride } from './types';\nexport declare function overrideProvider(override: ProviderOverride): void;\nexport declare function overrideComponentView(comp: Type<any>, componentFactory: ComponentFactory<any>): void;\nexport declare function clearOverrides(): void;\nexport declare function createNgModuleFactory(ngModuleType: Type<any>, bootstrapComponents: Type<any>[], defFactory: NgModuleDefinitionFactory): NgModuleFactory<any>;\n"
  },
  {
    "path": "node_modules/@angular/core/src/view/errors.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { DebugContext } from './types';\nexport declare function expressionChangedAfterItHasBeenCheckedError(context: DebugContext, oldValue: any, currValue: any, isFirstCheck: boolean): Error;\nexport declare function viewWrappedDebugError(err: any, context: DebugContext): Error;\nexport declare function viewDebugError(msg: string, context: DebugContext): Error;\nexport declare function isViewDebugError(err: Error): boolean;\nexport declare function viewDestroyedError(action: string): Error;\n"
  },
  {
    "path": "node_modules/@angular/core/src/view/index.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nexport { anchorDef, elementDef } from './element';\nexport { clearOverrides, createNgModuleFactory, overrideComponentView, overrideProvider } from './entrypoint';\nexport { ngContentDef } from './ng_content';\nexport { moduleDef, moduleProvideDef } from './ng_module';\nexport { directiveDef, pipeDef, providerDef } from './provider';\nexport { pureArrayDef, pureObjectDef, purePipeDef } from './pure_expression';\nexport { queryDef } from './query';\nexport { ViewRef_, createComponentFactory, getComponentViewDefinitionFactory, nodeValue } from './refs';\nexport { initServicesIfNeeded } from './services';\nexport { textDef } from './text';\nexport { EMPTY_ARRAY, EMPTY_MAP, createRendererType2, elementEventFullName, inlineInterpolate, interpolate, rootRenderNodes, tokenKey, unwrapValue } from './util';\nexport { viewDef } from './view';\nexport { attachEmbeddedView, detachEmbeddedView, moveEmbeddedView } from './view_attach';\nexport * from './types';\n"
  },
  {
    "path": "node_modules/@angular/core/src/view/ng_content.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { NodeDef, ViewData } from './types';\nexport declare function ngContentDef(ngContentIndex: null | number, index: number): NodeDef;\nexport declare function appendNgContent(view: ViewData, renderHost: any, def: NodeDef): void;\n"
  },
  {
    "path": "node_modules/@angular/core/src/view/ng_module.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { DepDef, DepFlags, NgModuleData, NgModuleDefinition, NgModuleProviderDef, NodeFlags } from './types';\nexport declare function moduleProvideDef(flags: NodeFlags, token: any, value: any, deps: ([DepFlags, any] | any)[]): NgModuleProviderDef;\nexport declare function moduleDef(providers: NgModuleProviderDef[]): NgModuleDefinition;\nexport declare function initNgModule(data: NgModuleData): void;\nexport declare function resolveNgModuleDep(data: NgModuleData, depDef: DepDef, notFoundValue?: any): any;\nexport declare function callNgModuleLifecycle(ngModule: NgModuleData, lifecycles: NodeFlags): void;\n"
  },
  {
    "path": "node_modules/@angular/core/src/view/provider.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { BindingDef, DepDef, DepFlags, NodeDef, NodeFlags, OutputDef, QueryValueType, ViewData } from './types';\nexport declare function directiveDef(checkIndex: number, flags: NodeFlags, matchedQueries: null | [string | number, QueryValueType][], childCount: number, ctor: any, deps: ([DepFlags, any] | any)[], props?: null | {\n    [name: string]: [number, string];\n}, outputs?: null | {\n    [name: string]: string;\n}): NodeDef;\nexport declare function pipeDef(flags: NodeFlags, ctor: any, deps: ([DepFlags, any] | any)[]): NodeDef;\nexport declare function providerDef(flags: NodeFlags, matchedQueries: null | [string | number, QueryValueType][], token: any, value: any, deps: ([DepFlags, any] | any)[]): NodeDef;\nexport declare function _def(checkIndex: number, flags: NodeFlags, matchedQueriesDsl: [string | number, QueryValueType][] | null, childCount: number, token: any, value: any, deps: ([DepFlags, any] | any)[], bindings?: BindingDef[], outputs?: OutputDef[]): NodeDef;\nexport declare function createProviderInstance(view: ViewData, def: NodeDef): any;\nexport declare function createPipeInstance(view: ViewData, def: NodeDef): any;\nexport declare function createDirectiveInstance(view: ViewData, def: NodeDef): any;\nexport declare function checkAndUpdateDirectiveInline(view: ViewData, def: NodeDef, v0: any, v1: any, v2: any, v3: any, v4: any, v5: any, v6: any, v7: any, v8: any, v9: any): boolean;\nexport declare function checkAndUpdateDirectiveDynamic(view: ViewData, def: NodeDef, values: any[]): boolean;\nexport declare const NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR: {};\nexport declare function resolveDep(view: ViewData, elDef: NodeDef, allowPrivateServices: boolean, depDef: DepDef, notFoundValue?: any): any;\nexport declare function callLifecycleHooksChildrenFirst(view: ViewData, lifecycles: NodeFlags): void;\n"
  },
  {
    "path": "node_modules/@angular/core/src/view/pure_expression.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { NodeDef, PureExpressionData, ViewData } from './types';\nexport declare function purePipeDef(checkIndex: number, argCount: number): NodeDef;\nexport declare function pureArrayDef(checkIndex: number, argCount: number): NodeDef;\nexport declare function pureObjectDef(checkIndex: number, propToIndex: {\n    [p: string]: number;\n}): NodeDef;\nexport declare function createPureExpression(view: ViewData, def: NodeDef): PureExpressionData;\nexport declare function checkAndUpdatePureExpressionInline(view: ViewData, def: NodeDef, v0: any, v1: any, v2: any, v3: any, v4: any, v5: any, v6: any, v7: any, v8: any, v9: any): boolean;\nexport declare function checkAndUpdatePureExpressionDynamic(view: ViewData, def: NodeDef, values: any[]): boolean;\n"
  },
  {
    "path": "node_modules/@angular/core/src/view/query.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { QueryList } from '../linker/query_list';\nimport { NodeDef, NodeFlags, QueryBindingType, QueryValueType, ViewData } from './types';\nexport declare function queryDef(flags: NodeFlags, id: number, bindings: {\n    [propName: string]: QueryBindingType;\n}): NodeDef;\nexport declare function createQuery(): QueryList<any>;\nexport declare function dirtyParentQueries(view: ViewData): void;\nexport declare function checkAndUpdateQuery(view: ViewData, nodeDef: NodeDef): void;\nexport declare function getQueryValue(view: ViewData, nodeDef: NodeDef, queryValueType: QueryValueType): any;\n"
  },
  {
    "path": "node_modules/@angular/core/src/view/refs.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { ApplicationRef } from '../application_ref';\nimport { ChangeDetectorRef } from '../change_detection/change_detection';\nimport { Injector } from '../di/injector';\nimport { ComponentFactory } from '../linker/component_factory';\nimport { NgModuleRef } from '../linker/ng_module_factory';\nimport { ViewContainerRef } from '../linker/view_container_ref';\nimport { EmbeddedViewRef, InternalViewRef } from '../linker/view_ref';\nimport { Renderer as RendererV1 } from '../render/api';\nimport { Type } from '../type';\nimport { ElementData, NgModuleDefinition, NodeDef, TemplateData, ViewContainerData, ViewData, ViewDefinitionFactory } from './types';\nexport declare function createComponentFactory(selector: string, componentType: Type<any>, viewDefFactory: ViewDefinitionFactory, inputs: {\n    [propName: string]: string;\n} | null, outputs: {\n    [propName: string]: string;\n}, ngContentSelectors: string[]): ComponentFactory<any>;\nexport declare function getComponentViewDefinitionFactory(componentFactory: ComponentFactory<any>): ViewDefinitionFactory;\nexport declare function createViewContainerData(view: ViewData, elDef: NodeDef, elData: ElementData): ViewContainerData;\nexport declare function createChangeDetectorRef(view: ViewData): ChangeDetectorRef;\nexport declare class ViewRef_ implements EmbeddedViewRef<any>, InternalViewRef {\n    private _viewContainerRef;\n    private _appRef;\n    constructor(_view: ViewData);\n    readonly rootNodes: any[];\n    readonly context: any;\n    readonly destroyed: boolean;\n    markForCheck(): void;\n    detach(): void;\n    detectChanges(): void;\n    checkNoChanges(): void;\n    reattach(): void;\n    onDestroy(callback: Function): void;\n    destroy(): void;\n    detachFromAppRef(): void;\n    attachToAppRef(appRef: ApplicationRef): void;\n    attachToViewContainerRef(vcRef: ViewContainerRef): void;\n}\nexport declare function createTemplateData(view: ViewData, def: NodeDef): TemplateData;\nexport declare function createInjector(view: ViewData, elDef: NodeDef): Injector;\nexport declare function nodeValue(view: ViewData, index: number): any;\nexport declare function createRendererV1(view: ViewData): RendererV1;\nexport declare function createNgModuleRef(moduleType: Type<any>, parent: Injector, bootstrapComponents: Type<any>[], def: NgModuleDefinition): NgModuleRef<any>;\n"
  },
  {
    "path": "node_modules/@angular/core/src/view/services.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { Renderer2, RendererFactory2, RendererStyleFlags2, RendererType2 } from '../render/api';\nimport { DebugContext } from './types';\nexport declare function initServicesIfNeeded(): void;\nexport declare function getCurrentDebugContext(): DebugContext | null;\nexport declare class DebugRendererFactory2 implements RendererFactory2 {\n    private delegate;\n    constructor(delegate: RendererFactory2);\n    createRenderer(element: any, renderData: RendererType2 | null): Renderer2;\n    begin(): void;\n    end(): void;\n    whenRenderingDone(): Promise<any>;\n}\nexport declare class DebugRenderer2 implements Renderer2 {\n    private delegate;\n    readonly data: {\n        [key: string]: any;\n    };\n    private createDebugContext;\n    /**\n     * Factory function used to create a `DebugContext` when a node is created.\n     *\n     * The `DebugContext` allows to retrieve information about the nodes that are useful in tests.\n     *\n     * The factory is configurable so that the `DebugRenderer2` could instantiate either a View Engine\n     * or a Render context.\n     */\n    debugContextFactory: (nativeElement?: any) => DebugContext | null;\n    constructor(delegate: Renderer2);\n    destroyNode(node: any): void;\n    destroy(): void;\n    createElement(name: string, namespace?: string): any;\n    createComment(value: string): any;\n    createText(value: string): any;\n    appendChild(parent: any, newChild: any): void;\n    insertBefore(parent: any, newChild: any, refChild: any): void;\n    removeChild(parent: any, oldChild: any): void;\n    selectRootElement(selectorOrNode: string | any, preserveContent?: boolean): any;\n    setAttribute(el: any, name: string, value: string, namespace?: string): void;\n    removeAttribute(el: any, name: string, namespace?: string): void;\n    addClass(el: any, name: string): void;\n    removeClass(el: any, name: string): void;\n    setStyle(el: any, style: string, value: any, flags: RendererStyleFlags2): void;\n    removeStyle(el: any, style: string, flags: RendererStyleFlags2): void;\n    setProperty(el: any, name: string, value: any): void;\n    listen(target: 'document' | 'windows' | 'body' | any, eventName: string, callback: (event: any) => boolean): () => void;\n    parentNode(node: any): any;\n    nextSibling(node: any): any;\n    setValue(node: any, value: string): void;\n}\n"
  },
  {
    "path": "node_modules/@angular/core/src/view/text.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { NodeDef, TextData, ViewData } from './types';\nexport declare function textDef(checkIndex: number, ngContentIndex: number | null, staticText: string[]): NodeDef;\nexport declare function createText(view: ViewData, renderHost: any, def: NodeDef): TextData;\nexport declare function checkAndUpdateTextInline(view: ViewData, def: NodeDef, v0: any, v1: any, v2: any, v3: any, v4: any, v5: any, v6: any, v7: any, v8: any, v9: any): boolean;\nexport declare function checkAndUpdateTextDynamic(view: ViewData, def: NodeDef, values: any[]): boolean;\n"
  },
  {
    "path": "node_modules/@angular/core/src/view/types.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { Injector } from '../di';\nimport { ErrorHandler } from '../error_handler';\nimport { ComponentFactory } from '../linker/component_factory';\nimport { NgModuleRef } from '../linker/ng_module_factory';\nimport { QueryList } from '../linker/query_list';\nimport { TemplateRef } from '../linker/template_ref';\nimport { ViewContainerRef } from '../linker/view_container_ref';\nimport { Renderer2, RendererFactory2, RendererType2 } from '../render/api';\nimport { Sanitizer, SecurityContext } from '../sanitization/security';\nimport { Type } from '../type';\n/**\n * Factory for ViewDefinitions/NgModuleDefinitions.\n * We use a function so we can reexeute it in case an error happens and use the given logger\n * function to log the error from the definition of the node, which is shown in all browser\n * logs.\n */\nexport interface DefinitionFactory<D extends Definition<any>> {\n    (logger: NodeLogger): D;\n}\n/**\n * Function to call console.error at the right source location. This is an indirection\n * via another function as browser will log the location that actually called\n * `console.error`.\n */\nexport interface NodeLogger {\n    (): () => void;\n}\nexport interface Definition<DF extends DefinitionFactory<any>> {\n    factory: DF | null;\n}\nexport interface NgModuleDefinition extends Definition<NgModuleDefinitionFactory> {\n    providers: NgModuleProviderDef[];\n    providersByKey: {\n        [tokenKey: string]: NgModuleProviderDef;\n    };\n    modules: any[];\n    isRoot: boolean;\n}\nexport interface NgModuleDefinitionFactory extends DefinitionFactory<NgModuleDefinition> {\n}\nexport interface ViewDefinition extends Definition<ViewDefinitionFactory> {\n    flags: ViewFlags;\n    updateDirectives: ViewUpdateFn;\n    updateRenderer: ViewUpdateFn;\n    handleEvent: ViewHandleEventFn;\n    /**\n     * Order: Depth first.\n     * Especially providers are before elements / anchors.\n     */\n    nodes: NodeDef[];\n    /** aggregated NodeFlags for all nodes **/\n    nodeFlags: NodeFlags;\n    rootNodeFlags: NodeFlags;\n    lastRenderRootNode: NodeDef | null;\n    bindingCount: number;\n    outputCount: number;\n    /**\n     * Binary or of all query ids that are matched by one of the nodes.\n     * This includes query ids from templates as well.\n     * Used as a bloom filter.\n     */\n    nodeMatchedQueries: number;\n}\nexport interface ViewDefinitionFactory extends DefinitionFactory<ViewDefinition> {\n}\nexport interface ViewUpdateFn {\n    (check: NodeCheckFn, view: ViewData): void;\n}\nexport interface NodeCheckFn {\n    (view: ViewData, nodeIndex: number, argStyle: ArgumentType.Dynamic, values: any[]): any;\n    (view: ViewData, nodeIndex: number, argStyle: ArgumentType.Inline, v0?: any, v1?: any, v2?: any, v3?: any, v4?: any, v5?: any, v6?: any, v7?: any, v8?: any, v9?: any): any;\n}\nexport declare const enum ArgumentType {\n    Inline = 0,\n    Dynamic = 1\n}\nexport interface ViewHandleEventFn {\n    (view: ViewData, nodeIndex: number, eventName: string, event: any): boolean;\n}\n/**\n * Bitmask for ViewDefinition.flags.\n */\nexport declare const enum ViewFlags {\n    None = 0,\n    OnPush = 2\n}\n/**\n * A node definition in the view.\n *\n * Note: We use one type for all nodes so that loops that loop over all nodes\n * of a ViewDefinition stay monomorphic!\n */\nexport interface NodeDef {\n    flags: NodeFlags;\n    nodeIndex: number;\n    checkIndex: number;\n    parent: NodeDef | null;\n    renderParent: NodeDef | null;\n    /** this is checked against NgContentDef.index to find matched nodes */\n    ngContentIndex: number | null;\n    /** number of transitive children */\n    childCount: number;\n    /** aggregated NodeFlags for all transitive children (does not include self) **/\n    childFlags: NodeFlags;\n    /** aggregated NodeFlags for all direct children (does not include self) **/\n    directChildFlags: NodeFlags;\n    bindingIndex: number;\n    bindings: BindingDef[];\n    bindingFlags: BindingFlags;\n    outputIndex: number;\n    outputs: OutputDef[];\n    /**\n     * references that the user placed on the element\n     */\n    references: {\n        [refId: string]: QueryValueType;\n    };\n    /**\n     * ids and value types of all queries that are matched by this node.\n     */\n    matchedQueries: {\n        [queryId: number]: QueryValueType;\n    };\n    /** Binary or of all matched query ids of this node. */\n    matchedQueryIds: number;\n    /**\n     * Binary or of all query ids that are matched by one of the children.\n     * This includes query ids from templates as well.\n     * Used as a bloom filter.\n     */\n    childMatchedQueries: number;\n    element: ElementDef | null;\n    provider: ProviderDef | null;\n    text: TextDef | null;\n    query: QueryDef | null;\n    ngContent: NgContentDef | null;\n}\n/**\n * Bitmask for NodeDef.flags.\n * Naming convention:\n * - `Type...`: flags that are mutually exclusive\n * - `Cat...`: union of multiple `Type...` (short for category).\n */\nexport declare const enum NodeFlags {\n    None = 0,\n    TypeElement = 1,\n    TypeText = 2,\n    ProjectedTemplate = 4,\n    CatRenderNode = 3,\n    TypeNgContent = 8,\n    TypePipe = 16,\n    TypePureArray = 32,\n    TypePureObject = 64,\n    TypePurePipe = 128,\n    CatPureExpression = 224,\n    TypeValueProvider = 256,\n    TypeClassProvider = 512,\n    TypeFactoryProvider = 1024,\n    TypeUseExistingProvider = 2048,\n    LazyProvider = 4096,\n    PrivateProvider = 8192,\n    TypeDirective = 16384,\n    Component = 32768,\n    CatProviderNoDirective = 3840,\n    CatProvider = 20224,\n    OnInit = 65536,\n    OnDestroy = 131072,\n    DoCheck = 262144,\n    OnChanges = 524288,\n    AfterContentInit = 1048576,\n    AfterContentChecked = 2097152,\n    AfterViewInit = 4194304,\n    AfterViewChecked = 8388608,\n    EmbeddedViews = 16777216,\n    ComponentView = 33554432,\n    TypeContentQuery = 67108864,\n    TypeViewQuery = 134217728,\n    StaticQuery = 268435456,\n    DynamicQuery = 536870912,\n    TypeNgModule = 1073741824,\n    CatQuery = 201326592,\n    Types = 201347067\n}\nexport interface BindingDef {\n    flags: BindingFlags;\n    ns: string | null;\n    name: string | null;\n    nonMinifiedName: string | null;\n    securityContext: SecurityContext | null;\n    suffix: string | null;\n}\nexport declare const enum BindingFlags {\n    TypeElementAttribute = 1,\n    TypeElementClass = 2,\n    TypeElementStyle = 4,\n    TypeProperty = 8,\n    SyntheticProperty = 16,\n    SyntheticHostProperty = 32,\n    CatSyntheticProperty = 48,\n    Types = 15\n}\nexport interface OutputDef {\n    type: OutputType;\n    target: 'window' | 'document' | 'body' | 'component' | null;\n    eventName: string;\n    propName: string | null;\n}\nexport declare const enum OutputType {\n    ElementOutput = 0,\n    DirectiveOutput = 1\n}\nexport declare const enum QueryValueType {\n    ElementRef = 0,\n    RenderElement = 1,\n    TemplateRef = 2,\n    ViewContainerRef = 3,\n    Provider = 4\n}\nexport interface ElementDef {\n    name: string | null;\n    ns: string | null;\n    /** ns, name, value */\n    attrs: [string, string, string][] | null;\n    template: ViewDefinition | null;\n    componentProvider: NodeDef | null;\n    componentRendererType: RendererType2 | null;\n    componentView: ViewDefinitionFactory | null;\n    /**\n     * visible public providers for DI in the view,\n     * as see from this element. This does not include private providers.\n     */\n    publicProviders: {\n        [tokenKey: string]: NodeDef;\n    } | null;\n    /**\n     * same as visiblePublicProviders, but also includes private providers\n     * that are located on this element.\n     */\n    allProviders: {\n        [tokenKey: string]: NodeDef;\n    } | null;\n    handleEvent: ElementHandleEventFn | null;\n}\nexport interface ElementHandleEventFn {\n    (view: ViewData, eventName: string, event: any): boolean;\n}\nexport interface ProviderDef {\n    token: any;\n    value: any;\n    deps: DepDef[];\n}\nexport interface NgModuleProviderDef {\n    flags: NodeFlags;\n    index: number;\n    token: any;\n    value: any;\n    deps: DepDef[];\n}\nexport interface DepDef {\n    flags: DepFlags;\n    token: any;\n    tokenKey: string;\n}\n/**\n * Bitmask for DI flags\n */\nexport declare const enum DepFlags {\n    None = 0,\n    SkipSelf = 1,\n    Optional = 2,\n    Self = 4,\n    Value = 8\n}\nexport interface TextDef {\n    prefix: string;\n}\nexport interface QueryDef {\n    id: number;\n    filterId: number;\n    bindings: QueryBindingDef[];\n}\nexport interface QueryBindingDef {\n    propName: string;\n    bindingType: QueryBindingType;\n}\nexport declare const enum QueryBindingType {\n    First = 0,\n    All = 1\n}\nexport interface NgContentDef {\n    /**\n     * this index is checked against NodeDef.ngContentIndex to find the nodes\n     * that are matched by this ng-content.\n     * Note that a NodeDef with an ng-content can be reprojected, i.e.\n     * have a ngContentIndex on its own.\n     */\n    index: number;\n}\nexport interface NgModuleData extends Injector, NgModuleRef<any> {\n    _def: NgModuleDefinition;\n    _parent: Injector;\n    _providers: any[];\n}\n/**\n * View instance data.\n * Attention: Adding fields to this is performance sensitive!\n */\nexport interface ViewData {\n    def: ViewDefinition;\n    root: RootData;\n    renderer: Renderer2;\n    parentNodeDef: NodeDef | null;\n    parent: ViewData | null;\n    viewContainerParent: ViewData | null;\n    component: any;\n    context: any;\n    nodes: {\n        [key: number]: NodeData;\n    };\n    state: ViewState;\n    oldValues: any[];\n    disposables: DisposableFn[] | null;\n    initIndex: number;\n}\n/**\n * Bitmask of states\n */\nexport declare const enum ViewState {\n    BeforeFirstCheck = 1,\n    FirstCheck = 2,\n    Attached = 4,\n    ChecksEnabled = 8,\n    IsProjectedView = 16,\n    CheckProjectedView = 32,\n    CheckProjectedViews = 64,\n    Destroyed = 128,\n    InitState_Mask = 1792,\n    InitState_BeforeInit = 0,\n    InitState_CallingOnInit = 256,\n    InitState_CallingAfterContentInit = 512,\n    InitState_CallingAfterViewInit = 768,\n    InitState_AfterInit = 1024,\n    CatDetectChanges = 12,\n    CatInit = 13\n}\nexport declare function shiftInitState(view: ViewData, priorInitState: ViewState, newInitState: ViewState): boolean;\nexport declare function shouldCallLifecycleInitHook(view: ViewData, initState: ViewState, index: number): boolean;\nexport interface DisposableFn {\n    (): void;\n}\n/**\n * Node instance data.\n *\n * We have a separate type per NodeType to save memory\n * (TextData | ElementData | ProviderData | PureExpressionData | QueryList<any>)\n *\n * To keep our code monomorphic,\n * we prohibit using `NodeData` directly but enforce the use of accessors (`asElementData`, ...).\n * This way, no usage site can get a `NodeData` from view.nodes and then use it for different\n * purposes.\n */\nexport declare class NodeData {\n    private __brand;\n}\n/**\n * Data for an instantiated NodeType.Text.\n *\n * Attention: Adding fields to this is performance sensitive!\n */\nexport interface TextData {\n    renderText: any;\n}\n/**\n * Accessor for view.nodes, enforcing that every usage site stays monomorphic.\n */\nexport declare function asTextData(view: ViewData, index: number): TextData;\n/**\n * Data for an instantiated NodeType.Element.\n *\n * Attention: Adding fields to this is performance sensitive!\n */\nexport interface ElementData {\n    renderElement: any;\n    componentView: ViewData;\n    viewContainer: ViewContainerData | null;\n    template: TemplateData;\n}\nexport interface ViewContainerData extends ViewContainerRef {\n    _embeddedViews: ViewData[];\n}\nexport interface TemplateData extends TemplateRef<any> {\n    _projectedViews: ViewData[];\n}\n/**\n * Accessor for view.nodes, enforcing that every usage site stays monomorphic.\n */\nexport declare function asElementData(view: ViewData, index: number): ElementData;\n/**\n * Data for an instantiated NodeType.Provider.\n *\n * Attention: Adding fields to this is performance sensitive!\n */\nexport interface ProviderData {\n    instance: any;\n}\n/**\n * Accessor for view.nodes, enforcing that every usage site stays monomorphic.\n */\nexport declare function asProviderData(view: ViewData, index: number): ProviderData;\n/**\n * Data for an instantiated NodeType.PureExpression.\n *\n * Attention: Adding fields to this is performance sensitive!\n */\nexport interface PureExpressionData {\n    value: any;\n}\n/**\n * Accessor for view.nodes, enforcing that every usage site stays monomorphic.\n */\nexport declare function asPureExpressionData(view: ViewData, index: number): PureExpressionData;\n/**\n * Accessor for view.nodes, enforcing that every usage site stays monomorphic.\n */\nexport declare function asQueryList(view: ViewData, index: number): QueryList<any>;\nexport interface RootData {\n    injector: Injector;\n    ngModule: NgModuleRef<any>;\n    projectableNodes: any[][];\n    selectorOrNode: any;\n    renderer: Renderer2;\n    rendererFactory: RendererFactory2;\n    errorHandler: ErrorHandler;\n    sanitizer: Sanitizer;\n}\nexport declare abstract class DebugContext {\n    abstract readonly view: ViewData;\n    abstract readonly nodeIndex: number | null;\n    abstract readonly injector: Injector;\n    abstract readonly component: any;\n    abstract readonly providerTokens: any[];\n    abstract readonly references: {\n        [key: string]: any;\n    };\n    abstract readonly context: any;\n    abstract readonly componentRenderElement: any;\n    abstract readonly renderNode: any;\n    abstract logError(console: Console, ...values: any[]): void;\n}\nexport declare const enum CheckType {\n    CheckAndUpdate = 0,\n    CheckNoChanges = 1\n}\nexport interface ProviderOverride {\n    token: any;\n    flags: NodeFlags;\n    value: any;\n    deps: ([DepFlags, any] | any)[];\n    deprecatedBehavior: boolean;\n}\nexport interface Services {\n    setCurrentNode(view: ViewData, nodeIndex: number): void;\n    createRootView(injector: Injector, projectableNodes: any[][], rootSelectorOrNode: string | any, def: ViewDefinition, ngModule: NgModuleRef<any>, context?: any): ViewData;\n    createEmbeddedView(parent: ViewData, anchorDef: NodeDef, viewDef: ViewDefinition, context?: any): ViewData;\n    createComponentView(parentView: ViewData, nodeDef: NodeDef, viewDef: ViewDefinition, hostElement: any): ViewData;\n    createNgModuleRef(moduleType: Type<any>, parent: Injector, bootstrapComponents: Type<any>[], def: NgModuleDefinition): NgModuleRef<any>;\n    overrideProvider(override: ProviderOverride): void;\n    overrideComponentView(compType: Type<any>, compFactory: ComponentFactory<any>): void;\n    clearOverrides(): void;\n    checkAndUpdateView(view: ViewData): void;\n    checkNoChangesView(view: ViewData): void;\n    destroyView(view: ViewData): void;\n    resolveDep(view: ViewData, elDef: NodeDef | null, allowPrivateServices: boolean, depDef: DepDef, notFoundValue?: any): any;\n    createDebugContext(view: ViewData, nodeIndex: number): DebugContext;\n    handleEvent: ViewHandleEventFn;\n    updateDirectives: (view: ViewData, checkType: CheckType) => void;\n    updateRenderer: (view: ViewData, checkType: CheckType) => void;\n    dirtyParentQueries: (view: ViewData) => void;\n}\n/**\n * This object is used to prevent cycles in the source files and to have a place where\n * debug mode can hook it. It is lazily filled when `isDevMode` is known.\n */\nexport declare const Services: Services;\n"
  },
  {
    "path": "node_modules/@angular/core/src/view/util.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { ViewEncapsulation } from '../metadata/view';\nimport { RendererType2 } from '../render/api';\nimport { BindingDef, BindingFlags, Definition, DefinitionFactory, DepDef, DepFlags, ElementData, NodeDef, QueryValueType, ViewData } from './types';\nexport declare const NOOP: any;\nexport declare function tokenKey(token: any): string;\nexport declare function unwrapValue(view: ViewData, nodeIdx: number, bindingIdx: number, value: any): any;\nexport declare function createRendererType2(values: {\n    styles: (string | any[])[];\n    encapsulation: ViewEncapsulation;\n    data: {\n        [kind: string]: any[];\n    };\n}): RendererType2;\nexport declare function resolveRendererType2(type?: RendererType2 | null): RendererType2 | null;\nexport declare function checkBinding(view: ViewData, def: NodeDef, bindingIdx: number, value: any): boolean;\nexport declare function checkAndUpdateBinding(view: ViewData, def: NodeDef, bindingIdx: number, value: any): boolean;\nexport declare function checkBindingNoChanges(view: ViewData, def: NodeDef, bindingIdx: number, value: any): void;\nexport declare function markParentViewsForCheck(view: ViewData): void;\nexport declare function markParentViewsForCheckProjectedViews(view: ViewData, endView: ViewData): void;\nexport declare function dispatchEvent(view: ViewData, nodeIndex: number, eventName: string, event: any): boolean | undefined;\nexport declare function declaredViewContainer(view: ViewData): ElementData | null;\n/**\n * for component views, this is the host element.\n * for embedded views, this is the index of the parent node\n * that contains the view container.\n */\nexport declare function viewParentEl(view: ViewData): NodeDef | null;\nexport declare function renderNode(view: ViewData, def: NodeDef): any;\nexport declare function elementEventFullName(target: string | null, name: string): string;\nexport declare function isComponentView(view: ViewData): boolean;\nexport declare function isEmbeddedView(view: ViewData): boolean;\nexport declare function filterQueryId(queryId: number): number;\nexport declare function splitMatchedQueriesDsl(matchedQueriesDsl: [string | number, QueryValueType][] | null): {\n    matchedQueries: {\n        [queryId: string]: QueryValueType;\n    };\n    references: {\n        [refId: string]: QueryValueType;\n    };\n    matchedQueryIds: number;\n};\nexport declare function splitDepsDsl(deps: ([DepFlags, any] | any)[], sourceName?: string): DepDef[];\nexport declare function getParentRenderElement(view: ViewData, renderHost: any, def: NodeDef): any;\nexport declare function resolveDefinition<D extends Definition<any>>(factory: DefinitionFactory<D>): D;\nexport declare function rootRenderNodes(view: ViewData): any[];\nexport declare const enum RenderNodeAction {\n    Collect = 0,\n    AppendChild = 1,\n    InsertBefore = 2,\n    RemoveChild = 3\n}\nexport declare function visitRootRenderNodes(view: ViewData, action: RenderNodeAction, parentNode: any, nextSibling: any, target?: any[]): void;\nexport declare function visitSiblingRenderNodes(view: ViewData, action: RenderNodeAction, startIndex: number, endIndex: number, parentNode: any, nextSibling: any, target?: any[]): void;\nexport declare function visitProjectedRenderNodes(view: ViewData, ngContentIndex: number, action: RenderNodeAction, parentNode: any, nextSibling: any, target?: any[]): void;\nexport declare function splitNamespace(name: string): string[];\nexport declare function calcBindingFlags(bindings: BindingDef[]): BindingFlags;\nexport declare function interpolate(valueCount: number, constAndInterp: string[]): string;\nexport declare function inlineInterpolate(valueCount: number, c0: string, a1: any, c1: string, a2?: any, c2?: string, a3?: any, c3?: string, a4?: any, c4?: string, a5?: any, c5?: string, a6?: any, c6?: string, a7?: any, c7?: string, a8?: any, c8?: string, a9?: any, c9?: string): string;\nexport declare const EMPTY_ARRAY: any[];\nexport declare const EMPTY_MAP: {\n    [key: string]: any;\n};\n"
  },
  {
    "path": "node_modules/@angular/core/src/view/view_attach.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { ElementData, ViewData } from './types';\nexport declare function attachEmbeddedView(parentView: ViewData, elementData: ElementData, viewIndex: number | undefined | null, view: ViewData): void;\nexport declare function detachEmbeddedView(elementData: ElementData, viewIndex?: number): ViewData | null;\nexport declare function detachProjectedView(view: ViewData): void;\nexport declare function moveEmbeddedView(elementData: ElementData, oldViewIndex: number, newViewIndex: number): ViewData;\nexport declare function renderDetachView(view: ViewData): void;\n"
  },
  {
    "path": "node_modules/@angular/core/src/view/view.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { ArgumentType, NodeDef, RootData, ViewData, ViewDefinition, ViewFlags, ViewUpdateFn } from './types';\nexport declare function viewDef(flags: ViewFlags, nodes: NodeDef[], updateDirectives?: null | ViewUpdateFn, updateRenderer?: null | ViewUpdateFn): ViewDefinition;\nexport declare function createEmbeddedView(parent: ViewData, anchorDef: NodeDef, viewDef: ViewDefinition, context?: any): ViewData;\nexport declare function createRootView(root: RootData, def: ViewDefinition, context?: any): ViewData;\nexport declare function createComponentView(parentView: ViewData, nodeDef: NodeDef, viewDef: ViewDefinition, hostElement: any): ViewData;\nexport declare function checkNoChangesView(view: ViewData): void;\nexport declare function checkAndUpdateView(view: ViewData): void;\nexport declare function checkAndUpdateNode(view: ViewData, nodeDef: NodeDef, argStyle: ArgumentType, v0?: any, v1?: any, v2?: any, v3?: any, v4?: any, v5?: any, v6?: any, v7?: any, v8?: any, v9?: any): boolean;\nexport declare function checkNoChangesNode(view: ViewData, nodeDef: NodeDef, argStyle: ArgumentType, v0?: any, v1?: any, v2?: any, v3?: any, v4?: any, v5?: any, v6?: any, v7?: any, v8?: any, v9?: any): any;\nexport declare function destroyView(view: ViewData): void;\n"
  },
  {
    "path": "node_modules/@angular/core/src/zone.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nexport { NgZone, NoopNgZone as ɵNoopNgZone } from './zone/ng_zone';\n"
  },
  {
    "path": "node_modules/@angular/core/src/zone/ng_zone.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { EventEmitter } from '../event_emitter';\n/**\n * An injectable service for executing work inside or outside of the Angular zone.\n *\n * The most common use of this service is to optimize performance when starting a work consisting of\n * one or more asynchronous tasks that don't require UI updates or error handling to be handled by\n * Angular. Such tasks can be kicked off via {@link #runOutsideAngular} and if needed, these tasks\n * can reenter the Angular zone via {@link #run}.\n *\n * <!-- TODO: add/fix links to:\n *   - docs explaining zones and the use of zones in Angular and change-detection\n *   - link to runOutsideAngular/run (throughout this file!)\n *   -->\n *\n * @usageNotes\n * ### Example\n *\n * ```\n * import {Component, NgZone} from '@angular/core';\n * import {NgIf} from '@angular/common';\n *\n * @Component({\n *   selector: 'ng-zone-demo',\n *   template: `\n *     <h2>Demo: NgZone</h2>\n *\n *     <p>Progress: {{progress}}%</p>\n *     <p *ngIf=\"progress >= 100\">Done processing {{label}} of Angular zone!</p>\n *\n *     <button (click)=\"processWithinAngularZone()\">Process within Angular zone</button>\n *     <button (click)=\"processOutsideOfAngularZone()\">Process outside of Angular zone</button>\n *   `,\n * })\n * export class NgZoneDemo {\n *   progress: number = 0;\n *   label: string;\n *\n *   constructor(private _ngZone: NgZone) {}\n *\n *   // Loop inside the Angular zone\n *   // so the UI DOES refresh after each setTimeout cycle\n *   processWithinAngularZone() {\n *     this.label = 'inside';\n *     this.progress = 0;\n *     this._increaseProgress(() => console.log('Inside Done!'));\n *   }\n *\n *   // Loop outside of the Angular zone\n *   // so the UI DOES NOT refresh after each setTimeout cycle\n *   processOutsideOfAngularZone() {\n *     this.label = 'outside';\n *     this.progress = 0;\n *     this._ngZone.runOutsideAngular(() => {\n *       this._increaseProgress(() => {\n *         // reenter the Angular zone and display done\n *         this._ngZone.run(() => { console.log('Outside Done!'); });\n *       });\n *     });\n *   }\n *\n *   _increaseProgress(doneCallback: () => void) {\n *     this.progress += 1;\n *     console.log(`Current progress: ${this.progress}%`);\n *\n *     if (this.progress < 100) {\n *       window.setTimeout(() => this._increaseProgress(doneCallback), 10);\n *     } else {\n *       doneCallback();\n *     }\n *   }\n * }\n * ```\n *\n * @publicApi\n */\nexport declare class NgZone {\n    readonly hasPendingMicrotasks: boolean;\n    readonly hasPendingMacrotasks: boolean;\n    /**\n     * Whether there are no outstanding microtasks or macrotasks.\n     */\n    readonly isStable: boolean;\n    /**\n     * Notifies when code enters Angular Zone. This gets fired first on VM Turn.\n     */\n    readonly onUnstable: EventEmitter<any>;\n    /**\n     * Notifies when there is no more microtasks enqueued in the current VM Turn.\n     * This is a hint for Angular to do change detection, which may enqueue more microtasks.\n     * For this reason this event can fire multiple times per VM Turn.\n     */\n    readonly onMicrotaskEmpty: EventEmitter<any>;\n    /**\n     * Notifies when the last `onMicrotaskEmpty` has run and there are no more microtasks, which\n     * implies we are about to relinquish VM turn.\n     * This event gets called just once.\n     */\n    readonly onStable: EventEmitter<any>;\n    /**\n     * Notifies that an error has been delivered.\n     */\n    readonly onError: EventEmitter<any>;\n    constructor({ enableLongStackTrace }: {\n        enableLongStackTrace?: boolean | undefined;\n    });\n    static isInAngularZone(): boolean;\n    static assertInAngularZone(): void;\n    static assertNotInAngularZone(): void;\n    /**\n     * Executes the `fn` function synchronously within the Angular zone and returns value returned by\n     * the function.\n     *\n     * Running functions via `run` allows you to reenter Angular zone from a task that was executed\n     * outside of the Angular zone (typically started via {@link #runOutsideAngular}).\n     *\n     * Any future tasks or microtasks scheduled from within this function will continue executing from\n     * within the Angular zone.\n     *\n     * If a synchronous error happens it will be rethrown and not reported via `onError`.\n     */\n    run<T>(fn: (...args: any[]) => T, applyThis?: any, applyArgs?: any[]): T;\n    /**\n     * Executes the `fn` function synchronously within the Angular zone as a task and returns value\n     * returned by the function.\n     *\n     * Running functions via `run` allows you to reenter Angular zone from a task that was executed\n     * outside of the Angular zone (typically started via {@link #runOutsideAngular}).\n     *\n     * Any future tasks or microtasks scheduled from within this function will continue executing from\n     * within the Angular zone.\n     *\n     * If a synchronous error happens it will be rethrown and not reported via `onError`.\n     */\n    runTask<T>(fn: (...args: any[]) => T, applyThis?: any, applyArgs?: any[], name?: string): T;\n    /**\n     * Same as `run`, except that synchronous errors are caught and forwarded via `onError` and not\n     * rethrown.\n     */\n    runGuarded<T>(fn: (...args: any[]) => T, applyThis?: any, applyArgs?: any[]): T;\n    /**\n     * Executes the `fn` function synchronously in Angular's parent zone and returns value returned by\n     * the function.\n     *\n     * Running functions via {@link #runOutsideAngular} allows you to escape Angular's zone and do\n     * work that\n     * doesn't trigger Angular change-detection or is subject to Angular's error handling.\n     *\n     * Any future tasks or microtasks scheduled from within this function will continue executing from\n     * outside of the Angular zone.\n     *\n     * Use {@link #run} to reenter the Angular zone and do work that updates the application model.\n     */\n    runOutsideAngular<T>(fn: (...args: any[]) => T): T;\n}\n/**\n * Provides a noop implementation of `NgZone` which does nothing. This zone requires explicit calls\n * to framework to perform rendering.\n */\nexport declare class NoopNgZone implements NgZone {\n    readonly hasPendingMicrotasks: boolean;\n    readonly hasPendingMacrotasks: boolean;\n    readonly isStable: boolean;\n    readonly onUnstable: EventEmitter<any>;\n    readonly onMicrotaskEmpty: EventEmitter<any>;\n    readonly onStable: EventEmitter<any>;\n    readonly onError: EventEmitter<any>;\n    run(fn: () => any): any;\n    runGuarded(fn: () => any): any;\n    runOutsideAngular(fn: () => any): any;\n    runTask<T>(fn: () => any): any;\n}\n"
  },
  {
    "path": "node_modules/@angular/core/testing.d.ts",
    "content": "/**\n * @license Angular v7.1.4\n * (c) 2010-2018 Google, Inc. https://angular.io/\n * License: MIT\n */\n\n  export * from './testing/testing';\n  "
  },
  {
    "path": "node_modules/@angular/core/testing/index.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nexport * from './public_api';\n"
  },
  {
    "path": "node_modules/@angular/core/testing/public_api.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * @module\n * @description\n * Entry point for all public APIs of this package.\n */\nexport * from './src/testing';\n"
  },
  {
    "path": "node_modules/@angular/core/testing/src/async_fallback.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Wraps a test function in an asynchronous test zone. The test will automatically\n * complete when all asynchronous calls within this zone are done. Can be used\n * to wrap an {@link inject} call.\n *\n * Example:\n *\n * ```\n * it('...', async(inject([AClass], (object) => {\n *   object.doSomething.then(() => {\n *     expect(...);\n *   })\n * });\n * ```\n *\n *\n */\nexport declare function asyncFallback(fn: Function): (done: any) => any;\n"
  },
  {
    "path": "node_modules/@angular/core/testing/src/async_test_completer.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Injectable completer that allows signaling completion of an asynchronous test. Used internally.\n */\nexport declare class AsyncTestCompleter {\n    private _resolve;\n    private _reject;\n    private _promise;\n    done(value?: any): void;\n    fail(error?: any, stackTrace?: string): void;\n    readonly promise: Promise<any>;\n}\n"
  },
  {
    "path": "node_modules/@angular/core/testing/src/async.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Wraps a test function in an asynchronous test zone. The test will automatically\n * complete when all asynchronous calls within this zone are done. Can be used\n * to wrap an {@link inject} call.\n *\n * Example:\n *\n * ```\n * it('...', async(inject([AClass], (object) => {\n *   object.doSomething.then(() => {\n *     expect(...);\n *   })\n * });\n * ```\n *\n * @publicApi\n */\nexport declare function async(fn: Function): (done: any) => any;\n"
  },
  {
    "path": "node_modules/@angular/core/testing/src/before_each.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nexport declare const __core_private_testing_placeholder__ = \"\";\n"
  },
  {
    "path": "node_modules/@angular/core/testing/src/component_fixture.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { ChangeDetectorRef, ComponentRef, DebugElement, ElementRef, NgZone } from '@angular/core';\n/**\n * Fixture for debugging and testing a component.\n *\n * @publicApi\n */\nexport declare class ComponentFixture<T> {\n    componentRef: ComponentRef<T>;\n    ngZone: NgZone | null;\n    private _autoDetect;\n    /**\n     * The DebugElement associated with the root element of this component.\n     */\n    debugElement: DebugElement;\n    /**\n     * The instance of the root component class.\n     */\n    componentInstance: T;\n    /**\n     * The native element at the root of the component.\n     */\n    nativeElement: any;\n    /**\n     * The ElementRef for the element at the root of the component.\n     */\n    elementRef: ElementRef;\n    /**\n     * The ChangeDetectorRef for the component\n     */\n    changeDetectorRef: ChangeDetectorRef;\n    private _renderer;\n    private _isStable;\n    private _isDestroyed;\n    private _resolve;\n    private _promise;\n    private _onUnstableSubscription;\n    private _onStableSubscription;\n    private _onMicrotaskEmptySubscription;\n    private _onErrorSubscription;\n    constructor(componentRef: ComponentRef<T>, ngZone: NgZone | null, _autoDetect: boolean);\n    private _tick;\n    /**\n     * Trigger a change detection cycle for the component.\n     */\n    detectChanges(checkNoChanges?: boolean): void;\n    /**\n     * Do a change detection run to make sure there were no changes.\n     */\n    checkNoChanges(): void;\n    /**\n     * Set whether the fixture should autodetect changes.\n     *\n     * Also runs detectChanges once so that any existing change is detected.\n     */\n    autoDetectChanges(autoDetect?: boolean): void;\n    /**\n     * Return whether the fixture is currently stable or has async tasks that have not been completed\n     * yet.\n     */\n    isStable(): boolean;\n    /**\n     * Get a promise that resolves when the fixture is stable.\n     *\n     * This can be used to resume testing after events have triggered asynchronous activity or\n     * asynchronous change detection.\n     */\n    whenStable(): Promise<any>;\n    private _getRenderer;\n    /**\n      * Get a promise that resolves when the ui state is stable following animations.\n      */\n    whenRenderingDone(): Promise<any>;\n    /**\n     * Trigger component destruction.\n     */\n    destroy(): void;\n}\n"
  },
  {
    "path": "node_modules/@angular/core/testing/src/fake_async_fallback.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Clears out the shared fake async zone for a test.\n * To be called in a global `beforeEach`.\n *\n * @publicApi\n */\nexport declare function resetFakeAsyncZoneFallback(): void;\n/**\n * Wraps a function to be executed in the fakeAsync zone:\n * - microtasks are manually executed by calling `flushMicrotasks()`,\n * - timers are synchronous, `tick()` simulates the asynchronous passage of time.\n *\n * If there are any pending timers at the end of the function, an exception will be thrown.\n *\n * Can be used to wrap inject() calls.\n *\n * @usageNotes\n * ### Example\n *\n * {@example core/testing/ts/fake_async.ts region='basic'}\n *\n * @param fn\n * @returns The function wrapped to be executed in the fakeAsync zone\n *\n * @publicApi\n */\nexport declare function fakeAsyncFallback(fn: Function): (...args: any[]) => any;\n/**\n * Simulates the asynchronous passage of time for the timers in the fakeAsync zone.\n *\n * The microtasks queue is drained at the very start of this function and after any timer callback\n * has been executed.\n *\n * @usageNotes\n * ### Example\n *\n * {@example core/testing/ts/fake_async.ts region='basic'}\n *\n * @publicApi\n */\nexport declare function tickFallback(millis?: number): void;\n/**\n * Simulates the asynchronous passage of time for the timers in the fakeAsync zone by\n * draining the macrotask queue until it is empty. The returned value is the milliseconds\n * of time that would have been elapsed.\n *\n * @param maxTurns\n * @returns The simulated time elapsed, in millis.\n *\n * @publicApi\n */\nexport declare function flushFallback(maxTurns?: number): number;\n/**\n * Discard all remaining periodic tasks.\n *\n * @publicApi\n */\nexport declare function discardPeriodicTasksFallback(): void;\n/**\n * Flush any pending microtasks.\n *\n * @publicApi\n */\nexport declare function flushMicrotasksFallback(): void;\n"
  },
  {
    "path": "node_modules/@angular/core/testing/src/fake_async.d.ts",
    "content": "/**\n * Clears out the shared fake async zone for a test.\n * To be called in a global `beforeEach`.\n *\n * @publicApi\n */\nexport declare function resetFakeAsyncZone(): void;\n/**\n * Wraps a function to be executed in the fakeAsync zone:\n * - microtasks are manually executed by calling `flushMicrotasks()`,\n * - timers are synchronous, `tick()` simulates the asynchronous passage of time.\n *\n * If there are any pending timers at the end of the function, an exception will be thrown.\n *\n * Can be used to wrap inject() calls.\n *\n * @usageNotes\n * ### Example\n *\n * {@example core/testing/ts/fake_async.ts region='basic'}\n *\n * @param fn\n * @returns The function wrapped to be executed in the fakeAsync zone\n *\n * @publicApi\n */\nexport declare function fakeAsync(fn: Function): (...args: any[]) => any;\n/**\n * Simulates the asynchronous passage of time for the timers in the fakeAsync zone.\n *\n * The microtasks queue is drained at the very start of this function and after any timer callback\n * has been executed.\n *\n * @usageNotes\n * ### Example\n *\n * {@example core/testing/ts/fake_async.ts region='basic'}\n *\n * @publicApi\n */\nexport declare function tick(millis?: number): void;\n/**\n * Simulates the asynchronous passage of time for the timers in the fakeAsync zone by\n * draining the macrotask queue until it is empty. The returned value is the milliseconds\n * of time that would have been elapsed.\n *\n * @param maxTurns\n * @returns The simulated time elapsed, in millis.\n *\n * @publicApi\n */\nexport declare function flush(maxTurns?: number): number;\n/**\n * Discard all remaining periodic tasks.\n *\n * @publicApi\n */\nexport declare function discardPeriodicTasks(): void;\n/**\n * Flush any pending microtasks.\n *\n * @publicApi\n */\nexport declare function flushMicrotasks(): void;\n"
  },
  {
    "path": "node_modules/@angular/core/testing/src/lang_utils.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nexport declare function getTypeOf(instance: any /** TODO #9100 */): any;\nexport declare function instantiateType(type: Function, params?: any[]): any;\n"
  },
  {
    "path": "node_modules/@angular/core/testing/src/logger.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nexport declare class Log {\n    logItems: any[];\n    constructor();\n    add(value: any /** TODO #9100 */): void;\n    fn(value: any /** TODO #9100 */): (a1?: any, a2?: any, a3?: any, a4?: any, a5?: any) => void;\n    clear(): void;\n    result(): string;\n}\n"
  },
  {
    "path": "node_modules/@angular/core/testing/src/metadata_override.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Type used for modifications to metadata\n *\n * @publicApi\n */\nexport declare type MetadataOverride<T> = {\n    add?: Partial<T>;\n    remove?: Partial<T>;\n    set?: Partial<T>;\n};\n"
  },
  {
    "path": "node_modules/@angular/core/testing/src/metadata_overrider.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { MetadataOverride } from './metadata_override';\nexport declare class MetadataOverrider {\n    private _references;\n    /**\n     * Creates a new instance for the given metadata class\n     * based on an old instance and overrides.\n     */\n    overrideMetadata<C extends T, T>(metadataClass: {\n        new (options: T): C;\n    }, oldMetadata: C, override: MetadataOverride<T>): C;\n}\n"
  },
  {
    "path": "node_modules/@angular/core/testing/src/ng_zone_mock.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { EventEmitter, NgZone } from '@angular/core';\n/**\n * A mock implementation of {@link NgZone}.\n */\nexport declare class MockNgZone extends NgZone {\n    onStable: EventEmitter<any>;\n    constructor();\n    run(fn: Function): any;\n    runOutsideAngular(fn: Function): any;\n    simulateZoneExit(): void;\n}\n"
  },
  {
    "path": "node_modules/@angular/core/testing/src/private_export_testing.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nexport { TestingCompiler as ɵTestingCompiler, TestingCompilerFactory as ɵTestingCompilerFactory } from './test_compiler';\n"
  },
  {
    "path": "node_modules/@angular/core/testing/src/r3_test_bed.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { Component, Directive, Injector, NgModule, Pipe, PlatformRef, Type } from '@angular/core';\nimport { ComponentFixture } from './component_fixture';\nimport { MetadataOverride } from './metadata_override';\nimport { TestBed } from './test_bed';\nimport { TestBedStatic, TestModuleMetadata } from './test_bed_common';\n/**\n * @description\n * Configures and initializes environment for unit testing and provides methods for\n * creating components and services in unit tests.\n *\n * TestBed is the primary api for writing unit tests for Angular applications and libraries.\n *\n * Note: Use `TestBed` in tests. It will be set to either `TestBedViewEngine` or `TestBedRender3`\n * according to the compiler used.\n */\nexport declare class TestBedRender3 implements Injector, TestBed {\n    /**\n     * Initialize the environment for testing with a compiler factory, a PlatformRef, and an\n     * angular module. These are common to every test in the suite.\n     *\n     * This may only be called once, to set up the common providers for the current test\n     * suite on the current platform. If you absolutely need to change the providers,\n     * first use `resetTestEnvironment`.\n     *\n     * Test modules and platforms for individual platforms are available from\n     * '@angular/<platform_name>/testing'.\n     *\n     * @publicApi\n     */\n    static initTestEnvironment(ngModule: Type<any> | Type<any>[], platform: PlatformRef, aotSummaries?: () => any[]): TestBed;\n    /**\n     * Reset the providers for the test injector.\n     *\n     * @publicApi\n     */\n    static resetTestEnvironment(): void;\n    static configureCompiler(config: {\n        providers?: any[];\n        useJit?: boolean;\n    }): TestBedStatic;\n    /**\n     * Allows overriding default providers, directives, pipes, modules of the test injector,\n     * which are defined in test_injector.js\n     */\n    static configureTestingModule(moduleDef: TestModuleMetadata): TestBedStatic;\n    /**\n     * Compile components with a `templateUrl` for the test's NgModule.\n     * It is necessary to call this function\n     * as fetching urls is asynchronous.\n     */\n    static compileComponents(): Promise<any>;\n    static overrideModule(ngModule: Type<any>, override: MetadataOverride<NgModule>): TestBedStatic;\n    static overrideComponent(component: Type<any>, override: MetadataOverride<Component>): TestBedStatic;\n    static overrideDirective(directive: Type<any>, override: MetadataOverride<Directive>): TestBedStatic;\n    static overridePipe(pipe: Type<any>, override: MetadataOverride<Pipe>): TestBedStatic;\n    static overrideTemplate(component: Type<any>, template: string): TestBedStatic;\n    /**\n     * Overrides the template of the given component, compiling the template\n     * in the context of the TestingModule.\n     *\n     * Note: This works for JIT and AOTed components as well.\n     */\n    static overrideTemplateUsingTestingModule(component: Type<any>, template: string): TestBedStatic;\n    overrideTemplateUsingTestingModule(component: Type<any>, template: string): void;\n    static overrideProvider(token: any, provider: {\n        useFactory: Function;\n        deps: any[];\n    }): TestBedStatic;\n    static overrideProvider(token: any, provider: {\n        useValue: any;\n    }): TestBedStatic;\n    /**\n     * Overwrites all providers for the given token with the given provider definition.\n     *\n     * @deprecated as it makes all NgModules lazy. Introduced only for migrating off of it.\n     */\n    static deprecatedOverrideProvider(token: any, provider: {\n        useFactory: Function;\n        deps: any[];\n    }): void;\n    static deprecatedOverrideProvider(token: any, provider: {\n        useValue: any;\n    }): void;\n    static get(token: any, notFoundValue?: any): any;\n    static createComponent<T>(component: Type<T>): ComponentFixture<T>;\n    static resetTestingModule(): TestBedStatic;\n    platform: PlatformRef;\n    ngModule: Type<any> | Type<any>[];\n    private _moduleOverrides;\n    private _componentOverrides;\n    private _directiveOverrides;\n    private _pipeOverrides;\n    private _providerOverrides;\n    private _rootProviderOverrides;\n    private _providers;\n    private _declarations;\n    private _imports;\n    private _schemas;\n    private _activeFixtures;\n    private _moduleRef;\n    private _instantiated;\n    /**\n     * Initialize the environment for testing with a compiler factory, a PlatformRef, and an\n     * angular module. These are common to every test in the suite.\n     *\n     * This may only be called once, to set up the common providers for the current test\n     * suite on the current platform. If you absolutely need to change the providers,\n     * first use `resetTestEnvironment`.\n     *\n     * Test modules and platforms for individual platforms are available from\n     * '@angular/<platform_name>/testing'.\n     *\n     * @publicApi\n     */\n    initTestEnvironment(ngModule: Type<any> | Type<any>[], platform: PlatformRef, aotSummaries?: () => any[]): void;\n    /**\n     * Reset the providers for the test injector.\n     *\n     * @publicApi\n     */\n    resetTestEnvironment(): void;\n    resetTestingModule(): void;\n    configureCompiler(config: {\n        providers?: any[];\n        useJit?: boolean;\n    }): void;\n    configureTestingModule(moduleDef: TestModuleMetadata): void;\n    compileComponents(): Promise<any>;\n    get(token: any, notFoundValue?: any): any;\n    execute(tokens: any[], fn: Function, context?: any): any;\n    overrideModule(ngModule: Type<any>, override: MetadataOverride<NgModule>): void;\n    overrideComponent(component: Type<any>, override: MetadataOverride<Component>): void;\n    overrideDirective(directive: Type<any>, override: MetadataOverride<Directive>): void;\n    overridePipe(pipe: Type<any>, override: MetadataOverride<Pipe>): void;\n    /**\n     * Overwrites all providers for the given token with the given provider definition.\n     */\n    overrideProvider(token: any, provider: {\n        useFactory?: Function;\n        useValue?: any;\n        deps?: any[];\n    }): void;\n    /**\n     * Overwrites all providers for the given token with the given provider definition.\n     *\n     * @deprecated as it makes all NgModules lazy. Introduced only for migrating off of it.\n     */\n    deprecatedOverrideProvider(token: any, provider: {\n        useFactory: Function;\n        deps: any[];\n    }): void;\n    deprecatedOverrideProvider(token: any, provider: {\n        useValue: any;\n    }): void;\n    createComponent<T>(type: Type<T>): ComponentFixture<T>;\n    private _initIfNeeded;\n    private _getResolvers;\n    private _assertNotInstantiated;\n    private _createTestModule;\n}\nexport declare function _getTestBedRender3(): TestBedRender3;\n"
  },
  {
    "path": "node_modules/@angular/core/testing/src/resolvers.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { Component, Directive, NgModule, Pipe, Type } from '@angular/core';\nimport { MetadataOverride } from './metadata_override';\n/**\n * Base interface to resolve `@Component`, `@Directive`, `@Pipe` and `@NgModule`.\n */\nexport interface Resolver<T> {\n    resolve(type: Type<any>): T | null;\n}\n/**\n * Allows to override ivy metadata for tests (via the `TestBed`).\n */\ndeclare abstract class OverrideResolver<T> implements Resolver<T> {\n    private overrides;\n    private resolved;\n    abstract readonly type: any;\n    setOverrides(overrides: Array<[Type<any>, MetadataOverride<T>]>): void;\n    getAnnotation(type: Type<any>): T | null;\n    resolve(type: Type<any>): T | null;\n}\nexport declare class DirectiveResolver extends OverrideResolver<Directive> {\n    readonly type: import(\"@angular/core/src/metadata/directives\").DirectiveDecorator;\n}\nexport declare class ComponentResolver extends OverrideResolver<Component> {\n    readonly type: import(\"@angular/core/src/metadata/directives\").ComponentDecorator;\n}\nexport declare class PipeResolver extends OverrideResolver<Pipe> {\n    readonly type: import(\"@angular/core/src/metadata/directives\").PipeDecorator;\n}\nexport declare class NgModuleResolver extends OverrideResolver<NgModule> {\n    readonly type: import(\"@angular/core/src/metadata/ng_module\").NgModuleDecorator;\n}\nexport {};\n"
  },
  {
    "path": "node_modules/@angular/core/testing/src/test_bed_common.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { Component, Directive, InjectionToken, NgModule, Pipe, PlatformRef, SchemaMetadata, Type } from '@angular/core';\nimport { ComponentFixture } from './component_fixture';\nimport { MetadataOverride } from './metadata_override';\nimport { TestBed } from './test_bed';\n/**\n * An abstract class for inserting the root test component element in a platform independent way.\n *\n * @publicApi\n */\nexport declare class TestComponentRenderer {\n    insertRootElement(rootElementId: string): void;\n}\n/**\n * @publicApi\n */\nexport declare const ComponentFixtureAutoDetect: InjectionToken<boolean[]>;\n/**\n * @publicApi\n */\nexport declare const ComponentFixtureNoNgZone: InjectionToken<boolean[]>;\n/**\n * @publicApi\n */\nexport declare type TestModuleMetadata = {\n    providers?: any[];\n    declarations?: any[];\n    imports?: any[];\n    schemas?: Array<SchemaMetadata | any[]>;\n    aotSummaries?: () => any[];\n};\n/**\n * Static methods implemented by the `TestBedViewEngine` and `TestBedRender3`\n *\n * @publicApi\n */\nexport interface TestBedStatic {\n    new (...args: any[]): TestBed;\n    initTestEnvironment(ngModule: Type<any> | Type<any>[], platform: PlatformRef, aotSummaries?: () => any[]): TestBed;\n    /**\n     * Reset the providers for the test injector.\n     */\n    resetTestEnvironment(): void;\n    resetTestingModule(): TestBedStatic;\n    /**\n     * Allows overriding default compiler providers and settings\n     * which are defined in test_injector.js\n     */\n    configureCompiler(config: {\n        providers?: any[];\n        useJit?: boolean;\n    }): TestBedStatic;\n    /**\n     * Allows overriding default providers, directives, pipes, modules of the test injector,\n     * which are defined in test_injector.js\n     */\n    configureTestingModule(moduleDef: TestModuleMetadata): TestBedStatic;\n    /**\n     * Compile components with a `templateUrl` for the test's NgModule.\n     * It is necessary to call this function\n     * as fetching urls is asynchronous.\n     */\n    compileComponents(): Promise<any>;\n    overrideModule(ngModule: Type<any>, override: MetadataOverride<NgModule>): TestBedStatic;\n    overrideComponent(component: Type<any>, override: MetadataOverride<Component>): TestBedStatic;\n    overrideDirective(directive: Type<any>, override: MetadataOverride<Directive>): TestBedStatic;\n    overridePipe(pipe: Type<any>, override: MetadataOverride<Pipe>): TestBedStatic;\n    overrideTemplate(component: Type<any>, template: string): TestBedStatic;\n    /**\n     * Overrides the template of the given component, compiling the template\n     * in the context of the TestingModule.\n     *\n     * Note: This works for JIT and AOTed components as well.\n     */\n    overrideTemplateUsingTestingModule(component: Type<any>, template: string): TestBedStatic;\n    /**\n     * Overwrites all providers for the given token with the given provider definition.\n     *\n     * Note: This works for JIT and AOTed components as well.\n     */\n    overrideProvider(token: any, provider: {\n        useFactory: Function;\n        deps: any[];\n    }): TestBedStatic;\n    overrideProvider(token: any, provider: {\n        useValue: any;\n    }): TestBedStatic;\n    overrideProvider(token: any, provider: {\n        useFactory?: Function;\n        useValue?: any;\n        deps?: any[];\n    }): TestBedStatic;\n    /**\n     * Overwrites all providers for the given token with the given provider definition.\n     *\n     * @deprecated as it makes all NgModules lazy. Introduced only for migrating off of it.\n     */\n    deprecatedOverrideProvider(token: any, provider: {\n        useFactory: Function;\n        deps: any[];\n    }): void;\n    deprecatedOverrideProvider(token: any, provider: {\n        useValue: any;\n    }): void;\n    deprecatedOverrideProvider(token: any, provider: {\n        useFactory?: Function;\n        useValue?: any;\n        deps?: any[];\n    }): TestBedStatic;\n    get(token: any, notFoundValue?: any): any;\n    createComponent<T>(component: Type<T>): ComponentFixture<T>;\n}\n"
  },
  {
    "path": "node_modules/@angular/core/testing/src/test_bed.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { Component, Directive, Injector, NgModule, Pipe, PlatformRef, Type } from '@angular/core';\nimport { ComponentFixture } from './component_fixture';\nimport { MetadataOverride } from './metadata_override';\nimport { TestBedStatic, TestModuleMetadata } from './test_bed_common';\nexport interface TestBed {\n    platform: PlatformRef;\n    ngModule: Type<any> | Type<any>[];\n    /**\n     * Initialize the environment for testing with a compiler factory, a PlatformRef, and an\n     * angular module. These are common to every test in the suite.\n     *\n     * This may only be called once, to set up the common providers for the current test\n     * suite on the current platform. If you absolutely need to change the providers,\n     * first use `resetTestEnvironment`.\n     *\n     * Test modules and platforms for individual platforms are available from\n     * '@angular/<platform_name>/testing'.\n     *\n     * @publicApi\n     */\n    initTestEnvironment(ngModule: Type<any> | Type<any>[], platform: PlatformRef, aotSummaries?: () => any[]): void;\n    /**\n     * Reset the providers for the test injector.\n     *\n     * @publicApi\n     */\n    resetTestEnvironment(): void;\n    resetTestingModule(): void;\n    configureCompiler(config: {\n        providers?: any[];\n        useJit?: boolean;\n    }): void;\n    configureTestingModule(moduleDef: TestModuleMetadata): void;\n    compileComponents(): Promise<any>;\n    get(token: any, notFoundValue?: any): any;\n    execute(tokens: any[], fn: Function, context?: any): any;\n    overrideModule(ngModule: Type<any>, override: MetadataOverride<NgModule>): void;\n    overrideComponent(component: Type<any>, override: MetadataOverride<Component>): void;\n    overrideDirective(directive: Type<any>, override: MetadataOverride<Directive>): void;\n    overridePipe(pipe: Type<any>, override: MetadataOverride<Pipe>): void;\n    /**\n     * Overwrites all providers for the given token with the given provider definition.\n     */\n    overrideProvider(token: any, provider: {\n        useFactory: Function;\n        deps: any[];\n    }): void;\n    overrideProvider(token: any, provider: {\n        useValue: any;\n    }): void;\n    overrideProvider(token: any, provider: {\n        useFactory?: Function;\n        useValue?: any;\n        deps?: any[];\n    }): void;\n    /**\n     * Overwrites all providers for the given token with the given provider definition.\n     *\n     * @deprecated as it makes all NgModules lazy. Introduced only for migrating off of it.\n     */\n    deprecatedOverrideProvider(token: any, provider: {\n        useFactory: Function;\n        deps: any[];\n    }): void;\n    deprecatedOverrideProvider(token: any, provider: {\n        useValue: any;\n    }): void;\n    deprecatedOverrideProvider(token: any, provider: {\n        useFactory?: Function;\n        useValue?: any;\n        deps?: any[];\n    }): void;\n    overrideTemplateUsingTestingModule(component: Type<any>, template: string): void;\n    createComponent<T>(component: Type<T>): ComponentFixture<T>;\n}\n/**\n * @description\n * Configures and initializes environment for unit testing and provides methods for\n * creating components and services in unit tests.\n *\n * `TestBed` is the primary api for writing unit tests for Angular applications and libraries.\n *\n * Note: Use `TestBed` in tests. It will be set to either `TestBedViewEngine` or `TestBedRender3`\n * according to the compiler used.\n */\nexport declare class TestBedViewEngine implements Injector, TestBed {\n    /**\n     * Initialize the environment for testing with a compiler factory, a PlatformRef, and an\n     * angular module. These are common to every test in the suite.\n     *\n     * This may only be called once, to set up the common providers for the current test\n     * suite on the current platform. If you absolutely need to change the providers,\n     * first use `resetTestEnvironment`.\n     *\n     * Test modules and platforms for individual platforms are available from\n     * '@angular/<platform_name>/testing'.\n     *\n     * @publicApi\n     */\n    static initTestEnvironment(ngModule: Type<any> | Type<any>[], platform: PlatformRef, aotSummaries?: () => any[]): TestBedViewEngine;\n    /**\n     * Reset the providers for the test injector.\n     *\n     * @publicApi\n     */\n    static resetTestEnvironment(): void;\n    static resetTestingModule(): TestBedStatic;\n    /**\n     * Allows overriding default compiler providers and settings\n     * which are defined in test_injector.js\n     */\n    static configureCompiler(config: {\n        providers?: any[];\n        useJit?: boolean;\n    }): TestBedStatic;\n    /**\n     * Allows overriding default providers, directives, pipes, modules of the test injector,\n     * which are defined in test_injector.js\n     */\n    static configureTestingModule(moduleDef: TestModuleMetadata): TestBedStatic;\n    /**\n     * Compile components with a `templateUrl` for the test's NgModule.\n     * It is necessary to call this function\n     * as fetching urls is asynchronous.\n     */\n    static compileComponents(): Promise<any>;\n    static overrideModule(ngModule: Type<any>, override: MetadataOverride<NgModule>): TestBedStatic;\n    static overrideComponent(component: Type<any>, override: MetadataOverride<Component>): TestBedStatic;\n    static overrideDirective(directive: Type<any>, override: MetadataOverride<Directive>): TestBedStatic;\n    static overridePipe(pipe: Type<any>, override: MetadataOverride<Pipe>): TestBedStatic;\n    static overrideTemplate(component: Type<any>, template: string): TestBedStatic;\n    /**\n     * Overrides the template of the given component, compiling the template\n     * in the context of the TestingModule.\n     *\n     * Note: This works for JIT and AOTed components as well.\n     */\n    static overrideTemplateUsingTestingModule(component: Type<any>, template: string): TestBedStatic;\n    /**\n     * Overwrites all providers for the given token with the given provider definition.\n     *\n     * Note: This works for JIT and AOTed components as well.\n     */\n    static overrideProvider(token: any, provider: {\n        useFactory: Function;\n        deps: any[];\n    }): TestBedStatic;\n    static overrideProvider(token: any, provider: {\n        useValue: any;\n    }): TestBedStatic;\n    /**\n     * Overwrites all providers for the given token with the given provider definition.\n     *\n     * @deprecated as it makes all NgModules lazy. Introduced only for migrating off of it.\n     */\n    static deprecatedOverrideProvider(token: any, provider: {\n        useFactory: Function;\n        deps: any[];\n    }): void;\n    static deprecatedOverrideProvider(token: any, provider: {\n        useValue: any;\n    }): void;\n    static get(token: any, notFoundValue?: any): any;\n    static createComponent<T>(component: Type<T>): ComponentFixture<T>;\n    private _instantiated;\n    private _compiler;\n    private _moduleRef;\n    private _moduleFactory;\n    private _compilerOptions;\n    private _moduleOverrides;\n    private _componentOverrides;\n    private _directiveOverrides;\n    private _pipeOverrides;\n    private _providers;\n    private _declarations;\n    private _imports;\n    private _schemas;\n    private _activeFixtures;\n    private _testEnvAotSummaries;\n    private _aotSummaries;\n    private _templateOverrides;\n    private _isRoot;\n    private _rootProviderOverrides;\n    platform: PlatformRef;\n    ngModule: Type<any> | Type<any>[];\n    /**\n     * Initialize the environment for testing with a compiler factory, a PlatformRef, and an\n     * angular module. These are common to every test in the suite.\n     *\n     * This may only be called once, to set up the common providers for the current test\n     * suite on the current platform. If you absolutely need to change the providers,\n     * first use `resetTestEnvironment`.\n     *\n     * Test modules and platforms for individual platforms are available from\n     * '@angular/<platform_name>/testing'.\n     *\n     * @publicApi\n     */\n    initTestEnvironment(ngModule: Type<any> | Type<any>[], platform: PlatformRef, aotSummaries?: () => any[]): void;\n    /**\n     * Reset the providers for the test injector.\n     *\n     * @publicApi\n     */\n    resetTestEnvironment(): void;\n    resetTestingModule(): void;\n    configureCompiler(config: {\n        providers?: any[];\n        useJit?: boolean;\n    }): void;\n    configureTestingModule(moduleDef: TestModuleMetadata): void;\n    compileComponents(): Promise<any>;\n    private _initIfNeeded;\n    private _createCompilerAndModule;\n    private _assertNotInstantiated;\n    get(token: any, notFoundValue?: any): any;\n    execute(tokens: any[], fn: Function, context?: any): any;\n    overrideModule(ngModule: Type<any>, override: MetadataOverride<NgModule>): void;\n    overrideComponent(component: Type<any>, override: MetadataOverride<Component>): void;\n    overrideDirective(directive: Type<any>, override: MetadataOverride<Directive>): void;\n    overridePipe(pipe: Type<any>, override: MetadataOverride<Pipe>): void;\n    /**\n     * Overwrites all providers for the given token with the given provider definition.\n     */\n    overrideProvider(token: any, provider: {\n        useFactory: Function;\n        deps: any[];\n    }): void;\n    overrideProvider(token: any, provider: {\n        useValue: any;\n    }): void;\n    /**\n     * Overwrites all providers for the given token with the given provider definition.\n     *\n     * @deprecated as it makes all NgModules lazy. Introduced only for migrating off of it.\n     */\n    deprecatedOverrideProvider(token: any, provider: {\n        useFactory: Function;\n        deps: any[];\n    }): void;\n    deprecatedOverrideProvider(token: any, provider: {\n        useValue: any;\n    }): void;\n    private overrideProviderImpl;\n    overrideTemplateUsingTestingModule(component: Type<any>, template: string): void;\n    createComponent<T>(component: Type<T>): ComponentFixture<T>;\n}\n/**\n * @description\n * Configures and initializes environment for unit testing and provides methods for\n * creating components and services in unit tests.\n *\n * `TestBed` is the primary api for writing unit tests for Angular applications and libraries.\n *\n * Note: Use `TestBed` in tests. It will be set to either `TestBedViewEngine` or `TestBedRender3`\n * according to the compiler used.\n *\n * @publicApi\n */\nexport declare const TestBed: TestBedStatic;\n/**\n * Returns a singleton of the applicable `TestBed`.\n *\n * It will be either an instance of `TestBedViewEngine` or `TestBedRender3`.\n *\n * @publicApi\n */\nexport declare const getTestBed: () => TestBed;\n/**\n * Allows injecting dependencies in `beforeEach()` and `it()`.\n *\n * Example:\n *\n * ```\n * beforeEach(inject([Dependency, AClass], (dep, object) => {\n *   // some code that uses `dep` and `object`\n *   // ...\n * }));\n *\n * it('...', inject([AClass], (object) => {\n *   object.doSomething();\n *   expect(...);\n * })\n * ```\n *\n * Notes:\n * - inject is currently a function because of some Traceur limitation the syntax should\n * eventually\n *   becomes `it('...', @Inject (object: AClass, async: AsyncTestCompleter) => { ... });`\n *\n * @publicApi\n */\nexport declare function inject(tokens: any[], fn: Function): () => any;\n/**\n * @publicApi\n */\nexport declare class InjectSetupWrapper {\n    private _moduleDef;\n    constructor(_moduleDef: () => TestModuleMetadata);\n    private _addModule;\n    inject(tokens: any[], fn: Function): () => any;\n}\n/**\n * @publicApi\n */\nexport declare function withModule(moduleDef: TestModuleMetadata): InjectSetupWrapper;\nexport declare function withModule(moduleDef: TestModuleMetadata, fn: Function): () => any;\n"
  },
  {
    "path": "node_modules/@angular/core/testing/src/test_compiler.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { Compiler, CompilerOptions, Component, ComponentFactory, Directive, Injector, NgModule, Pipe, Type } from '@angular/core';\nimport { MetadataOverride } from './metadata_override';\n/**\n * Special interface to the compiler only used by testing\n *\n * @publicApi\n */\nexport declare class TestingCompiler extends Compiler {\n    readonly injector: Injector;\n    overrideModule(module: Type<any>, overrides: MetadataOverride<NgModule>): void;\n    overrideDirective(directive: Type<any>, overrides: MetadataOverride<Directive>): void;\n    overrideComponent(component: Type<any>, overrides: MetadataOverride<Component>): void;\n    overridePipe(directive: Type<any>, overrides: MetadataOverride<Pipe>): void;\n    /**\n     * Allows to pass the compile summary from AOT compilation to the JIT compiler,\n     * so that it can use the code generated by AOT.\n     */\n    loadAotSummaries(summaries: () => any[]): void;\n    /**\n     * Gets the component factory for the given component.\n     * This assumes that the component has been compiled before calling this call using\n     * `compileModuleAndAllComponents*`.\n     */\n    getComponentFactory<T>(component: Type<T>): ComponentFactory<T>;\n    /**\n     * Returns the component type that is stored in the given error.\n     * This can be used for errors created by compileModule...\n     */\n    getComponentFromError(error: Error): Type<any> | null;\n}\n/**\n * A factory for creating a Compiler\n *\n * @publicApi\n */\nexport declare abstract class TestingCompilerFactory {\n    abstract createTestingCompiler(options?: CompilerOptions[]): TestingCompiler;\n}\n"
  },
  {
    "path": "node_modules/@angular/core/testing/src/testing_internal.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/// <reference types=\"jasmine\" />\nexport { AsyncTestCompleter } from './async_test_completer';\nexport { inject } from './test_bed';\nexport * from './logger';\nexport * from './ng_zone_mock';\nexport declare const proxy: ClassDecorator;\nexport declare const afterEach: Function;\nexport declare const expect: <T>(actual: T) => jasmine.Matchers<T>;\nexport declare function describe(...args: any[]): void;\nexport declare function ddescribe(...args: any[]): void;\nexport declare function xdescribe(...args: any[]): void;\nexport declare function beforeEach(fn: Function): void;\n/**\n * Allows overriding default providers defined in test_injector.js.\n *\n * The given function must return a list of DI providers.\n *\n * Example:\n *\n *   beforeEachProviders(() => [\n *     {provide: Compiler, useClass: MockCompiler},\n *     {provide: SomeToken, useValue: myValue},\n *   ]);\n */\nexport declare function beforeEachProviders(fn: Function): void;\nexport declare function it(expectation: string, assertion: (done: DoneFn) => any, timeout?: number): void;\nexport declare function fit(expectation: string, assertion: (done: DoneFn) => any, timeout?: number): void;\nexport declare function xit(expectation: string, assertion: (done: DoneFn) => any, timeout?: number): void;\nexport declare class SpyObject {\n    constructor(type?: any);\n    spy(name: string): any;\n    prop(name: string, value: any): void;\n    static stub(object?: any, config?: any, overrides?: any): any;\n}\n"
  },
  {
    "path": "node_modules/@angular/core/testing/src/testing.d.ts",
    "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * @module\n * @description\n * Entry point for all public APIs of the core/testing package.\n */\nexport * from './async';\nexport * from './component_fixture';\nexport * from './fake_async';\nexport { TestBed, getTestBed, inject, InjectSetupWrapper, withModule } from './test_bed';\nexport * from './test_bed_common';\nexport * from './before_each';\nexport * from './metadata_override';\nexport { MetadataOverrider as ɵMetadataOverrider } from './metadata_overrider';\nexport * from './private_export_testing';\n"
  },
  {
    "path": "node_modules/@angular/core/testing/testing.d.ts",
    "content": "/**\n * Generated bundle index. Do not edit.\n */\nexport * from './index';\nexport { TestBedRender3 as ɵangular_packages_core_testing_testing_b, _getTestBedRender3 as ɵangular_packages_core_testing_testing_c } from './src/r3_test_bed';\nexport { TestBedViewEngine as ɵangular_packages_core_testing_testing_a } from './src/test_bed';\n"
  },
  {
    "path": "node_modules/rxjs/add/observable/bindCallback.d.ts",
    "content": "import 'rxjs-compat/add/observable/bindCallback';\n"
  },
  {
    "path": "node_modules/rxjs/add/observable/bindNodeCallback.d.ts",
    "content": "import 'rxjs-compat/add/observable/bindNodeCallback';\n"
  },
  {
    "path": "node_modules/rxjs/add/observable/combineLatest.d.ts",
    "content": "import 'rxjs-compat/add/observable/combineLatest';\n"
  },
  {
    "path": "node_modules/rxjs/add/observable/concat.d.ts",
    "content": "import 'rxjs-compat/add/observable/concat';\n"
  },
  {
    "path": "node_modules/rxjs/add/observable/defer.d.ts",
    "content": "import 'rxjs-compat/add/observable/defer';\n"
  },
  {
    "path": "node_modules/rxjs/add/observable/dom/ajax.d.ts",
    "content": "import 'rxjs-compat/add/observable/dom/ajax';\n"
  },
  {
    "path": "node_modules/rxjs/add/observable/dom/webSocket.d.ts",
    "content": "import 'rxjs-compat/add/observable/dom/webSocket';\n"
  },
  {
    "path": "node_modules/rxjs/add/observable/empty.d.ts",
    "content": "import 'rxjs-compat/add/observable/empty';\n"
  },
  {
    "path": "node_modules/rxjs/add/observable/forkJoin.d.ts",
    "content": "import 'rxjs-compat/add/observable/forkJoin';\n"
  },
  {
    "path": "node_modules/rxjs/add/observable/from.d.ts",
    "content": "import 'rxjs-compat/add/observable/from';\n"
  },
  {
    "path": "node_modules/rxjs/add/observable/fromEvent.d.ts",
    "content": "import 'rxjs-compat/add/observable/fromEvent';\n"
  },
  {
    "path": "node_modules/rxjs/add/observable/fromEventPattern.d.ts",
    "content": "import 'rxjs-compat/add/observable/fromEventPattern';\n"
  },
  {
    "path": "node_modules/rxjs/add/observable/fromPromise.d.ts",
    "content": "import 'rxjs-compat/add/observable/fromPromise';\n"
  },
  {
    "path": "node_modules/rxjs/add/observable/generate.d.ts",
    "content": "import 'rxjs-compat/add/observable/generate';\n"
  },
  {
    "path": "node_modules/rxjs/add/observable/if.d.ts",
    "content": "import 'rxjs-compat/add/observable/if';\n"
  },
  {
    "path": "node_modules/rxjs/add/observable/interval.d.ts",
    "content": "import 'rxjs-compat/add/observable/interval';\n"
  },
  {
    "path": "node_modules/rxjs/add/observable/merge.d.ts",
    "content": "import 'rxjs-compat/add/observable/merge';\n"
  },
  {
    "path": "node_modules/rxjs/add/observable/never.d.ts",
    "content": "import 'rxjs-compat/add/observable/never';\n"
  },
  {
    "path": "node_modules/rxjs/add/observable/of.d.ts",
    "content": "import 'rxjs-compat/add/observable/of';\n"
  },
  {
    "path": "node_modules/rxjs/add/observable/onErrorResumeNext.d.ts",
    "content": "import 'rxjs-compat/add/observable/onErrorResumeNext';\n"
  },
  {
    "path": "node_modules/rxjs/add/observable/pairs.d.ts",
    "content": "import 'rxjs-compat/add/observable/pairs';\n"
  },
  {
    "path": "node_modules/rxjs/add/observable/race.d.ts",
    "content": "import 'rxjs-compat/add/observable/race';\n"
  },
  {
    "path": "node_modules/rxjs/add/observable/range.d.ts",
    "content": "import 'rxjs-compat/add/observable/range';\n"
  },
  {
    "path": "node_modules/rxjs/add/observable/throw.d.ts",
    "content": "import 'rxjs-compat/add/observable/throw';\n"
  },
  {
    "path": "node_modules/rxjs/add/observable/timer.d.ts",
    "content": "import 'rxjs-compat/add/observable/timer';\n"
  },
  {
    "path": "node_modules/rxjs/add/observable/using.d.ts",
    "content": "import 'rxjs-compat/add/observable/using';\n"
  },
  {
    "path": "node_modules/rxjs/add/observable/zip.d.ts",
    "content": "import 'rxjs-compat/add/observable/zip';\n"
  },
  {
    "path": "node_modules/rxjs/add/operator/audit.d.ts",
    "content": "import 'rxjs-compat/add/operator/audit';\n"
  },
  {
    "path": "node_modules/rxjs/add/operator/auditTime.d.ts",
    "content": "import 'rxjs-compat/add/operator/auditTime';\n"
  },
  {
    "path": "node_modules/rxjs/add/operator/buffer.d.ts",
    "content": "import 'rxjs-compat/add/operator/buffer';\n"
  },
  {
    "path": "node_modules/rxjs/add/operator/bufferCount.d.ts",
    "content": "import 'rxjs-compat/add/operator/bufferCount';\n"
  },
  {
    "path": "node_modules/rxjs/add/operator/bufferTime.d.ts",
    "content": "import 'rxjs-compat/add/operator/bufferTime';\n"
  },
  {
    "path": "node_modules/rxjs/add/operator/bufferToggle.d.ts",
    "content": "import 'rxjs-compat/add/operator/bufferToggle';\n"
  },
  {
    "path": "node_modules/rxjs/add/operator/bufferWhen.d.ts",
    "content": "import 'rxjs-compat/add/operator/bufferWhen';\n"
  },
  {
    "path": "node_modules/rxjs/add/operator/catch.d.ts",
    "content": "import 'rxjs-compat/add/operator/catch';\n"
  },
  {
    "path": "node_modules/rxjs/add/operator/combineAll.d.ts",
    "content": "import 'rxjs-compat/add/operator/combineAll';\n"
  },
  {
    "path": "node_modules/rxjs/add/operator/combineLatest.d.ts",
    "content": "import 'rxjs-compat/add/operator/combineLatest';\n"
  },
  {
    "path": "node_modules/rxjs/add/operator/concat.d.ts",
    "content": "import 'rxjs-compat/add/operator/concat';\n"
  },
  {
    "path": "node_modules/rxjs/add/operator/concatAll.d.ts",
    "content": "import 'rxjs-compat/add/operator/concatAll';\n"
  },
  {
    "path": "node_modules/rxjs/add/operator/concatMap.d.ts",
    "content": "import 'rxjs-compat/add/operator/concatMap';\n"
  },
  {
    "path": "node_modules/rxjs/add/operator/concatMapTo.d.ts",
    "content": "import 'rxjs-compat/add/operator/concatMapTo';\n"
  },
  {
    "path": "node_modules/rxjs/add/operator/count.d.ts",
    "content": "import 'rxjs-compat/add/operator/count';\n"
  },
  {
    "path": "node_modules/rxjs/add/operator/debounce.d.ts",
    "content": "import 'rxjs-compat/add/operator/debounce';\n"
  },
  {
    "path": "node_modules/rxjs/add/operator/debounceTime.d.ts",
    "content": "import 'rxjs-compat/add/operator/debounceTime';\n"
  },
  {
    "path": "node_modules/rxjs/add/operator/defaultIfEmpty.d.ts",
    "content": "import 'rxjs-compat/add/operator/defaultIfEmpty';\n"
  },
  {
    "path": "node_modules/rxjs/add/operator/delay.d.ts",
    "content": "import 'rxjs-compat/add/operator/delay';\n"
  },
  {
    "path": "node_modules/rxjs/add/operator/delayWhen.d.ts",
    "content": "import 'rxjs-compat/add/operator/delayWhen';\n"
  },
  {
    "path": "node_modules/rxjs/add/operator/dematerialize.d.ts",
    "content": "import 'rxjs-compat/add/operator/dematerialize';\n"
  },
  {
    "path": "node_modules/rxjs/add/operator/distinct.d.ts",
    "content": "import 'rxjs-compat/add/operator/distinct';\n"
  },
  {
    "path": "node_modules/rxjs/add/operator/distinctUntilChanged.d.ts",
    "content": "import 'rxjs-compat/add/operator/distinctUntilChanged';\n"
  },
  {
    "path": "node_modules/rxjs/add/operator/distinctUntilKeyChanged.d.ts",
    "content": "import 'rxjs-compat/add/operator/distinctUntilKeyChanged';\n"
  },
  {
    "path": "node_modules/rxjs/add/operator/do.d.ts",
    "content": "import 'rxjs-compat/add/operator/do';\n"
  },
  {
    "path": "node_modules/rxjs/add/operator/elementAt.d.ts",
    "content": "import 'rxjs-compat/add/operator/elementAt';\n"
  },
  {
    "path": "node_modules/rxjs/add/operator/every.d.ts",
    "content": "import 'rxjs-compat/add/operator/every';\n"
  },
  {
    "path": "node_modules/rxjs/add/operator/exhaust.d.ts",
    "content": "import 'rxjs-compat/add/operator/exhaust';\n"
  },
  {
    "path": "node_modules/rxjs/add/operator/exhaustMap.d.ts",
    "content": "import 'rxjs-compat/add/operator/exhaustMap';\n"
  },
  {
    "path": "node_modules/rxjs/add/operator/expand.d.ts",
    "content": "import 'rxjs-compat/add/operator/expand';\n"
  },
  {
    "path": "node_modules/rxjs/add/operator/filter.d.ts",
    "content": "import 'rxjs-compat/add/operator/filter';\n"
  },
  {
    "path": "node_modules/rxjs/add/operator/finally.d.ts",
    "content": "import 'rxjs-compat/add/operator/finally';\n"
  },
  {
    "path": "node_modules/rxjs/add/operator/find.d.ts",
    "content": "import 'rxjs-compat/add/operator/find';\n"
  },
  {
    "path": "node_modules/rxjs/add/operator/findIndex.d.ts",
    "content": "import 'rxjs-compat/add/operator/findIndex';\n"
  },
  {
    "path": "node_modules/rxjs/add/operator/first.d.ts",
    "content": "import 'rxjs-compat/add/operator/first';\n"
  },
  {
    "path": "node_modules/rxjs/add/operator/groupBy.d.ts",
    "content": "import 'rxjs-compat/add/operator/groupBy';\n"
  },
  {
    "path": "node_modules/rxjs/add/operator/ignoreElements.d.ts",
    "content": "import 'rxjs-compat/add/operator/ignoreElements';\n"
  },
  {
    "path": "node_modules/rxjs/add/operator/isEmpty.d.ts",
    "content": "import 'rxjs-compat/add/operator/isEmpty';\n"
  },
  {
    "path": "node_modules/rxjs/add/operator/last.d.ts",
    "content": "import 'rxjs-compat/add/operator/last';\n"
  },
  {
    "path": "node_modules/rxjs/add/operator/let.d.ts",
    "content": "import 'rxjs-compat/add/operator/let';\n"
  },
  {
    "path": "node_modules/rxjs/add/operator/map.d.ts",
    "content": "import 'rxjs-compat/add/operator/map';\n"
  },
  {
    "path": "node_modules/rxjs/add/operator/mapTo.d.ts",
    "content": "import 'rxjs-compat/add/operator/mapTo';\n"
  },
  {
    "path": "node_modules/rxjs/add/operator/materialize.d.ts",
    "content": "import 'rxjs-compat/add/operator/materialize';\n"
  },
  {
    "path": "node_modules/rxjs/add/operator/max.d.ts",
    "content": "import 'rxjs-compat/add/operator/max';\n"
  },
  {
    "path": "node_modules/rxjs/add/operator/merge.d.ts",
    "content": "import 'rxjs-compat/add/operator/merge';\n"
  },
  {
    "path": "node_modules/rxjs/add/operator/mergeAll.d.ts",
    "content": "import 'rxjs-compat/add/operator/mergeAll';\n"
  },
  {
    "path": "node_modules/rxjs/add/operator/mergeMap.d.ts",
    "content": "import 'rxjs-compat/add/operator/mergeMap';\n"
  },
  {
    "path": "node_modules/rxjs/add/operator/mergeMapTo.d.ts",
    "content": "import 'rxjs-compat/add/operator/mergeMapTo';\n"
  },
  {
    "path": "node_modules/rxjs/add/operator/mergeScan.d.ts",
    "content": "import 'rxjs-compat/add/operator/mergeScan';\n"
  },
  {
    "path": "node_modules/rxjs/add/operator/min.d.ts",
    "content": "import 'rxjs-compat/add/operator/min';\n"
  },
  {
    "path": "node_modules/rxjs/add/operator/multicast.d.ts",
    "content": "import 'rxjs-compat/add/operator/multicast';\n"
  },
  {
    "path": "node_modules/rxjs/add/operator/observeOn.d.ts",
    "content": "import 'rxjs-compat/add/operator/observeOn';\n"
  },
  {
    "path": "node_modules/rxjs/add/operator/onErrorResumeNext.d.ts",
    "content": "import 'rxjs-compat/add/operator/onErrorResumeNext';\n"
  },
  {
    "path": "node_modules/rxjs/add/operator/pairwise.d.ts",
    "content": "import 'rxjs-compat/add/operator/pairwise';\n"
  },
  {
    "path": "node_modules/rxjs/add/operator/partition.d.ts",
    "content": "import 'rxjs-compat/add/operator/partition';\n"
  },
  {
    "path": "node_modules/rxjs/add/operator/pluck.d.ts",
    "content": "import 'rxjs-compat/add/operator/pluck';\n"
  },
  {
    "path": "node_modules/rxjs/add/operator/publish.d.ts",
    "content": "import 'rxjs-compat/add/operator/publish';\n"
  },
  {
    "path": "node_modules/rxjs/add/operator/publishBehavior.d.ts",
    "content": "import 'rxjs-compat/add/operator/publishBehavior';\n"
  },
  {
    "path": "node_modules/rxjs/add/operator/publishLast.d.ts",
    "content": "import 'rxjs-compat/add/operator/publishLast';\n"
  },
  {
    "path": "node_modules/rxjs/add/operator/publishReplay.d.ts",
    "content": "import 'rxjs-compat/add/operator/publishReplay';\n"
  },
  {
    "path": "node_modules/rxjs/add/operator/race.d.ts",
    "content": "import 'rxjs-compat/add/operator/race';\n"
  },
  {
    "path": "node_modules/rxjs/add/operator/reduce.d.ts",
    "content": "import 'rxjs-compat/add/operator/reduce';\n"
  },
  {
    "path": "node_modules/rxjs/add/operator/repeat.d.ts",
    "content": "import 'rxjs-compat/add/operator/repeat';\n"
  },
  {
    "path": "node_modules/rxjs/add/operator/repeatWhen.d.ts",
    "content": "import 'rxjs-compat/add/operator/repeatWhen';\n"
  },
  {
    "path": "node_modules/rxjs/add/operator/retry.d.ts",
    "content": "import 'rxjs-compat/add/operator/retry';\n"
  },
  {
    "path": "node_modules/rxjs/add/operator/retryWhen.d.ts",
    "content": "import 'rxjs-compat/add/operator/retryWhen';\n"
  },
  {
    "path": "node_modules/rxjs/add/operator/sample.d.ts",
    "content": "import 'rxjs-compat/add/operator/sample';\n"
  },
  {
    "path": "node_modules/rxjs/add/operator/sampleTime.d.ts",
    "content": "import 'rxjs-compat/add/operator/sampleTime';\n"
  },
  {
    "path": "node_modules/rxjs/add/operator/scan.d.ts",
    "content": "import 'rxjs-compat/add/operator/scan';\n"
  },
  {
    "path": "node_modules/rxjs/add/operator/sequenceEqual.d.ts",
    "content": "import 'rxjs-compat/add/operator/sequenceEqual';\n"
  },
  {
    "path": "node_modules/rxjs/add/operator/share.d.ts",
    "content": "import 'rxjs-compat/add/operator/share';\n"
  },
  {
    "path": "node_modules/rxjs/add/operator/shareReplay.d.ts",
    "content": "import 'rxjs-compat/add/operator/shareReplay';\n"
  },
  {
    "path": "node_modules/rxjs/add/operator/single.d.ts",
    "content": "import 'rxjs-compat/add/operator/single';\n"
  },
  {
    "path": "node_modules/rxjs/add/operator/skip.d.ts",
    "content": "import 'rxjs-compat/add/operator/skip';\n"
  },
  {
    "path": "node_modules/rxjs/add/operator/skipLast.d.ts",
    "content": "import 'rxjs-compat/add/operator/skipLast';\n"
  },
  {
    "path": "node_modules/rxjs/add/operator/skipUntil.d.ts",
    "content": "import 'rxjs-compat/add/operator/skipUntil';\n"
  },
  {
    "path": "node_modules/rxjs/add/operator/skipWhile.d.ts",
    "content": "import 'rxjs-compat/add/operator/skipWhile';\n"
  },
  {
    "path": "node_modules/rxjs/add/operator/startWith.d.ts",
    "content": "import 'rxjs-compat/add/operator/startWith';\n"
  },
  {
    "path": "node_modules/rxjs/add/operator/subscribeOn.d.ts",
    "content": "import 'rxjs-compat/add/operator/subscribeOn';\n"
  },
  {
    "path": "node_modules/rxjs/add/operator/switch.d.ts",
    "content": "import 'rxjs-compat/add/operator/switch';\n"
  },
  {
    "path": "node_modules/rxjs/add/operator/switchMap.d.ts",
    "content": "import 'rxjs-compat/add/operator/switchMap';\n"
  },
  {
    "path": "node_modules/rxjs/add/operator/switchMapTo.d.ts",
    "content": "import 'rxjs-compat/add/operator/switchMapTo';\n"
  },
  {
    "path": "node_modules/rxjs/add/operator/take.d.ts",
    "content": "import 'rxjs-compat/add/operator/take';\n"
  },
  {
    "path": "node_modules/rxjs/add/operator/takeLast.d.ts",
    "content": "import 'rxjs-compat/add/operator/takeLast';\n"
  },
  {
    "path": "node_modules/rxjs/add/operator/takeUntil.d.ts",
    "content": "import 'rxjs-compat/add/operator/takeUntil';\n"
  },
  {
    "path": "node_modules/rxjs/add/operator/takeWhile.d.ts",
    "content": "import 'rxjs-compat/add/operator/takeWhile';\n"
  },
  {
    "path": "node_modules/rxjs/add/operator/throttle.d.ts",
    "content": "import 'rxjs-compat/add/operator/throttle';\n"
  },
  {
    "path": "node_modules/rxjs/add/operator/throttleTime.d.ts",
    "content": "import 'rxjs-compat/add/operator/throttleTime';\n"
  },
  {
    "path": "node_modules/rxjs/add/operator/timeInterval.d.ts",
    "content": "import 'rxjs-compat/add/operator/timeInterval';\n"
  },
  {
    "path": "node_modules/rxjs/add/operator/timeout.d.ts",
    "content": "import 'rxjs-compat/add/operator/timeout';\n"
  },
  {
    "path": "node_modules/rxjs/add/operator/timeoutWith.d.ts",
    "content": "import 'rxjs-compat/add/operator/timeoutWith';\n"
  },
  {
    "path": "node_modules/rxjs/add/operator/timestamp.d.ts",
    "content": "import 'rxjs-compat/add/operator/timestamp';\n"
  },
  {
    "path": "node_modules/rxjs/add/operator/toArray.d.ts",
    "content": "import 'rxjs-compat/add/operator/toArray';\n"
  },
  {
    "path": "node_modules/rxjs/add/operator/toPromise.d.ts",
    "content": "import 'rxjs-compat/add/operator/toPromise';\n"
  },
  {
    "path": "node_modules/rxjs/add/operator/window.d.ts",
    "content": "import 'rxjs-compat/add/operator/window';\n"
  },
  {
    "path": "node_modules/rxjs/add/operator/windowCount.d.ts",
    "content": "import 'rxjs-compat/add/operator/windowCount';\n"
  },
  {
    "path": "node_modules/rxjs/add/operator/windowTime.d.ts",
    "content": "import 'rxjs-compat/add/operator/windowTime';\n"
  },
  {
    "path": "node_modules/rxjs/add/operator/windowToggle.d.ts",
    "content": "import 'rxjs-compat/add/operator/windowToggle';\n"
  },
  {
    "path": "node_modules/rxjs/add/operator/windowWhen.d.ts",
    "content": "import 'rxjs-compat/add/operator/windowWhen';\n"
  },
  {
    "path": "node_modules/rxjs/add/operator/withLatestFrom.d.ts",
    "content": "import 'rxjs-compat/add/operator/withLatestFrom';\n"
  },
  {
    "path": "node_modules/rxjs/add/operator/zip.d.ts",
    "content": "import 'rxjs-compat/add/operator/zip';\n"
  },
  {
    "path": "node_modules/rxjs/add/operator/zipAll.d.ts",
    "content": "import 'rxjs-compat/add/operator/zipAll';\n"
  },
  {
    "path": "node_modules/rxjs/ajax/index.d.ts",
    "content": "export { ajax } from '../internal/observable/dom/ajax';\nexport { AjaxRequest, AjaxResponse, AjaxError, AjaxTimeoutError } from '../internal/observable/dom/AjaxObservable';\n"
  },
  {
    "path": "node_modules/rxjs/AsyncSubject.d.ts",
    "content": "export * from 'rxjs-compat/AsyncSubject';\n"
  },
  {
    "path": "node_modules/rxjs/BehaviorSubject.d.ts",
    "content": "export * from 'rxjs-compat/BehaviorSubject';\n"
  },
  {
    "path": "node_modules/rxjs/index.d.ts",
    "content": "export { Observable } from './internal/Observable';\nexport { ConnectableObservable } from './internal/observable/ConnectableObservable';\nexport { GroupedObservable } from './internal/operators/groupBy';\nexport { Operator } from './internal/Operator';\nexport { observable } from './internal/symbol/observable';\nexport { Subject } from './internal/Subject';\nexport { BehaviorSubject } from './internal/BehaviorSubject';\nexport { ReplaySubject } from './internal/ReplaySubject';\nexport { AsyncSubject } from './internal/AsyncSubject';\nexport { asap as asapScheduler } from './internal/scheduler/asap';\nexport { async as asyncScheduler } from './internal/scheduler/async';\nexport { queue as queueScheduler } from './internal/scheduler/queue';\nexport { animationFrame as animationFrameScheduler } from './internal/scheduler/animationFrame';\nexport { VirtualTimeScheduler, VirtualAction } from './internal/scheduler/VirtualTimeScheduler';\nexport { Scheduler } from './internal/Scheduler';\nexport { Subscription } from './internal/Subscription';\nexport { Subscriber } from './internal/Subscriber';\nexport { Notification } from './internal/Notification';\nexport { pipe } from './internal/util/pipe';\nexport { noop } from './internal/util/noop';\nexport { identity } from './internal/util/identity';\nexport { isObservable } from './internal/util/isObservable';\nexport { ArgumentOutOfRangeError } from './internal/util/ArgumentOutOfRangeError';\nexport { EmptyError } from './internal/util/EmptyError';\nexport { ObjectUnsubscribedError } from './internal/util/ObjectUnsubscribedError';\nexport { UnsubscriptionError } from './internal/util/UnsubscriptionError';\nexport { TimeoutError } from './internal/util/TimeoutError';\nexport { bindCallback } from './internal/observable/bindCallback';\nexport { bindNodeCallback } from './internal/observable/bindNodeCallback';\nexport { combineLatest } from './internal/observable/combineLatest';\nexport { concat } from './internal/observable/concat';\nexport { defer } from './internal/observable/defer';\nexport { empty } from './internal/observable/empty';\nexport { forkJoin } from './internal/observable/forkJoin';\nexport { from } from './internal/observable/from';\nexport { fromEvent } from './internal/observable/fromEvent';\nexport { fromEventPattern } from './internal/observable/fromEventPattern';\nexport { generate } from './internal/observable/generate';\nexport { iif } from './internal/observable/iif';\nexport { interval } from './internal/observable/interval';\nexport { merge } from './internal/observable/merge';\nexport { never } from './internal/observable/never';\nexport { of } from './internal/observable/of';\nexport { onErrorResumeNext } from './internal/observable/onErrorResumeNext';\nexport { pairs } from './internal/observable/pairs';\nexport { race } from './internal/observable/race';\nexport { range } from './internal/observable/range';\nexport { throwError } from './internal/observable/throwError';\nexport { timer } from './internal/observable/timer';\nexport { using } from './internal/observable/using';\nexport { zip } from './internal/observable/zip';\nexport { EMPTY } from './internal/observable/empty';\nexport { NEVER } from './internal/observable/never';\nexport * from './internal/types';\nexport { config } from './internal/config';\n"
  },
  {
    "path": "node_modules/rxjs/InnerSubscriber.d.ts",
    "content": "export * from 'rxjs-compat/InnerSubscriber';\n"
  },
  {
    "path": "node_modules/rxjs/interfaces.d.ts",
    "content": "export * from 'rxjs-compat/interfaces';\n"
  },
  {
    "path": "node_modules/rxjs/internal-compatibility/index.d.ts",
    "content": "export { config } from '../internal/config';\nexport { InnerSubscriber } from '../internal/InnerSubscriber';\nexport { OuterSubscriber } from '../internal/OuterSubscriber';\nexport { Scheduler } from '../internal/Scheduler';\nexport { AnonymousSubject } from '../internal/Subject';\nexport { SubjectSubscription } from '../internal/SubjectSubscription';\nexport { Subscriber } from '../internal/Subscriber';\nexport { fromPromise } from '../internal/observable/fromPromise';\nexport { fromIterable } from '../internal/observable/fromIterable';\nexport { ajax } from '../internal/observable/dom/ajax';\nexport { webSocket } from '../internal/observable/dom/webSocket';\nexport { AjaxRequest, AjaxCreationMethod, ajaxGet, ajaxPost, ajaxDelete, ajaxPut, ajaxPatch, ajaxGetJSON, AjaxObservable, AjaxSubscriber, AjaxResponse, AjaxError, AjaxTimeoutError } from '../internal/observable/dom/AjaxObservable';\nexport { WebSocketSubjectConfig, WebSocketSubject } from '../internal/observable/dom/WebSocketSubject';\nexport { CombineLatestOperator } from '../internal/observable/combineLatest';\nexport { EventTargetLike } from '../internal/observable/fromEvent';\nexport { ConditionFunc, IterateFunc, ResultFunc, GenerateBaseOptions, GenerateOptions } from '../internal/observable/generate';\nexport { dispatch } from '../internal/observable/range';\nexport { SubscribeOnObservable } from '../internal/observable/SubscribeOnObservable';\nexport { Timestamp } from '../internal/operators/timestamp';\nexport { TimeInterval } from '../internal/operators/timeInterval';\nexport { GroupedObservable } from '../internal/operators/groupBy';\nexport { ThrottleConfig, defaultThrottleConfig } from '../internal/operators/throttle';\nexport { rxSubscriber } from '../internal/symbol/rxSubscriber';\nexport { iterator } from '../internal/symbol/iterator';\nexport { observable } from '../internal/symbol/observable';\nexport { ArgumentOutOfRangeError } from '../internal/util/ArgumentOutOfRangeError';\nexport { EmptyError } from '../internal/util/EmptyError';\nexport { Immediate } from '../internal/util/Immediate';\nexport { ObjectUnsubscribedError } from '../internal/util/ObjectUnsubscribedError';\nexport { TimeoutError } from '../internal/util/TimeoutError';\nexport { UnsubscriptionError } from '../internal/util/UnsubscriptionError';\nexport { applyMixins } from '../internal/util/applyMixins';\nexport { errorObject } from '../internal/util/errorObject';\nexport { hostReportError } from '../internal/util/hostReportError';\nexport { identity } from '../internal/util/identity';\nexport { isArray } from '../internal/util/isArray';\nexport { isArrayLike } from '../internal/util/isArrayLike';\nexport { isDate } from '../internal/util/isDate';\nexport { isFunction } from '../internal/util/isFunction';\nexport { isIterable } from '../internal/util/isIterable';\nexport { isNumeric } from '../internal/util/isNumeric';\nexport { isObject } from '../internal/util/isObject';\nexport { isInteropObservable as isObservable } from '../internal/util/isInteropObservable';\nexport { isPromise } from '../internal/util/isPromise';\nexport { isScheduler } from '../internal/util/isScheduler';\nexport { noop } from '../internal/util/noop';\nexport { not } from '../internal/util/not';\nexport { pipe } from '../internal/util/pipe';\nexport { root } from '../internal/util/root';\nexport { subscribeTo } from '../internal/util/subscribeTo';\nexport { subscribeToArray } from '../internal/util/subscribeToArray';\nexport { subscribeToIterable } from '../internal/util/subscribeToIterable';\nexport { subscribeToObservable } from '../internal/util/subscribeToObservable';\nexport { subscribeToPromise } from '../internal/util/subscribeToPromise';\nexport { subscribeToResult } from '../internal/util/subscribeToResult';\nexport { toSubscriber } from '../internal/util/toSubscriber';\nexport { tryCatch } from '../internal/util/tryCatch';\n"
  },
  {
    "path": "node_modules/rxjs/internal/AsyncSubject.d.ts",
    "content": "import { Subject } from './Subject';\nimport { Subscriber } from './Subscriber';\nimport { Subscription } from './Subscription';\n/**\n * A variant of Subject that only emits a value when it completes. It will emit\n * its latest value to all its observers on completion.\n *\n * @class AsyncSubject<T>\n */\nexport declare class AsyncSubject<T> extends Subject<T> {\n    private value;\n    private hasNext;\n    private hasCompleted;\n    /** @deprecated This is an internal implementation detail, do not use. */\n    _subscribe(subscriber: Subscriber<any>): Subscription;\n    next(value: T): void;\n    error(error: any): void;\n    complete(): void;\n}\n"
  },
  {
    "path": "node_modules/rxjs/internal/BehaviorSubject.d.ts",
    "content": "import { Subject } from './Subject';\nimport { Subscriber } from './Subscriber';\nimport { Subscription } from './Subscription';\n/**\n * A variant of Subject that requires an initial value and emits its current\n * value whenever it is subscribed to.\n *\n * @class BehaviorSubject<T>\n */\nexport declare class BehaviorSubject<T> extends Subject<T> {\n    private _value;\n    constructor(_value: T);\n    readonly value: T;\n    /** @deprecated This is an internal implementation detail, do not use. */\n    _subscribe(subscriber: Subscriber<T>): Subscription;\n    getValue(): T;\n    next(value: T): void;\n}\n"
  },
  {
    "path": "node_modules/rxjs/internal/config.d.ts",
    "content": "/**\n * The global configuration object for RxJS, used to configure things\n * like what Promise contructor should used to create Promises\n */\nexport declare const config: {\n    /**\n     * The promise constructor used by default for methods such as\n     * {@link toPromise} and {@link forEach}\n     */\n    Promise: PromiseConstructorLike;\n    /**\n     * If true, turns on synchronous error rethrowing, which is a deprecated behavior\n     * in v6 and higher. This behavior enables bad patterns like wrapping a subscribe\n     * call in a try/catch block. It also enables producer interference, a nasty bug\n     * where a multicast can be broken for all observers by a downstream consumer with\n     * an unhandled error. DO NOT USE THIS FLAG UNLESS IT'S NEEDED TO BY TIME\n     * FOR MIGRATION REASONS.\n     */\n    useDeprecatedSynchronousErrorHandling: boolean;\n};\n"
  },
  {
    "path": "node_modules/rxjs/internal/InnerSubscriber.d.ts",
    "content": "import { Subscriber } from './Subscriber';\nimport { OuterSubscriber } from './OuterSubscriber';\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport declare class InnerSubscriber<T, R> extends Subscriber<R> {\n    private parent;\n    outerValue: T;\n    outerIndex: number;\n    private index;\n    constructor(parent: OuterSubscriber<T, R>, outerValue: T, outerIndex: number);\n    protected _next(value: R): void;\n    protected _error(error: any): void;\n    protected _complete(): void;\n}\n"
  },
  {
    "path": "node_modules/rxjs/internal/Notification.d.ts",
    "content": "import { PartialObserver } from './types';\nimport { Observable } from './Observable';\n/**\n * Represents a push-based event or value that an {@link Observable} can emit.\n * This class is particularly useful for operators that manage notifications,\n * like {@link materialize}, {@link dematerialize}, {@link observeOn}, and\n * others. Besides wrapping the actual delivered value, it also annotates it\n * with metadata of, for instance, what type of push message it is (`next`,\n * `error`, or `complete`).\n *\n * @see {@link materialize}\n * @see {@link dematerialize}\n * @see {@link observeOn}\n *\n * @class Notification<T>\n */\nexport declare class Notification<T> {\n    kind: string;\n    value?: T;\n    error?: any;\n    hasValue: boolean;\n    constructor(kind: string, value?: T, error?: any);\n    /**\n     * Delivers to the given `observer` the value wrapped by this Notification.\n     * @param {Observer} observer\n     * @return\n     */\n    observe(observer: PartialObserver<T>): any;\n    /**\n     * Given some {@link Observer} callbacks, deliver the value represented by the\n     * current Notification to the correctly corresponding callback.\n     * @param {function(value: T): void} next An Observer `next` callback.\n     * @param {function(err: any): void} [error] An Observer `error` callback.\n     * @param {function(): void} [complete] An Observer `complete` callback.\n     * @return {any}\n     */\n    do(next: (value: T) => void, error?: (err: any) => void, complete?: () => void): any;\n    /**\n     * Takes an Observer or its individual callback functions, and calls `observe`\n     * or `do` methods accordingly.\n     * @param {Observer|function(value: T): void} nextOrObserver An Observer or\n     * the `next` callback.\n     * @param {function(err: any): void} [error] An Observer `error` callback.\n     * @param {function(): void} [complete] An Observer `complete` callback.\n     * @return {any}\n     */\n    accept(nextOrObserver: PartialObserver<T> | ((value: T) => void), error?: (err: any) => void, complete?: () => void): any;\n    /**\n     * Returns a simple Observable that just delivers the notification represented\n     * by this Notification instance.\n     * @return {any}\n     */\n    toObservable(): Observable<T>;\n    private static completeNotification;\n    private static undefinedValueNotification;\n    /**\n     * A shortcut to create a Notification instance of the type `next` from a\n     * given value.\n     * @param {T} value The `next` value.\n     * @return {Notification<T>} The \"next\" Notification representing the\n     * argument.\n     * @nocollapse\n     */\n    static createNext<T>(value: T): Notification<T>;\n    /**\n     * A shortcut to create a Notification instance of the type `error` from a\n     * given error.\n     * @param {any} [err] The `error` error.\n     * @return {Notification<T>} The \"error\" Notification representing the\n     * argument.\n     * @nocollapse\n     */\n    static createError<T>(err?: any): Notification<T>;\n    /**\n     * A shortcut to create a Notification instance of the type `complete`.\n     * @return {Notification<any>} The valueless \"complete\" Notification.\n     * @nocollapse\n     */\n    static createComplete(): Notification<any>;\n}\n"
  },
  {
    "path": "node_modules/rxjs/internal/Observable.d.ts",
    "content": "import { Operator } from './Operator';\nimport { Subscriber } from './Subscriber';\nimport { Subscription } from './Subscription';\nimport { TeardownLogic, OperatorFunction, PartialObserver, Subscribable } from './types';\nimport { iif } from './observable/iif';\nimport { throwError } from './observable/throwError';\n/**\n * A representation of any set of values over any amount of time. This is the most basic building block\n * of RxJS.\n *\n * @class Observable<T>\n */\nexport declare class Observable<T> implements Subscribable<T> {\n    /** Internal implementation detail, do not use directly. */\n    _isScalar: boolean;\n    /** @deprecated This is an internal implementation detail, do not use. */\n    source: Observable<any>;\n    /** @deprecated This is an internal implementation detail, do not use. */\n    operator: Operator<any, T>;\n    /**\n     * @constructor\n     * @param {Function} subscribe the function that is called when the Observable is\n     * initially subscribed to. This function is given a Subscriber, to which new values\n     * can be `next`ed, or an `error` method can be called to raise an error, or\n     * `complete` can be called to notify of a successful completion.\n     */\n    constructor(subscribe?: (this: Observable<T>, subscriber: Subscriber<T>) => TeardownLogic);\n    /**\n     * Creates a new cold Observable by calling the Observable constructor\n     * @static true\n     * @owner Observable\n     * @method create\n     * @param {Function} subscribe? the subscriber function to be passed to the Observable constructor\n     * @return {Observable} a new cold observable\n     * @nocollapse\n     */\n    static create: Function;\n    /**\n     * Creates a new Observable, with this Observable as the source, and the passed\n     * operator defined as the new observable's operator.\n     * @method lift\n     * @param {Operator} operator the operator defining the operation to take on the observable\n     * @return {Observable} a new observable with the Operator applied\n     */\n    lift<R>(operator: Operator<T, R>): Observable<R>;\n    subscribe(observer?: PartialObserver<T>): Subscription;\n    subscribe(next?: (value: T) => void, error?: (error: any) => void, complete?: () => void): Subscription;\n    /** @deprecated This is an internal implementation detail, do not use. */\n    _trySubscribe(sink: Subscriber<T>): TeardownLogic;\n    /**\n     * @method forEach\n     * @param {Function} next a handler for each value emitted by the observable\n     * @param {PromiseConstructor} [promiseCtor] a constructor function used to instantiate the Promise\n     * @return {Promise} a promise that either resolves on observable completion or\n     *  rejects with the handled error\n     */\n    forEach(next: (value: T) => void, promiseCtor?: PromiseConstructorLike): Promise<void>;\n    /** @internal This is an internal implementation detail, do not use. */\n    _subscribe(subscriber: Subscriber<any>): TeardownLogic;\n    /**\n     * @nocollapse\n     * @deprecated In favor of iif creation function: import { iif } from 'rxjs';\n     */\n    static if: typeof iif;\n    /**\n     * @nocollapse\n     * @deprecated In favor of throwError creation function: import { throwError } from 'rxjs';\n     */\n    static throw: typeof throwError;\n    pipe(): Observable<T>;\n    pipe<A>(op1: OperatorFunction<T, A>): Observable<A>;\n    pipe<A, B>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>): Observable<B>;\n    pipe<A, B, C>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>): Observable<C>;\n    pipe<A, B, C, D>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>, op4: OperatorFunction<C, D>): Observable<D>;\n    pipe<A, B, C, D, E>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>, op4: OperatorFunction<C, D>, op5: OperatorFunction<D, E>): Observable<E>;\n    pipe<A, B, C, D, E, F>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>, op4: OperatorFunction<C, D>, op5: OperatorFunction<D, E>, op6: OperatorFunction<E, F>): Observable<F>;\n    pipe<A, B, C, D, E, F, G>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>, op4: OperatorFunction<C, D>, op5: OperatorFunction<D, E>, op6: OperatorFunction<E, F>, op7: OperatorFunction<F, G>): Observable<G>;\n    pipe<A, B, C, D, E, F, G, H>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>, op4: OperatorFunction<C, D>, op5: OperatorFunction<D, E>, op6: OperatorFunction<E, F>, op7: OperatorFunction<F, G>, op8: OperatorFunction<G, H>): Observable<H>;\n    pipe<A, B, C, D, E, F, G, H, I>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>, op4: OperatorFunction<C, D>, op5: OperatorFunction<D, E>, op6: OperatorFunction<E, F>, op7: OperatorFunction<F, G>, op8: OperatorFunction<G, H>, op9: OperatorFunction<H, I>): Observable<I>;\n    pipe<A, B, C, D, E, F, G, H, I>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>, op4: OperatorFunction<C, D>, op5: OperatorFunction<D, E>, op6: OperatorFunction<E, F>, op7: OperatorFunction<F, G>, op8: OperatorFunction<G, H>, op9: OperatorFunction<H, I>, ...operations: OperatorFunction<any, any>[]): Observable<{}>;\n    toPromise<T>(this: Observable<T>): Promise<T>;\n    toPromise<T>(this: Observable<T>, PromiseCtor: typeof Promise): Promise<T>;\n    toPromise<T>(this: Observable<T>, PromiseCtor: PromiseConstructorLike): Promise<T>;\n}\n"
  },
  {
    "path": "node_modules/rxjs/internal/observable/bindCallback.d.ts",
    "content": "import { SchedulerLike } from '../types';\nimport { Observable } from '../Observable';\n/** @deprecated resultSelector is no longer supported, use a mapping function. */\nexport declare function bindCallback(callbackFunc: Function, resultSelector: Function, scheduler?: SchedulerLike): (...args: any[]) => Observable<any>;\nexport declare function bindCallback<R1, R2, R3, R4>(callbackFunc: (callback: (res1: R1, res2: R2, res3: R3, res4: R4, ...args: any[]) => any) => any, scheduler?: SchedulerLike): () => Observable<any[]>;\nexport declare function bindCallback<R1, R2, R3>(callbackFunc: (callback: (res1: R1, res2: R2, res3: R3) => any) => any, scheduler?: SchedulerLike): () => Observable<[R1, R2, R3]>;\nexport declare function bindCallback<R1, R2>(callbackFunc: (callback: (res1: R1, res2: R2) => any) => any, scheduler?: SchedulerLike): () => Observable<[R1, R2]>;\nexport declare function bindCallback<R1>(callbackFunc: (callback: (res1: R1) => any) => any, scheduler?: SchedulerLike): () => Observable<R1>;\nexport declare function bindCallback(callbackFunc: (callback: () => any) => any, scheduler?: SchedulerLike): () => Observable<void>;\nexport declare function bindCallback<A1, R1, R2, R3, R4>(callbackFunc: (arg1: A1, callback: (res1: R1, res2: R2, res3: R3, res4: R4, ...args: any[]) => any) => any, scheduler?: SchedulerLike): (arg1: A1) => Observable<any[]>;\nexport declare function bindCallback<A1, R1, R2, R3>(callbackFunc: (arg1: A1, callback: (res1: R1, res2: R2, res3: R3) => any) => any, scheduler?: SchedulerLike): (arg1: A1) => Observable<[R1, R2, R3]>;\nexport declare function bindCallback<A1, R1, R2>(callbackFunc: (arg1: A1, callback: (res1: R1, res2: R2) => any) => any, scheduler?: SchedulerLike): (arg1: A1) => Observable<[R1, R2]>;\nexport declare function bindCallback<A1, R1>(callbackFunc: (arg1: A1, callback: (res1: R1) => any) => any, scheduler?: SchedulerLike): (arg1: A1) => Observable<R1>;\nexport declare function bindCallback<A1>(callbackFunc: (arg1: A1, callback: () => any) => any, scheduler?: SchedulerLike): (arg1: A1) => Observable<void>;\nexport declare function bindCallback<A1, A2, R1, R2, R3, R4>(callbackFunc: (arg1: A1, arg2: A2, callback: (res1: R1, res2: R2, res3: R3, res4: R4, ...args: any[]) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2) => Observable<any[]>;\nexport declare function bindCallback<A1, A2, R1, R2, R3>(callbackFunc: (arg1: A1, arg2: A2, callback: (res1: R1, res2: R2, res3: R3) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2) => Observable<[R1, R2, R3]>;\nexport declare function bindCallback<A1, A2, R1, R2>(callbackFunc: (arg1: A1, arg2: A2, callback: (res1: R1, res2: R2) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2) => Observable<[R1, R2]>;\nexport declare function bindCallback<A1, A2, R1>(callbackFunc: (arg1: A1, arg2: A2, callback: (res1: R1) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2) => Observable<R1>;\nexport declare function bindCallback<A1, A2>(callbackFunc: (arg1: A1, arg2: A2, callback: () => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2) => Observable<void>;\nexport declare function bindCallback<A1, A2, A3, R1, R2, R3, R4>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, callback: (res1: R1, res2: R2, res3: R3, res4: R4, ...args: any[]) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2, arg3: A3) => Observable<any[]>;\nexport declare function bindCallback<A1, A2, A3, R1, R2, R3>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, callback: (res1: R1, res2: R2, res3: R3) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2, arg3: A3) => Observable<[R1, R2, R3]>;\nexport declare function bindCallback<A1, A2, A3, R1, R2>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, callback: (res1: R1, res2: R2) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2, arg3: A3) => Observable<[R1, R2]>;\nexport declare function bindCallback<A1, A2, A3, R1>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, callback: (res1: R1) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2, arg3: A3) => Observable<R1>;\nexport declare function bindCallback<A1, A2, A3>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, callback: () => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2, arg3: A3) => Observable<void>;\nexport declare function bindCallback<A1, A2, A3, A4, R1, R2, R3, R4>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, arg4: A4, callback: (res1: R1, res2: R2, res3: R3, res4: R4, ...args: any[]) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2, arg3: A3, arg4: A4) => Observable<any[]>;\nexport declare function bindCallback<A1, A2, A3, A4, R1, R2, R3>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, arg4: A4, callback: (res1: R1, res2: R2, res3: R3) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2, arg3: A3, arg4: A4) => Observable<[R1, R2, R3]>;\nexport declare function bindCallback<A1, A2, A3, A4, R1, R2>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, arg4: A4, callback: (res1: R1, res2: R2) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2, arg3: A3, arg4: A4) => Observable<[R1, R2]>;\nexport declare function bindCallback<A1, A2, A3, A4, R1>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, arg4: A4, callback: (res1: R1) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2, arg3: A3, arg4: A4) => Observable<R1>;\nexport declare function bindCallback<A1, A2, A3, A4>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, arg4: A4, callback: () => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2, arg3: A3, arg4: A4) => Observable<void>;\nexport declare function bindCallback<A1, A2, A3, A4, A5, R1, R2, R3, R4>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, arg4: A4, arg5: A5, callback: (res1: R1, res2: R2, res3: R3, res4: R4, ...args: any[]) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2, arg3: A3, arg4: A4, arg5: A5) => Observable<any[]>;\nexport declare function bindCallback<A1, A2, A3, A4, A5, R1, R2, R3>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, arg4: A4, arg5: A5, callback: (res1: R1, res2: R2, res3: R3) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2, arg3: A3, arg4: A4, arg5: A5) => Observable<[R1, R2, R3]>;\nexport declare function bindCallback<A1, A2, A3, A4, A5, R1, R2>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, arg4: A4, arg5: A5, callback: (res1: R1, res2: R2) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2, arg3: A3, arg4: A4, arg5: A5) => Observable<[R1, R2]>;\nexport declare function bindCallback<A1, A2, A3, A4, A5, R1>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, arg4: A4, arg5: A5, callback: (res1: R1) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2, arg3: A3, arg4: A4, arg5: A5) => Observable<R1>;\nexport declare function bindCallback<A1, A2, A3, A4, A5>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, arg4: A4, arg5: A5, callback: () => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2, arg3: A3, arg4: A4, arg5: A5) => Observable<void>;\nexport declare function bindCallback<A, R>(callbackFunc: (...args: Array<A | ((result: R) => any)>) => any, scheduler?: SchedulerLike): (...args: A[]) => Observable<R>;\nexport declare function bindCallback<A, R>(callbackFunc: (...args: Array<A | ((...results: R[]) => any)>) => any, scheduler?: SchedulerLike): (...args: A[]) => Observable<R[]>;\nexport declare function bindCallback(callbackFunc: Function, scheduler?: SchedulerLike): (...args: any[]) => Observable<any>;\n"
  },
  {
    "path": "node_modules/rxjs/internal/observable/bindNodeCallback.d.ts",
    "content": "import { Observable } from '../Observable';\nimport { SchedulerLike } from '../types';\n/** @deprecated resultSelector is deprecated, pipe to map instead */\nexport declare function bindNodeCallback(callbackFunc: Function, resultSelector: Function, scheduler?: SchedulerLike): (...args: any[]) => Observable<any>;\nexport declare function bindNodeCallback<R1, R2, R3, R4>(callbackFunc: (callback: (err: any, res1: R1, res2: R2, res3: R3, res4: R4, ...args: any[]) => any) => any, scheduler?: SchedulerLike): (...args: any[]) => Observable<any[]>;\nexport declare function bindNodeCallback<R1, R2, R3>(callbackFunc: (callback: (err: any, res1: R1, res2: R2, res3: R3) => any) => any, scheduler?: SchedulerLike): () => Observable<[R1, R2, R3]>;\nexport declare function bindNodeCallback<R1, R2>(callbackFunc: (callback: (err: any, res1: R1, res2: R2) => any) => any, scheduler?: SchedulerLike): () => Observable<[R1, R2]>;\nexport declare function bindNodeCallback<R1>(callbackFunc: (callback: (err: any, res1: R1) => any) => any, scheduler?: SchedulerLike): () => Observable<R1>;\nexport declare function bindNodeCallback(callbackFunc: (callback: (err: any) => any) => any, scheduler?: SchedulerLike): () => Observable<void>;\nexport declare function bindNodeCallback<A1, R1, R2, R3, R4>(callbackFunc: (arg1: A1, callback: (err: any, res1: R1, res2: R2, res3: R3, res4: R4, ...args: any[]) => any) => any, scheduler?: SchedulerLike): (...args: any[]) => Observable<any[]>;\nexport declare function bindNodeCallback<A1, R1, R2, R3>(callbackFunc: (arg1: A1, callback: (err: any, res1: R1, res2: R2, res3: R3) => any) => any, scheduler?: SchedulerLike): (arg1: A1) => Observable<[R1, R2, R3]>;\nexport declare function bindNodeCallback<A1, R1, R2>(callbackFunc: (arg1: A1, callback: (err: any, res1: R1, res2: R2) => any) => any, scheduler?: SchedulerLike): (arg1: A1) => Observable<[R1, R2]>;\nexport declare function bindNodeCallback<A1, R1>(callbackFunc: (arg1: A1, callback: (err: any, res1: R1) => any) => any, scheduler?: SchedulerLike): (arg1: A1) => Observable<R1>;\nexport declare function bindNodeCallback<A1>(callbackFunc: (arg1: A1, callback: (err: any) => any) => any, scheduler?: SchedulerLike): (arg1: A1) => Observable<void>;\nexport declare function bindNodeCallback<A1, A2, R1, R2, R3, R4>(callbackFunc: (arg1: A1, arg2: A2, callback: (err: any, res1: R1, res2: R2, res3: R3, res4: R4, ...args: any[]) => any) => any, scheduler?: SchedulerLike): (...args: any[]) => Observable<any[]>;\nexport declare function bindNodeCallback<A1, A2, R1, R2, R3>(callbackFunc: (arg1: A1, arg2: A2, callback: (err: any, res1: R1, res2: R2, res3: R3) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2) => Observable<[R1, R2, R3]>;\nexport declare function bindNodeCallback<A1, A2, R1, R2>(callbackFunc: (arg1: A1, arg2: A2, callback: (err: any, res1: R1, res2: R2) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2) => Observable<[R1, R2]>;\nexport declare function bindNodeCallback<A1, A2, R1>(callbackFunc: (arg1: A1, arg2: A2, callback: (err: any, res1: R1) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2) => Observable<R1>;\nexport declare function bindNodeCallback<A1, A2>(callbackFunc: (arg1: A1, arg2: A2, callback: (err: any) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2) => Observable<void>;\nexport declare function bindNodeCallback<A1, A2, A3, R1, R2, R3, R4>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, callback: (err: any, res1: R1, res2: R2, res3: R3, res4: R4, ...args: any[]) => any) => any, scheduler?: SchedulerLike): (...args: any[]) => Observable<any[]>;\nexport declare function bindNodeCallback<A1, A2, A3, R1, R2, R3>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, callback: (err: any, res1: R1, res2: R2, res3: R3) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2, arg3: A3) => Observable<[R1, R2, R3]>;\nexport declare function bindNodeCallback<A1, A2, A3, R1, R2>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, callback: (err: any, res1: R1, res2: R2) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2, arg3: A3) => Observable<[R1, R2]>;\nexport declare function bindNodeCallback<A1, A2, A3, R1>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, callback: (err: any, res1: R1) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2, arg3: A3) => Observable<R1>;\nexport declare function bindNodeCallback<A1, A2, A3>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, callback: (err: any) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2, arg3: A3) => Observable<void>;\nexport declare function bindNodeCallback<A1, A2, A3, A4, R1, R2, R3, R4>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, arg4: A4, callback: (err: any, res1: R1, res2: R2, res3: R3, res4: R4, ...args: any[]) => any) => any, scheduler?: SchedulerLike): (...args: any[]) => Observable<any[]>;\nexport declare function bindNodeCallback<A1, A2, A3, A4, R1, R2, R3>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, arg4: A4, callback: (err: any, res1: R1, res2: R2, res3: R3) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2, arg3: A3, arg4: A4) => Observable<[R1, R2, R3]>;\nexport declare function bindNodeCallback<A1, A2, A3, A4, R1, R2>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, arg4: A4, callback: (err: any, res1: R1, res2: R2) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2, arg3: A3, arg4: A4) => Observable<[R1, R2]>;\nexport declare function bindNodeCallback<A1, A2, A3, A4, R1>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, arg4: A4, callback: (err: any, res1: R1) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2, arg3: A3, arg4: A4) => Observable<R1>;\nexport declare function bindNodeCallback<A1, A2, A3, A4>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, arg4: A4, callback: (err: any) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2, arg3: A3, arg4: A4) => Observable<void>;\nexport declare function bindNodeCallback<A1, A2, A3, A4, A5, R1, R2, R3, R4>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, arg4: A4, arg5: A5, callback: (err: any, res1: R1, res2: R2, res3: R3, res4: R4, ...args: any[]) => any) => any, scheduler?: SchedulerLike): (...args: any[]) => Observable<any[]>;\nexport declare function bindNodeCallback<A1, A2, A3, A4, A5, R1, R2, R3>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, arg4: A4, arg5: A5, callback: (err: any, res1: R1, res2: R2, res3: R3) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2, arg3: A3, arg4: A4, arg5: A5) => Observable<[R1, R2, R3]>;\nexport declare function bindNodeCallback<A1, A2, A3, A4, A5, R1, R2>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, arg4: A4, arg5: A5, callback: (err: any, res1: R1, res2: R2) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2, arg3: A3, arg4: A4, arg5: A5) => Observable<[R1, R2]>;\nexport declare function bindNodeCallback<A1, A2, A3, A4, A5, R1>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, arg4: A4, arg5: A5, callback: (err: any, res1: R1) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2, arg3: A3, arg4: A4, arg5: A5) => Observable<R1>;\nexport declare function bindNodeCallback<A1, A2, A3, A4, A5>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, arg4: A4, arg5: A5, callback: (err: any) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2, arg3: A3, arg4: A4, arg5: A5) => Observable<void>;\nexport declare function bindNodeCallback(callbackFunc: Function, scheduler?: SchedulerLike): (...args: any[]) => Observable<any[]>;\n"
  },
  {
    "path": "node_modules/rxjs/internal/observable/combineLatest.d.ts",
    "content": "import { Observable } from '../Observable';\nimport { ObservableInput, SchedulerLike } from '../types';\nimport { Subscriber } from '../Subscriber';\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { Operator } from '../Operator';\nimport { InnerSubscriber } from '../InnerSubscriber';\n/** @deprecated resultSelector no longer supported, pipe to map instead */\nexport declare function combineLatest<T, R>(v1: ObservableInput<T>, resultSelector: (v1: T) => R, scheduler?: SchedulerLike): Observable<R>;\n/** @deprecated resultSelector no longer supported, pipe to map instead */\nexport declare function combineLatest<T, T2, R>(v1: ObservableInput<T>, v2: ObservableInput<T2>, resultSelector: (v1: T, v2: T2) => R, scheduler?: SchedulerLike): Observable<R>;\n/** @deprecated resultSelector no longer supported, pipe to map instead */\nexport declare function combineLatest<T, T2, T3, R>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, resultSelector: (v1: T, v2: T2, v3: T3) => R, scheduler?: SchedulerLike): Observable<R>;\n/** @deprecated resultSelector no longer supported, pipe to map instead */\nexport declare function combineLatest<T, T2, T3, T4, R>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, resultSelector: (v1: T, v2: T2, v3: T3, v4: T4) => R, scheduler?: SchedulerLike): Observable<R>;\n/** @deprecated resultSelector no longer supported, pipe to map instead */\nexport declare function combineLatest<T, T2, T3, T4, T5, R>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, resultSelector: (v1: T, v2: T2, v3: T3, v4: T4, v5: T5) => R, scheduler?: SchedulerLike): Observable<R>;\n/** @deprecated resultSelector no longer supported, pipe to map instead */\nexport declare function combineLatest<T, T2, T3, T4, T5, T6, R>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>, resultSelector: (v1: T, v2: T2, v3: T3, v4: T4, v5: T5, v6: T6) => R, scheduler?: SchedulerLike): Observable<R>;\nexport declare function combineLatest<T, T2>(v1: ObservableInput<T>, v2: ObservableInput<T2>, scheduler?: SchedulerLike): Observable<[T, T2]>;\nexport declare function combineLatest<T, T2, T3>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, scheduler?: SchedulerLike): Observable<[T, T2, T3]>;\nexport declare function combineLatest<T, T2, T3, T4>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, scheduler?: SchedulerLike): Observable<[T, T2, T3, T4]>;\nexport declare function combineLatest<T, T2, T3, T4, T5>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, scheduler?: SchedulerLike): Observable<[T, T2, T3, T4, T5]>;\nexport declare function combineLatest<T, T2, T3, T4, T5, T6>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>, scheduler?: SchedulerLike): Observable<[T, T2, T3, T4, T5, T6]>;\nexport declare function combineLatest<T>(array: ObservableInput<T>[], scheduler?: SchedulerLike): Observable<T[]>;\nexport declare function combineLatest<R>(array: ObservableInput<any>[], scheduler?: SchedulerLike): Observable<R>;\n/** @deprecated resultSelector no longer supported, pipe to map instead */\nexport declare function combineLatest<T, R>(array: ObservableInput<T>[], resultSelector: (...values: Array<T>) => R, scheduler?: SchedulerLike): Observable<R>;\n/** @deprecated resultSelector no longer supported, pipe to map instead */\nexport declare function combineLatest<R>(array: ObservableInput<any>[], resultSelector: (...values: Array<any>) => R, scheduler?: SchedulerLike): Observable<R>;\nexport declare function combineLatest<T>(...observables: Array<ObservableInput<T> | SchedulerLike>): Observable<T[]>;\nexport declare function combineLatest<T, R>(...observables: Array<ObservableInput<T> | ((...values: Array<T>) => R) | SchedulerLike>): Observable<R>;\nexport declare function combineLatest<R>(...observables: Array<ObservableInput<any> | ((...values: Array<any>) => R) | SchedulerLike>): Observable<R>;\nexport declare class CombineLatestOperator<T, R> implements Operator<T, R> {\n    private resultSelector?;\n    constructor(resultSelector?: (...values: Array<any>) => R);\n    call(subscriber: Subscriber<R>, source: any): any;\n}\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport declare class CombineLatestSubscriber<T, R> extends OuterSubscriber<T, R> {\n    private resultSelector?;\n    private active;\n    private values;\n    private observables;\n    private toRespond;\n    constructor(destination: Subscriber<R>, resultSelector?: (...values: Array<any>) => R);\n    protected _next(observable: any): void;\n    protected _complete(): void;\n    notifyComplete(unused: Subscriber<R>): void;\n    notifyNext(outerValue: T, innerValue: R, outerIndex: number, innerIndex: number, innerSub: InnerSubscriber<T, R>): void;\n    private _tryResultSelector;\n}\n"
  },
  {
    "path": "node_modules/rxjs/internal/observable/concat.d.ts",
    "content": "import { Observable } from '../Observable';\nimport { ObservableInput, SchedulerLike } from '../types';\nexport declare function concat<T>(v1: ObservableInput<T>, scheduler?: SchedulerLike): Observable<T>;\nexport declare function concat<T, T2>(v1: ObservableInput<T>, v2: ObservableInput<T2>, scheduler?: SchedulerLike): Observable<T | T2>;\nexport declare function concat<T, T2, T3>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, scheduler?: SchedulerLike): Observable<T | T2 | T3>;\nexport declare function concat<T, T2, T3, T4>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, scheduler?: SchedulerLike): Observable<T | T2 | T3 | T4>;\nexport declare function concat<T, T2, T3, T4, T5>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, scheduler?: SchedulerLike): Observable<T | T2 | T3 | T4 | T5>;\nexport declare function concat<T, T2, T3, T4, T5, T6>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>, scheduler?: SchedulerLike): Observable<T | T2 | T3 | T4 | T5 | T6>;\nexport declare function concat<T>(...observables: (ObservableInput<T> | SchedulerLike)[]): Observable<T>;\nexport declare function concat<T, R>(...observables: (ObservableInput<any> | SchedulerLike)[]): Observable<R>;\n"
  },
  {
    "path": "node_modules/rxjs/internal/observable/ConnectableObservable.d.ts",
    "content": "import { Subject } from '../Subject';\nimport { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { Subscription } from '../Subscription';\n/**\n * @class ConnectableObservable<T>\n */\nexport declare class ConnectableObservable<T> extends Observable<T> {\n    source: Observable<T>;\n    protected subjectFactory: () => Subject<T>;\n    protected _subject: Subject<T>;\n    protected _refCount: number;\n    protected _connection: Subscription;\n    /** @internal */\n    _isComplete: boolean;\n    constructor(source: Observable<T>, subjectFactory: () => Subject<T>);\n    /** @deprecated This is an internal implementation detail, do not use. */\n    _subscribe(subscriber: Subscriber<T>): Subscription;\n    protected getSubject(): Subject<T>;\n    connect(): Subscription;\n    refCount(): Observable<T>;\n}\nexport declare const connectableObservableDescriptor: PropertyDescriptorMap;\n"
  },
  {
    "path": "node_modules/rxjs/internal/observable/defer.d.ts",
    "content": "import { Observable } from '../Observable';\nimport { SubscribableOrPromise } from '../types';\n/**\n * Creates an Observable that, on subscribe, calls an Observable factory to\n * make an Observable for each new Observer.\n *\n * <span class=\"informal\">Creates the Observable lazily, that is, only when it\n * is subscribed.\n * </span>\n *\n * ![](defer.png)\n *\n * `defer` allows you to create the Observable only when the Observer\n * subscribes, and create a fresh Observable for each Observer. It waits until\n * an Observer subscribes to it, and then it generates an Observable,\n * typically with an Observable factory function. It does this afresh for each\n * subscriber, so although each subscriber may think it is subscribing to the\n * same Observable, in fact each subscriber gets its own individual\n * Observable.\n *\n * ## Example\n * ### Subscribe to either an Observable of clicks or an Observable of interval, at random\n * ```javascript\n * const clicksOrInterval = defer(function () {\n *   return Math.random() > 0.5\n *     ? fromEvent(document, 'click')\n *     : interval(1000);\n * });\n * clicksOrInterval.subscribe(x => console.log(x));\n *\n * // Results in the following behavior:\n * // If the result of Math.random() is greater than 0.5 it will listen\n * // for clicks anywhere on the \"document\"; when document is clicked it\n * // will log a MouseEvent object to the console. If the result is less\n * // than 0.5 it will emit ascending numbers, one every second(1000ms).\n * ```\n *\n * @see {@link Observable}\n *\n * @param {function(): SubscribableOrPromise} observableFactory The Observable\n * factory function to invoke for each Observer that subscribes to the output\n * Observable. May also return a Promise, which will be converted on the fly\n * to an Observable.\n * @return {Observable} An Observable whose Observers' subscriptions trigger\n * an invocation of the given Observable factory function.\n * @static true\n * @name defer\n * @owner Observable\n */\nexport declare function defer<T>(observableFactory: () => SubscribableOrPromise<T> | void): Observable<T>;\n"
  },
  {
    "path": "node_modules/rxjs/internal/observable/dom/ajax.d.ts",
    "content": "import { AjaxCreationMethod } from './AjaxObservable';\n/**\n * There is an ajax operator on the Rx object.\n *\n * It creates an observable for an Ajax request with either a request object with\n * url, headers, etc or a string for a URL.\n *\n * ## Using ajax.getJSON() to fetch data from API.\n * ```javascript\n * import { ajax } from 'rxjs/ajax';\n * import { map, catchError } from 'rxjs/operators';\n *\n * const obs$ = ajax.getJSON(`https://api.github.com/users?per_page=5`).pipe(\n *   map(userResponse => console.log('users: ', userResponse)),\n *   catchError(error => console.log('error: ', error))\n * ));\n * ```\n */\nexport declare const ajax: AjaxCreationMethod;\n"
  },
  {
    "path": "node_modules/rxjs/internal/observable/dom/AjaxObservable.d.ts",
    "content": "import { Observable } from '../../Observable';\nimport { Subscriber } from '../../Subscriber';\nimport { TeardownLogic } from '../../types';\nexport interface AjaxRequest {\n    url?: string;\n    body?: any;\n    user?: string;\n    async?: boolean;\n    method?: string;\n    headers?: Object;\n    timeout?: number;\n    password?: string;\n    hasContent?: boolean;\n    crossDomain?: boolean;\n    withCredentials?: boolean;\n    createXHR?: () => XMLHttpRequest;\n    progressSubscriber?: Subscriber<any>;\n    responseType?: string;\n}\nexport interface AjaxCreationMethod {\n    (urlOrRequest: string | AjaxRequest): Observable<AjaxResponse>;\n    get(url: string, headers?: Object): Observable<AjaxResponse>;\n    post(url: string, body?: any, headers?: Object): Observable<AjaxResponse>;\n    put(url: string, body?: any, headers?: Object): Observable<AjaxResponse>;\n    patch(url: string, body?: any, headers?: Object): Observable<AjaxResponse>;\n    delete(url: string, headers?: Object): Observable<AjaxResponse>;\n    getJSON<T>(url: string, headers?: Object): Observable<T>;\n}\nexport declare function ajaxGet(url: string, headers?: Object): AjaxObservable<AjaxResponse>;\nexport declare function ajaxPost(url: string, body?: any, headers?: Object): Observable<AjaxResponse>;\nexport declare function ajaxDelete(url: string, headers?: Object): Observable<AjaxResponse>;\nexport declare function ajaxPut(url: string, body?: any, headers?: Object): Observable<AjaxResponse>;\nexport declare function ajaxPatch(url: string, body?: any, headers?: Object): Observable<AjaxResponse>;\nexport declare function ajaxGetJSON<T>(url: string, headers?: Object): Observable<T>;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nexport declare class AjaxObservable<T> extends Observable<T> {\n    /**\n     * Creates an observable for an Ajax request with either a request object with\n     * url, headers, etc or a string for a URL.\n     *\n     * ## Example\n     * ```javascript\n     * source = Rx.Observable.ajax('/products');\n     * source = Rx.Observable.ajax({ url: 'products', method: 'GET' });\n     * ```\n     *\n     * @param {string|Object} request Can be one of the following:\n     *   A string of the URL to make the Ajax call.\n     *   An object with the following properties\n     *   - url: URL of the request\n     *   - body: The body of the request\n     *   - method: Method of the request, such as GET, POST, PUT, PATCH, DELETE\n     *   - async: Whether the request is async\n     *   - headers: Optional headers\n     *   - crossDomain: true if a cross domain request, else false\n     *   - createXHR: a function to override if you need to use an alternate\n     *   XMLHttpRequest implementation.\n     *   - resultSelector: a function to use to alter the output value type of\n     *   the Observable. Gets {@link AjaxResponse} as an argument.\n     * @return {Observable} An observable sequence containing the XMLHttpRequest.\n     * @static true\n     * @name ajax\n     * @owner Observable\n     * @nocollapse\n    */\n    static create: AjaxCreationMethod;\n    private request;\n    constructor(urlOrRequest: string | AjaxRequest);\n    /** @deprecated This is an internal implementation detail, do not use. */\n    _subscribe(subscriber: Subscriber<T>): TeardownLogic;\n}\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport declare class AjaxSubscriber<T> extends Subscriber<Event> {\n    request: AjaxRequest;\n    private xhr;\n    private done;\n    constructor(destination: Subscriber<T>, request: AjaxRequest);\n    next(e: Event): void;\n    private send;\n    private serializeBody;\n    private setHeaders;\n    private setupEvents;\n    unsubscribe(): void;\n}\n/**\n * A normalized AJAX response.\n *\n * @see {@link ajax}\n *\n * @class AjaxResponse\n */\nexport declare class AjaxResponse {\n    originalEvent: Event;\n    xhr: XMLHttpRequest;\n    request: AjaxRequest;\n    /** @type {number} The HTTP status code */\n    status: number;\n    /** @type {string|ArrayBuffer|Document|object|any} The response data */\n    response: any;\n    /** @type {string} The raw responseText */\n    responseText: string;\n    /** @type {string} The responseType (e.g. 'json', 'arraybuffer', or 'xml') */\n    responseType: string;\n    constructor(originalEvent: Event, xhr: XMLHttpRequest, request: AjaxRequest);\n}\nexport declare type AjaxErrorNames = 'AjaxError' | 'AjaxTimeoutError';\n/**\n * A normalized AJAX error.\n *\n * @see {@link ajax}\n *\n * @class AjaxError\n */\nexport interface AjaxError extends Error {\n    /** @type {XMLHttpRequest} The XHR instance associated with the error */\n    xhr: XMLHttpRequest;\n    /** @type {AjaxRequest} The AjaxRequest associated with the error */\n    request: AjaxRequest;\n    /** @type {number} The HTTP status code */\n    status: number;\n    /** @type {string} The responseType (e.g. 'json', 'arraybuffer', or 'xml') */\n    responseType: string;\n    /** @type {string|ArrayBuffer|Document|object|any} The response data */\n    response: any;\n}\nexport interface AjaxErrorCtor {\n    new (message: string, xhr: XMLHttpRequest, request: AjaxRequest): AjaxError;\n}\nexport declare const AjaxError: AjaxErrorCtor;\nexport interface AjaxTimeoutError extends AjaxError {\n}\nexport interface AjaxTimeoutErrorCtor {\n    new (xhr: XMLHttpRequest, request: AjaxRequest): AjaxTimeoutError;\n}\n/**\n * @see {@link ajax}\n *\n * @class AjaxTimeoutError\n */\nexport declare const AjaxTimeoutError: AjaxTimeoutErrorCtor;\n"
  },
  {
    "path": "node_modules/rxjs/internal/observable/dom/webSocket.d.ts",
    "content": "import { WebSocketSubject, WebSocketSubjectConfig } from './WebSocketSubject';\n/**\n * Wrapper around the w3c-compatible WebSocket object provided by the browser.\n *\n * <span class=\"informal\">{@link Subject} that communicates with a server via WebSocket</span>\n *\n * `webSocket` is a factory function that produces a `WebSocketSubject`,\n * which can be used to make WebSocket connection with an arbitrary endpoint.\n * `webSocket` accepts as an argument either a string with url of WebSocket endpoint, or an\n * {@link WebSocketSubjectConfig} object for providing additional configuration, as\n * well as Observers for tracking lifecycle of WebSocket connection.\n *\n * When `WebSocketSubject` is subscribed, it attempts to make a socket connection,\n * unless there is one made already. This means that many subscribers will always listen\n * on the same socket, thus saving resources. If however, two instances are made of `WebSocketSubject`,\n * even if these two were provided with the same url, they will attempt to make separate\n * connections. When consumer of a `WebSocketSubject` unsubscribes, socket connection is closed,\n * only if there are no more subscribers still listening. If after some time a consumer starts\n * subscribing again, connection is reestablished.\n *\n * Once connection is made, whenever a new message comes from the server, `WebSocketSubject` will emit that\n * message as a value in the stream. By default, a message from the socket is parsed via `JSON.parse`. If you\n * want to customize how deserialization is handled (if at all), you can provide custom `resultSelector`\n * function in {@link WebSocketSubject}. When connection closes, stream will complete, provided it happened without\n * any errors. If at any point (starting, maintaining or closing a connection) there is an error,\n * stream will also error with whatever WebSocket API has thrown.\n *\n * By virtue of being a {@link Subject}, `WebSocketSubject` allows for receiving and sending messages from the server. In order\n * to communicate with a connected endpoint, use `next`, `error` and `complete` methods. `next` sends a value to the server, so bear in mind\n * that this value will not be serialized beforehand. Because of This, `JSON.stringify` will have to be called on a value by hand,\n * before calling `next` with a result. Note also that if at the moment of nexting value\n * there is no socket connection (for example no one is subscribing), those values will be buffered, and sent when connection\n * is finally established. `complete` method closes socket connection. `error` does the same,\n * as well as notifying the server that something went wrong via status code and string with details of what happened.\n * Since status code is required in WebSocket API, `WebSocketSubject` does not allow, like regular `Subject`,\n * arbitrary values being passed to the `error` method. It needs to be called with an object that has `code`\n * property with status code number and optional `reason` property with string describing details\n * of an error.\n *\n * Calling `next` does not affect subscribers of `WebSocketSubject` - they have no\n * information that something was sent to the server (unless of course the server\n * responds somehow to a message). On the other hand, since calling `complete` triggers\n * an attempt to close socket connection. If that connection is closed without any errors, stream will\n * complete, thus notifying all subscribers. And since calling `error` closes\n * socket connection as well, just with a different status code for the server, if closing itself proceeds\n * without errors, subscribed Observable will not error, as one might expect, but complete as usual. In both cases\n * (calling `complete` or `error`), if process of closing socket connection results in some errors, *then* stream\n * will error.\n *\n * **Multiplexing**\n *\n * `WebSocketSubject` has an additional operator, not found in other Subjects. It is called `multiplex` and it is\n * used to simulate opening several socket connections, while in reality maintaining only one.\n * For example, an application has both chat panel and real-time notifications about sport news. Since these are two distinct functions,\n * it would make sense to have two separate connections for each. Perhaps there could even be two separate services with WebSocket\n * endpoints, running on separate machines with only GUI combining them together. Having a socket connection\n * for each functionality could become too resource expensive. It is a common pattern to have single\n * WebSocket endpoint that acts as a gateway for the other services (in this case chat and sport news services).\n * Even though there is a single connection in a client app, having the ability to manipulate streams as if it\n * were two separate sockets is desirable. This eliminates manually registering and unregistering in a gateway for\n * given service and filter out messages of interest. This is exactly what `multiplex` method is for.\n *\n * Method accepts three parameters. First two are functions returning subscription and unsubscription messages\n * respectively. These are messages that will be sent to the server, whenever consumer of resulting Observable\n * subscribes and unsubscribes. Server can use them to verify that some kind of messages should start or stop\n * being forwarded to the client. In case of the above example application, after getting subscription message with proper identifier,\n * gateway server can decide that it should connect to real sport news service and start forwarding messages from it.\n * Note that both messages will be sent as returned by the functions, meaning they will have to be serialized manually, just\n * as messages pushed via `next`. Also bear in mind that these messages will be sent on *every* subscription and\n * unsubscription. This is potentially dangerous, because one consumer of an Observable may unsubscribe and the server\n * might stop sending messages, since it got unsubscription message. This needs to be handled\n * on the server or using {@link publish} on a Observable returned from 'multiplex'.\n *\n * Last argument to `multiplex` is a `messageFilter` function which filters out messages\n * sent by the server to only those that belong to simulated WebSocket stream. For example, server might mark these\n * messages with some kind of string identifier on a message object and `messageFilter` would return `true`\n * if there is such identifier on an object emitted by the socket.\n *\n * Return value of `multiplex` is an Observable with messages incoming from emulated socket connection. Note that this\n * is not a `WebSocketSubject`, so calling `next` or `multiplex` again will fail. For pushing values to the\n * server, use root `WebSocketSubject`.\n *\n * ### Examples\n * #### Listening for messages from the server\n * const subject = Rx.Observable.webSocket('ws://localhost:8081');\n *\n * subject.subscribe(\n *    (msg) => console.log('message received: ' + msg), // Called whenever there is a message from the server.\n *    (err) => console.log(err), // Called if at any point WebSocket API signals some kind of error.\n *    () => console.log('complete') // Called when connection is closed (for whatever reason).\n *  );\n *\n *\n * #### Pushing messages to the server\n * const subject = Rx.Observable.webSocket('ws://localhost:8081');\n *\n * subject.subscribe(); // Note that at least one consumer has to subscribe to\n *                      // the created subject - otherwise \"nexted\" values will be just\n *                      // buffered and not sent, since no connection was established!\n *\n * subject.next(JSON.stringify({message: 'some message'})); // This will send a message to the server\n *                                                          // once a connection is made.\n *                                                          // Remember to serialize sent value first!\n *\n * subject.complete(); // Closes the connection.\n *\n *\n * subject.error({code: 4000, reason: 'I think our app just broke!'}); // Also closes the connection,\n *                                                                     // but let's the server know that\n *                                                                     // this closing is caused by some error.\n *\n *\n * #### Multiplexing WebSocket\n * const subject = Rx.Observable.webSocket('ws://localhost:8081');\n *\n * const observableA = subject.multiplex(\n *   () => JSON.stringify({subscribe: 'A'}), // When server gets this message, it will start sending messages for 'A'...\n *   () => JSON.stringify({unsubscribe: 'A'}), // ...and when gets this one, it will stop.\n *   message => message.type === 'A' // Server will tag all messages for 'A' with type property.\n * );\n *\n * const observableB = subject.multiplex( // And the same goes for 'B'.\n *   () => JSON.stringify({subscribe: 'B'}),\n *   () => JSON.stringify({unsubscribe: 'B'}),\n *   message => message.type === 'B'\n * );\n *\n * const subA = observableA.subscribe(messageForA => console.log(messageForA));\n * // At this moment WebSocket connection\n * // is established. Server gets '{\"subscribe\": \"A\"}'\n * // message and starts sending messages for 'A',\n * // which we log here.\n *\n * const subB = observableB.subscribe(messageForB => console.log(messageForB));\n * // Since we already have a connection,\n * // we just send '{\"subscribe\": \"B\"}' message\n * // to the server. It starts sending\n * // messages for 'B', which we log here.\n *\n * subB.unsubscribe();\n * // Message '{\"unsubscribe\": \"B\"}' is sent to the\n * // server, which stops sending 'B' messages.\n *\n * subA.unubscribe();\n * // Message '{\"unsubscribe\": \"A\"}' makes the server\n * // stop sending messages for 'A'. Since there is\n * // no more subscribers to root Subject, socket\n * // connection closes.\n *\n *\n *\n * @param {string|WebSocketSubjectConfig} urlConfigOrSource The WebSocket endpoint as an url or an object with\n * configuration and additional Observers.\n * @return {WebSocketSubject} Subject which allows to both send and receive messages via WebSocket connection.\n */\nexport declare function webSocket<T>(urlConfigOrSource: string | WebSocketSubjectConfig<T>): WebSocketSubject<T>;\n"
  },
  {
    "path": "node_modules/rxjs/internal/observable/dom/WebSocketSubject.d.ts",
    "content": "import { Subject, AnonymousSubject } from '../../Subject';\nimport { Subscriber } from '../../Subscriber';\nimport { Observable } from '../../Observable';\nimport { Subscription } from '../../Subscription';\nimport { Operator } from '../../Operator';\nimport { Observer, NextObserver } from '../../types';\nexport interface WebSocketSubjectConfig<T> {\n    /** The url of the socket server to connect to */\n    url: string;\n    /** The protocol to use to connect */\n    protocol?: string | Array<string>;\n    /** @deprecated use {@link deserializer} */\n    resultSelector?: (e: MessageEvent) => T;\n    /**\n     * A serializer used to create messages from passed values before the\n     * messages are sent to the server. Defaults to JSON.stringify.\n     */\n    serializer?: (value: T) => WebSocketMessage;\n    /**\n     * A deserializer used for messages arriving on the socket from the\n     * server. Defaults to JSON.parse.\n     */\n    deserializer?: (e: MessageEvent) => T;\n    /**\n     * An Observer that watches when open events occur on the underlying web socket.\n     */\n    openObserver?: NextObserver<Event>;\n    /**\n     * An Observer than watches when close events occur on the underlying webSocket\n     */\n    closeObserver?: NextObserver<CloseEvent>;\n    /**\n     * An Observer that watches when a close is about to occur due to\n     * unsubscription.\n     */\n    closingObserver?: NextObserver<void>;\n    /**\n     * A WebSocket constructor to use. This is useful for situations like using a\n     * WebSocket impl in Node (WebSocket is a DOM API), or for mocking a WebSocket\n     * for testing purposes\n     */\n    WebSocketCtor?: {\n        new (url: string, protocols?: string | string[]): WebSocket;\n    };\n    /** Sets the `binaryType` property of the underlying WebSocket. */\n    binaryType?: 'blob' | 'arraybuffer';\n}\nexport declare type WebSocketMessage = string | ArrayBuffer | Blob | ArrayBufferView;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nexport declare class WebSocketSubject<T> extends AnonymousSubject<T> {\n    private _config;\n    /** @deprecated This is an internal implementation detail, do not use. */\n    _output: Subject<T>;\n    private _socket;\n    constructor(urlConfigOrSource: string | WebSocketSubjectConfig<T> | Observable<T>, destination?: Observer<T>);\n    lift<R>(operator: Operator<T, R>): WebSocketSubject<R>;\n    private _resetState;\n    /**\n     * Creates an {@link Observable}, that when subscribed to, sends a message,\n     * defined by the `subMsg` function, to the server over the socket to begin a\n     * subscription to data over that socket. Once data arrives, the\n     * `messageFilter` argument will be used to select the appropriate data for\n     * the resulting Observable. When teardown occurs, either due to\n     * unsubscription, completion or error, a message defined by the `unsubMsg`\n     * argument will be send to the server over the WebSocketSubject.\n     *\n     * @param subMsg A function to generate the subscription message to be sent to\n     * the server. This will still be processed by the serializer in the\n     * WebSocketSubject's config. (Which defaults to JSON serialization)\n     * @param unsubMsg A function to generate the unsubscription message to be\n     * sent to the server at teardown. This will still be processed by the\n     * serializer in the WebSocketSubject's config.\n     * @param messageFilter A predicate for selecting the appropriate messages\n     * from the server for the output stream.\n     */\n    multiplex(subMsg: () => any, unsubMsg: () => any, messageFilter: (value: T) => boolean): Observable<any>;\n    private _connectSocket;\n    /** @deprecated This is an internal implementation detail, do not use. */\n    _subscribe(subscriber: Subscriber<T>): Subscription;\n    unsubscribe(): void;\n}\n"
  },
  {
    "path": "node_modules/rxjs/internal/observable/empty.d.ts",
    "content": "import { Observable } from '../Observable';\nimport { SchedulerLike } from '../types';\n/**\n * The same Observable instance returned by any call to {@link empty} without a\n * `scheduler`. It is preferrable to use this over `empty()`.\n */\nexport declare const EMPTY: Observable<never>;\n/**\n * Creates an Observable that emits no items to the Observer and immediately\n * emits a complete notification.\n *\n * <span class=\"informal\">Just emits 'complete', and nothing else.\n * </span>\n *\n * ![](empty.png)\n *\n * This static operator is useful for creating a simple Observable that only\n * emits the complete notification. It can be used for composing with other\n * Observables, such as in a {@link mergeMap}.\n *\n * ## Examples\n * ### Emit the number 7, then complete\n * ```javascript\n * const result = empty().pipe(startWith(7));\n * result.subscribe(x => console.log(x));\n * ```\n *\n * ### Map and flatten only odd numbers to the sequence 'a', 'b', 'c'\n * ```javascript\n * const interval$ = interval(1000);\n * result = interval$.pipe(\n *   mergeMap(x => x % 2 === 1 ? of('a', 'b', 'c') : empty()),\n * );\n * result.subscribe(x => console.log(x));\n *\n * // Results in the following to the console:\n * // x is equal to the count on the interval eg(0,1,2,3,...)\n * // x will occur every 1000ms\n * // if x % 2 is equal to 1 print abc\n * // if x % 2 is not equal to 1 nothing will be output\n * ```\n *\n * @see {@link Observable}\n * @see {@link never}\n * @see {@link of}\n * @see {@link throwError}\n *\n * @param {SchedulerLike} [scheduler] A {@link SchedulerLike} to use for scheduling\n * the emission of the complete notification.\n * @return {Observable} An \"empty\" Observable: emits only the complete\n * notification.\n * @static true\n * @name empty\n * @owner Observable\n * @deprecated Deprecated in favor of using {@link index/EMPTY} constant.\n */\nexport declare function empty(scheduler?: SchedulerLike): Observable<never>;\nexport declare function emptyScheduled(scheduler: SchedulerLike): Observable<never>;\n"
  },
  {
    "path": "node_modules/rxjs/internal/observable/forkJoin.d.ts",
    "content": "import { Observable } from '../Observable';\nimport { ObservableInput } from '../types';\nexport declare function forkJoin<T>(sources: [ObservableInput<T>]): Observable<T[]>;\nexport declare function forkJoin<T, T2>(sources: [ObservableInput<T>, ObservableInput<T2>]): Observable<[T, T2]>;\nexport declare function forkJoin<T, T2, T3>(sources: [ObservableInput<T>, ObservableInput<T2>, ObservableInput<T3>]): Observable<[T, T2, T3]>;\nexport declare function forkJoin<T, T2, T3, T4>(sources: [ObservableInput<T>, ObservableInput<T2>, ObservableInput<T3>, ObservableInput<T4>]): Observable<[T, T2, T3, T4]>;\nexport declare function forkJoin<T, T2, T3, T4, T5>(sources: [ObservableInput<T>, ObservableInput<T2>, ObservableInput<T3>, ObservableInput<T4>, ObservableInput<T5>]): Observable<[T, T2, T3, T4, T5]>;\nexport declare function forkJoin<T, T2, T3, T4, T5, T6>(sources: [ObservableInput<T>, ObservableInput<T2>, ObservableInput<T3>, ObservableInput<T4>, ObservableInput<T5>, ObservableInput<T6>]): Observable<[T, T2, T3, T4, T5, T6]>;\nexport declare function forkJoin<T>(sources: Array<ObservableInput<T>>): Observable<T[]>;\nexport declare function forkJoin<T>(v1: ObservableInput<T>): Observable<T[]>;\nexport declare function forkJoin<T, T2>(v1: ObservableInput<T>, v2: ObservableInput<T2>): Observable<[T, T2]>;\nexport declare function forkJoin<T, T2, T3>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>): Observable<[T, T2, T3]>;\nexport declare function forkJoin<T, T2, T3, T4>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>): Observable<[T, T2, T3, T4]>;\nexport declare function forkJoin<T, T2, T3, T4, T5>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>): Observable<[T, T2, T3, T4, T5]>;\nexport declare function forkJoin<T, T2, T3, T4, T5, T6>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>): Observable<[T, T2, T3, T4, T5, T6]>;\n/** @deprecated resultSelector is deprecated, pipe to map instead */\nexport declare function forkJoin(...args: Array<ObservableInput<any> | Function>): Observable<any>;\nexport declare function forkJoin<T>(...sources: ObservableInput<T>[]): Observable<T[]>;\n"
  },
  {
    "path": "node_modules/rxjs/internal/observable/from.d.ts",
    "content": "import { Observable } from '../Observable';\nimport { ObservableInput, SchedulerLike } from '../types';\nexport declare function from<T>(input: ObservableInput<T>, scheduler?: SchedulerLike): Observable<T>;\nexport declare function from<T>(input: ObservableInput<ObservableInput<T>>, scheduler?: SchedulerLike): Observable<Observable<T>>;\n"
  },
  {
    "path": "node_modules/rxjs/internal/observable/fromArray.d.ts",
    "content": "import { Observable } from '../Observable';\nimport { SchedulerLike } from '../types';\nexport declare function fromArray<T>(input: ArrayLike<T>, scheduler?: SchedulerLike): Observable<T>;\n"
  },
  {
    "path": "node_modules/rxjs/internal/observable/fromEvent.d.ts",
    "content": "import { Observable } from '../Observable';\nexport interface NodeStyleEventEmitter {\n    addListener: (eventName: string | symbol, handler: NodeEventHandler) => this;\n    removeListener: (eventName: string | symbol, handler: NodeEventHandler) => this;\n}\nexport declare type NodeEventHandler = (...args: any[]) => void;\nexport interface NodeCompatibleEventEmitter {\n    addListener: (eventName: string, handler: NodeEventHandler) => void | {};\n    removeListener: (eventName: string, handler: NodeEventHandler) => void | {};\n}\nexport interface JQueryStyleEventEmitter {\n    on: (eventName: string, handler: Function) => void;\n    off: (eventName: string, handler: Function) => void;\n}\nexport interface HasEventTargetAddRemove<E> {\n    addEventListener(type: string, listener: ((evt: E) => void) | null, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener(type: string, listener?: ((evt: E) => void) | null, options?: EventListenerOptions | boolean): void;\n}\nexport declare type EventTargetLike<T> = HasEventTargetAddRemove<T> | NodeStyleEventEmitter | NodeCompatibleEventEmitter | JQueryStyleEventEmitter;\nexport declare type FromEventTarget<T> = EventTargetLike<T> | ArrayLike<EventTargetLike<T>>;\nexport interface EventListenerOptions {\n    capture?: boolean;\n    passive?: boolean;\n    once?: boolean;\n}\nexport interface AddEventListenerOptions extends EventListenerOptions {\n    once?: boolean;\n    passive?: boolean;\n}\nexport declare function fromEvent<T>(target: FromEventTarget<T>, eventName: string): Observable<T>;\n/** @deprecated resultSelector no longer supported, pipe to map instead */\nexport declare function fromEvent<T>(target: FromEventTarget<T>, eventName: string, resultSelector: (...args: any[]) => T): Observable<T>;\nexport declare function fromEvent<T>(target: FromEventTarget<T>, eventName: string, options: EventListenerOptions): Observable<T>;\n/** @deprecated resultSelector no longer supported, pipe to map instead */\nexport declare function fromEvent<T>(target: FromEventTarget<T>, eventName: string, options: EventListenerOptions, resultSelector: (...args: any[]) => T): Observable<T>;\n"
  },
  {
    "path": "node_modules/rxjs/internal/observable/fromEventPattern.d.ts",
    "content": "import { Observable } from '../Observable';\nexport declare function fromEventPattern<T>(addHandler: (handler: Function) => any, removeHandler?: (handler: Function, signal?: any) => void): Observable<T>;\n/** @deprecated resultSelector no longer supported, pipe to map instead */\nexport declare function fromEventPattern<T>(addHandler: (handler: Function) => any, removeHandler?: (handler: Function, signal?: any) => void, resultSelector?: (...args: any[]) => T): Observable<T>;\n"
  },
  {
    "path": "node_modules/rxjs/internal/observable/fromIterable.d.ts",
    "content": "import { Observable } from '../Observable';\nimport { SchedulerLike } from '../types';\nexport declare function fromIterable<T>(input: Iterable<T>, scheduler: SchedulerLike): Observable<T>;\n"
  },
  {
    "path": "node_modules/rxjs/internal/observable/fromObservable.d.ts",
    "content": "import { Observable } from '../Observable';\nimport { InteropObservable, SchedulerLike } from '../types';\nexport declare function fromObservable<T>(input: InteropObservable<T>, scheduler: SchedulerLike): Observable<T>;\n"
  },
  {
    "path": "node_modules/rxjs/internal/observable/fromPromise.d.ts",
    "content": "import { Observable } from '../Observable';\nimport { SchedulerLike } from '../types';\nexport declare function fromPromise<T>(input: PromiseLike<T>, scheduler?: SchedulerLike): Observable<T>;\n"
  },
  {
    "path": "node_modules/rxjs/internal/observable/generate.d.ts",
    "content": "import { Observable } from '../Observable';\nimport { SchedulerLike } from '../types';\nexport declare type ConditionFunc<S> = (state: S) => boolean;\nexport declare type IterateFunc<S> = (state: S) => S;\nexport declare type ResultFunc<S, T> = (state: S) => T;\nexport interface GenerateBaseOptions<S> {\n    /**\n     * Initial state.\n     */\n    initialState: S;\n    /**\n     * Condition function that accepts state and returns boolean.\n     * When it returns false, the generator stops.\n     * If not specified, a generator never stops.\n     */\n    condition?: ConditionFunc<S>;\n    /**\n     * Iterate function that accepts state and returns new state.\n     */\n    iterate: IterateFunc<S>;\n    /**\n     * SchedulerLike to use for generation process.\n     * By default, a generator starts immediately.\n     */\n    scheduler?: SchedulerLike;\n}\nexport interface GenerateOptions<T, S> extends GenerateBaseOptions<S> {\n    /**\n     * Result selection function that accepts state and returns a value to emit.\n     */\n    resultSelector: ResultFunc<S, T>;\n}\n/**\n * Generates an observable sequence by running a state-driven loop\n * producing the sequence's elements, using the specified scheduler\n * to send out observer messages.\n *\n * ![](generate.png)\n *\n * @example <caption>Produces sequence of 0, 1, 2, ... 9, then completes.</caption>\n * const res = generate(0, x => x < 10, x => x + 1, x => x);\n *\n * @example <caption>Using asap scheduler, produces sequence of 2, 3, 5, then completes.</caption>\n * const res = generate(1, x => x < 5, x =>  * 2, x => x + 1, asap);\n *\n * @see {@link from}\n * @see {@link Observable}\n *\n * @param {S} initialState Initial state.\n * @param {function (state: S): boolean} condition Condition to terminate generation (upon returning false).\n * @param {function (state: S): S} iterate Iteration step function.\n * @param {function (state: S): T} resultSelector Selector function for results produced in the sequence. (deprecated)\n * @param {SchedulerLike} [scheduler] A {@link SchedulerLike} on which to run the generator loop. If not provided, defaults to emit immediately.\n * @returns {Observable<T>} The generated sequence.\n */\nexport declare function generate<T, S>(initialState: S, condition: ConditionFunc<S>, iterate: IterateFunc<S>, resultSelector: ResultFunc<S, T>, scheduler?: SchedulerLike): Observable<T>;\n/**\n * Generates an Observable by running a state-driven loop\n * that emits an element on each iteration.\n *\n * <span class=\"informal\">Use it instead of nexting values in a for loop.</span>\n *\n * <img src=\"./img/generate.png\" width=\"100%\">\n *\n * `generate` allows you to create stream of values generated with a loop very similar to\n * traditional for loop. First argument of `generate` is a beginning value. Second argument\n * is a function that accepts this value and tests if some condition still holds. If it does,\n * loop continues, if not, it stops. Third value is a function which takes previously defined\n * value and modifies it in some way on each iteration. Note how these three parameters\n * are direct equivalents of three expressions in regular for loop: first expression\n * initializes some state (for example numeric index), second tests if loop can make next\n * iteration (for example if index is lower than 10) and third states how defined value\n * will be modified on every step (index will be incremented by one).\n *\n * Return value of a `generate` operator is an Observable that on each loop iteration\n * emits a value. First, condition function is ran. If it returned true, Observable\n * emits currently stored value (initial value at the first iteration) and then updates\n * that value with iterate function. If at some point condition returned false, Observable\n * completes at that moment.\n *\n * Optionally you can pass fourth parameter to `generate` - a result selector function which allows you\n * to immediately map value that would normally be emitted by an Observable.\n *\n * If you find three anonymous functions in `generate` call hard to read, you can provide\n * single object to the operator instead. That object has properties: `initialState`,\n * `condition`, `iterate` and `resultSelector`, which should have respective values that you\n * would normally pass to `generate`. `resultSelector` is still optional, but that form\n * of calling `generate` allows you to omit `condition` as well. If you omit it, that means\n * condition always holds, so output Observable will never complete.\n *\n * Both forms of `generate` can optionally accept a scheduler. In case of multi-parameter call,\n * scheduler simply comes as a last argument (no matter if there is resultSelector\n * function or not). In case of single-parameter call, you can provide it as a\n * `scheduler` property on object passed to the operator. In both cases scheduler decides when\n * next iteration of the loop will happen and therefore when next value will be emitted\n * by the Observable. For example to ensure that each value is pushed to the observer\n * on separate task in event loop, you could use `async` scheduler. Note that\n * by default (when no scheduler is passed) values are simply emitted synchronously.\n *\n *\n * @example <caption>Use with condition and iterate functions.</caption>\n * const generated = generate(0, x => x < 3, x => x + 1);\n *\n * generated.subscribe(\n *   value => console.log(value),\n *   err => {},\n *   () => console.log('Yo!')\n * );\n *\n * // Logs:\n * // 0\n * // 1\n * // 2\n * // \"Yo!\"\n *\n *\n * @example <caption>Use with condition, iterate and resultSelector functions.</caption>\n * const generated = generate(0, x => x < 3, x => x + 1, x => x * 1000);\n *\n * generated.subscribe(\n *   value => console.log(value),\n *   err => {},\n *   () => console.log('Yo!')\n * );\n *\n * // Logs:\n * // 0\n * // 1000\n * // 2000\n * // \"Yo!\"\n *\n *\n * @example <caption>Use with options object.</caption>\n * const generated = generate({\n *   initialState: 0,\n *   condition(value) { return value < 3; },\n *   iterate(value) { return value + 1; },\n *   resultSelector(value) { return value * 1000; }\n * });\n *\n * generated.subscribe(\n *   value => console.log(value),\n *   err => {},\n *   () => console.log('Yo!')\n * );\n *\n * // Logs:\n * // 0\n * // 1000\n * // 2000\n * // \"Yo!\"\n *\n * @example <caption>Use options object without condition function.</caption>\n * const generated = generate({\n *   initialState: 0,\n *   iterate(value) { return value + 1; },\n *   resultSelector(value) { return value * 1000; }\n * });\n *\n * generated.subscribe(\n *   value => console.log(value),\n *   err => {},\n *   () => console.log('Yo!') // This will never run.\n * );\n *\n * // Logs:\n * // 0\n * // 1000\n * // 2000\n * // 3000\n * // ...and never stops.\n *\n *\n * @see {@link from}\n * @see {@link create}\n *\n * @param {S} initialState Initial state.\n * @param {function (state: S): boolean} condition Condition to terminate generation (upon returning false).\n * @param {function (state: S): S} iterate Iteration step function.\n * @param {function (state: S): T} [resultSelector] Selector function for results produced in the sequence.\n * @param {Scheduler} [scheduler] A {@link Scheduler} on which to run the generator loop. If not provided, defaults to emitting immediately.\n * @return {Observable<T>} The generated sequence.\n */\nexport declare function generate<S>(initialState: S, condition: ConditionFunc<S>, iterate: IterateFunc<S>, scheduler?: SchedulerLike): Observable<S>;\n/**\n * Generates an observable sequence by running a state-driven loop\n * producing the sequence's elements, using the specified scheduler\n * to send out observer messages.\n * The overload accepts options object that might contain initial state, iterate,\n * condition and scheduler.\n *\n * ![](generate.png)\n *\n * @example <caption>Produces sequence of 0, 1, 2, ... 9, then completes.</caption>\n * const res = generate({\n *   initialState: 0,\n *   condition: x => x < 10,\n *   iterate: x => x + 1,\n * });\n *\n * @see {@link from}\n * @see {@link Observable}\n *\n * @param {GenerateBaseOptions<S>} options Object that must contain initialState, iterate and might contain condition and scheduler.\n * @returns {Observable<S>} The generated sequence.\n */\nexport declare function generate<S>(options: GenerateBaseOptions<S>): Observable<S>;\n/**\n * Generates an observable sequence by running a state-driven loop\n * producing the sequence's elements, using the specified scheduler\n * to send out observer messages.\n * The overload accepts options object that might contain initial state, iterate,\n * condition, result selector and scheduler.\n *\n * ![](generate.png)\n *\n * @example <caption>Produces sequence of 0, 1, 2, ... 9, then completes.</caption>\n * const res = generate({\n *   initialState: 0,\n *   condition: x => x < 10,\n *   iterate: x => x + 1,\n *   resultSelector: x => x,\n * });\n *\n * @see {@link from}\n * @see {@link Observable}\n *\n * @param {GenerateOptions<T, S>} options Object that must contain initialState, iterate, resultSelector and might contain condition and scheduler.\n * @returns {Observable<T>} The generated sequence.\n */\nexport declare function generate<T, S>(options: GenerateOptions<T, S>): Observable<T>;\n"
  },
  {
    "path": "node_modules/rxjs/internal/observable/iif.d.ts",
    "content": "import { Observable } from '../Observable';\nimport { SubscribableOrPromise } from '../types';\n/**\n * Decides at subscription time which Observable will actually be subscribed.\n *\n * <span class=\"informal\">`If` statement for Observables.</span>\n *\n * `iif` accepts a condition function and two Observables. When\n * an Observable returned by the operator is subscribed, condition function will be called.\n * Based on what boolean it returns at that moment, consumer will subscribe either to\n * the first Observable (if condition was true) or to the second (if condition was false). Condition\n * function may also not return anything - in that case condition will be evaluated as false and\n * second Observable will be subscribed.\n *\n * Note that Observables for both cases (true and false) are optional. If condition points to an Observable that\n * was left undefined, resulting stream will simply complete immediately. That allows you to, rather\n * then controlling which Observable will be subscribed, decide at runtime if consumer should have access\n * to given Observable or not.\n *\n * If you have more complex logic that requires decision between more than two Observables, {@link defer}\n * will probably be a better choice. Actually `iif` can be easily implemented with {@link defer}\n * and exists only for convenience and readability reasons.\n *\n *\n * ## Examples\n * ### Change at runtime which Observable will be subscribed\n * ```javascript\n * let subscribeToFirst;\n * const firstOrSecond = iif(\n *   () => subscribeToFirst,\n *   of('first'),\n *   of('second'),\n * );\n *\n * subscribeToFirst = true;\n * firstOrSecond.subscribe(value => console.log(value));\n *\n * // Logs:\n * // \"first\"\n *\n * subscribeToFirst = false;\n * firstOrSecond.subscribe(value => console.log(value));\n *\n * // Logs:\n * // \"second\"\n *\n * ```\n *\n * ### Control an access to an Observable\n * ```javascript\n * let accessGranted;\n * const observableIfYouHaveAccess = iif(\n *   () => accessGranted,\n *   of('It seems you have an access...'), // Note that only one Observable is passed to the operator.\n * );\n *\n * accessGranted = true;\n * observableIfYouHaveAccess.subscribe(\n *   value => console.log(value),\n *   err => {},\n *   () => console.log('The end'),\n * );\n *\n * // Logs:\n * // \"It seems you have an access...\"\n * // \"The end\"\n *\n * accessGranted = false;\n * observableIfYouHaveAccess.subscribe(\n *   value => console.log(value),\n *   err => {},\n *   () => console.log('The end'),\n * );\n *\n * // Logs:\n * // \"The end\"\n * ```\n *\n * @see {@link defer}\n *\n * @param {function(): boolean} condition Condition which Observable should be chosen.\n * @param {Observable} [trueObservable] An Observable that will be subscribed if condition is true.\n * @param {Observable} [falseObservable] An Observable that will be subscribed if condition is false.\n * @return {Observable} Either first or second Observable, depending on condition.\n * @static true\n * @name iif\n * @owner Observable\n */\nexport declare function iif<T, F>(condition: () => boolean, trueResult?: SubscribableOrPromise<T>, falseResult?: SubscribableOrPromise<F>): Observable<T | F>;\n"
  },
  {
    "path": "node_modules/rxjs/internal/observable/interval.d.ts",
    "content": "import { Observable } from '../Observable';\nimport { SchedulerLike } from '../types';\n/**\n * Creates an Observable that emits sequential numbers every specified\n * interval of time, on a specified {@link SchedulerLike}.\n *\n * <span class=\"informal\">Emits incremental numbers periodically in time.\n * </span>\n *\n * ![](interval.png)\n *\n * `interval` returns an Observable that emits an infinite sequence of\n * ascending integers, with a constant interval of time of your choosing\n * between those emissions. The first emission is not sent immediately, but\n * only after the first period has passed. By default, this operator uses the\n * `async` {@link SchedulerLike} to provide a notion of time, but you may pass any\n * {@link SchedulerLike} to it.\n *\n * ## Example\n * Emits ascending numbers, one every second (1000ms) up to the number 3\n * ```javascript\n * import { interval } from 'rxjs';\n * import { take } from 'rxjs/operators';\n *\n * const numbers = interval(1000);\n *\n * const takeFourNumbers = numbers.pipe(take(4));\n *\n * takeFourNumbers.subscribe(x => console.log('Next: ', x));\n *\n * // Logs:\n * // Next: 0\n * // Next: 1\n * // Next: 2\n * // Next: 3\n * ```\n *\n * @see {@link timer}\n * @see {@link delay}\n *\n * @param {number} [period=0] The interval size in milliseconds (by default)\n * or the time unit determined by the scheduler's clock.\n * @param {SchedulerLike} [scheduler=async] The {@link SchedulerLike} to use for scheduling\n * the emission of values, and providing a notion of \"time\".\n * @return {Observable} An Observable that emits a sequential number each time\n * interval.\n * @static true\n * @name interval\n * @owner Observable\n */\nexport declare function interval(period?: number, scheduler?: SchedulerLike): Observable<number>;\n"
  },
  {
    "path": "node_modules/rxjs/internal/observable/merge.d.ts",
    "content": "import { Observable } from '../Observable';\nimport { ObservableInput, SchedulerLike } from '../types';\nexport declare function merge<T>(v1: ObservableInput<T>, scheduler?: SchedulerLike): Observable<T>;\nexport declare function merge<T>(v1: ObservableInput<T>, concurrent?: number, scheduler?: SchedulerLike): Observable<T>;\nexport declare function merge<T, T2>(v1: ObservableInput<T>, v2: ObservableInput<T2>, scheduler?: SchedulerLike): Observable<T | T2>;\nexport declare function merge<T, T2>(v1: ObservableInput<T>, v2: ObservableInput<T2>, concurrent?: number, scheduler?: SchedulerLike): Observable<T | T2>;\nexport declare function merge<T, T2, T3>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, scheduler?: SchedulerLike): Observable<T | T2 | T3>;\nexport declare function merge<T, T2, T3>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, concurrent?: number, scheduler?: SchedulerLike): Observable<T | T2 | T3>;\nexport declare function merge<T, T2, T3, T4>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, scheduler?: SchedulerLike): Observable<T | T2 | T3 | T4>;\nexport declare function merge<T, T2, T3, T4>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, concurrent?: number, scheduler?: SchedulerLike): Observable<T | T2 | T3 | T4>;\nexport declare function merge<T, T2, T3, T4, T5>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, scheduler?: SchedulerLike): Observable<T | T2 | T3 | T4 | T5>;\nexport declare function merge<T, T2, T3, T4, T5>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, concurrent?: number, scheduler?: SchedulerLike): Observable<T | T2 | T3 | T4 | T5>;\nexport declare function merge<T, T2, T3, T4, T5, T6>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>, scheduler?: SchedulerLike): Observable<T | T2 | T3 | T4 | T5 | T6>;\nexport declare function merge<T, T2, T3, T4, T5, T6>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>, concurrent?: number, scheduler?: SchedulerLike): Observable<T | T2 | T3 | T4 | T5 | T6>;\nexport declare function merge<T>(...observables: (ObservableInput<T> | SchedulerLike | number)[]): Observable<T>;\nexport declare function merge<T, R>(...observables: (ObservableInput<any> | SchedulerLike | number)[]): Observable<R>;\n"
  },
  {
    "path": "node_modules/rxjs/internal/observable/never.d.ts",
    "content": "import { Observable } from '../Observable';\n/**\n * An Observable that emits no items to the Observer and never completes.\n *\n * ![](never.png)\n *\n * A simple Observable that emits neither values nor errors nor the completion\n * notification. It can be used for testing purposes or for composing with other\n * Observables. Please note that by never emitting a complete notification, this\n * Observable keeps the subscription from being disposed automatically.\n * Subscriptions need to be manually disposed.\n *\n * ##  Example\n * ### Emit the number 7, then never emit anything else (not even complete)\n * ```javascript\n * function info() {\n *   console.log('Will not be called');\n * }\n * const result = NEVER.pipe(startWith(7));\n * result.subscribe(x => console.log(x), info, info);\n *\n * ```\n *\n * @see {@link Observable}\n * @see {@link index/EMPTY}\n * @see {@link of}\n * @see {@link throwError}\n */\nexport declare const NEVER: Observable<never>;\n/**\n * @deprecated Deprecated in favor of using {@link NEVER} constant.\n */\nexport declare function never(): Observable<never>;\n"
  },
  {
    "path": "node_modules/rxjs/internal/observable/of.d.ts",
    "content": "import { SchedulerLike } from '../types';\nimport { Observable } from '../Observable';\nexport declare function of<T>(a: T, scheduler?: SchedulerLike): Observable<T>;\nexport declare function of<T, T2>(a: T, b: T2, scheduler?: SchedulerLike): Observable<T | T2>;\nexport declare function of<T, T2, T3>(a: T, b: T2, c: T3, scheduler?: SchedulerLike): Observable<T | T2 | T3>;\nexport declare function of<T, T2, T3, T4>(a: T, b: T2, c: T3, d: T4, scheduler?: SchedulerLike): Observable<T | T2 | T3 | T4>;\nexport declare function of<T, T2, T3, T4, T5>(a: T, b: T2, c: T3, d: T4, e: T5, scheduler?: SchedulerLike): Observable<T | T2 | T3 | T4 | T5>;\nexport declare function of<T, T2, T3, T4, T5, T6>(a: T, b: T2, c: T3, d: T4, e: T5, f: T6, scheduler?: SchedulerLike): Observable<T | T2 | T3 | T4 | T5 | T6>;\nexport declare function of<T, T2, T3, T4, T5, T6, T7>(a: T, b: T2, c: T3, d: T4, e: T5, f: T6, g: T7, scheduler?: SchedulerLike): Observable<T | T2 | T3 | T4 | T5 | T6 | T7>;\nexport declare function of<T, T2, T3, T4, T5, T6, T7, T8>(a: T, b: T2, c: T3, d: T4, e: T5, f: T6, g: T7, h: T8, scheduler?: SchedulerLike): Observable<T | T2 | T3 | T4 | T5 | T6 | T7 | T8>;\nexport declare function of<T, T2, T3, T4, T5, T6, T7, T8, T9>(a: T, b: T2, c: T3, d: T4, e: T5, f: T6, g: T7, h: T8, i: T9, scheduler?: SchedulerLike): Observable<T | T2 | T3 | T4 | T5 | T6 | T7 | T8 | T9>;\nexport declare function of<T>(...args: Array<T | SchedulerLike>): Observable<T>;\n"
  },
  {
    "path": "node_modules/rxjs/internal/observable/onErrorResumeNext.d.ts",
    "content": "import { Observable } from '../Observable';\nimport { ObservableInput } from '../types';\nexport declare function onErrorResumeNext<R>(v: ObservableInput<R>): Observable<R>;\nexport declare function onErrorResumeNext<T2, T3, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>): Observable<R>;\nexport declare function onErrorResumeNext<T2, T3, T4, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>): Observable<R>;\nexport declare function onErrorResumeNext<T2, T3, T4, T5, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>): Observable<R>;\nexport declare function onErrorResumeNext<T2, T3, T4, T5, T6, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>): Observable<R>;\nexport declare function onErrorResumeNext<R>(...observables: Array<ObservableInput<any> | ((...values: Array<any>) => R)>): Observable<R>;\nexport declare function onErrorResumeNext<R>(array: ObservableInput<any>[]): Observable<R>;\n"
  },
  {
    "path": "node_modules/rxjs/internal/observable/pairs.d.ts",
    "content": "import { Observable } from '../Observable';\nimport { SchedulerAction, SchedulerLike } from '../types';\nimport { Subscriber } from '../Subscriber';\nimport { Subscription } from '../Subscription';\n/**\n * Convert an object into an Observable of `[key, value]` pairs.\n *\n * <span class=\"informal\">Turn entries of an object into a stream.</span>\n *\n * <img src=\"./img/pairs.png\" width=\"100%\">\n *\n * `pairs` takes an arbitrary object and returns an Observable that emits arrays. Each\n * emitted array has exactly two elements - the first is a key from the object\n * and the second is a value corresponding to that key. Keys are extracted from\n * an object via `Object.keys` function, which means that they will be only\n * enumerable keys that are present on an object directly - not ones inherited\n * via prototype chain.\n *\n * By default these arrays are emitted synchronously. To change that you can\n * pass a {@link SchedulerLike} as a second argument to `pairs`.\n *\n * @example <caption>Converts a javascript object to an Observable</caption>\n * ```javascript\n * const obj = {\n *   foo: 42,\n *   bar: 56,\n *   baz: 78\n * };\n *\n * pairs(obj)\n * .subscribe(\n *   value => console.log(value),\n *   err => {},\n *   () => console.log('the end!')\n * );\n *\n * // Logs:\n * // [\"foo\": 42],\n * // [\"bar\": 56],\n * // [\"baz\": 78],\n * // \"the end!\"\n * ```\n *\n * @param {Object} obj The object to inspect and turn into an\n * Observable sequence.\n * @param {Scheduler} [scheduler] An optional IScheduler to schedule\n * when resulting Observable will emit values.\n * @returns {(Observable<Array<string|T>>)} An observable sequence of\n * [key, value] pairs from the object.\n */\nexport declare function pairs<T>(obj: Object, scheduler?: SchedulerLike): Observable<[string, T]>;\n/** @internal */\nexport declare function dispatch<T>(this: SchedulerAction<any>, state: {\n    keys: string[];\n    index: number;\n    subscriber: Subscriber<[string, T]>;\n    subscription: Subscription;\n    obj: Object;\n}): void;\n"
  },
  {
    "path": "node_modules/rxjs/internal/observable/race.d.ts",
    "content": "import { Observable } from '../Observable';\nimport { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { TeardownLogic } from '../types';\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { InnerSubscriber } from '../InnerSubscriber';\n/**\n * Returns an Observable that mirrors the first source Observable to emit an item.\n *\n * ## Example\n * ### Subscribes to the observable that was the first to start emitting.\n *\n * ```javascript\n * const obs1 = interval(1000).pipe(mapTo('fast one'));\n * const obs2 = interval(3000).pipe(mapTo('medium one'));\n * const obs3 = interval(5000).pipe(mapTo('slow one'));\n *\n * race(obs3, obs1, obs2)\n * .subscribe(\n *   winner => console.log(winner)\n * );\n *\n * // result:\n * // a series of 'fast one'\n * ```\n *\n * @param {...Observables} ...observables sources used to race for which Observable emits first.\n * @return {Observable} an Observable that mirrors the output of the first Observable to emit an item.\n * @static true\n * @name race\n * @owner Observable\n */\nexport declare function race<T>(observables: Array<Observable<T>>): Observable<T>;\nexport declare function race<T>(observables: Array<Observable<any>>): Observable<T>;\nexport declare function race<T>(...observables: Array<Observable<T> | Array<Observable<T>>>): Observable<T>;\nexport declare class RaceOperator<T> implements Operator<T, T> {\n    call(subscriber: Subscriber<T>, source: any): TeardownLogic;\n}\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport declare class RaceSubscriber<T> extends OuterSubscriber<T, T> {\n    private hasFirst;\n    private observables;\n    private subscriptions;\n    constructor(destination: Subscriber<T>);\n    protected _next(observable: any): void;\n    protected _complete(): void;\n    notifyNext(outerValue: T, innerValue: T, outerIndex: number, innerIndex: number, innerSub: InnerSubscriber<T, T>): void;\n}\n"
  },
  {
    "path": "node_modules/rxjs/internal/observable/range.d.ts",
    "content": "import { SchedulerAction, SchedulerLike } from '../types';\nimport { Observable } from '../Observable';\n/**\n * Creates an Observable that emits a sequence of numbers within a specified\n * range.\n *\n * <span class=\"informal\">Emits a sequence of numbers in a range.</span>\n *\n * ![](range.png)\n *\n * `range` operator emits a range of sequential integers, in order, where you\n * select the `start` of the range and its `length`. By default, uses no\n * {@link SchedulerLike} and just delivers the notifications synchronously, but may use\n * an optional {@link SchedulerLike} to regulate those deliveries.\n *\n * ## Example\n * Emits the numbers 1 to 10</caption>\n * ```javascript\n * const numbers = range(1, 10);\n * numbers.subscribe(x => console.log(x));\n * ```\n * @see {@link timer}\n * @see {@link index/interval}\n *\n * @param {number} [start=0] The value of the first integer in the sequence.\n * @param {number} [count=0] The number of sequential integers to generate.\n * @param {SchedulerLike} [scheduler] A {@link SchedulerLike} to use for scheduling\n * the emissions of the notifications.\n * @return {Observable} An Observable of numbers that emits a finite range of\n * sequential integers.\n * @static true\n * @name range\n * @owner Observable\n */\nexport declare function range(start?: number, count?: number, scheduler?: SchedulerLike): Observable<number>;\n/** @internal */\nexport declare function dispatch(this: SchedulerAction<any>, state: any): void;\n"
  },
  {
    "path": "node_modules/rxjs/internal/observable/scalar.d.ts",
    "content": "import { Observable } from '../Observable';\nexport declare function scalar<T>(value: T): Observable<T>;\n"
  },
  {
    "path": "node_modules/rxjs/internal/observable/SubscribeOnObservable.d.ts",
    "content": "import { SchedulerLike, SchedulerAction } from '../types';\nimport { Subscriber } from '../Subscriber';\nimport { Subscription } from '../Subscription';\nimport { Observable } from '../Observable';\nexport interface DispatchArg<T> {\n    source: Observable<T>;\n    subscriber: Subscriber<T>;\n}\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nexport declare class SubscribeOnObservable<T> extends Observable<T> {\n    source: Observable<T>;\n    private delayTime;\n    private scheduler;\n    /** @nocollapse */\n    static create<T>(source: Observable<T>, delay?: number, scheduler?: SchedulerLike): Observable<T>;\n    /** @nocollapse */\n    static dispatch<T>(this: SchedulerAction<T>, arg: DispatchArg<T>): Subscription;\n    constructor(source: Observable<T>, delayTime?: number, scheduler?: SchedulerLike);\n    /** @deprecated This is an internal implementation detail, do not use. */\n    _subscribe(subscriber: Subscriber<T>): Subscription;\n}\n"
  },
  {
    "path": "node_modules/rxjs/internal/observable/throwError.d.ts",
    "content": "import { Observable } from '../Observable';\nimport { SchedulerLike } from '../types';\n/**\n * Creates an Observable that emits no items to the Observer and immediately\n * emits an error notification.\n *\n * <span class=\"informal\">Just emits 'error', and nothing else.\n * </span>\n *\n * ![](throw.png)\n *\n * This static operator is useful for creating a simple Observable that only\n * emits the error notification. It can be used for composing with other\n * Observables, such as in a {@link mergeMap}.\n *\n * ## Examples\n * ### Emit the number 7, then emit an error\n * ```javascript\n * import { throwError, concat, of } from 'rxjs';\n *\n * const result = concat(of(7), throwError(new Error('oops!')));\n * result.subscribe(x => console.log(x), e => console.error(e));\n *\n * // Logs:\n * // 7\n * // Error: oops!\n * ```\n *\n * ---\n *\n * ### Map and flatten numbers to the sequence 'a', 'b', 'c', but throw an error for 13\n * ```javascript\n * import { throwError, interval, of } from 'rxjs';\n * import { mergeMap } from 'rxjs/operators';\n *\n * interval(1000).pipe(\n *   mergeMap(x => x === 2\n *     ? throwError('Twos are bad')\n *     : of('a', 'b', 'c')\n *   ),\n * ).subscribe(x => console.log(x), e => console.error(e));\n *\n * // Logs:\n * // a\n * // b\n * // c\n * // a\n * // b\n * // c\n * // Twos are bad\n * ```\n *\n * @see {@link Observable}\n * @see {@link empty}\n * @see {@link never}\n * @see {@link of}\n *\n * @param {any} error The particular Error to pass to the error notification.\n * @param {SchedulerLike} [scheduler] A {@link SchedulerLike} to use for scheduling\n * the emission of the error notification.\n * @return {Observable} An error Observable: emits only the error notification\n * using the given error argument.\n * @static true\n * @name throwError\n * @owner Observable\n */\nexport declare function throwError(error: any, scheduler?: SchedulerLike): Observable<never>;\n"
  },
  {
    "path": "node_modules/rxjs/internal/observable/timer.d.ts",
    "content": "import { Observable } from '../Observable';\nimport { SchedulerLike } from '../types';\n/**\n * Creates an Observable that starts emitting after an `dueTime` and\n * emits ever increasing numbers after each `period` of time thereafter.\n *\n * <span class=\"informal\">Its like {@link index/interval}, but you can specify when\n * should the emissions start.</span>\n *\n * ![](timer.png)\n *\n * `timer` returns an Observable that emits an infinite sequence of ascending\n * integers, with a constant interval of time, `period` of your choosing\n * between those emissions. The first emission happens after the specified\n * `dueTime`. The initial delay may be a `Date`. By default, this\n * operator uses the {@link asyncScheduler} {@link SchedulerLike} to provide a notion of time, but you\n * may pass any {@link SchedulerLike} to it. If `period` is not specified, the output\n * Observable emits only one value, `0`. Otherwise, it emits an infinite\n * sequence.\n *\n * ## Examples\n * ### Emits ascending numbers, one every second (1000ms), starting after 3 seconds\n * ```javascript\n * const numbers = timer(3000, 1000);\n * numbers.subscribe(x => console.log(x));\n * ```\n *\n * ### Emits one number after five seconds\n * ```javascript\n * const numbers = timer(5000);\n * numbers.subscribe(x => console.log(x));\n * ```\n * @see {@link index/interval}\n * @see {@link delay}\n *\n * @param {number|Date} [dueTime] The initial delay time specified as a Date object or as an integer denoting\n * milliseconds to wait before emitting the first value of 0`.\n * @param {number|SchedulerLike} [periodOrScheduler] The period of time between emissions of the\n * subsequent numbers.\n * @param {SchedulerLike} [scheduler=async] The {@link SchedulerLike} to use for scheduling\n * the emission of values, and providing a notion of \"time\".\n * @return {Observable} An Observable that emits a `0` after the\n * `dueTime` and ever increasing numbers after each `period` of time\n * thereafter.\n * @static true\n * @name timer\n * @owner Observable\n */\nexport declare function timer(dueTime?: number | Date, periodOrScheduler?: number | SchedulerLike, scheduler?: SchedulerLike): Observable<number>;\n"
  },
  {
    "path": "node_modules/rxjs/internal/observable/using.d.ts",
    "content": "import { Observable } from '../Observable';\nimport { Unsubscribable, ObservableInput } from '../types';\n/**\n * Creates an Observable that uses a resource which will be disposed at the same time as the Observable.\n *\n * <span class=\"informal\">Use it when you catch yourself cleaning up after an Observable.</span>\n *\n * `using` is a factory operator, which accepts two functions. First function returns a disposable resource.\n * It can be an arbitrary object that implements `unsubscribe` method. Second function will be injected with\n * that object and should return an Observable. That Observable can use resource object during its execution.\n * Both functions passed to `using` will be called every time someone subscribes - neither an Observable nor\n * resource object will be shared in any way between subscriptions.\n *\n * When Observable returned by `using` is subscribed, Observable returned from the second function will be subscribed\n * as well. All its notifications (nexted values, completion and error events) will be emitted unchanged by the output\n * Observable. If however someone unsubscribes from the Observable or source Observable completes or errors by itself,\n * the `unsubscribe` method on resource object will be called. This can be used to do any necessary clean up, which\n * otherwise would have to be handled by hand. Note that complete or error notifications are not emitted when someone\n * cancels subscription to an Observable via `unsubscribe`, so `using` can be used as a hook, allowing you to make\n * sure that all resources which need to exist during an Observable execution will be disposed at appropriate time.\n *\n * @see {@link defer}\n *\n * @param {function(): ISubscription} resourceFactory A function which creates any resource object\n * that implements `unsubscribe` method.\n * @param {function(resource: ISubscription): Observable<T>} observableFactory A function which\n * creates an Observable, that can use injected resource object.\n * @return {Observable<T>} An Observable that behaves the same as Observable returned by `observableFactory`, but\n * which - when completed, errored or unsubscribed - will also call `unsubscribe` on created resource object.\n */\nexport declare function using<T>(resourceFactory: () => Unsubscribable | void, observableFactory: (resource: Unsubscribable | void) => ObservableInput<T> | void): Observable<T>;\n"
  },
  {
    "path": "node_modules/rxjs/internal/observable/zip.d.ts",
    "content": "import { Observable } from '../Observable';\nimport { Operator } from '../Operator';\nimport { ObservableInput } from '../types';\nimport { Subscriber } from '../Subscriber';\n/** @deprecated resultSelector is no longer supported, pipe to map instead */\nexport declare function zip<T, R>(v1: ObservableInput<T>, resultSelector: (v1: T) => R): Observable<R>;\n/** @deprecated resultSelector is no longer supported, pipe to map instead */\nexport declare function zip<T, T2, R>(v1: ObservableInput<T>, v2: ObservableInput<T2>, resultSelector: (v1: T, v2: T2) => R): Observable<R>;\n/** @deprecated resultSelector is no longer supported, pipe to map instead */\nexport declare function zip<T, T2, T3, R>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, resultSelector: (v1: T, v2: T2, v3: T3) => R): Observable<R>;\n/** @deprecated resultSelector is no longer supported, pipe to map instead */\nexport declare function zip<T, T2, T3, T4, R>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, resultSelector: (v1: T, v2: T2, v3: T3, v4: T4) => R): Observable<R>;\n/** @deprecated resultSelector is no longer supported, pipe to map instead */\nexport declare function zip<T, T2, T3, T4, T5, R>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, resultSelector: (v1: T, v2: T2, v3: T3, v4: T4, v5: T5) => R): Observable<R>;\n/** @deprecated resultSelector is no longer supported, pipe to map instead */\nexport declare function zip<T, T2, T3, T4, T5, T6, R>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>, resultSelector: (v1: T, v2: T2, v3: T3, v4: T4, v5: T5, v6: T6) => R): Observable<R>;\nexport declare function zip<T, T2>(v1: ObservableInput<T>, v2: ObservableInput<T2>): Observable<[T, T2]>;\nexport declare function zip<T, T2, T3>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>): Observable<[T, T2, T3]>;\nexport declare function zip<T, T2, T3, T4>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>): Observable<[T, T2, T3, T4]>;\nexport declare function zip<T, T2, T3, T4, T5>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>): Observable<[T, T2, T3, T4, T5]>;\nexport declare function zip<T, T2, T3, T4, T5, T6>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>): Observable<[T, T2, T3, T4, T5, T6]>;\nexport declare function zip<T>(array: ObservableInput<T>[]): Observable<T[]>;\nexport declare function zip<R>(array: ObservableInput<any>[]): Observable<R>;\n/** @deprecated resultSelector is no longer supported, pipe to map instead */\nexport declare function zip<T, R>(array: ObservableInput<T>[], resultSelector: (...values: Array<T>) => R): Observable<R>;\n/** @deprecated resultSelector is no longer supported, pipe to map instead */\nexport declare function zip<R>(array: ObservableInput<any>[], resultSelector: (...values: Array<any>) => R): Observable<R>;\nexport declare function zip<T>(...observables: Array<ObservableInput<T>>): Observable<T[]>;\nexport declare function zip<T, R>(...observables: Array<ObservableInput<T> | ((...values: Array<T>) => R)>): Observable<R>;\nexport declare function zip<R>(...observables: Array<ObservableInput<any> | ((...values: Array<any>) => R)>): Observable<R>;\nexport declare class ZipOperator<T, R> implements Operator<T, R> {\n    resultSelector: (...values: Array<any>) => R;\n    constructor(resultSelector?: (...values: Array<any>) => R);\n    call(subscriber: Subscriber<R>, source: any): any;\n}\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport declare class ZipSubscriber<T, R> extends Subscriber<T> {\n    private values;\n    private resultSelector;\n    private iterators;\n    private active;\n    constructor(destination: Subscriber<R>, resultSelector?: (...values: Array<any>) => R, values?: any);\n    protected _next(value: any): void;\n    protected _complete(): void;\n    notifyInactive(): void;\n    checkIterators(): void;\n    protected _tryresultSelector(args: any[]): void;\n}\n"
  },
  {
    "path": "node_modules/rxjs/internal/Observer.d.ts",
    "content": "import { Observer } from './types';\nexport declare const empty: Observer<any>;\n"
  },
  {
    "path": "node_modules/rxjs/internal/Operator.d.ts",
    "content": "import { Subscriber } from './Subscriber';\nimport { TeardownLogic } from './types';\nexport interface Operator<T, R> {\n    call(subscriber: Subscriber<R>, source: any): TeardownLogic;\n}\n"
  },
  {
    "path": "node_modules/rxjs/internal/operators/audit.d.ts",
    "content": "import { MonoTypeOperatorFunction, SubscribableOrPromise } from '../types';\n/**\n * Ignores source values for a duration determined by another Observable, then\n * emits the most recent value from the source Observable, then repeats this\n * process.\n *\n * <span class=\"informal\">It's like {@link auditTime}, but the silencing\n * duration is determined by a second Observable.</span>\n *\n * ![](audit.png)\n *\n * `audit` is similar to `throttle`, but emits the last value from the silenced\n * time window, instead of the first value. `audit` emits the most recent value\n * from the source Observable on the output Observable as soon as its internal\n * timer becomes disabled, and ignores source values while the timer is enabled.\n * Initially, the timer is disabled. As soon as the first source value arrives,\n * the timer is enabled by calling the `durationSelector` function with the\n * source value, which returns the \"duration\" Observable. When the duration\n * Observable emits a value or completes, the timer is disabled, then the most\n * recent source value is emitted on the output Observable, and this process\n * repeats for the next source value.\n *\n * ## Example\n *\n * Emit clicks at a rate of at most one click per second\n * ```javascript\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(audit(ev => interval(1000)));\n * result.subscribe(x => console.log(x));\n * ```\n * @see {@link auditTime}\n * @see {@link debounce}\n * @see {@link delayWhen}\n * @see {@link sample}\n * @see {@link throttle}\n *\n * @param {function(value: T): SubscribableOrPromise} durationSelector A function\n * that receives a value from the source Observable, for computing the silencing\n * duration, returned as an Observable or a Promise.\n * @return {Observable<T>} An Observable that performs rate-limiting of\n * emissions from the source Observable.\n * @method audit\n * @owner Observable\n */\nexport declare function audit<T>(durationSelector: (value: T) => SubscribableOrPromise<any>): MonoTypeOperatorFunction<T>;\n"
  },
  {
    "path": "node_modules/rxjs/internal/operators/auditTime.d.ts",
    "content": "import { MonoTypeOperatorFunction, SchedulerLike } from '../types';\n/**\n * Ignores source values for `duration` milliseconds, then emits the most recent\n * value from the source Observable, then repeats this process.\n *\n * <span class=\"informal\">When it sees a source values, it ignores that plus\n * the next ones for `duration` milliseconds, and then it emits the most recent\n * value from the source.</span>\n *\n * ![](auditTime.png)\n *\n * `auditTime` is similar to `throttleTime`, but emits the last value from the\n * silenced time window, instead of the first value. `auditTime` emits the most\n * recent value from the source Observable on the output Observable as soon as\n * its internal timer becomes disabled, and ignores source values while the\n * timer is enabled. Initially, the timer is disabled. As soon as the first\n * source value arrives, the timer is enabled. After `duration` milliseconds (or\n * the time unit determined internally by the optional `scheduler`) has passed,\n * the timer is disabled, then the most recent source value is emitted on the\n * output Observable, and this process repeats for the next source value.\n * Optionally takes a {@link SchedulerLike} for managing timers.\n *\n * ## Example\n *\n * Emit clicks at a rate of at most one click per second\n * ```javascript\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(auditTime(1000));\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link audit}\n * @see {@link debounceTime}\n * @see {@link delay}\n * @see {@link sampleTime}\n * @see {@link throttleTime}\n *\n * @param {number} duration Time to wait before emitting the most recent source\n * value, measured in milliseconds or the time unit determined internally\n * by the optional `scheduler`.\n * @param {SchedulerLike} [scheduler=async] The {@link SchedulerLike} to use for\n * managing the timers that handle the rate-limiting behavior.\n * @return {Observable<T>} An Observable that performs rate-limiting of\n * emissions from the source Observable.\n * @method auditTime\n * @owner Observable\n */\nexport declare function auditTime<T>(duration: number, scheduler?: SchedulerLike): MonoTypeOperatorFunction<T>;\n"
  },
  {
    "path": "node_modules/rxjs/internal/operators/buffer.d.ts",
    "content": "import { Observable } from '../Observable';\nimport { OperatorFunction } from '../types';\n/**\n * Buffers the source Observable values until `closingNotifier` emits.\n *\n * <span class=\"informal\">Collects values from the past as an array, and emits\n * that array only when another Observable emits.</span>\n *\n * ![](buffer.png)\n *\n * Buffers the incoming Observable values until the given `closingNotifier`\n * Observable emits a value, at which point it emits the buffer on the output\n * Observable and starts a new buffer internally, awaiting the next time\n * `closingNotifier` emits.\n *\n * ## Example\n *\n * On every click, emit array of most recent interval events\n *\n * ```javascript\n * const clicks = fromEvent(document, 'click');\n * const interval = interval(1000);\n * const buffered = interval.pipe(buffer(clicks));\n * buffered.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link bufferCount}\n * @see {@link bufferTime}\n * @see {@link bufferToggle}\n * @see {@link bufferWhen}\n * @see {@link window}\n *\n * @param {Observable<any>} closingNotifier An Observable that signals the\n * buffer to be emitted on the output Observable.\n * @return {Observable<T[]>} An Observable of buffers, which are arrays of\n * values.\n * @method buffer\n * @owner Observable\n */\nexport declare function buffer<T>(closingNotifier: Observable<any>): OperatorFunction<T, T[]>;\n"
  },
  {
    "path": "node_modules/rxjs/internal/operators/bufferCount.d.ts",
    "content": "import { OperatorFunction } from '../types';\n/**\n * Buffers the source Observable values until the size hits the maximum\n * `bufferSize` given.\n *\n * <span class=\"informal\">Collects values from the past as an array, and emits\n * that array only when its size reaches `bufferSize`.</span>\n *\n * ![](bufferCount.png)\n *\n * Buffers a number of values from the source Observable by `bufferSize` then\n * emits the buffer and clears it, and starts a new buffer each\n * `startBufferEvery` values. If `startBufferEvery` is not provided or is\n * `null`, then new buffers are started immediately at the start of the source\n * and when each buffer closes and is emitted.\n *\n * ## Examples\n *\n * Emit the last two click events as an array\n *\n * ```javascript\n * const clicks = fromEvent(document, 'click');\n * const buffered = clicks.pipe(bufferCount(2));\n * buffered.subscribe(x => console.log(x));\n * ```\n *\n * On every click, emit the last two click events as an array\n *\n * ```javascript\n * const clicks = fromEvent(document, 'click');\n * const buffered = clicks.pipe(bufferCount(2, 1));\n * buffered.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link buffer}\n * @see {@link bufferTime}\n * @see {@link bufferToggle}\n * @see {@link bufferWhen}\n * @see {@link pairwise}\n * @see {@link windowCount}\n *\n * @param {number} bufferSize The maximum size of the buffer emitted.\n * @param {number} [startBufferEvery] Interval at which to start a new buffer.\n * For example if `startBufferEvery` is `2`, then a new buffer will be started\n * on every other value from the source. A new buffer is started at the\n * beginning of the source by default.\n * @return {Observable<T[]>} An Observable of arrays of buffered values.\n * @method bufferCount\n * @owner Observable\n */\nexport declare function bufferCount<T>(bufferSize: number, startBufferEvery?: number): OperatorFunction<T, T[]>;\n"
  },
  {
    "path": "node_modules/rxjs/internal/operators/bufferTime.d.ts",
    "content": "import { OperatorFunction, SchedulerLike } from '../types';\nexport declare function bufferTime<T>(bufferTimeSpan: number, scheduler?: SchedulerLike): OperatorFunction<T, T[]>;\nexport declare function bufferTime<T>(bufferTimeSpan: number, bufferCreationInterval: number | null | undefined, scheduler?: SchedulerLike): OperatorFunction<T, T[]>;\nexport declare function bufferTime<T>(bufferTimeSpan: number, bufferCreationInterval: number | null | undefined, maxBufferSize: number, scheduler?: SchedulerLike): OperatorFunction<T, T[]>;\n"
  },
  {
    "path": "node_modules/rxjs/internal/operators/bufferToggle.d.ts",
    "content": "import { OperatorFunction, SubscribableOrPromise } from '../types';\n/**\n * Buffers the source Observable values starting from an emission from\n * `openings` and ending when the output of `closingSelector` emits.\n *\n * <span class=\"informal\">Collects values from the past as an array. Starts\n * collecting only when `opening` emits, and calls the `closingSelector`\n * function to get an Observable that tells when to close the buffer.</span>\n *\n * ![](bufferToggle.png)\n *\n * Buffers values from the source by opening the buffer via signals from an\n * Observable provided to `openings`, and closing and sending the buffers when\n * a Subscribable or Promise returned by the `closingSelector` function emits.\n *\n * ## Example\n *\n * Every other second, emit the click events from the next 500ms\n *\n * ```javascript\n * const clicks = fromEvent(document, 'click');\n * const openings = interval(1000);\n * const buffered = clicks.pipe(bufferToggle(openings, i =>\n *   i % 2 ? interval(500) : empty()\n * ));\n * buffered.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link buffer}\n * @see {@link bufferCount}\n * @see {@link bufferTime}\n * @see {@link bufferWhen}\n * @see {@link windowToggle}\n *\n * @param {SubscribableOrPromise<O>} openings A Subscribable or Promise of notifications to start new\n * buffers.\n * @param {function(value: O): SubscribableOrPromise} closingSelector A function that takes\n * the value emitted by the `openings` observable and returns a Subscribable or Promise,\n * which, when it emits, signals that the associated buffer should be emitted\n * and cleared.\n * @return {Observable<T[]>} An observable of arrays of buffered values.\n * @method bufferToggle\n * @owner Observable\n */\nexport declare function bufferToggle<T, O>(openings: SubscribableOrPromise<O>, closingSelector: (value: O) => SubscribableOrPromise<any>): OperatorFunction<T, T[]>;\n"
  },
  {
    "path": "node_modules/rxjs/internal/operators/bufferWhen.d.ts",
    "content": "import { Observable } from '../Observable';\nimport { OperatorFunction } from '../types';\n/**\n * Buffers the source Observable values, using a factory function of closing\n * Observables to determine when to close, emit, and reset the buffer.\n *\n * <span class=\"informal\">Collects values from the past as an array. When it\n * starts collecting values, it calls a function that returns an Observable that\n * tells when to close the buffer and restart collecting.</span>\n *\n * ![](bufferWhen.png)\n *\n * Opens a buffer immediately, then closes the buffer when the observable\n * returned by calling `closingSelector` function emits a value. When it closes\n * the buffer, it immediately opens a new buffer and repeats the process.\n *\n * ## Example\n *\n * Emit an array of the last clicks every [1-5] random seconds\n *\n * ```javascript\n * const clicks = fromEvent(document, 'click');\n * const buffered = clicks.pipe(bufferWhen(() =>\n *   interval(1000 + Math.random() * 4000)\n * ));\n * buffered.subscribe(x => console.log(x));\n * ```\n *\n *\n * @see {@link buffer}\n * @see {@link bufferCount}\n * @see {@link bufferTime}\n * @see {@link bufferToggle}\n * @see {@link windowWhen}\n *\n * @param {function(): Observable} closingSelector A function that takes no\n * arguments and returns an Observable that signals buffer closure.\n * @return {Observable<T[]>} An observable of arrays of buffered values.\n * @method bufferWhen\n * @owner Observable\n */\nexport declare function bufferWhen<T>(closingSelector: () => Observable<any>): OperatorFunction<T, T[]>;\n"
  },
  {
    "path": "node_modules/rxjs/internal/operators/catchError.d.ts",
    "content": "import { Observable } from '../Observable';\nimport { ObservableInput, OperatorFunction, MonoTypeOperatorFunction } from '../types';\n/**\n * Catches errors on the observable to be handled by returning a new observable or throwing an error.\n *\n * ![](catch.png)\n *\n * ## Examples\n * Continues with a different Observable when there's an error\n *\n * ```javascript\n * of(1, 2, 3, 4, 5).pipe(\n *     map(n => {\n *   \t   if (n == 4) {\n * \t       throw 'four!';\n *       }\n *\t     return n;\n *     }),\n *     catchError(err => of('I', 'II', 'III', 'IV', 'V')),\n *   )\n *   .subscribe(x => console.log(x));\n *   // 1, 2, 3, I, II, III, IV, V\n * ```\n *\n * Retries the caught source Observable again in case of error, similar to retry() operator\n *\n * ```javascript\n * of(1, 2, 3, 4, 5).pipe(\n *     map(n => {\n *   \t   if (n === 4) {\n *   \t     throw 'four!';\n *       }\n * \t     return n;\n *     }),\n *     catchError((err, caught) => caught),\n *     take(30),\n *   )\n *   .subscribe(x => console.log(x));\n *   // 1, 2, 3, 1, 2, 3, ...\n * ```\n *\n * Throws a new error when the source Observable throws an error\n *\n * ```javascript\n * of(1, 2, 3, 4, 5).pipe(\n *     map(n => {\n *       if (n == 4) {\n *         throw 'four!';\n *       }\n *       return n;\n *     }),\n *     catchError(err => {\n *       throw 'error in source. Details: ' + err;\n *     }),\n *   )\n *   .subscribe(\n *     x => console.log(x),\n *     err => console.log(err)\n *   );\n *   // 1, 2, 3, error in source. Details: four!\n * ```\n *\n *  @param {function} selector a function that takes as arguments `err`, which is the error, and `caught`, which\n *  is the source observable, in case you'd like to \"retry\" that observable by returning it again. Whatever observable\n *  is returned by the `selector` will be used to continue the observable chain.\n * @return {Observable} An observable that originates from either the source or the observable returned by the\n *  catch `selector` function.\n * @name catchError\n */\nexport declare function catchError<T>(selector: (err: any, caught: Observable<T>) => never): MonoTypeOperatorFunction<T>;\nexport declare function catchError<T, R>(selector: (err: any, caught: Observable<T>) => ObservableInput<R>): OperatorFunction<T, T | R>;\n"
  },
  {
    "path": "node_modules/rxjs/internal/operators/combineAll.d.ts",
    "content": "import { OperatorFunction, ObservableInput } from '../types';\nexport declare function combineAll<T>(): OperatorFunction<ObservableInput<T>, T[]>;\nexport declare function combineAll<T>(): OperatorFunction<any, T[]>;\nexport declare function combineAll<T, R>(project: (...values: T[]) => R): OperatorFunction<ObservableInput<T>, R>;\nexport declare function combineAll<R>(project: (...values: Array<any>) => R): OperatorFunction<any, R>;\n"
  },
  {
    "path": "node_modules/rxjs/internal/operators/combineLatest.d.ts",
    "content": "import { ObservableInput, OperatorFunction } from '../types';\n/** @deprecated Deprecated in favor of static combineLatest. */\nexport declare function combineLatest<T, R>(project: (v1: T) => R): OperatorFunction<T, R>;\n/** @deprecated Deprecated in favor of static combineLatest. */\nexport declare function combineLatest<T, T2, R>(v2: ObservableInput<T2>, project: (v1: T, v2: T2) => R): OperatorFunction<T, R>;\n/** @deprecated Deprecated in favor of static combineLatest. */\nexport declare function combineLatest<T, T2, T3, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, project: (v1: T, v2: T2, v3: T3) => R): OperatorFunction<T, R>;\n/** @deprecated Deprecated in favor of static combineLatest. */\nexport declare function combineLatest<T, T2, T3, T4, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, project: (v1: T, v2: T2, v3: T3, v4: T4) => R): OperatorFunction<T, R>;\n/** @deprecated Deprecated in favor of static combineLatest. */\nexport declare function combineLatest<T, T2, T3, T4, T5, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, project: (v1: T, v2: T2, v3: T3, v4: T4, v5: T5) => R): OperatorFunction<T, R>;\n/** @deprecated Deprecated in favor of static combineLatest. */\nexport declare function combineLatest<T, T2, T3, T4, T5, T6, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>, project: (v1: T, v2: T2, v3: T3, v4: T4, v5: T5, v6: T6) => R): OperatorFunction<T, R>;\n/** @deprecated Deprecated in favor of static combineLatest. */\nexport declare function combineLatest<T, T2>(v2: ObservableInput<T2>): OperatorFunction<T, [T, T2]>;\n/** @deprecated Deprecated in favor of static combineLatest. */\nexport declare function combineLatest<T, T2, T3>(v2: ObservableInput<T2>, v3: ObservableInput<T3>): OperatorFunction<T, [T, T2, T3]>;\n/** @deprecated Deprecated in favor of static combineLatest. */\nexport declare function combineLatest<T, T2, T3, T4>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>): OperatorFunction<T, [T, T2, T3, T4]>;\n/** @deprecated Deprecated in favor of static combineLatest. */\nexport declare function combineLatest<T, T2, T3, T4, T5>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>): OperatorFunction<T, [T, T2, T3, T4, T5]>;\n/** @deprecated Deprecated in favor of static combineLatest. */\nexport declare function combineLatest<T, T2, T3, T4, T5, T6>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>): OperatorFunction<T, [T, T2, T3, T4, T5, T6]>;\n/** @deprecated Deprecated in favor of static combineLatest. */\nexport declare function combineLatest<T, R>(...observables: Array<ObservableInput<T> | ((...values: Array<T>) => R)>): OperatorFunction<T, R>;\n/** @deprecated Deprecated in favor of static combineLatest. */\nexport declare function combineLatest<T, R>(array: ObservableInput<T>[]): OperatorFunction<T, Array<T>>;\n/** @deprecated Deprecated in favor of static combineLatest. */\nexport declare function combineLatest<T, TOther, R>(array: ObservableInput<TOther>[], project: (v1: T, ...values: Array<TOther>) => R): OperatorFunction<T, R>;\n"
  },
  {
    "path": "node_modules/rxjs/internal/operators/concat.d.ts",
    "content": "import { ObservableInput, OperatorFunction, MonoTypeOperatorFunction, SchedulerLike } from '../types';\n/** @deprecated Deprecated in favor of static concat. */\nexport declare function concat<T>(scheduler?: SchedulerLike): MonoTypeOperatorFunction<T>;\n/** @deprecated Deprecated in favor of static concat. */\nexport declare function concat<T, T2>(v2: ObservableInput<T2>, scheduler?: SchedulerLike): OperatorFunction<T, T | T2>;\n/** @deprecated Deprecated in favor of static concat. */\nexport declare function concat<T, T2, T3>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, scheduler?: SchedulerLike): OperatorFunction<T, T | T2 | T3>;\n/** @deprecated Deprecated in favor of static concat. */\nexport declare function concat<T, T2, T3, T4>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, scheduler?: SchedulerLike): OperatorFunction<T, T | T2 | T3 | T4>;\n/** @deprecated Deprecated in favor of static concat. */\nexport declare function concat<T, T2, T3, T4, T5>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, scheduler?: SchedulerLike): OperatorFunction<T, T | T2 | T3 | T4 | T5>;\n/** @deprecated Deprecated in favor of static concat. */\nexport declare function concat<T, T2, T3, T4, T5, T6>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>, scheduler?: SchedulerLike): OperatorFunction<T, T | T2 | T3 | T4 | T5 | T6>;\n/** @deprecated Deprecated in favor of static concat. */\nexport declare function concat<T>(...observables: Array<ObservableInput<T> | SchedulerLike>): MonoTypeOperatorFunction<T>;\n/** @deprecated Deprecated in favor of static concat. */\nexport declare function concat<T, R>(...observables: Array<ObservableInput<any> | SchedulerLike>): OperatorFunction<T, R>;\n"
  },
  {
    "path": "node_modules/rxjs/internal/operators/concatAll.d.ts",
    "content": "import { OperatorFunction, ObservableInput } from '../types';\nexport declare function concatAll<T>(): OperatorFunction<ObservableInput<T>, T>;\nexport declare function concatAll<R>(): OperatorFunction<any, R>;\n"
  },
  {
    "path": "node_modules/rxjs/internal/operators/concatMap.d.ts",
    "content": "import { ObservableInput, OperatorFunction } from '../types';\nexport declare function concatMap<T, R>(project: (value: T, index: number) => ObservableInput<R>): OperatorFunction<T, R>;\n/** @deprecated resultSelector no longer supported, use inner map instead */\nexport declare function concatMap<T, R>(project: (value: T, index: number) => ObservableInput<R>, resultSelector: undefined): OperatorFunction<T, R>;\n/** @deprecated resultSelector no longer supported, use inner map instead */\nexport declare function concatMap<T, I, R>(project: (value: T, index: number) => ObservableInput<I>, resultSelector: (outerValue: T, innerValue: I, outerIndex: number, innerIndex: number) => R): OperatorFunction<T, R>;\n"
  },
  {
    "path": "node_modules/rxjs/internal/operators/concatMapTo.d.ts",
    "content": "import { ObservableInput, OperatorFunction } from '../types';\nexport declare function concatMapTo<T>(observable: ObservableInput<T>): OperatorFunction<any, T>;\n/** @deprecated */\nexport declare function concatMapTo<T>(observable: ObservableInput<T>, resultSelector: undefined): OperatorFunction<any, T>;\n/** @deprecated */\nexport declare function concatMapTo<T, I, R>(observable: ObservableInput<I>, resultSelector: (outerValue: T, innerValue: I, outerIndex: number, innerIndex: number) => R): OperatorFunction<T, R>;\n"
  },
  {
    "path": "node_modules/rxjs/internal/operators/count.d.ts",
    "content": "import { Observable } from '../Observable';\nimport { OperatorFunction } from '../types';\n/**\n * Counts the number of emissions on the source and emits that number when the\n * source completes.\n *\n * <span class=\"informal\">Tells how many values were emitted, when the source\n * completes.</span>\n *\n * ![](count.png)\n *\n * `count` transforms an Observable that emits values into an Observable that\n * emits a single value that represents the number of values emitted by the\n * source Observable. If the source Observable terminates with an error, `count`\n * will pass this error notification along without emitting a value first. If\n * the source Observable does not terminate at all, `count` will neither emit\n * a value nor terminate. This operator takes an optional `predicate` function\n * as argument, in which case the output emission will represent the number of\n * source values that matched `true` with the `predicate`.\n *\n * ## Examples\n *\n * Counts how many seconds have passed before the first click happened\n * ```javascript\n * const seconds = interval(1000);\n * const clicks = fromEvent(document, 'click');\n * const secondsBeforeClick = seconds.pipe(takeUntil(clicks));\n * const result = secondsBeforeClick.pipe(count());\n * result.subscribe(x => console.log(x));\n * ```\n *\n * Counts how many odd numbers are there between 1 and 7\n * ```javascript\n * const numbers = range(1, 7);\n * const result = numbers.pipe(count(i => i % 2 === 1));\n * result.subscribe(x => console.log(x));\n * // Results in:\n * // 4\n * ```\n *\n * @see {@link max}\n * @see {@link min}\n * @see {@link reduce}\n *\n * @param {function(value: T, i: number, source: Observable<T>): boolean} [predicate] A\n * boolean function to select what values are to be counted. It is provided with\n * arguments of:\n * - `value`: the value from the source Observable.\n * - `index`: the (zero-based) \"index\" of the value from the source Observable.\n * - `source`: the source Observable instance itself.\n * @return {Observable} An Observable of one number that represents the count as\n * described above.\n * @method count\n * @owner Observable\n */\nexport declare function count<T>(predicate?: (value: T, index: number, source: Observable<T>) => boolean): OperatorFunction<T, number>;\n"
  },
  {
    "path": "node_modules/rxjs/internal/operators/debounce.d.ts",
    "content": "import { MonoTypeOperatorFunction, SubscribableOrPromise } from '../types';\n/**\n * Emits a value from the source Observable only after a particular time span\n * determined by another Observable has passed without another source emission.\n *\n * <span class=\"informal\">It's like {@link debounceTime}, but the time span of\n * emission silence is determined by a second Observable.</span>\n *\n * ![](debounce.png)\n *\n * `debounce` delays values emitted by the source Observable, but drops previous\n * pending delayed emissions if a new value arrives on the source Observable.\n * This operator keeps track of the most recent value from the source\n * Observable, and spawns a duration Observable by calling the\n * `durationSelector` function. The value is emitted only when the duration\n * Observable emits a value or completes, and if no other value was emitted on\n * the source Observable since the duration Observable was spawned. If a new\n * value appears before the duration Observable emits, the previous value will\n * be dropped and will not be emitted on the output Observable.\n *\n * Like {@link debounceTime}, this is a rate-limiting operator, and also a\n * delay-like operator since output emissions do not necessarily occur at the\n * same time as they did on the source Observable.\n *\n * ## Example\n * Emit the most recent click after a burst of clicks\n * ```javascript\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(debounce(() => interval(1000)));\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link audit}\n * @see {@link debounceTime}\n * @see {@link delayWhen}\n * @see {@link throttle}\n *\n * @param {function(value: T): SubscribableOrPromise} durationSelector A function\n * that receives a value from the source Observable, for computing the timeout\n * duration for each source value, returned as an Observable or a Promise.\n * @return {Observable} An Observable that delays the emissions of the source\n * Observable by the specified duration Observable returned by\n * `durationSelector`, and may drop some values if they occur too frequently.\n * @method debounce\n * @owner Observable\n */\nexport declare function debounce<T>(durationSelector: (value: T) => SubscribableOrPromise<any>): MonoTypeOperatorFunction<T>;\n"
  },
  {
    "path": "node_modules/rxjs/internal/operators/debounceTime.d.ts",
    "content": "import { MonoTypeOperatorFunction, SchedulerLike } from '../types';\n/**\n * Emits a value from the source Observable only after a particular time span\n * has passed without another source emission.\n *\n * <span class=\"informal\">It's like {@link delay}, but passes only the most\n * recent value from each burst of emissions.</span>\n *\n * ![](debounceTime.png)\n *\n * `debounceTime` delays values emitted by the source Observable, but drops\n * previous pending delayed emissions if a new value arrives on the source\n * Observable. This operator keeps track of the most recent value from the\n * source Observable, and emits that only when `dueTime` enough time has passed\n * without any other value appearing on the source Observable. If a new value\n * appears before `dueTime` silence occurs, the previous value will be dropped\n * and will not be emitted on the output Observable.\n *\n * This is a rate-limiting operator, because it is impossible for more than one\n * value to be emitted in any time window of duration `dueTime`, but it is also\n * a delay-like operator since output emissions do not occur at the same time as\n * they did on the source Observable. Optionally takes a {@link SchedulerLike} for\n * managing timers.\n *\n * ## Example\n * Emit the most recent click after a burst of clicks\n * ```javascript\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(debounceTime(1000));\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link auditTime}\n * @see {@link debounce}\n * @see {@link delay}\n * @see {@link sampleTime}\n * @see {@link throttleTime}\n *\n * @param {number} dueTime The timeout duration in milliseconds (or the time\n * unit determined internally by the optional `scheduler`) for the window of\n * time required to wait for emission silence before emitting the most recent\n * source value.\n * @param {SchedulerLike} [scheduler=async] The {@link SchedulerLike} to use for\n * managing the timers that handle the timeout for each value.\n * @return {Observable} An Observable that delays the emissions of the source\n * Observable by the specified `dueTime`, and may drop some values if they occur\n * too frequently.\n * @method debounceTime\n * @owner Observable\n */\nexport declare function debounceTime<T>(dueTime: number, scheduler?: SchedulerLike): MonoTypeOperatorFunction<T>;\n"
  },
  {
    "path": "node_modules/rxjs/internal/operators/defaultIfEmpty.d.ts",
    "content": "import { OperatorFunction, MonoTypeOperatorFunction } from '../types';\nexport declare function defaultIfEmpty<T>(defaultValue?: T): MonoTypeOperatorFunction<T>;\nexport declare function defaultIfEmpty<T, R>(defaultValue?: R): OperatorFunction<T, T | R>;\n"
  },
  {
    "path": "node_modules/rxjs/internal/operators/delay.d.ts",
    "content": "import { MonoTypeOperatorFunction, SchedulerLike } from '../types';\n/**\n * Delays the emission of items from the source Observable by a given timeout or\n * until a given Date.\n *\n * <span class=\"informal\">Time shifts each item by some specified amount of\n * milliseconds.</span>\n *\n * ![](delay.png)\n *\n * If the delay argument is a Number, this operator time shifts the source\n * Observable by that amount of time expressed in milliseconds. The relative\n * time intervals between the values are preserved.\n *\n * If the delay argument is a Date, this operator time shifts the start of the\n * Observable execution until the given date occurs.\n *\n * ## Examples\n * Delay each click by one second\n * ```javascript\n * const clicks = fromEvent(document, 'click');\n * const delayedClicks = clicks.pipe(delay(1000)); // each click emitted after 1 second\n * delayedClicks.subscribe(x => console.log(x));\n * ```\n *\n * Delay all clicks until a future date happens\n * ```javascript\n * const clicks = fromEvent(document, 'click');\n * const date = new Date('March 15, 2050 12:00:00'); // in the future\n * const delayedClicks = clicks.pipe(delay(date)); // click emitted only after that date\n * delayedClicks.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link debounceTime}\n * @see {@link delayWhen}\n *\n * @param {number|Date} delay The delay duration in milliseconds (a `number`) or\n * a `Date` until which the emission of the source items is delayed.\n * @param {SchedulerLike} [scheduler=async] The {@link SchedulerLike} to use for\n * managing the timers that handle the time-shift for each item.\n * @return {Observable} An Observable that delays the emissions of the source\n * Observable by the specified timeout or Date.\n * @method delay\n * @owner Observable\n */\nexport declare function delay<T>(delay: number | Date, scheduler?: SchedulerLike): MonoTypeOperatorFunction<T>;\n"
  },
  {
    "path": "node_modules/rxjs/internal/operators/delayWhen.d.ts",
    "content": "import { Observable } from '../Observable';\nimport { MonoTypeOperatorFunction } from '../types';\n/** @deprecated In future versions, empty notifiers will no longer re-emit the source value on the output observable. */\nexport declare function delayWhen<T>(delayDurationSelector: (value: T, index: number) => Observable<never>, subscriptionDelay?: Observable<any>): MonoTypeOperatorFunction<T>;\nexport declare function delayWhen<T>(delayDurationSelector: (value: T, index: number) => Observable<any>, subscriptionDelay?: Observable<any>): MonoTypeOperatorFunction<T>;\n"
  },
  {
    "path": "node_modules/rxjs/internal/operators/dematerialize.d.ts",
    "content": "import { Notification } from '../Notification';\nimport { OperatorFunction } from '../types';\n/**\n * Converts an Observable of {@link Notification} objects into the emissions\n * that they represent.\n *\n * <span class=\"informal\">Unwraps {@link Notification} objects as actual `next`,\n * `error` and `complete` emissions. The opposite of {@link materialize}.</span>\n *\n * ![](dematerialize.png)\n *\n * `dematerialize` is assumed to operate an Observable that only emits\n * {@link Notification} objects as `next` emissions, and does not emit any\n * `error`. Such Observable is the output of a `materialize` operation. Those\n * notifications are then unwrapped using the metadata they contain, and emitted\n * as `next`, `error`, and `complete` on the output Observable.\n *\n * Use this operator in conjunction with {@link materialize}.\n *\n * ## Example\n * Convert an Observable of Notifications to an actual Observable\n * ```javascript\n * const notifA = new Notification('N', 'A');\n * const notifB = new Notification('N', 'B');\n * const notifE = new Notification('E', undefined,\n *   new TypeError('x.toUpperCase is not a function')\n * );\n * const materialized = of(notifA, notifB, notifE);\n * const upperCase = materialized.pipe(dematerialize());\n * upperCase.subscribe(x => console.log(x), e => console.error(e));\n *\n * // Results in:\n * // A\n * // B\n * // TypeError: x.toUpperCase is not a function\n * ```\n *\n * @see {@link Notification}\n * @see {@link materialize}\n *\n * @return {Observable} An Observable that emits items and notifications\n * embedded in Notification objects emitted by the source Observable.\n * @method dematerialize\n * @owner Observable\n */\nexport declare function dematerialize<T>(): OperatorFunction<Notification<T>, T>;\n"
  },
  {
    "path": "node_modules/rxjs/internal/operators/distinct.d.ts",
    "content": "import { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { InnerSubscriber } from '../InnerSubscriber';\nimport { MonoTypeOperatorFunction } from '../types';\n/**\n * Returns an Observable that emits all items emitted by the source Observable that are distinct by comparison from previous items.\n *\n * If a keySelector function is provided, then it will project each value from the source observable into a new value that it will\n * check for equality with previously projected values. If a keySelector function is not provided, it will use each value from the\n * source observable directly with an equality check against previous values.\n *\n * In JavaScript runtimes that support `Set`, this operator will use a `Set` to improve performance of the distinct value checking.\n *\n * In other runtimes, this operator will use a minimal implementation of `Set` that relies on an `Array` and `indexOf` under the\n * hood, so performance will degrade as more values are checked for distinction. Even in newer browsers, a long-running `distinct`\n * use might result in memory leaks. To help alleviate this in some scenarios, an optional `flushes` parameter is also provided so\n * that the internal `Set` can be \"flushed\", basically clearing it of values.\n *\n * ## Examples\n * A simple example with numbers\n * ```javascript\n * of(1, 1, 2, 2, 2, 1, 2, 3, 4, 3, 2, 1).pipe(\n *     distinct(),\n *   )\n *   .subscribe(x => console.log(x)); // 1, 2, 3, 4\n * ```\n *\n * An example using a keySelector function\n * ```typescript\n * interface Person {\n *    age: number,\n *    name: string\n * }\n *\n * of<Person>(\n *     { age: 4, name: 'Foo'},\n *     { age: 7, name: 'Bar'},\n *     { age: 5, name: 'Foo'},\n *   ).pipe(\n *     distinct((p: Person) => p.name),\n *   )\n *   .subscribe(x => console.log(x));\n *\n * // displays:\n * // { age: 4, name: 'Foo' }\n * // { age: 7, name: 'Bar' }\n * ```\n * @see {@link distinctUntilChanged}\n * @see {@link distinctUntilKeyChanged}\n *\n * @param {function} [keySelector] Optional function to select which value you want to check as distinct.\n * @param {Observable} [flushes] Optional Observable for flushing the internal HashSet of the operator.\n * @return {Observable} An Observable that emits items from the source Observable with distinct values.\n * @method distinct\n * @owner Observable\n */\nexport declare function distinct<T, K>(keySelector?: (value: T) => K, flushes?: Observable<any>): MonoTypeOperatorFunction<T>;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport declare class DistinctSubscriber<T, K> extends OuterSubscriber<T, T> {\n    private keySelector;\n    private values;\n    constructor(destination: Subscriber<T>, keySelector: (value: T) => K, flushes: Observable<any>);\n    notifyNext(outerValue: T, innerValue: T, outerIndex: number, innerIndex: number, innerSub: InnerSubscriber<T, T>): void;\n    notifyError(error: any, innerSub: InnerSubscriber<T, T>): void;\n    protected _next(value: T): void;\n    private _useKeySelector;\n    private _finalizeNext;\n}\n"
  },
  {
    "path": "node_modules/rxjs/internal/operators/distinctUntilChanged.d.ts",
    "content": "import { MonoTypeOperatorFunction } from '../types';\nexport declare function distinctUntilChanged<T>(compare?: (x: T, y: T) => boolean): MonoTypeOperatorFunction<T>;\nexport declare function distinctUntilChanged<T, K>(compare: (x: K, y: K) => boolean, keySelector: (x: T) => K): MonoTypeOperatorFunction<T>;\n"
  },
  {
    "path": "node_modules/rxjs/internal/operators/distinctUntilKeyChanged.d.ts",
    "content": "import { MonoTypeOperatorFunction } from '../types';\nexport declare function distinctUntilKeyChanged<T>(key: keyof T): MonoTypeOperatorFunction<T>;\nexport declare function distinctUntilKeyChanged<T, K extends keyof T>(key: K, compare: (x: T[K], y: T[K]) => boolean): MonoTypeOperatorFunction<T>;\n"
  },
  {
    "path": "node_modules/rxjs/internal/operators/elementAt.d.ts",
    "content": "import { MonoTypeOperatorFunction } from '../types';\n/**\n * Emits the single value at the specified `index` in a sequence of emissions\n * from the source Observable.\n *\n * <span class=\"informal\">Emits only the i-th value, then completes.</span>\n *\n * ![](elementAt.png)\n *\n * `elementAt` returns an Observable that emits the item at the specified\n * `index` in the source Observable, or a default value if that `index` is out\n * of range and the `default` argument is provided. If the `default` argument is\n * not given and the `index` is out of range, the output Observable will emit an\n * `ArgumentOutOfRangeError` error.\n *\n * ## Example\n * Emit only the third click event\n * ```javascript\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(elementAt(2));\n * result.subscribe(x => console.log(x));\n *\n * // Results in:\n * // click 1 = nothing\n * // click 2 = nothing\n * // click 3 = MouseEvent object logged to console\n * ```\n *\n * @see {@link first}\n * @see {@link last}\n * @see {@link skip}\n * @see {@link single}\n * @see {@link take}\n *\n * @throws {ArgumentOutOfRangeError} When using `elementAt(i)`, it delivers an\n * ArgumentOutOrRangeError to the Observer's `error` callback if `i < 0` or the\n * Observable has completed before emitting the i-th `next` notification.\n *\n * @param {number} index Is the number `i` for the i-th source emission that has\n * happened since the subscription, starting from the number `0`.\n * @param {T} [defaultValue] The default value returned for missing indices.\n * @return {Observable} An Observable that emits a single item, if it is found.\n * Otherwise, will emit the default value if given. If not, then emits an error.\n * @method elementAt\n * @owner Observable\n */\nexport declare function elementAt<T>(index: number, defaultValue?: T): MonoTypeOperatorFunction<T>;\n"
  },
  {
    "path": "node_modules/rxjs/internal/operators/endWith.d.ts",
    "content": "import { MonoTypeOperatorFunction, SchedulerLike } from '../types';\nexport declare function endWith<T>(scheduler?: SchedulerLike): MonoTypeOperatorFunction<T>;\nexport declare function endWith<T>(v1: T, scheduler?: SchedulerLike): MonoTypeOperatorFunction<T>;\nexport declare function endWith<T>(v1: T, v2: T, scheduler?: SchedulerLike): MonoTypeOperatorFunction<T>;\nexport declare function endWith<T>(v1: T, v2: T, v3: T, scheduler?: SchedulerLike): MonoTypeOperatorFunction<T>;\nexport declare function endWith<T>(v1: T, v2: T, v3: T, v4: T, scheduler?: SchedulerLike): MonoTypeOperatorFunction<T>;\nexport declare function endWith<T>(v1: T, v2: T, v3: T, v4: T, v5: T, scheduler?: SchedulerLike): MonoTypeOperatorFunction<T>;\nexport declare function endWith<T>(v1: T, v2: T, v3: T, v4: T, v5: T, v6: T, scheduler?: SchedulerLike): MonoTypeOperatorFunction<T>;\nexport declare function endWith<T>(...array: Array<T | SchedulerLike>): MonoTypeOperatorFunction<T>;\n"
  },
  {
    "path": "node_modules/rxjs/internal/operators/every.d.ts",
    "content": "import { Observable } from '../Observable';\nimport { OperatorFunction } from '../types';\n/**\n * Returns an Observable that emits whether or not every item of the source satisfies the condition specified.\n *\n * ## Example\n * A simple example emitting true if all elements are less than 5, false otherwise\n * ```javascript\n *  of(1, 2, 3, 4, 5, 6).pipe(\n *     every(x => x < 5),\n * )\n * .subscribe(x => console.log(x)); // -> false\n * ```\n *\n * @param {function} predicate A function for determining if an item meets a specified condition.\n * @param {any} [thisArg] Optional object to use for `this` in the callback.\n * @return {Observable} An Observable of booleans that determines if all items of the source Observable meet the condition specified.\n * @method every\n * @owner Observable\n */\nexport declare function every<T>(predicate: (value: T, index: number, source: Observable<T>) => boolean, thisArg?: any): OperatorFunction<T, boolean>;\n"
  },
  {
    "path": "node_modules/rxjs/internal/operators/exhaust.d.ts",
    "content": "import { ObservableInput, OperatorFunction } from '../types';\nexport declare function exhaust<T>(): OperatorFunction<ObservableInput<T>, T>;\nexport declare function exhaust<R>(): OperatorFunction<any, R>;\n"
  },
  {
    "path": "node_modules/rxjs/internal/operators/exhaustMap.d.ts",
    "content": "import { ObservableInput, OperatorFunction } from '../types';\nexport declare function exhaustMap<T, R>(project: (value: T, index: number) => ObservableInput<R>): OperatorFunction<T, R>;\n/** @deprecated resultSelector is no longer supported. Use inner map instead. */\nexport declare function exhaustMap<T, R>(project: (value: T, index: number) => ObservableInput<R>, resultSelector: undefined): OperatorFunction<T, R>;\n/** @deprecated resultSelector is no longer supported. Use inner map instead. */\nexport declare function exhaustMap<T, I, R>(project: (value: T, index: number) => ObservableInput<I>, resultSelector: (outerValue: T, innerValue: I, outerIndex: number, innerIndex: number) => R): OperatorFunction<T, R>;\n"
  },
  {
    "path": "node_modules/rxjs/internal/operators/expand.d.ts",
    "content": "import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Subscription } from '../Subscription';\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { InnerSubscriber } from '../InnerSubscriber';\nimport { MonoTypeOperatorFunction, OperatorFunction, ObservableInput, SchedulerLike } from '../types';\nexport declare function expand<T, R>(project: (value: T, index: number) => ObservableInput<R>, concurrent?: number, scheduler?: SchedulerLike): OperatorFunction<T, R>;\nexport declare function expand<T>(project: (value: T, index: number) => ObservableInput<T>, concurrent?: number, scheduler?: SchedulerLike): MonoTypeOperatorFunction<T>;\nexport declare class ExpandOperator<T, R> implements Operator<T, R> {\n    private project;\n    private concurrent;\n    private scheduler;\n    constructor(project: (value: T, index: number) => ObservableInput<R>, concurrent: number, scheduler: SchedulerLike);\n    call(subscriber: Subscriber<R>, source: any): any;\n}\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport declare class ExpandSubscriber<T, R> extends OuterSubscriber<T, R> {\n    private project;\n    private concurrent;\n    private scheduler;\n    private index;\n    private active;\n    private hasCompleted;\n    private buffer;\n    constructor(destination: Subscriber<R>, project: (value: T, index: number) => ObservableInput<R>, concurrent: number, scheduler: SchedulerLike);\n    private static dispatch;\n    protected _next(value: any): void;\n    private subscribeToProjection;\n    protected _complete(): void;\n    notifyNext(outerValue: T, innerValue: R, outerIndex: number, innerIndex: number, innerSub: InnerSubscriber<T, R>): void;\n    notifyComplete(innerSub: Subscription): void;\n}\n"
  },
  {
    "path": "node_modules/rxjs/internal/operators/filter.d.ts",
    "content": "import { OperatorFunction, MonoTypeOperatorFunction } from '../types';\nexport declare function filter<T, S extends T>(predicate: (value: T, index: number) => value is S, thisArg?: any): OperatorFunction<T, S>;\nexport declare function filter<T>(predicate: (value: T, index: number) => boolean, thisArg?: any): MonoTypeOperatorFunction<T>;\n"
  },
  {
    "path": "node_modules/rxjs/internal/operators/finalize.d.ts",
    "content": "import { MonoTypeOperatorFunction } from '../types';\n/**\n * Returns an Observable that mirrors the source Observable, but will call a specified function when\n * the source terminates on complete or error.\n * @param {function} callback Function to be called when source terminates.\n * @return {Observable} An Observable that mirrors the source, but will call the specified function on termination.\n * @method finally\n * @owner Observable\n */\nexport declare function finalize<T>(callback: () => void): MonoTypeOperatorFunction<T>;\n"
  },
  {
    "path": "node_modules/rxjs/internal/operators/find.d.ts",
    "content": "import { Observable } from '../Observable';\nimport { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { OperatorFunction } from '../types';\nexport declare function find<T, S extends T>(predicate: (value: T, index: number, source: Observable<T>) => value is S, thisArg?: any): OperatorFunction<T, S | undefined>;\nexport declare function find<T>(predicate: (value: T, index: number, source: Observable<T>) => boolean, thisArg?: any): OperatorFunction<T, T | undefined>;\nexport declare class FindValueOperator<T> implements Operator<T, T | number | undefined> {\n    private predicate;\n    private source;\n    private yieldIndex;\n    private thisArg?;\n    constructor(predicate: (value: T, index: number, source: Observable<T>) => boolean, source: Observable<T>, yieldIndex: boolean, thisArg?: any);\n    call(observer: Subscriber<T>, source: any): any;\n}\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport declare class FindValueSubscriber<T> extends Subscriber<T> {\n    private predicate;\n    private source;\n    private yieldIndex;\n    private thisArg?;\n    private index;\n    constructor(destination: Subscriber<T>, predicate: (value: T, index: number, source: Observable<T>) => boolean, source: Observable<T>, yieldIndex: boolean, thisArg?: any);\n    private notifyComplete;\n    protected _next(value: T): void;\n    protected _complete(): void;\n}\n"
  },
  {
    "path": "node_modules/rxjs/internal/operators/findIndex.d.ts",
    "content": "import { Observable } from '../Observable';\nimport { OperatorFunction } from '../types';\n/**\n * Emits only the index of the first value emitted by the source Observable that\n * meets some condition.\n *\n * <span class=\"informal\">It's like {@link find}, but emits the index of the\n * found value, not the value itself.</span>\n *\n * ![](findIndex.png)\n *\n * `findIndex` searches for the first item in the source Observable that matches\n * the specified condition embodied by the `predicate`, and returns the\n * (zero-based) index of the first occurrence in the source. Unlike\n * {@link first}, the `predicate` is required in `findIndex`, and does not emit\n * an error if a valid value is not found.\n *\n * ## Example\n * Emit the index of first click that happens on a DIV element\n * ```javascript\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(findIndex(ev => ev.target.tagName === 'DIV'));\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link filter}\n * @see {@link find}\n * @see {@link first}\n * @see {@link take}\n *\n * @param {function(value: T, index: number, source: Observable<T>): boolean} predicate\n * A function called with each item to test for condition matching.\n * @param {any} [thisArg] An optional argument to determine the value of `this`\n * in the `predicate` function.\n * @return {Observable} An Observable of the index of the first item that\n * matches the condition.\n * @method find\n * @owner Observable\n */\nexport declare function findIndex<T>(predicate: (value: T, index: number, source: Observable<T>) => boolean, thisArg?: any): OperatorFunction<T, number>;\n"
  },
  {
    "path": "node_modules/rxjs/internal/operators/first.d.ts",
    "content": "import { Observable } from '../Observable';\nimport { OperatorFunction } from '../../internal/types';\nexport declare function first<T, D = T>(predicate?: null, defaultValue?: D): OperatorFunction<T, T | D>;\nexport declare function first<T, S extends T>(predicate: (value: T, index: number, source: Observable<T>) => value is S, defaultValue?: S): OperatorFunction<T, S>;\nexport declare function first<T, D = T>(predicate: (value: T, index: number, source: Observable<T>) => boolean, defaultValue?: D): OperatorFunction<T, T | D>;\n"
  },
  {
    "path": "node_modules/rxjs/internal/operators/groupBy.d.ts",
    "content": "import { Subscriber } from '../Subscriber';\nimport { Subscription } from '../Subscription';\nimport { Observable } from '../Observable';\nimport { Subject } from '../Subject';\nimport { OperatorFunction } from '../types';\nexport declare function groupBy<T, K>(keySelector: (value: T) => K): OperatorFunction<T, GroupedObservable<K, T>>;\nexport declare function groupBy<T, K>(keySelector: (value: T) => K, elementSelector: void, durationSelector: (grouped: GroupedObservable<K, T>) => Observable<any>): OperatorFunction<T, GroupedObservable<K, T>>;\nexport declare function groupBy<T, K, R>(keySelector: (value: T) => K, elementSelector?: (value: T) => R, durationSelector?: (grouped: GroupedObservable<K, R>) => Observable<any>): OperatorFunction<T, GroupedObservable<K, R>>;\nexport declare function groupBy<T, K, R>(keySelector: (value: T) => K, elementSelector?: (value: T) => R, durationSelector?: (grouped: GroupedObservable<K, R>) => Observable<any>, subjectSelector?: () => Subject<R>): OperatorFunction<T, GroupedObservable<K, R>>;\nexport interface RefCountSubscription {\n    count: number;\n    unsubscribe: () => void;\n    closed: boolean;\n    attemptedToUnsubscribe: boolean;\n}\n/**\n * An Observable representing values belonging to the same group represented by\n * a common key. The values emitted by a GroupedObservable come from the source\n * Observable. The common key is available as the field `key` on a\n * GroupedObservable instance.\n *\n * @class GroupedObservable<K, T>\n */\nexport declare class GroupedObservable<K, T> extends Observable<T> {\n    key: K;\n    private groupSubject;\n    private refCountSubscription?;\n    /** @deprecated Do not construct this type. Internal use only */\n    constructor(key: K, groupSubject: Subject<T>, refCountSubscription?: RefCountSubscription);\n    /** @deprecated This is an internal implementation detail, do not use. */\n    _subscribe(subscriber: Subscriber<T>): Subscription;\n}\n"
  },
  {
    "path": "node_modules/rxjs/internal/operators/ignoreElements.d.ts",
    "content": "import { OperatorFunction } from '../types';\n/**\n * Ignores all items emitted by the source Observable and only passes calls of `complete` or `error`.\n *\n * ![](ignoreElements.png)\n *\n * ## Examples\n * ### Ignores emitted values, reacts to observable's completion.\n * ```javascript\n * of('you', 'talking', 'to', 'me').pipe(\n *   ignoreElements(),\n * )\n * .subscribe(\n *   word => console.log(word),\n *   err => console.log('error:', err),\n *   () => console.log('the end'),\n * );\n * // result:\n * // 'the end'\n * ```\n * @return {Observable} An empty Observable that only calls `complete`\n * or `error`, based on which one is called by the source Observable.\n * @method ignoreElements\n * @owner Observable\n */\nexport declare function ignoreElements(): OperatorFunction<any, never>;\n"
  },
  {
    "path": "node_modules/rxjs/internal/operators/index.d.ts",
    "content": "export { audit } from './audit';\nexport { auditTime } from './auditTime';\nexport { buffer } from './buffer';\nexport { bufferCount } from './bufferCount';\nexport { bufferTime } from './bufferTime';\nexport { bufferToggle } from './bufferToggle';\nexport { bufferWhen } from './bufferWhen';\nexport { catchError } from './catchError';\nexport { combineAll } from './combineAll';\nexport { combineLatest } from './combineLatest';\nexport { concat } from './concat';\nexport { concatAll } from './concatAll';\nexport { concatMap } from './concatMap';\nexport { concatMapTo } from './concatMapTo';\nexport { count } from './count';\nexport { debounce } from './debounce';\nexport { debounceTime } from './debounceTime';\nexport { defaultIfEmpty } from './defaultIfEmpty';\nexport { delay } from './delay';\nexport { delayWhen } from './delayWhen';\nexport { dematerialize } from './dematerialize';\nexport { distinct } from './distinct';\nexport { distinctUntilChanged } from './distinctUntilChanged';\nexport { distinctUntilKeyChanged } from './distinctUntilKeyChanged';\nexport { elementAt } from './elementAt';\nexport { every } from './every';\nexport { exhaust } from './exhaust';\nexport { exhaustMap } from './exhaustMap';\nexport { expand } from './expand';\nexport { filter } from './filter';\nexport { finalize } from './finalize';\nexport { find } from './find';\nexport { findIndex } from './findIndex';\nexport { first } from './first';\nexport { groupBy } from './groupBy';\nexport { ignoreElements } from './ignoreElements';\nexport { isEmpty } from './isEmpty';\nexport { last } from './last';\nexport { map } from './map';\nexport { mapTo } from './mapTo';\nexport { materialize } from './materialize';\nexport { max } from './max';\nexport { merge } from './merge';\nexport { mergeAll } from './mergeAll';\nexport { mergeMap } from './mergeMap';\nexport { mergeMap as flatMap } from './mergeMap';\nexport { mergeMapTo } from './mergeMapTo';\nexport { mergeScan } from './mergeScan';\nexport { min } from './min';\nexport { multicast } from './multicast';\nexport { observeOn } from './observeOn';\nexport { onErrorResumeNext } from './onErrorResumeNext';\nexport { pairwise } from './pairwise';\nexport { partition } from './partition';\nexport { pluck } from './pluck';\nexport { publish } from './publish';\nexport { publishBehavior } from './publishBehavior';\nexport { publishLast } from './publishLast';\nexport { publishReplay } from './publishReplay';\nexport { race } from './race';\nexport { reduce } from './reduce';\nexport { repeat } from './repeat';\nexport { repeatWhen } from './repeatWhen';\nexport { retry } from './retry';\nexport { retryWhen } from './retryWhen';\nexport { refCount } from './refCount';\nexport { sample } from './sample';\nexport { sampleTime } from './sampleTime';\nexport { scan } from './scan';\nexport { sequenceEqual } from './sequenceEqual';\nexport { share } from './share';\nexport { shareReplay } from './shareReplay';\nexport { single } from './single';\nexport { skip } from './skip';\nexport { skipLast } from './skipLast';\nexport { skipUntil } from './skipUntil';\nexport { skipWhile } from './skipWhile';\nexport { startWith } from './startWith';\nexport { subscribeOn } from './subscribeOn';\nexport { switchAll } from './switchAll';\nexport { switchMap } from './switchMap';\nexport { switchMapTo } from './switchMapTo';\nexport { take } from './take';\nexport { takeLast } from './takeLast';\nexport { takeUntil } from './takeUntil';\nexport { takeWhile } from './takeWhile';\nexport { tap } from './tap';\nexport { throttle } from './throttle';\nexport { throttleTime } from './throttleTime';\nexport { timeInterval } from './timeInterval';\nexport { timeout } from './timeout';\nexport { timeoutWith } from './timeoutWith';\nexport { timestamp } from './timestamp';\nexport { toArray } from './toArray';\nexport { window } from './window';\nexport { windowCount } from './windowCount';\nexport { windowTime } from './windowTime';\nexport { windowToggle } from './windowToggle';\nexport { windowWhen } from './windowWhen';\nexport { withLatestFrom } from './withLatestFrom';\nexport { zip } from './zip';\nexport { zipAll } from './zipAll';\n"
  },
  {
    "path": "node_modules/rxjs/internal/operators/isEmpty.d.ts",
    "content": "import { OperatorFunction } from '../types';\nexport declare function isEmpty<T>(): OperatorFunction<T, boolean>;\n"
  },
  {
    "path": "node_modules/rxjs/internal/operators/last.d.ts",
    "content": "import { Observable } from '../Observable';\nimport { OperatorFunction } from '../../internal/types';\nexport declare function last<T, D = T>(predicate?: null, defaultValue?: D): OperatorFunction<T, T | D>;\nexport declare function last<T, S extends T>(predicate: (value: T, index: number, source: Observable<T>) => value is S, defaultValue?: S): OperatorFunction<T, S>;\nexport declare function last<T, D = T>(predicate: (value: T, index: number, source: Observable<T>) => boolean, defaultValue?: D): OperatorFunction<T, T | D>;\n"
  },
  {
    "path": "node_modules/rxjs/internal/operators/map.d.ts",
    "content": "import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { OperatorFunction } from '../types';\n/**\n * Applies a given `project` function to each value emitted by the source\n * Observable, and emits the resulting values as an Observable.\n *\n * <span class=\"informal\">Like [Array.prototype.map()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map),\n * it passes each source value through a transformation function to get\n * corresponding output values.</span>\n *\n * ![](map.png)\n *\n * Similar to the well known `Array.prototype.map` function, this operator\n * applies a projection to each value and emits that projection in the output\n * Observable.\n *\n * ## Example\n * Map every click to the clientX position of that click\n * ```javascript\n * const clicks = fromEvent(document, 'click');\n * const positions = clicks.pipe(map(ev => ev.clientX));\n * positions.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link mapTo}\n * @see {@link pluck}\n *\n * @param {function(value: T, index: number): R} project The function to apply\n * to each `value` emitted by the source Observable. The `index` parameter is\n * the number `i` for the i-th emission that has happened since the\n * subscription, starting from the number `0`.\n * @param {any} [thisArg] An optional argument to define what `this` is in the\n * `project` function.\n * @return {Observable<R>} An Observable that emits the values from the source\n * Observable transformed by the given `project` function.\n * @method map\n * @owner Observable\n */\nexport declare function map<T, R>(project: (value: T, index: number) => R, thisArg?: any): OperatorFunction<T, R>;\nexport declare class MapOperator<T, R> implements Operator<T, R> {\n    private project;\n    private thisArg;\n    constructor(project: (value: T, index: number) => R, thisArg: any);\n    call(subscriber: Subscriber<R>, source: any): any;\n}\n"
  },
  {
    "path": "node_modules/rxjs/internal/operators/mapTo.d.ts",
    "content": "import { OperatorFunction } from '../types';\n/**\n * Emits the given constant value on the output Observable every time the source\n * Observable emits a value.\n *\n * <span class=\"informal\">Like {@link map}, but it maps every source value to\n * the same output value every time.</span>\n *\n * ![](mapTo.png)\n *\n * Takes a constant `value` as argument, and emits that whenever the source\n * Observable emits a value. In other words, ignores the actual source value,\n * and simply uses the emission moment to know when to emit the given `value`.\n *\n * ## Example\n * Map every click to the string 'Hi'\n * ```javascript\n * const clicks = fromEvent(document, 'click');\n * const greetings = clicks.pipe(mapTo('Hi'));\n * greetings.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link map}\n *\n * @param {any} value The value to map each source value to.\n * @return {Observable} An Observable that emits the given `value` every time\n * the source Observable emits something.\n * @method mapTo\n * @owner Observable\n */\nexport declare function mapTo<T, R>(value: R): OperatorFunction<T, R>;\n"
  },
  {
    "path": "node_modules/rxjs/internal/operators/materialize.d.ts",
    "content": "import { Notification } from '../Notification';\nimport { OperatorFunction } from '../types';\n/**\n * Represents all of the notifications from the source Observable as `next`\n * emissions marked with their original types within {@link Notification}\n * objects.\n *\n * <span class=\"informal\">Wraps `next`, `error` and `complete` emissions in\n * {@link Notification} objects, emitted as `next` on the output Observable.\n * </span>\n *\n * ![](materialize.png)\n *\n * `materialize` returns an Observable that emits a `next` notification for each\n * `next`, `error`, or `complete` emission of the source Observable. When the\n * source Observable emits `complete`, the output Observable will emit `next` as\n * a Notification of type \"complete\", and then it will emit `complete` as well.\n * When the source Observable emits `error`, the output will emit `next` as a\n * Notification of type \"error\", and then `complete`.\n *\n * This operator is useful for producing metadata of the source Observable, to\n * be consumed as `next` emissions. Use it in conjunction with\n * {@link dematerialize}.\n *\n * ## Example\n * Convert a faulty Observable to an Observable of Notifications\n * ```javascript\n * const letters = of('a', 'b', 13, 'd');\n * const upperCase = letters.pipe(map(x => x.toUpperCase()));\n * const materialized = upperCase.pipe(materialize());\n * materialized.subscribe(x => console.log(x));\n *\n * // Results in the following:\n * // - Notification {kind: \"N\", value: \"A\", error: undefined, hasValue: true}\n * // - Notification {kind: \"N\", value: \"B\", error: undefined, hasValue: true}\n * // - Notification {kind: \"E\", value: undefined, error: TypeError:\n * //   x.toUpperCase is not a function at MapSubscriber.letters.map.x\n * //   [as project] (http://1…, hasValue: false}\n * ```\n *\n * @see {@link Notification}\n * @see {@link dematerialize}\n *\n * @return {Observable<Notification<T>>} An Observable that emits\n * {@link Notification} objects that wrap the original emissions from the source\n * Observable with metadata.\n * @method materialize\n * @owner Observable\n */\nexport declare function materialize<T>(): OperatorFunction<T, Notification<T>>;\n"
  },
  {
    "path": "node_modules/rxjs/internal/operators/max.d.ts",
    "content": "import { MonoTypeOperatorFunction } from '../types';\n/**\n * The Max operator operates on an Observable that emits numbers (or items that can be compared with a provided function),\n * and when source Observable completes it emits a single item: the item with the largest value.\n *\n * ![](max.png)\n *\n * ## Examples\n * Get the maximal value of a series of numbers\n * ```javascript\n * of(5, 4, 7, 2, 8).pipe(\n *   max(),\n * )\n * .subscribe(x => console.log(x)); // -> 8\n * ```\n *\n * Use a comparer function to get the maximal item\n * ```typescript\n * interface Person {\n *   age: number,\n *   name: string\n * }\n * of<Person>(\n *   {age: 7, name: 'Foo'},\n *   {age: 5, name: 'Bar'},\n *   {age: 9, name: 'Beer'},\n * ).pipe(\n *   max<Person>((a: Person, b: Person) => a.age < b.age ? -1 : 1),\n * )\n * .subscribe((x: Person) => console.log(x.name)); // -> 'Beer'\n * ```\n *\n * @see {@link min}\n *\n * @param {Function} [comparer] - Optional comparer function that it will use instead of its default to compare the\n * value of two items.\n * @return {Observable} An Observable that emits item with the largest value.\n * @method max\n * @owner Observable\n */\nexport declare function max<T>(comparer?: (x: T, y: T) => number): MonoTypeOperatorFunction<T>;\n"
  },
  {
    "path": "node_modules/rxjs/internal/operators/merge.d.ts",
    "content": "import { ObservableInput, OperatorFunction, MonoTypeOperatorFunction, SchedulerLike } from '../types';\n/** @deprecated Deprecated in favor of static merge. */\nexport declare function merge<T>(scheduler?: SchedulerLike): MonoTypeOperatorFunction<T>;\n/** @deprecated Deprecated in favor of static merge. */\nexport declare function merge<T>(concurrent?: number, scheduler?: SchedulerLike): MonoTypeOperatorFunction<T>;\n/** @deprecated Deprecated in favor of static merge. */\nexport declare function merge<T, T2>(v2: ObservableInput<T2>, scheduler?: SchedulerLike): OperatorFunction<T, T | T2>;\n/** @deprecated Deprecated in favor of static merge. */\nexport declare function merge<T, T2>(v2: ObservableInput<T2>, concurrent?: number, scheduler?: SchedulerLike): OperatorFunction<T, T | T2>;\n/** @deprecated Deprecated in favor of static merge. */\nexport declare function merge<T, T2, T3>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, scheduler?: SchedulerLike): OperatorFunction<T, T | T2 | T3>;\n/** @deprecated Deprecated in favor of static merge. */\nexport declare function merge<T, T2, T3>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, concurrent?: number, scheduler?: SchedulerLike): OperatorFunction<T, T | T2 | T3>;\n/** @deprecated Deprecated in favor of static merge. */\nexport declare function merge<T, T2, T3, T4>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, scheduler?: SchedulerLike): OperatorFunction<T, T | T2 | T3 | T4>;\n/** @deprecated Deprecated in favor of static merge. */\nexport declare function merge<T, T2, T3, T4>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, concurrent?: number, scheduler?: SchedulerLike): OperatorFunction<T, T | T2 | T3 | T4>;\n/** @deprecated Deprecated in favor of static merge. */\nexport declare function merge<T, T2, T3, T4, T5>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, scheduler?: SchedulerLike): OperatorFunction<T, T | T2 | T3 | T4 | T5>;\n/** @deprecated Deprecated in favor of static merge. */\nexport declare function merge<T, T2, T3, T4, T5>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, concurrent?: number, scheduler?: SchedulerLike): OperatorFunction<T, T | T2 | T3 | T4 | T5>;\n/** @deprecated Deprecated in favor of static merge. */\nexport declare function merge<T, T2, T3, T4, T5, T6>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>, scheduler?: SchedulerLike): OperatorFunction<T, T | T2 | T3 | T4 | T5 | T6>;\n/** @deprecated Deprecated in favor of static merge. */\nexport declare function merge<T, T2, T3, T4, T5, T6>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>, concurrent?: number, scheduler?: SchedulerLike): OperatorFunction<T, T | T2 | T3 | T4 | T5 | T6>;\n/** @deprecated Deprecated in favor of static merge. */\nexport declare function merge<T>(...observables: Array<ObservableInput<T> | SchedulerLike | number>): MonoTypeOperatorFunction<T>;\n/** @deprecated Deprecated in favor of static merge. */\nexport declare function merge<T, R>(...observables: Array<ObservableInput<any> | SchedulerLike | number>): OperatorFunction<T, R>;\n"
  },
  {
    "path": "node_modules/rxjs/internal/operators/mergeAll.d.ts",
    "content": "import { OperatorFunction, ObservableInput } from '../types';\nexport declare function mergeAll<T>(concurrent?: number): OperatorFunction<ObservableInput<T>, T>;\n"
  },
  {
    "path": "node_modules/rxjs/internal/operators/mergeMap.d.ts",
    "content": "import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Subscription } from '../Subscription';\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { InnerSubscriber } from '../InnerSubscriber';\nimport { ObservableInput, OperatorFunction } from '../types';\nexport declare function mergeMap<T, R>(project: (value: T, index: number) => ObservableInput<R>, concurrent?: number): OperatorFunction<T, R>;\n/** @deprecated resultSelector no longer supported, use inner map instead */\nexport declare function mergeMap<T, R>(project: (value: T, index: number) => ObservableInput<R>, resultSelector: undefined, concurrent?: number): OperatorFunction<T, R>;\n/** @deprecated resultSelector no longer supported, use inner map instead */\nexport declare function mergeMap<T, I, R>(project: (value: T, index: number) => ObservableInput<I>, resultSelector: (outerValue: T, innerValue: I, outerIndex: number, innerIndex: number) => R, concurrent?: number): OperatorFunction<T, R>;\nexport declare class MergeMapOperator<T, R> implements Operator<T, R> {\n    private project;\n    private concurrent;\n    constructor(project: (value: T, index: number) => ObservableInput<R>, concurrent?: number);\n    call(observer: Subscriber<R>, source: any): any;\n}\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport declare class MergeMapSubscriber<T, R> extends OuterSubscriber<T, R> {\n    private project;\n    private concurrent;\n    private hasCompleted;\n    private buffer;\n    private active;\n    protected index: number;\n    constructor(destination: Subscriber<R>, project: (value: T, index: number) => ObservableInput<R>, concurrent?: number);\n    protected _next(value: T): void;\n    protected _tryNext(value: T): void;\n    private _innerSub;\n    protected _complete(): void;\n    notifyNext(outerValue: T, innerValue: R, outerIndex: number, innerIndex: number, innerSub: InnerSubscriber<T, R>): void;\n    notifyComplete(innerSub: Subscription): void;\n}\n"
  },
  {
    "path": "node_modules/rxjs/internal/operators/mergeMapTo.d.ts",
    "content": "import { OperatorFunction } from '../../internal/types';\nimport { ObservableInput } from '../types';\nexport declare function mergeMapTo<T>(innerObservable: ObservableInput<T>, concurrent?: number): OperatorFunction<any, T>;\n/** @deprecated */\nexport declare function mergeMapTo<T, I, R>(innerObservable: ObservableInput<I>, resultSelector: (outerValue: T, innerValue: I, outerIndex: number, innerIndex: number) => R, concurrent?: number): OperatorFunction<T, R>;\n"
  },
  {
    "path": "node_modules/rxjs/internal/operators/mergeScan.d.ts",
    "content": "import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Subscription } from '../Subscription';\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { InnerSubscriber } from '../InnerSubscriber';\nimport { ObservableInput, OperatorFunction } from '../types';\n/**\n * Applies an accumulator function over the source Observable where the\n * accumulator function itself returns an Observable, then each intermediate\n * Observable returned is merged into the output Observable.\n *\n * <span class=\"informal\">It's like {@link scan}, but the Observables returned\n * by the accumulator are merged into the outer Observable.</span>\n *\n * ## Example\n * Count the number of click events\n * ```javascript\n * const click$ = fromEvent(document, 'click');\n * const one$ = click$.pipe(mapTo(1));\n * const seed = 0;\n * const count$ = one$.pipe(\n *   mergeScan((acc, one) => of(acc + one), seed),\n * );\n * count$.subscribe(x => console.log(x));\n *\n * // Results:\n * 1\n * 2\n * 3\n * 4\n * // ...and so on for each click\n * ```\n *\n * @param {function(acc: R, value: T): Observable<R>} accumulator\n * The accumulator function called on each source value.\n * @param seed The initial accumulation value.\n * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of\n * input Observables being subscribed to concurrently.\n * @return {Observable<R>} An observable of the accumulated values.\n * @method mergeScan\n * @owner Observable\n */\nexport declare function mergeScan<T, R>(accumulator: (acc: R, value: T) => ObservableInput<R>, seed: R, concurrent?: number): OperatorFunction<T, R>;\nexport declare class MergeScanOperator<T, R> implements Operator<T, R> {\n    private accumulator;\n    private seed;\n    private concurrent;\n    constructor(accumulator: (acc: R, value: T) => ObservableInput<R>, seed: R, concurrent: number);\n    call(subscriber: Subscriber<R>, source: any): any;\n}\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport declare class MergeScanSubscriber<T, R> extends OuterSubscriber<T, R> {\n    private accumulator;\n    private acc;\n    private concurrent;\n    private hasValue;\n    private hasCompleted;\n    private buffer;\n    private active;\n    protected index: number;\n    constructor(destination: Subscriber<R>, accumulator: (acc: R, value: T) => ObservableInput<R>, acc: R, concurrent: number);\n    protected _next(value: any): void;\n    private _innerSub;\n    protected _complete(): void;\n    notifyNext(outerValue: T, innerValue: R, outerIndex: number, innerIndex: number, innerSub: InnerSubscriber<T, R>): void;\n    notifyComplete(innerSub: Subscription): void;\n}\n"
  },
  {
    "path": "node_modules/rxjs/internal/operators/min.d.ts",
    "content": "import { MonoTypeOperatorFunction } from '../types';\n/**\n * The Min operator operates on an Observable that emits numbers (or items that can be compared with a provided function),\n * and when source Observable completes it emits a single item: the item with the smallest value.\n *\n * ![](min.png)\n *\n * ## Examples\n * Get the minimal value of a series of numbers\n * ```javascript\n * of(5, 4, 7, 2, 8).pipe(\n *   min(),\n * )\n * .subscribe(x => console.log(x)); // -> 2\n * ```\n *\n * Use a comparer function to get the minimal item\n * ```typescript\n * interface Person {\n *   age: number,\n *   name: string\n * }\n * of<Person>(\n *   {age: 7, name: 'Foo'},\n *   {age: 5, name: 'Bar'},\n *   {age: 9, name: 'Beer'},\n * ).pipe(\n *   min<Person>( (a: Person, b: Person) => a.age < b.age ? -1 : 1),\n * )\n * .subscribe((x: Person) => console.log(x.name)); // -> 'Bar'\n * ```\n * @see {@link max}\n *\n * @param {Function} [comparer] - Optional comparer function that it will use instead of its default to compare the\n * value of two items.\n * @return {Observable<R>} An Observable that emits item with the smallest value.\n * @method min\n * @owner Observable\n */\nexport declare function min<T>(comparer?: (x: T, y: T) => number): MonoTypeOperatorFunction<T>;\n"
  },
  {
    "path": "node_modules/rxjs/internal/operators/multicast.d.ts",
    "content": "import { Subject } from '../Subject';\nimport { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Observable } from '../Observable';\nimport { ConnectableObservable } from '../observable/ConnectableObservable';\nimport { FactoryOrValue, MonoTypeOperatorFunction, OperatorFunction, UnaryFunction } from '../types';\nexport declare function multicast<T>(subjectOrSubjectFactory: FactoryOrValue<Subject<T>>): UnaryFunction<Observable<T>, ConnectableObservable<T>>;\nexport declare function multicast<T>(SubjectFactory: (this: Observable<T>) => Subject<T>): UnaryFunction<Observable<T>, ConnectableObservable<T>>;\nexport declare function multicast<T>(SubjectFactory: (this: Observable<T>) => Subject<T>, selector?: MonoTypeOperatorFunction<T>): MonoTypeOperatorFunction<T>;\nexport declare function multicast<T, R>(SubjectFactory: (this: Observable<T>) => Subject<T>): UnaryFunction<Observable<T>, ConnectableObservable<R>>;\nexport declare function multicast<T, R>(SubjectFactory: (this: Observable<T>) => Subject<T>, selector?: OperatorFunction<T, R>): OperatorFunction<T, R>;\nexport declare class MulticastOperator<T, R> implements Operator<T, R> {\n    private subjectFactory;\n    private selector;\n    constructor(subjectFactory: () => Subject<T>, selector: (source: Observable<T>) => Observable<R>);\n    call(subscriber: Subscriber<R>, source: any): any;\n}\n"
  },
  {
    "path": "node_modules/rxjs/internal/operators/observeOn.d.ts",
    "content": "import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Notification } from '../Notification';\nimport { MonoTypeOperatorFunction, PartialObserver, SchedulerAction, SchedulerLike, TeardownLogic } from '../types';\n/**\n *\n * Re-emits all notifications from source Observable with specified scheduler.\n *\n * <span class=\"informal\">Ensure a specific scheduler is used, from outside of an Observable.</span>\n *\n * `observeOn` is an operator that accepts a scheduler as a first parameter, which will be used to reschedule\n * notifications emitted by the source Observable. It might be useful, if you do not have control over\n * internal scheduler of a given Observable, but want to control when its values are emitted nevertheless.\n *\n * Returned Observable emits the same notifications (nexted values, complete and error events) as the source Observable,\n * but rescheduled with provided scheduler. Note that this doesn't mean that source Observables internal\n * scheduler will be replaced in any way. Original scheduler still will be used, but when the source Observable emits\n * notification, it will be immediately scheduled again - this time with scheduler passed to `observeOn`.\n * An anti-pattern would be calling `observeOn` on Observable that emits lots of values synchronously, to split\n * that emissions into asynchronous chunks. For this to happen, scheduler would have to be passed into the source\n * Observable directly (usually into the operator that creates it). `observeOn` simply delays notifications a\n * little bit more, to ensure that they are emitted at expected moments.\n *\n * As a matter of fact, `observeOn` accepts second parameter, which specifies in milliseconds with what delay notifications\n * will be emitted. The main difference between {@link delay} operator and `observeOn` is that `observeOn`\n * will delay all notifications - including error notifications - while `delay` will pass through error\n * from source Observable immediately when it is emitted. In general it is highly recommended to use `delay` operator\n * for any kind of delaying of values in the stream, while using `observeOn` to specify which scheduler should be used\n * for notification emissions in general.\n *\n * ## Example\n * Ensure values in subscribe are called just before browser repaint.\n * ```javascript\n * const intervals = interval(10);                // Intervals are scheduled\n *                                                // with async scheduler by default...\n * intervals.pipe(\n *   observeOn(animationFrameScheduler),          // ...but we will observe on animationFrame\n * )                                              // scheduler to ensure smooth animation.\n * .subscribe(val => {\n *   someDiv.style.height = val + 'px';\n * });\n * ```\n *\n * @see {@link delay}\n *\n * @param {SchedulerLike} scheduler Scheduler that will be used to reschedule notifications from source Observable.\n * @param {number} [delay] Number of milliseconds that states with what delay every notification should be rescheduled.\n * @return {Observable<T>} Observable that emits the same notifications as the source Observable,\n * but with provided scheduler.\n *\n * @method observeOn\n * @owner Observable\n */\nexport declare function observeOn<T>(scheduler: SchedulerLike, delay?: number): MonoTypeOperatorFunction<T>;\nexport declare class ObserveOnOperator<T> implements Operator<T, T> {\n    private scheduler;\n    private delay;\n    constructor(scheduler: SchedulerLike, delay?: number);\n    call(subscriber: Subscriber<T>, source: any): TeardownLogic;\n}\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport declare class ObserveOnSubscriber<T> extends Subscriber<T> {\n    private scheduler;\n    private delay;\n    /** @nocollapse */\n    static dispatch(this: SchedulerAction<ObserveOnMessage>, arg: ObserveOnMessage): void;\n    constructor(destination: Subscriber<T>, scheduler: SchedulerLike, delay?: number);\n    private scheduleMessage;\n    protected _next(value: T): void;\n    protected _error(err: any): void;\n    protected _complete(): void;\n}\nexport declare class ObserveOnMessage {\n    notification: Notification<any>;\n    destination: PartialObserver<any>;\n    constructor(notification: Notification<any>, destination: PartialObserver<any>);\n}\n"
  },
  {
    "path": "node_modules/rxjs/internal/operators/onErrorResumeNext.d.ts",
    "content": "import { Observable } from '../Observable';\nimport { ObservableInput, OperatorFunction } from '../types';\nexport declare function onErrorResumeNext<T, R>(v: ObservableInput<R>): OperatorFunction<T, R>;\nexport declare function onErrorResumeNext<T, T2, T3, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>): OperatorFunction<T, R>;\nexport declare function onErrorResumeNext<T, T2, T3, T4, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>): OperatorFunction<T, R>;\nexport declare function onErrorResumeNext<T, T2, T3, T4, T5, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>): OperatorFunction<T, R>;\nexport declare function onErrorResumeNext<T, T2, T3, T4, T5, T6, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>): OperatorFunction<T, R>;\nexport declare function onErrorResumeNext<T, R>(...observables: Array<ObservableInput<any> | ((...values: Array<any>) => R)>): OperatorFunction<T, R>;\nexport declare function onErrorResumeNext<T, R>(array: ObservableInput<any>[]): OperatorFunction<T, R>;\nexport declare function onErrorResumeNextStatic<R>(v: ObservableInput<R>): Observable<R>;\nexport declare function onErrorResumeNextStatic<T2, T3, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>): Observable<R>;\nexport declare function onErrorResumeNextStatic<T2, T3, T4, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>): Observable<R>;\nexport declare function onErrorResumeNextStatic<T2, T3, T4, T5, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>): Observable<R>;\nexport declare function onErrorResumeNextStatic<T2, T3, T4, T5, T6, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>): Observable<R>;\nexport declare function onErrorResumeNextStatic<R>(...observables: Array<ObservableInput<any> | ((...values: Array<any>) => R)>): Observable<R>;\nexport declare function onErrorResumeNextStatic<R>(array: ObservableInput<any>[]): Observable<R>;\n"
  },
  {
    "path": "node_modules/rxjs/internal/operators/pairwise.d.ts",
    "content": "import { OperatorFunction } from '../types';\n/**\n * Groups pairs of consecutive emissions together and emits them as an array of\n * two values.\n *\n * <span class=\"informal\">Puts the current value and previous value together as\n * an array, and emits that.</span>\n *\n * ![](pairwise.png)\n *\n * The Nth emission from the source Observable will cause the output Observable\n * to emit an array [(N-1)th, Nth] of the previous and the current value, as a\n * pair. For this reason, `pairwise` emits on the second and subsequent\n * emissions from the source Observable, but not on the first emission, because\n * there is no previous value in that case.\n *\n * ## Example\n * On every click (starting from the second), emit the relative distance to the previous click\n * ```javascript\n * const clicks = fromEvent(document, 'click');\n * const pairs = clicks.pipe(pairwise());\n * const distance = pairs.pipe(\n *   map(pair => {\n *     const x0 = pair[0].clientX;\n *     const y0 = pair[0].clientY;\n *     const x1 = pair[1].clientX;\n *     const y1 = pair[1].clientY;\n *     return Math.sqrt(Math.pow(x0 - x1, 2) + Math.pow(y0 - y1, 2));\n *   }),\n * );\n * distance.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link buffer}\n * @see {@link bufferCount}\n *\n * @return {Observable<Array<T>>} An Observable of pairs (as arrays) of\n * consecutive values from the source Observable.\n * @method pairwise\n * @owner Observable\n */\nexport declare function pairwise<T>(): OperatorFunction<T, [T, T]>;\n"
  },
  {
    "path": "node_modules/rxjs/internal/operators/partition.d.ts",
    "content": "import { Observable } from '../Observable';\nimport { UnaryFunction } from '../types';\n/**\n * Splits the source Observable into two, one with values that satisfy a\n * predicate, and another with values that don't satisfy the predicate.\n *\n * <span class=\"informal\">It's like {@link filter}, but returns two Observables:\n * one like the output of {@link filter}, and the other with values that did not\n * pass the condition.</span>\n *\n * ![](partition.png)\n *\n * `partition` outputs an array with two Observables that partition the values\n * from the source Observable through the given `predicate` function. The first\n * Observable in that array emits source values for which the predicate argument\n * returns true. The second Observable emits source values for which the\n * predicate returns false. The first behaves like {@link filter} and the second\n * behaves like {@link filter} with the predicate negated.\n *\n * ## Example\n * Partition click events into those on DIV elements and those elsewhere\n * ```javascript\n * const clicks = fromEvent(document, 'click');\n * const parts = clicks.pipe(partition(ev => ev.target.tagName === 'DIV'));\n * const clicksOnDivs = parts[0];\n * const clicksElsewhere = parts[1];\n * clicksOnDivs.subscribe(x => console.log('DIV clicked: ', x));\n * clicksElsewhere.subscribe(x => console.log('Other clicked: ', x));\n * ```\n *\n * @see {@link filter}\n *\n * @param {function(value: T, index: number): boolean} predicate A function that\n * evaluates each value emitted by the source Observable. If it returns `true`,\n * the value is emitted on the first Observable in the returned array, if\n * `false` the value is emitted on the second Observable in the array. The\n * `index` parameter is the number `i` for the i-th source emission that has\n * happened since the subscription, starting from the number `0`.\n * @param {any} [thisArg] An optional argument to determine the value of `this`\n * in the `predicate` function.\n * @return {[Observable<T>, Observable<T>]} An array with two Observables: one\n * with values that passed the predicate, and another with values that did not\n * pass the predicate.\n * @method partition\n * @owner Observable\n */\nexport declare function partition<T>(predicate: (value: T, index: number) => boolean, thisArg?: any): UnaryFunction<Observable<T>, [Observable<T>, Observable<T>]>;\n"
  },
  {
    "path": "node_modules/rxjs/internal/operators/pluck.d.ts",
    "content": "import { OperatorFunction } from '../types';\n/**\n * Maps each source value (an object) to its specified nested property.\n *\n * <span class=\"informal\">Like {@link map}, but meant only for picking one of\n * the nested properties of every emitted object.</span>\n *\n * ![](pluck.png)\n *\n * Given a list of strings describing a path to an object property, retrieves\n * the value of a specified nested property from all values in the source\n * Observable. If a property can't be resolved, it will return `undefined` for\n * that value.\n *\n * ## Example\n * Map every click to the tagName of the clicked target element\n * ```javascript\n * const clicks = fromEvent(document, 'click');\n * const tagNames = clicks.pipe(pluck('target', 'tagName'));\n * tagNames.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link map}\n *\n * @param {...string} properties The nested properties to pluck from each source\n * value (an object).\n * @return {Observable} A new Observable of property values from the source values.\n * @method pluck\n * @owner Observable\n */\nexport declare function pluck<T, R>(...properties: string[]): OperatorFunction<T, R>;\n"
  },
  {
    "path": "node_modules/rxjs/internal/operators/publish.d.ts",
    "content": "import { Observable } from '../Observable';\nimport { ConnectableObservable } from '../observable/ConnectableObservable';\nimport { MonoTypeOperatorFunction, OperatorFunction, UnaryFunction } from '../types';\nexport declare function publish<T>(): UnaryFunction<Observable<T>, ConnectableObservable<T>>;\nexport declare function publish<T, R>(selector: OperatorFunction<T, R>): OperatorFunction<T, R>;\nexport declare function publish<T>(selector: MonoTypeOperatorFunction<T>): MonoTypeOperatorFunction<T>;\n"
  },
  {
    "path": "node_modules/rxjs/internal/operators/publishBehavior.d.ts",
    "content": "import { Observable } from '../Observable';\nimport { ConnectableObservable } from '../observable/ConnectableObservable';\nimport { UnaryFunction } from '../types';\n/**\n * @param value\n * @return {ConnectableObservable<T>}\n * @method publishBehavior\n * @owner Observable\n */\nexport declare function publishBehavior<T>(value: T): UnaryFunction<Observable<T>, ConnectableObservable<T>>;\n"
  },
  {
    "path": "node_modules/rxjs/internal/operators/publishLast.d.ts",
    "content": "import { Observable } from '../Observable';\nimport { ConnectableObservable } from '../observable/ConnectableObservable';\nimport { UnaryFunction } from '../types';\n/**\n * Returns a connectable observable sequence that shares a single subscription to the\n * underlying sequence containing only the last notification.\n *\n * ![](publishLast.png)\n *\n * Similar to {@link publish}, but it waits until the source observable completes and stores\n * the last emitted value.\n * Similarly to {@link publishReplay} and {@link publishBehavior}, this keeps storing the last\n * value even if it has no more subscribers. If subsequent subscriptions happen, they will\n * immediately get that last stored value and complete.\n *\n * ## Example\n *\n * ```js\n * const connectable =\n *   interval(1000)\n *     .pipe(\n *       tap(x => console.log(\"side effect\", x)),\n *       take(3),\n *       publishLast());\n *\n * connectable.subscribe(\n *   x => console.log(  \"Sub. A\", x),\n *   err => console.log(\"Sub. A Error\", err),\n *   () => console.log( \"Sub. A Complete\"));\n *\n * connectable.subscribe(\n *   x => console.log(  \"Sub. B\", x),\n *   err => console.log(\"Sub. B Error\", err),\n *   () => console.log( \"Sub. B Complete\"));\n *\n * connectable.connect();\n *\n * // Results:\n * //    \"side effect 0\"\n * //    \"side effect 1\"\n * //    \"side effect 2\"\n * //    \"Sub. A 2\"\n * //    \"Sub. B 2\"\n * //    \"Sub. A Complete\"\n * //    \"Sub. B Complete\"\n * ```\n *\n * @see {@link ConnectableObservable}\n * @see {@link publish}\n * @see {@link publishReplay}\n * @see {@link publishBehavior}\n *\n * @return {ConnectableObservable} An observable sequence that contains the elements of a\n * sequence produced by multicasting the source sequence.\n * @method publishLast\n * @owner Observable\n */\nexport declare function publishLast<T>(): UnaryFunction<Observable<T>, ConnectableObservable<T>>;\n"
  },
  {
    "path": "node_modules/rxjs/internal/operators/publishReplay.d.ts",
    "content": "import { MonoTypeOperatorFunction, OperatorFunction, SchedulerLike } from '../types';\nexport declare function publishReplay<T>(bufferSize?: number, windowTime?: number, scheduler?: SchedulerLike): MonoTypeOperatorFunction<T>;\nexport declare function publishReplay<T, R>(bufferSize?: number, windowTime?: number, selector?: OperatorFunction<T, R>, scheduler?: SchedulerLike): OperatorFunction<T, R>;\nexport declare function publishReplay<T>(bufferSize?: number, windowTime?: number, selector?: MonoTypeOperatorFunction<T>, scheduler?: SchedulerLike): MonoTypeOperatorFunction<T>;\n"
  },
  {
    "path": "node_modules/rxjs/internal/operators/race.d.ts",
    "content": "import { Observable } from '../Observable';\nimport { MonoTypeOperatorFunction, OperatorFunction } from '../types';\n/** @deprecated Deprecated in favor of static race. */\nexport declare function race<T>(observables: Array<Observable<T>>): MonoTypeOperatorFunction<T>;\n/** @deprecated Deprecated in favor of static race. */\nexport declare function race<T, R>(observables: Array<Observable<T>>): OperatorFunction<T, R>;\n/** @deprecated Deprecated in favor of static race. */\nexport declare function race<T>(...observables: Array<Observable<T> | Array<Observable<T>>>): MonoTypeOperatorFunction<T>;\n/** @deprecated Deprecated in favor of static race. */\nexport declare function race<T, R>(...observables: Array<Observable<any> | Array<Observable<any>>>): OperatorFunction<T, R>;\n"
  },
  {
    "path": "node_modules/rxjs/internal/operators/reduce.d.ts",
    "content": "import { OperatorFunction, MonoTypeOperatorFunction } from '../types';\nexport declare function reduce<T>(accumulator: (acc: T, value: T, index: number) => T, seed?: T): MonoTypeOperatorFunction<T>;\nexport declare function reduce<T>(accumulator: (acc: T[], value: T, index: number) => T[], seed: T[]): OperatorFunction<T, T[]>;\nexport declare function reduce<T, R>(accumulator: (acc: R, value: T, index: number) => R, seed?: R): OperatorFunction<T, R>;\n"
  },
  {
    "path": "node_modules/rxjs/internal/operators/refCount.d.ts",
    "content": "import { MonoTypeOperatorFunction } from '../types';\nexport declare function refCount<T>(): MonoTypeOperatorFunction<T>;\n"
  },
  {
    "path": "node_modules/rxjs/internal/operators/repeat.d.ts",
    "content": "import { MonoTypeOperatorFunction } from '../types';\n/**\n * Returns an Observable that repeats the stream of items emitted by the source Observable at most count times.\n *\n * ![](repeat.png)\n *\n * @param {number} [count] The number of times the source Observable items are repeated, a count of 0 will yield\n * an empty Observable.\n * @return {Observable} An Observable that repeats the stream of items emitted by the source Observable at most\n * count times.\n * @method repeat\n * @owner Observable\n */\nexport declare function repeat<T>(count?: number): MonoTypeOperatorFunction<T>;\n"
  },
  {
    "path": "node_modules/rxjs/internal/operators/repeatWhen.d.ts",
    "content": "import { Observable } from '../Observable';\nimport { MonoTypeOperatorFunction } from '../types';\n/**\n * Returns an Observable that mirrors the source Observable with the exception of a `complete`. If the source\n * Observable calls `complete`, this method will emit to the Observable returned from `notifier`. If that Observable\n * calls `complete` or `error`, then this method will call `complete` or `error` on the child subscription. Otherwise\n * this method will resubscribe to the source Observable.\n *\n * ![](repeatWhen.png)\n *\n * @param {function(notifications: Observable): Observable} notifier - Receives an Observable of notifications with\n * which a user can `complete` or `error`, aborting the repetition.\n * @return {Observable} The source Observable modified with repeat logic.\n * @method repeatWhen\n * @owner Observable\n */\nexport declare function repeatWhen<T>(notifier: (notifications: Observable<any>) => Observable<any>): MonoTypeOperatorFunction<T>;\n"
  },
  {
    "path": "node_modules/rxjs/internal/operators/retry.d.ts",
    "content": "import { MonoTypeOperatorFunction } from '../types';\n/**\n * Returns an Observable that mirrors the source Observable with the exception of an `error`. If the source Observable\n * calls `error`, this method will resubscribe to the source Observable for a maximum of `count` resubscriptions (given\n * as a number parameter) rather than propagating the `error` call.\n *\n * ![](retry.png)\n *\n * Any and all items emitted by the source Observable will be emitted by the resulting Observable, even those emitted\n * during failed subscriptions. For example, if an Observable fails at first but emits [1, 2] then succeeds the second\n * time and emits: [1, 2, 3, 4, 5] then the complete stream of emissions and notifications\n * would be: [1, 2, 1, 2, 3, 4, 5, `complete`].\n * @param {number} count - Number of retry attempts before failing.\n * @return {Observable} The source Observable modified with the retry logic.\n * @method retry\n * @owner Observable\n */\nexport declare function retry<T>(count?: number): MonoTypeOperatorFunction<T>;\n"
  },
  {
    "path": "node_modules/rxjs/internal/operators/retryWhen.d.ts",
    "content": "import { Observable } from '../Observable';\nimport { MonoTypeOperatorFunction } from '../types';\n/**\n * Returns an Observable that mirrors the source Observable with the exception of an `error`. If the source Observable\n * calls `error`, this method will emit the Throwable that caused the error to the Observable returned from `notifier`.\n * If that Observable calls `complete` or `error` then this method will call `complete` or `error` on the child\n * subscription. Otherwise this method will resubscribe to the source Observable.\n *\n * ![](retryWhen.png)\n *\n * @param {function(errors: Observable): Observable} notifier - Receives an Observable of notifications with which a\n * user can `complete` or `error`, aborting the retry.\n * @return {Observable} The source Observable modified with retry logic.\n * @method retryWhen\n * @owner Observable\n */\nexport declare function retryWhen<T>(notifier: (errors: Observable<any>) => Observable<any>): MonoTypeOperatorFunction<T>;\n"
  },
  {
    "path": "node_modules/rxjs/internal/operators/sample.d.ts",
    "content": "import { Observable } from '../Observable';\nimport { MonoTypeOperatorFunction } from '../types';\n/**\n * Emits the most recently emitted value from the source Observable whenever\n * another Observable, the `notifier`, emits.\n *\n * <span class=\"informal\">It's like {@link sampleTime}, but samples whenever\n * the `notifier` Observable emits something.</span>\n *\n * ![](sample.png)\n *\n * Whenever the `notifier` Observable emits a value or completes, `sample`\n * looks at the source Observable and emits whichever value it has most recently\n * emitted since the previous sampling, unless the source has not emitted\n * anything since the previous sampling. The `notifier` is subscribed to as soon\n * as the output Observable is subscribed.\n *\n * ## Example\n * On every click, sample the most recent \"seconds\" timer\n * ```javascript\n * const seconds = interval(1000);\n * const clicks = fromEvent(document, 'click');\n * const result = seconds.pipe(sample(clicks));\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link audit}\n * @see {@link debounce}\n * @see {@link sampleTime}\n * @see {@link throttle}\n *\n * @param {Observable<any>} notifier The Observable to use for sampling the\n * source Observable.\n * @return {Observable<T>} An Observable that emits the results of sampling the\n * values emitted by the source Observable whenever the notifier Observable\n * emits value or completes.\n * @method sample\n * @owner Observable\n */\nexport declare function sample<T>(notifier: Observable<any>): MonoTypeOperatorFunction<T>;\n"
  },
  {
    "path": "node_modules/rxjs/internal/operators/sampleTime.d.ts",
    "content": "import { MonoTypeOperatorFunction, SchedulerLike } from '../types';\n/**\n * Emits the most recently emitted value from the source Observable within\n * periodic time intervals.\n *\n * <span class=\"informal\">Samples the source Observable at periodic time\n * intervals, emitting what it samples.</span>\n *\n * ![](sampleTime.png)\n *\n * `sampleTime` periodically looks at the source Observable and emits whichever\n * value it has most recently emitted since the previous sampling, unless the\n * source has not emitted anything since the previous sampling. The sampling\n * happens periodically in time every `period` milliseconds (or the time unit\n * defined by the optional `scheduler` argument). The sampling starts as soon as\n * the output Observable is subscribed.\n *\n * ## Example\n * Every second, emit the most recent click at most once\n * ```javascript\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(sampleTime(1000));\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link auditTime}\n * @see {@link debounceTime}\n * @see {@link delay}\n * @see {@link sample}\n * @see {@link throttleTime}\n *\n * @param {number} period The sampling period expressed in milliseconds or the\n * time unit determined internally by the optional `scheduler`.\n * @param {SchedulerLike} [scheduler=async] The {@link SchedulerLike} to use for\n * managing the timers that handle the sampling.\n * @return {Observable<T>} An Observable that emits the results of sampling the\n * values emitted by the source Observable at the specified time interval.\n * @method sampleTime\n * @owner Observable\n */\nexport declare function sampleTime<T>(period: number, scheduler?: SchedulerLike): MonoTypeOperatorFunction<T>;\n"
  },
  {
    "path": "node_modules/rxjs/internal/operators/scan.d.ts",
    "content": "import { OperatorFunction, MonoTypeOperatorFunction } from '../types';\nexport declare function scan<T>(accumulator: (acc: T, value: T, index: number) => T, seed?: T): MonoTypeOperatorFunction<T>;\nexport declare function scan<T>(accumulator: (acc: T[], value: T, index: number) => T[], seed?: T[]): OperatorFunction<T, T[]>;\nexport declare function scan<T, R>(accumulator: (acc: R, value: T, index: number) => R, seed?: R): OperatorFunction<T, R>;\n"
  },
  {
    "path": "node_modules/rxjs/internal/operators/sequenceEqual.d.ts",
    "content": "import { Operator } from '../Operator';\nimport { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { Observer, OperatorFunction } from '../types';\n/**\n * Compares all values of two observables in sequence using an optional comparor function\n * and returns an observable of a single boolean value representing whether or not the two sequences\n * are equal.\n *\n * <span class=\"informal\">Checks to see of all values emitted by both observables are equal, in order.</span>\n *\n * ![](sequenceEqual.png)\n *\n * `sequenceEqual` subscribes to two observables and buffers incoming values from each observable. Whenever either\n * observable emits a value, the value is buffered and the buffers are shifted and compared from the bottom\n * up; If any value pair doesn't match, the returned observable will emit `false` and complete. If one of the\n * observables completes, the operator will wait for the other observable to complete; If the other\n * observable emits before completing, the returned observable will emit `false` and complete. If one observable never\n * completes or emits after the other complets, the returned observable will never complete.\n *\n * ## Example\n * figure out if the Konami code matches\n * ```javascript\n * const codes = from([\n *   'ArrowUp',\n *   'ArrowUp',\n *   'ArrowDown',\n *   'ArrowDown',\n *   'ArrowLeft',\n *   'ArrowRight',\n *   'ArrowLeft',\n *   'ArrowRight',\n *   'KeyB',\n *   'KeyA',\n *   'Enter', // no start key, clearly.\n * ]);\n *\n * const keys = fromEvent(document, 'keyup').pipe(map(e => e.code));\n * const matches = keys.pipe(\n *   bufferCount(11, 1),\n *   mergeMap(\n *     last11 => from(last11).pipe(sequenceEqual(codes)),\n *   ),\n * );\n * matches.subscribe(matched => console.log('Successful cheat at Contra? ', matched));\n * ```\n *\n * @see {@link combineLatest}\n * @see {@link zip}\n * @see {@link withLatestFrom}\n *\n * @param {Observable} compareTo The observable sequence to compare the source sequence to.\n * @param {function} [comparor] An optional function to compare each value pair\n * @return {Observable} An Observable of a single boolean value representing whether or not\n * the values emitted by both observables were equal in sequence.\n * @method sequenceEqual\n * @owner Observable\n */\nexport declare function sequenceEqual<T>(compareTo: Observable<T>, comparor?: (a: T, b: T) => boolean): OperatorFunction<T, boolean>;\nexport declare class SequenceEqualOperator<T> implements Operator<T, boolean> {\n    private compareTo;\n    private comparor;\n    constructor(compareTo: Observable<T>, comparor: (a: T, b: T) => boolean);\n    call(subscriber: Subscriber<boolean>, source: any): any;\n}\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport declare class SequenceEqualSubscriber<T, R> extends Subscriber<T> {\n    private compareTo;\n    private comparor;\n    private _a;\n    private _b;\n    private _oneComplete;\n    constructor(destination: Observer<R>, compareTo: Observable<T>, comparor: (a: T, b: T) => boolean);\n    protected _next(value: T): void;\n    _complete(): void;\n    checkValues(): void;\n    emit(value: boolean): void;\n    nextB(value: T): void;\n    completeB(): void;\n}\n"
  },
  {
    "path": "node_modules/rxjs/internal/operators/share.d.ts",
    "content": "import { MonoTypeOperatorFunction } from '../types';\n/**\n * Returns a new Observable that multicasts (shares) the original Observable. As long as there is at least one\n * Subscriber this Observable will be subscribed and emitting data. When all subscribers have unsubscribed it will\n * unsubscribe from the source Observable. Because the Observable is multicasting it makes the stream `hot`.\n * This is an alias for `multicast(() => new Subject()), refCount()`.\n *\n * ![](share.png)\n *\n * @return {Observable<T>} An Observable that upon connection causes the source Observable to emit items to its Observers.\n * @method share\n * @owner Observable\n */\nexport declare function share<T>(): MonoTypeOperatorFunction<T>;\n"
  },
  {
    "path": "node_modules/rxjs/internal/operators/shareReplay.d.ts",
    "content": "import { MonoTypeOperatorFunction, SchedulerLike } from '../types';\n/**\n * Share source and replay specified number of emissions on subscription.\n *\n * This operator is a specialization of `replay` that connects to a source observable\n * and multicasts through a `ReplaySubject` constructed with the specified arguments.\n * A successfully completed source will stay cached in the `shareReplayed observable` forever,\n * but an errored source can be retried.\n *\n * ## Why use shareReplay?\n * You generally want to use `shareReplay` when you have side-effects or taxing computations\n * that you do not wish to be executed amongst multiple subscribers.\n * It may also be valuable in situations where you know you will have late subscribers to\n * a stream that need access to previously emitted values.\n * This ability to replay values on subscription is what differentiates {@link share} and `shareReplay`.\n *\n * ![](shareReplay.png)\n *\n * ## Example\n * ```javascript\n * const obs$ = interval(1000);\n * const subscription = obs$.pipe(\n *   take(4),\n *   shareReplay(3)\n * );\n * subscription.subscribe(x => console.log('source A: ', x));\n * subscription.subscribe(y => console.log('source B: ', y));\n *\n * ```\n *\n * @see {@link publish}\n * @see {@link share}\n * @see {@link publishReplay}\n *\n * @param {Number} [bufferSize=Number.POSITIVE_INFINITY] Maximum element count of the replay buffer.\n * @param {Number} [windowTime=Number.POSITIVE_INFINITY] Maximum time length of the replay buffer in milliseconds.\n * @param {Scheduler} [scheduler] Scheduler where connected observers within the selector function\n * will be invoked on.\n * @return {Observable} An observable sequence that contains the elements of a sequence produced\n * by multicasting the source sequence within a selector function.\n * @method shareReplay\n * @owner Observable\n */\nexport declare function shareReplay<T>(bufferSize?: number, windowTime?: number, scheduler?: SchedulerLike): MonoTypeOperatorFunction<T>;\n"
  },
  {
    "path": "node_modules/rxjs/internal/operators/single.d.ts",
    "content": "import { Observable } from '../Observable';\nimport { MonoTypeOperatorFunction } from '../types';\n/**\n * Returns an Observable that emits the single item emitted by the source Observable that matches a specified\n * predicate, if that Observable emits one such item. If the source Observable emits more than one such item or no\n * items, notify of an IllegalArgumentException or NoSuchElementException respectively. If the source Observable\n * emits items but none match the specified predicate then `undefined` is emiited.\n *\n * ![](single.png)\n *\n * @throws {EmptyError} Delivers an EmptyError to the Observer's `error`\n * callback if the Observable completes before any `next` notification was sent.\n * @param {Function} predicate - A predicate function to evaluate items emitted by the source Observable.\n * @return {Observable<T>} An Observable that emits the single item emitted by the source Observable that matches\n * the predicate or `undefined` when no items match.\n *\n * @method single\n * @owner Observable\n */\nexport declare function single<T>(predicate?: (value: T, index: number, source: Observable<T>) => boolean): MonoTypeOperatorFunction<T>;\n"
  },
  {
    "path": "node_modules/rxjs/internal/operators/skip.d.ts",
    "content": "import { MonoTypeOperatorFunction } from '../types';\n/**\n * Returns an Observable that skips the first `count` items emitted by the source Observable.\n *\n * ![](skip.png)\n *\n * @param {Number} count - The number of times, items emitted by source Observable should be skipped.\n * @return {Observable} An Observable that skips values emitted by the source Observable.\n *\n * @method skip\n * @owner Observable\n */\nexport declare function skip<T>(count: number): MonoTypeOperatorFunction<T>;\n"
  },
  {
    "path": "node_modules/rxjs/internal/operators/skipLast.d.ts",
    "content": "import { MonoTypeOperatorFunction } from '../types';\n/**\n * Skip the last `count` values emitted by the source Observable.\n *\n * ![](skipLast.png)\n *\n * `skipLast` returns an Observable that accumulates a queue with a length\n * enough to store the first `count` values. As more values are received,\n * values are taken from the front of the queue and produced on the result\n * sequence. This causes values to be delayed.\n *\n * ## Example\n * Skip the last 2 values of an Observable with many values\n * ```javascript\n * const many = range(1, 5);\n * const skipLastTwo = many.pipe(skipLast(2));\n * skipLastTwo.subscribe(x => console.log(x));\n *\n * // Results in:\n * // 1 2 3\n * ```\n *\n * @see {@link skip}\n * @see {@link skipUntil}\n * @see {@link skipWhile}\n * @see {@link take}\n *\n * @throws {ArgumentOutOfRangeError} When using `skipLast(i)`, it throws\n * ArgumentOutOrRangeError if `i < 0`.\n *\n * @param {number} count Number of elements to skip from the end of the source Observable.\n * @returns {Observable<T>} An Observable that skips the last count values\n * emitted by the source Observable.\n * @method skipLast\n * @owner Observable\n */\nexport declare function skipLast<T>(count: number): MonoTypeOperatorFunction<T>;\n"
  },
  {
    "path": "node_modules/rxjs/internal/operators/skipUntil.d.ts",
    "content": "import { Observable } from '../Observable';\nimport { MonoTypeOperatorFunction } from '../types';\n/**\n * Returns an Observable that skips items emitted by the source Observable until a second Observable emits an item.\n *\n * ![](skipUntil.png)\n *\n * @param {Observable} notifier - The second Observable that has to emit an item before the source Observable's elements begin to\n * be mirrored by the resulting Observable.\n * @return {Observable<T>} An Observable that skips items from the source Observable until the second Observable emits\n * an item, then emits the remaining items.\n * @method skipUntil\n * @owner Observable\n */\nexport declare function skipUntil<T>(notifier: Observable<any>): MonoTypeOperatorFunction<T>;\n"
  },
  {
    "path": "node_modules/rxjs/internal/operators/skipWhile.d.ts",
    "content": "import { MonoTypeOperatorFunction } from '../types';\n/**\n * Returns an Observable that skips all items emitted by the source Observable as long as a specified condition holds\n * true, but emits all further source items as soon as the condition becomes false.\n *\n * ![](skipWhile.png)\n *\n * @param {Function} predicate - A function to test each item emitted from the source Observable.\n * @return {Observable<T>} An Observable that begins emitting items emitted by the source Observable when the\n * specified predicate becomes false.\n * @method skipWhile\n * @owner Observable\n */\nexport declare function skipWhile<T>(predicate: (value: T, index: number) => boolean): MonoTypeOperatorFunction<T>;\n"
  },
  {
    "path": "node_modules/rxjs/internal/operators/startWith.d.ts",
    "content": "import { MonoTypeOperatorFunction, OperatorFunction, SchedulerLike } from '../types';\nexport declare function startWith<T>(scheduler?: SchedulerLike): MonoTypeOperatorFunction<T>;\nexport declare function startWith<T, D = T>(v1: D, scheduler?: SchedulerLike): OperatorFunction<T, T | D>;\nexport declare function startWith<T, D = T, E = T>(v1: D, v2: E, scheduler?: SchedulerLike): OperatorFunction<T, T | D | E>;\nexport declare function startWith<T, D = T, E = T, F = T>(v1: D, v2: E, v3: F, scheduler?: SchedulerLike): OperatorFunction<T, T | D | E | F>;\nexport declare function startWith<T, D = T, E = T, F = T, G = T>(v1: D, v2: E, v3: F, v4: G, scheduler?: SchedulerLike): OperatorFunction<T, T | D | E | F | G>;\nexport declare function startWith<T, D = T, E = T, F = T, G = T, H = T>(v1: D, v2: E, v3: F, v4: G, v5: H, scheduler?: SchedulerLike): OperatorFunction<T, T | D | E | F | G | H>;\nexport declare function startWith<T, D = T, E = T, F = T, G = T, H = T, I = T>(v1: D, v2: E, v3: F, v4: G, v5: H, v6: I, scheduler?: SchedulerLike): OperatorFunction<T, T | D | E | F | G | H | I>;\nexport declare function startWith<T, D = T>(...array: Array<D | SchedulerLike>): OperatorFunction<T, T | D>;\n"
  },
  {
    "path": "node_modules/rxjs/internal/operators/subscribeOn.d.ts",
    "content": "import { MonoTypeOperatorFunction, SchedulerLike } from '../types';\n/**\n * Asynchronously subscribes Observers to this Observable on the specified {@link SchedulerLike}.\n *\n * ![](subscribeOn.png)\n *\n * @param {SchedulerLike} scheduler - The {@link SchedulerLike} to perform subscription actions on.\n * @return {Observable<T>} The source Observable modified so that its subscriptions happen on the specified {@link SchedulerLike}.\n .\n * @method subscribeOn\n * @owner Observable\n */\nexport declare function subscribeOn<T>(scheduler: SchedulerLike, delay?: number): MonoTypeOperatorFunction<T>;\n"
  },
  {
    "path": "node_modules/rxjs/internal/operators/switchAll.d.ts",
    "content": "import { OperatorFunction, ObservableInput } from '../types';\nexport declare function switchAll<T>(): OperatorFunction<ObservableInput<T>, T>;\nexport declare function switchAll<R>(): OperatorFunction<any, R>;\n"
  },
  {
    "path": "node_modules/rxjs/internal/operators/switchMap.d.ts",
    "content": "import { ObservableInput, OperatorFunction } from '../types';\nexport declare function switchMap<T, R>(project: (value: T, index: number) => ObservableInput<R>): OperatorFunction<T, R>;\n/** @deprecated resultSelector is no longer supported, use inner map instead */\nexport declare function switchMap<T, R>(project: (value: T, index: number) => ObservableInput<R>, resultSelector: undefined): OperatorFunction<T, R>;\n/** @deprecated resultSelector is no longer supported, use inner map instead */\nexport declare function switchMap<T, I, R>(project: (value: T, index: number) => ObservableInput<I>, resultSelector: (outerValue: T, innerValue: I, outerIndex: number, innerIndex: number) => R): OperatorFunction<T, R>;\n"
  },
  {
    "path": "node_modules/rxjs/internal/operators/switchMapTo.d.ts",
    "content": "import { ObservableInput, OperatorFunction } from '../types';\nexport declare function switchMapTo<R>(observable: ObservableInput<R>): OperatorFunction<any, R>;\n/** @deprecated resultSelector is no longer supported. Switch to using switchMap with an inner map */\nexport declare function switchMapTo<T, R>(observable: ObservableInput<R>, resultSelector: undefined): OperatorFunction<T, R>;\n/** @deprecated resultSelector is no longer supported. Switch to using switchMap with an inner map */\nexport declare function switchMapTo<T, I, R>(observable: ObservableInput<I>, resultSelector: (outerValue: T, innerValue: I, outerIndex: number, innerIndex: number) => R): OperatorFunction<T, R>;\n"
  },
  {
    "path": "node_modules/rxjs/internal/operators/take.d.ts",
    "content": "import { MonoTypeOperatorFunction } from '../types';\n/**\n * Emits only the first `count` values emitted by the source Observable.\n *\n * <span class=\"informal\">Takes the first `count` values from the source, then\n * completes.</span>\n *\n * ![](take.png)\n *\n * `take` returns an Observable that emits only the first `count` values emitted\n * by the source Observable. If the source emits fewer than `count` values then\n * all of its values are emitted. After that, it completes, regardless if the\n * source completes.\n *\n * ## Example\n * Take the first 5 seconds of an infinite 1-second interval Observable\n * ```javascript\n * import { interval } from 'rxjs';\n * import { take } from 'rxjs/operators';\n *\n * const intervalCount = interval(1000);\n * const takeFive = intervalCount.pipe(take(5));\n * takeFive.subscribe(x => console.log(x));\n *\n * // Logs:\n * // 0\n * // 1\n * // 2\n * // 3\n * // 4\n * ```\n *\n * @see {@link takeLast}\n * @see {@link takeUntil}\n * @see {@link takeWhile}\n * @see {@link skip}\n *\n * @throws {ArgumentOutOfRangeError} When using `take(i)`, it delivers an\n * ArgumentOutOrRangeError to the Observer's `error` callback if `i < 0`.\n *\n * @param {number} count The maximum number of `next` values to emit.\n * @return {Observable<T>} An Observable that emits only the first `count`\n * values emitted by the source Observable, or all of the values from the source\n * if the source emits fewer than `count` values.\n * @method take\n * @owner Observable\n */\nexport declare function take<T>(count: number): MonoTypeOperatorFunction<T>;\n"
  },
  {
    "path": "node_modules/rxjs/internal/operators/takeLast.d.ts",
    "content": "import { MonoTypeOperatorFunction } from '../types';\n/**\n * Emits only the last `count` values emitted by the source Observable.\n *\n * <span class=\"informal\">Remembers the latest `count` values, then emits those\n * only when the source completes.</span>\n *\n * ![](takeLast.png)\n *\n * `takeLast` returns an Observable that emits at most the last `count` values\n * emitted by the source Observable. If the source emits fewer than `count`\n * values then all of its values are emitted. This operator must wait until the\n * `complete` notification emission from the source in order to emit the `next`\n * values on the output Observable, because otherwise it is impossible to know\n * whether or not more values will be emitted on the source. For this reason,\n * all values are emitted synchronously, followed by the complete notification.\n *\n * ## Example\n * Take the last 3 values of an Observable with many values\n * ```javascript\n * const many = range(1, 100);\n * const lastThree = many.pipe(takeLast(3));\n * lastThree.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link take}\n * @see {@link takeUntil}\n * @see {@link takeWhile}\n * @see {@link skip}\n *\n * @throws {ArgumentOutOfRangeError} When using `takeLast(i)`, it delivers an\n * ArgumentOutOrRangeError to the Observer's `error` callback if `i < 0`.\n *\n * @param {number} count The maximum number of values to emit from the end of\n * the sequence of values emitted by the source Observable.\n * @return {Observable<T>} An Observable that emits at most the last count\n * values emitted by the source Observable.\n * @method takeLast\n * @owner Observable\n */\nexport declare function takeLast<T>(count: number): MonoTypeOperatorFunction<T>;\n"
  },
  {
    "path": "node_modules/rxjs/internal/operators/takeUntil.d.ts",
    "content": "import { Observable } from '../Observable';\nimport { MonoTypeOperatorFunction } from '../types';\n/**\n * Emits the values emitted by the source Observable until a `notifier`\n * Observable emits a value.\n *\n * <span class=\"informal\">Lets values pass until a second Observable,\n * `notifier`, emits a value. Then, it completes.</span>\n *\n * ![](takeUntil.png)\n *\n * `takeUntil` subscribes and begins mirroring the source Observable. It also\n * monitors a second Observable, `notifier` that you provide. If the `notifier`\n * emits a value, the output Observable stops mirroring the source Observable\n * and completes. If the `notifier` doesn't emit any value and completes\n * then `takeUntil` will pass all values.\n *\n * ## Example\n * Tick every second until the first click happens\n * ```javascript\n * const interval = interval(1000);\n * const clicks = fromEvent(document, 'click');\n * const result = interval.pipe(takeUntil(clicks));\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link take}\n * @see {@link takeLast}\n * @see {@link takeWhile}\n * @see {@link skip}\n *\n * @param {Observable} notifier The Observable whose first emitted value will\n * cause the output Observable of `takeUntil` to stop emitting values from the\n * source Observable.\n * @return {Observable<T>} An Observable that emits the values from the source\n * Observable until such time as `notifier` emits its first value.\n * @method takeUntil\n * @owner Observable\n */\nexport declare function takeUntil<T>(notifier: Observable<any>): MonoTypeOperatorFunction<T>;\n"
  },
  {
    "path": "node_modules/rxjs/internal/operators/takeWhile.d.ts",
    "content": "import { OperatorFunction, MonoTypeOperatorFunction } from '../types';\nexport declare function takeWhile<T, S extends T>(predicate: (value: T, index: number) => value is S): OperatorFunction<T, S>;\nexport declare function takeWhile<T>(predicate: (value: T, index: number) => boolean): MonoTypeOperatorFunction<T>;\n"
  },
  {
    "path": "node_modules/rxjs/internal/operators/tap.d.ts",
    "content": "import { MonoTypeOperatorFunction, PartialObserver } from '../types';\nexport declare function tap<T>(next?: (x: T) => void, error?: (e: any) => void, complete?: () => void): MonoTypeOperatorFunction<T>;\nexport declare function tap<T>(observer: PartialObserver<T>): MonoTypeOperatorFunction<T>;\n"
  },
  {
    "path": "node_modules/rxjs/internal/operators/throttle.d.ts",
    "content": "import { MonoTypeOperatorFunction, SubscribableOrPromise } from '../types';\nexport interface ThrottleConfig {\n    leading?: boolean;\n    trailing?: boolean;\n}\nexport declare const defaultThrottleConfig: ThrottleConfig;\n/**\n * Emits a value from the source Observable, then ignores subsequent source\n * values for a duration determined by another Observable, then repeats this\n * process.\n *\n * <span class=\"informal\">It's like {@link throttleTime}, but the silencing\n * duration is determined by a second Observable.</span>\n *\n * ![](throttle.png)\n *\n * `throttle` emits the source Observable values on the output Observable\n * when its internal timer is disabled, and ignores source values when the timer\n * is enabled. Initially, the timer is disabled. As soon as the first source\n * value arrives, it is forwarded to the output Observable, and then the timer\n * is enabled by calling the `durationSelector` function with the source value,\n * which returns the \"duration\" Observable. When the duration Observable emits a\n * value or completes, the timer is disabled, and this process repeats for the\n * next source value.\n *\n * ## Example\n * Emit clicks at a rate of at most one click per second\n * ```javascript\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(throttle(ev => interval(1000)));\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link audit}\n * @see {@link debounce}\n * @see {@link delayWhen}\n * @see {@link sample}\n * @see {@link throttleTime}\n *\n * @param {function(value: T): SubscribableOrPromise} durationSelector A function\n * that receives a value from the source Observable, for computing the silencing\n * duration for each source value, returned as an Observable or a Promise.\n * @param {Object} config a configuration object to define `leading` and `trailing` behavior. Defaults\n * to `{ leading: true, trailing: false }`.\n * @return {Observable<T>} An Observable that performs the throttle operation to\n * limit the rate of emissions from the source.\n * @method throttle\n * @owner Observable\n */\nexport declare function throttle<T>(durationSelector: (value: T) => SubscribableOrPromise<any>, config?: ThrottleConfig): MonoTypeOperatorFunction<T>;\n"
  },
  {
    "path": "node_modules/rxjs/internal/operators/throttleTime.d.ts",
    "content": "import { ThrottleConfig } from './throttle';\nimport { MonoTypeOperatorFunction, SchedulerLike } from '../types';\n/**\n * Emits a value from the source Observable, then ignores subsequent source\n * values for `duration` milliseconds, then repeats this process.\n *\n * <span class=\"informal\">Lets a value pass, then ignores source values for the\n * next `duration` milliseconds.</span>\n *\n * ![](throttleTime.png)\n *\n * `throttleTime` emits the source Observable values on the output Observable\n * when its internal timer is disabled, and ignores source values when the timer\n * is enabled. Initially, the timer is disabled. As soon as the first source\n * value arrives, it is forwarded to the output Observable, and then the timer\n * is enabled. After `duration` milliseconds (or the time unit determined\n * internally by the optional `scheduler`) has passed, the timer is disabled,\n * and this process repeats for the next source value. Optionally takes a\n * {@link SchedulerLike} for managing timers.\n *\n * ## Example\n * Emit clicks at a rate of at most one click per second\n * ```javascript\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(throttleTime(1000));\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link auditTime}\n * @see {@link debounceTime}\n * @see {@link delay}\n * @see {@link sampleTime}\n * @see {@link throttle}\n *\n * @param {number} duration Time to wait before emitting another value after\n * emitting the last value, measured in milliseconds or the time unit determined\n * internally by the optional `scheduler`.\n * @param {SchedulerLike} [scheduler=async] The {@link SchedulerLike} to use for\n * managing the timers that handle the throttling.\n * @param {Object} config a configuration object to define `leading` and\n * `trailing` behavior. Defaults to `{ leading: true, trailing: false }`.\n * @return {Observable<T>} An Observable that performs the throttle operation to\n * limit the rate of emissions from the source.\n * @method throttleTime\n * @owner Observable\n */\nexport declare function throttleTime<T>(duration: number, scheduler?: SchedulerLike, config?: ThrottleConfig): MonoTypeOperatorFunction<T>;\n"
  },
  {
    "path": "node_modules/rxjs/internal/operators/throwIfEmpty.d.ts",
    "content": "import { MonoTypeOperatorFunction } from '../types';\n/**\n * If the source observable completes without emitting a value, it will emit\n * an error. The error will be created at that time by the optional\n * `errorFactory` argument, otherwise, the error will be {@link EmptyError}.\n *\n * ![](throwIfEmpty.png)\n *\n * ## Example\n * ```javascript\n * const click$ = fromEvent(button, 'click');\n *\n * clicks$.pipe(\n *   takeUntil(timer(1000)),\n *   throwIfEmpty(\n *     () => new Error('the button was not clicked within 1 second')\n *   ),\n * )\n * .subscribe({\n *   next() { console.log('The button was clicked'); },\n *   error(err) { console.error(err); },\n * });\n * ```\n *\n * @param {Function} [errorFactory] A factory function called to produce the\n * error to be thrown when the source observable completes without emitting a\n * value.\n */\nexport declare const throwIfEmpty: <T>(errorFactory?: () => any) => MonoTypeOperatorFunction<T>;\n"
  },
  {
    "path": "node_modules/rxjs/internal/operators/timeInterval.d.ts",
    "content": "import { SchedulerLike, OperatorFunction } from '../types';\nexport declare function timeInterval<T>(scheduler?: SchedulerLike): OperatorFunction<T, TimeInterval<T>>;\nexport declare class TimeInterval<T> {\n    value: T;\n    interval: number;\n    constructor(value: T, interval: number);\n}\n"
  },
  {
    "path": "node_modules/rxjs/internal/operators/timeout.d.ts",
    "content": "import { MonoTypeOperatorFunction, SchedulerLike } from '../types';\n/**\n *\n * Errors if Observable does not emit a value in given time span.\n *\n * <span class=\"informal\">Timeouts on Observable that doesn't emit values fast enough.</span>\n *\n * ![](timeout.png)\n *\n * `timeout` operator accepts as an argument either a number or a Date.\n *\n * If number was provided, it returns an Observable that behaves like a source\n * Observable, unless there is a period of time where there is no value emitted.\n * So if you provide `100` as argument and first value comes after 50ms from\n * the moment of subscription, this value will be simply re-emitted by the resulting\n * Observable. If however after that 100ms passes without a second value being emitted,\n * stream will end with an error and source Observable will be unsubscribed.\n * These checks are performed throughout whole lifecycle of Observable - from the moment\n * it was subscribed to, until it completes or errors itself. Thus every value must be\n * emitted within specified period since previous value.\n *\n * If provided argument was Date, returned Observable behaves differently. It throws\n * if Observable did not complete before provided Date. This means that periods between\n * emission of particular values do not matter in this case. If Observable did not complete\n * before provided Date, source Observable will be unsubscribed. Other than that, resulting\n * stream behaves just as source Observable.\n *\n * `timeout` accepts also a Scheduler as a second parameter. It is used to schedule moment (or moments)\n * when returned Observable will check if source stream emitted value or completed.\n *\n * ## Examples\n * Check if ticks are emitted within certain timespan\n * ```javascript\n * const seconds = interval(1000);\n *\n * seconds.pipe(timeout(1100))      // Let's use bigger timespan to be safe,\n *                                  // since `interval` might fire a bit later then scheduled.\n * .subscribe(\n *     value => console.log(value), // Will emit numbers just as regular `interval` would.\n *     err => console.log(err),     // Will never be called.\n * );\n *\n * seconds.pipe(timeout(900))\n * .subscribe(\n *     value => console.log(value), // Will never be called.\n *     err => console.log(err),     // Will emit error before even first value is emitted,\n *                                  // since it did not arrive within 900ms period.\n * );\n * ```\n *\n * Use Date to check if Observable completed\n * ```javascript\n * const seconds = interval(1000);\n *\n * seconds.pipe(\n *   timeout(new Date(\"December 17, 2020 03:24:00\")),\n * )\n * .subscribe(\n *     value => console.log(value), // Will emit values as regular `interval` would\n *                                  // until December 17, 2020 at 03:24:00.\n *     err => console.log(err)      // On December 17, 2020 at 03:24:00 it will emit an error,\n *                                  // since Observable did not complete by then.\n * );\n * ```\n * @see {@link timeoutWith}\n *\n * @param {number|Date} due Number specifying period within which Observable must emit values\n *                          or Date specifying before when Observable should complete\n * @param {SchedulerLike} [scheduler] Scheduler controlling when timeout checks occur.\n * @return {Observable<T>} Observable that mirrors behaviour of source, unless timeout checks fail.\n * @method timeout\n * @owner Observable\n */\nexport declare function timeout<T>(due: number | Date, scheduler?: SchedulerLike): MonoTypeOperatorFunction<T>;\n"
  },
  {
    "path": "node_modules/rxjs/internal/operators/timeoutWith.d.ts",
    "content": "import { ObservableInput, OperatorFunction, SchedulerLike } from '../types';\nexport declare function timeoutWith<T, R>(due: number | Date, withObservable: ObservableInput<R>, scheduler?: SchedulerLike): OperatorFunction<T, T | R>;\n"
  },
  {
    "path": "node_modules/rxjs/internal/operators/timestamp.d.ts",
    "content": "import { OperatorFunction, SchedulerLike, Timestamp as TimestampInterface } from '../types';\n/**\n * @param scheduler\n * @return {Observable<Timestamp<any>>|WebSocketSubject<T>|Observable<T>}\n * @method timestamp\n * @owner Observable\n */\nexport declare function timestamp<T>(scheduler?: SchedulerLike): OperatorFunction<T, Timestamp<T>>;\nexport declare class Timestamp<T> implements TimestampInterface<T> {\n    value: T;\n    timestamp: number;\n    constructor(value: T, timestamp: number);\n}\n"
  },
  {
    "path": "node_modules/rxjs/internal/operators/toArray.d.ts",
    "content": "import { OperatorFunction } from '../types';\nexport declare function toArray<T>(): OperatorFunction<T, T[]>;\n"
  },
  {
    "path": "node_modules/rxjs/internal/operators/window.d.ts",
    "content": "import { Observable } from '../Observable';\nimport { OperatorFunction } from '../types';\n/**\n * Branch out the source Observable values as a nested Observable whenever\n * `windowBoundaries` emits.\n *\n * <span class=\"informal\">It's like {@link buffer}, but emits a nested Observable\n * instead of an array.</span>\n *\n * ![](window.png)\n *\n * Returns an Observable that emits windows of items it collects from the source\n * Observable. The output Observable emits connected, non-overlapping\n * windows. It emits the current window and opens a new one whenever the\n * Observable `windowBoundaries` emits an item. Because each window is an\n * Observable, the output is a higher-order Observable.\n *\n * ## Example\n * In every window of 1 second each, emit at most 2 click events\n * ```javascript\n * const clicks = fromEvent(document, 'click');\n * const interval = interval(1000);\n * const result = clicks.pipe(\n *   window(interval),\n *   map(win => win.take(2)), // each window has at most 2 emissions\n *   mergeAll(),              // flatten the Observable-of-Observables\n * );\n * result.subscribe(x => console.log(x));\n * ```\n * @see {@link windowCount}\n * @see {@link windowTime}\n * @see {@link windowToggle}\n * @see {@link windowWhen}\n * @see {@link buffer}\n *\n * @param {Observable<any>} windowBoundaries An Observable that completes the\n * previous window and starts a new window.\n * @return {Observable<Observable<T>>} An Observable of windows, which are\n * Observables emitting values of the source Observable.\n * @method window\n * @owner Observable\n */\nexport declare function window<T>(windowBoundaries: Observable<any>): OperatorFunction<T, Observable<T>>;\n"
  },
  {
    "path": "node_modules/rxjs/internal/operators/windowCount.d.ts",
    "content": "import { Observable } from '../Observable';\nimport { OperatorFunction } from '../types';\n/**\n * Branch out the source Observable values as a nested Observable with each\n * nested Observable emitting at most `windowSize` values.\n *\n * <span class=\"informal\">It's like {@link bufferCount}, but emits a nested\n * Observable instead of an array.</span>\n *\n * ![](windowCount.png)\n *\n * Returns an Observable that emits windows of items it collects from the source\n * Observable. The output Observable emits windows every `startWindowEvery`\n * items, each containing no more than `windowSize` items. When the source\n * Observable completes or encounters an error, the output Observable emits\n * the current window and propagates the notification from the source\n * Observable. If `startWindowEvery` is not provided, then new windows are\n * started immediately at the start of the source and when each window completes\n * with size `windowSize`.\n *\n * ## Examples\n * Ignore every 3rd click event, starting from the first one\n * ```javascript\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(\n *   windowCount(3)),\n *   map(win => win.skip(1)), // skip first of every 3 clicks\n *   mergeAll(),              // flatten the Observable-of-Observables\n * );\n * result.subscribe(x => console.log(x));\n * ```\n *\n * Ignore every 3rd click event, starting from the third one\n * ```javascript\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(\n *   windowCount(2, 3),\n *   mergeAll(),              // flatten the Observable-of-Observables\n * );\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link window}\n * @see {@link windowTime}\n * @see {@link windowToggle}\n * @see {@link windowWhen}\n * @see {@link bufferCount}\n *\n * @param {number} windowSize The maximum number of values emitted by each\n * window.\n * @param {number} [startWindowEvery] Interval at which to start a new window.\n * For example if `startWindowEvery` is `2`, then a new window will be started\n * on every other value from the source. A new window is started at the\n * beginning of the source by default.\n * @return {Observable<Observable<T>>} An Observable of windows, which in turn\n * are Observable of values.\n * @method windowCount\n * @owner Observable\n */\nexport declare function windowCount<T>(windowSize: number, startWindowEvery?: number): OperatorFunction<T, Observable<T>>;\n"
  },
  {
    "path": "node_modules/rxjs/internal/operators/windowTime.d.ts",
    "content": "import { Observable } from '../Observable';\nimport { OperatorFunction, SchedulerLike } from '../types';\n/**\n * Branch out the source Observable values as a nested Observable periodically\n * in time.\n *\n * <span class=\"informal\">It's like {@link bufferTime}, but emits a nested\n * Observable instead of an array.</span>\n *\n * ![](windowTime.png)\n *\n * Returns an Observable that emits windows of items it collects from the source\n * Observable. The output Observable starts a new window periodically, as\n * determined by the `windowCreationInterval` argument. It emits each window\n * after a fixed timespan, specified by the `windowTimeSpan` argument. When the\n * source Observable completes or encounters an error, the output Observable\n * emits the current window and propagates the notification from the source\n * Observable. If `windowCreationInterval` is not provided, the output\n * Observable starts a new window when the previous window of duration\n * `windowTimeSpan` completes. If `maxWindowCount` is provided, each window\n * will emit at most fixed number of values. Window will complete immediately\n * after emitting last value and next one still will open as specified by\n * `windowTimeSpan` and `windowCreationInterval` arguments.\n *\n * ## Examples\n * In every window of 1 second each, emit at most 2 click events\n * ```javascript\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(\n *   windowTime(1000),\n *   map(win => win.take(2)),   // each window has at most 2 emissions\n *   mergeAll(),                // flatten the Observable-of-Observables\n * );\n * result.subscribe(x => console.log(x));\n * ```\n *\n * Every 5 seconds start a window 1 second long, and emit at most 2 click events per window\n * ```javascript\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(\n *   windowTime(1000, 5000),\n *   map(win => win.take(2)),   // each window has at most 2 emissions\n *   mergeAll(),                // flatten the Observable-of-Observables\n * );\n * result.subscribe(x => console.log(x));\n * ```\n *\n * Same as example above but with maxWindowCount instead of take\n * ```javascript\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(\n *   windowTime(1000, 5000, 2), // each window has still at most 2 emissions\n *   mergeAll(),                // flatten the Observable-of-Observables\n * );\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link window}\n * @see {@link windowCount}\n * @see {@link windowToggle}\n * @see {@link windowWhen}\n * @see {@link bufferTime}\n *\n * @param {number} windowTimeSpan The amount of time to fill each window.\n * @param {number} [windowCreationInterval] The interval at which to start new\n * windows.\n * @param {number} [maxWindowSize=Number.POSITIVE_INFINITY] Max number of\n * values each window can emit before completion.\n * @param {SchedulerLike} [scheduler=async] The scheduler on which to schedule the\n * intervals that determine window boundaries.\n * @return {Observable<Observable<T>>} An observable of windows, which in turn\n * are Observables.\n * @method windowTime\n * @owner Observable\n */\nexport declare function windowTime<T>(windowTimeSpan: number, scheduler?: SchedulerLike): OperatorFunction<T, Observable<T>>;\nexport declare function windowTime<T>(windowTimeSpan: number, windowCreationInterval: number, scheduler?: SchedulerLike): OperatorFunction<T, Observable<T>>;\nexport declare function windowTime<T>(windowTimeSpan: number, windowCreationInterval: number, maxWindowSize: number, scheduler?: SchedulerLike): OperatorFunction<T, Observable<T>>;\n"
  },
  {
    "path": "node_modules/rxjs/internal/operators/windowToggle.d.ts",
    "content": "import { Observable } from '../Observable';\nimport { OperatorFunction } from '../types';\n/**\n * Branch out the source Observable values as a nested Observable starting from\n * an emission from `openings` and ending when the output of `closingSelector`\n * emits.\n *\n * <span class=\"informal\">It's like {@link bufferToggle}, but emits a nested\n * Observable instead of an array.</span>\n *\n * ![](windowToggle.png)\n *\n * Returns an Observable that emits windows of items it collects from the source\n * Observable. The output Observable emits windows that contain those items\n * emitted by the source Observable between the time when the `openings`\n * Observable emits an item and when the Observable returned by\n * `closingSelector` emits an item.\n *\n * ## Example\n * Every other second, emit the click events from the next 500ms\n * ```javascript\n * const clicks = fromEvent(document, 'click');\n * const openings = interval(1000);\n * const result = clicks.pipe(\n *   windowToggle(openings, i => i % 2 ? interval(500) : empty()),\n *   mergeAll(),\n * );\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link window}\n * @see {@link windowCount}\n * @see {@link windowTime}\n * @see {@link windowWhen}\n * @see {@link bufferToggle}\n *\n * @param {Observable<O>} openings An observable of notifications to start new\n * windows.\n * @param {function(value: O): Observable} closingSelector A function that takes\n * the value emitted by the `openings` observable and returns an Observable,\n * which, when it emits (either `next` or `complete`), signals that the\n * associated window should complete.\n * @return {Observable<Observable<T>>} An observable of windows, which in turn\n * are Observables.\n * @method windowToggle\n * @owner Observable\n */\nexport declare function windowToggle<T, O>(openings: Observable<O>, closingSelector: (openValue: O) => Observable<any>): OperatorFunction<T, Observable<T>>;\n"
  },
  {
    "path": "node_modules/rxjs/internal/operators/windowWhen.d.ts",
    "content": "import { Observable } from '../Observable';\nimport { OperatorFunction } from '../types';\n/**\n * Branch out the source Observable values as a nested Observable using a\n * factory function of closing Observables to determine when to start a new\n * window.\n *\n * <span class=\"informal\">It's like {@link bufferWhen}, but emits a nested\n * Observable instead of an array.</span>\n *\n * ![](windowWhen.png)\n *\n * Returns an Observable that emits windows of items it collects from the source\n * Observable. The output Observable emits connected, non-overlapping windows.\n * It emits the current window and opens a new one whenever the Observable\n * produced by the specified `closingSelector` function emits an item. The first\n * window is opened immediately when subscribing to the output Observable.\n *\n * ## Example\n * Emit only the first two clicks events in every window of [1-5] random seconds\n * ```javascript\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(\n *   windowWhen(() => interval(1000 + Math.random() * 4000)),\n *   map(win => win.pipe(take(2))),     // each window has at most 2 emissions\n *   mergeAll(),                        // flatten the Observable-of-Observables\n * );\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link window}\n * @see {@link windowCount}\n * @see {@link windowTime}\n * @see {@link windowToggle}\n * @see {@link bufferWhen}\n *\n * @param {function(): Observable} closingSelector A function that takes no\n * arguments and returns an Observable that signals (on either `next` or\n * `complete`) when to close the previous window and start a new one.\n * @return {Observable<Observable<T>>} An observable of windows, which in turn\n * are Observables.\n * @method windowWhen\n * @owner Observable\n */\nexport declare function windowWhen<T>(closingSelector: () => Observable<any>): OperatorFunction<T, Observable<T>>;\n"
  },
  {
    "path": "node_modules/rxjs/internal/operators/withLatestFrom.d.ts",
    "content": "import { ObservableInput, OperatorFunction } from '../types';\nexport declare function withLatestFrom<T, R>(project: (v1: T) => R): OperatorFunction<T, R>;\nexport declare function withLatestFrom<T, T2, R>(v2: ObservableInput<T2>, project: (v1: T, v2: T2) => R): OperatorFunction<T, R>;\nexport declare function withLatestFrom<T, T2, T3, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, project: (v1: T, v2: T2, v3: T3) => R): OperatorFunction<T, R>;\nexport declare function withLatestFrom<T, T2, T3, T4, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, project: (v1: T, v2: T2, v3: T3, v4: T4) => R): OperatorFunction<T, R>;\nexport declare function withLatestFrom<T, T2, T3, T4, T5, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, project: (v1: T, v2: T2, v3: T3, v4: T4, v5: T5) => R): OperatorFunction<T, R>;\nexport declare function withLatestFrom<T, T2, T3, T4, T5, T6, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>, project: (v1: T, v2: T2, v3: T3, v4: T4, v5: T5, v6: T6) => R): OperatorFunction<T, R>;\nexport declare function withLatestFrom<T, T2>(v2: ObservableInput<T2>): OperatorFunction<T, [T, T2]>;\nexport declare function withLatestFrom<T, T2, T3>(v2: ObservableInput<T2>, v3: ObservableInput<T3>): OperatorFunction<T, [T, T2, T3]>;\nexport declare function withLatestFrom<T, T2, T3, T4>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>): OperatorFunction<T, [T, T2, T3, T4]>;\nexport declare function withLatestFrom<T, T2, T3, T4, T5>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>): OperatorFunction<T, [T, T2, T3, T4, T5]>;\nexport declare function withLatestFrom<T, T2, T3, T4, T5, T6>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>): OperatorFunction<T, [T, T2, T3, T4, T5, T6]>;\nexport declare function withLatestFrom<T, R>(...observables: Array<ObservableInput<any> | ((...values: Array<any>) => R)>): OperatorFunction<T, R>;\nexport declare function withLatestFrom<T, R>(array: ObservableInput<any>[]): OperatorFunction<T, R>;\nexport declare function withLatestFrom<T, R>(array: ObservableInput<any>[], project: (...values: Array<any>) => R): OperatorFunction<T, R>;\n"
  },
  {
    "path": "node_modules/rxjs/internal/operators/zip.d.ts",
    "content": "import { ObservableInput, OperatorFunction } from '../types';\n/** @deprecated Deprecated in favor of static zip. */\nexport declare function zip<T, R>(project: (v1: T) => R): OperatorFunction<T, R>;\n/** @deprecated Deprecated in favor of static zip. */\nexport declare function zip<T, T2, R>(v2: ObservableInput<T2>, project: (v1: T, v2: T2) => R): OperatorFunction<T, R>;\n/** @deprecated Deprecated in favor of static zip. */\nexport declare function zip<T, T2, T3, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, project: (v1: T, v2: T2, v3: T3) => R): OperatorFunction<T, R>;\n/** @deprecated Deprecated in favor of static zip. */\nexport declare function zip<T, T2, T3, T4, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, project: (v1: T, v2: T2, v3: T3, v4: T4) => R): OperatorFunction<T, R>;\n/** @deprecated Deprecated in favor of static zip. */\nexport declare function zip<T, T2, T3, T4, T5, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, project: (v1: T, v2: T2, v3: T3, v4: T4, v5: T5) => R): OperatorFunction<T, R>;\n/** @deprecated Deprecated in favor of static zip. */\nexport declare function zip<T, T2, T3, T4, T5, T6, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>, project: (v1: T, v2: T2, v3: T3, v4: T4, v5: T5, v6: T6) => R): OperatorFunction<T, R>;\n/** @deprecated Deprecated in favor of static zip. */\nexport declare function zip<T, T2>(v2: ObservableInput<T2>): OperatorFunction<T, [T, T2]>;\n/** @deprecated Deprecated in favor of static zip. */\nexport declare function zip<T, T2, T3>(v2: ObservableInput<T2>, v3: ObservableInput<T3>): OperatorFunction<T, [T, T2, T3]>;\n/** @deprecated Deprecated in favor of static zip. */\nexport declare function zip<T, T2, T3, T4>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>): OperatorFunction<T, [T, T2, T3, T4]>;\n/** @deprecated Deprecated in favor of static zip. */\nexport declare function zip<T, T2, T3, T4, T5>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>): OperatorFunction<T, [T, T2, T3, T4, T5]>;\n/** @deprecated Deprecated in favor of static zip. */\nexport declare function zip<T, T2, T3, T4, T5, T6>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>): OperatorFunction<T, [T, T2, T3, T4, T5, T6]>;\n/** @deprecated Deprecated in favor of static zip. */\nexport declare function zip<T, R>(...observables: Array<ObservableInput<T> | ((...values: Array<T>) => R)>): OperatorFunction<T, R>;\n/** @deprecated Deprecated in favor of static zip. */\nexport declare function zip<T, R>(array: Array<ObservableInput<T>>): OperatorFunction<T, R>;\n/** @deprecated Deprecated in favor of static zip. */\nexport declare function zip<T, TOther, R>(array: Array<ObservableInput<TOther>>, project: (v1: T, ...values: Array<TOther>) => R): OperatorFunction<T, R>;\n"
  },
  {
    "path": "node_modules/rxjs/internal/operators/zipAll.d.ts",
    "content": "import { OperatorFunction, ObservableInput } from '../types';\nexport declare function zipAll<T>(): OperatorFunction<ObservableInput<T>, T[]>;\nexport declare function zipAll<T>(): OperatorFunction<any, T[]>;\nexport declare function zipAll<T, R>(project: (...values: T[]) => R): OperatorFunction<ObservableInput<T>, R>;\nexport declare function zipAll<R>(project: (...values: Array<any>) => R): OperatorFunction<any, R>;\n"
  },
  {
    "path": "node_modules/rxjs/internal/OuterSubscriber.d.ts",
    "content": "import { Subscriber } from './Subscriber';\nimport { InnerSubscriber } from './InnerSubscriber';\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport declare class OuterSubscriber<T, R> extends Subscriber<T> {\n    notifyNext(outerValue: T, innerValue: R, outerIndex: number, innerIndex: number, innerSub: InnerSubscriber<T, R>): void;\n    notifyError(error: any, innerSub: InnerSubscriber<T, R>): void;\n    notifyComplete(innerSub: InnerSubscriber<T, R>): void;\n}\n"
  },
  {
    "path": "node_modules/rxjs/internal/ReplaySubject.d.ts",
    "content": "import { Subject } from './Subject';\nimport { SchedulerLike } from './types';\nimport { Subscriber } from './Subscriber';\nimport { Subscription } from './Subscription';\n/**\n * A variant of Subject that \"replays\" or emits old values to new subscribers.\n * It buffers a set number of values and will emit those values immediately to\n * any new subscribers in addition to emitting new values to existing subscribers.\n *\n * @class ReplaySubject<T>\n */\nexport declare class ReplaySubject<T> extends Subject<T> {\n    private scheduler?;\n    private _events;\n    private _bufferSize;\n    private _windowTime;\n    private _infiniteTimeWindow;\n    constructor(bufferSize?: number, windowTime?: number, scheduler?: SchedulerLike);\n    private nextInfiniteTimeWindow;\n    private nextTimeWindow;\n    /** @deprecated This is an internal implementation detail, do not use. */\n    _subscribe(subscriber: Subscriber<T>): Subscription;\n    _getNow(): number;\n    private _trimBufferThenGetEvents;\n}\n"
  },
  {
    "path": "node_modules/rxjs/internal/Rx.d.ts",
    "content": "export { Subject, AnonymousSubject } from './Subject';\nexport { Observable } from './Observable';\nexport { config } from './config';\nimport 'rxjs-compat/add/observable/bindCallback';\nimport 'rxjs-compat/add/observable/bindNodeCallback';\nimport 'rxjs-compat/add/observable/combineLatest';\nimport 'rxjs-compat/add/observable/concat';\nimport 'rxjs-compat/add/observable/defer';\nimport 'rxjs-compat/add/observable/empty';\nimport 'rxjs-compat/add/observable/forkJoin';\nimport 'rxjs-compat/add/observable/from';\nimport 'rxjs-compat/add/observable/fromEvent';\nimport 'rxjs-compat/add/observable/fromEventPattern';\nimport 'rxjs-compat/add/observable/fromPromise';\nimport 'rxjs-compat/add/observable/generate';\nimport 'rxjs-compat/add/observable/if';\nimport 'rxjs-compat/add/observable/interval';\nimport 'rxjs-compat/add/observable/merge';\nimport 'rxjs-compat/add/observable/race';\nimport 'rxjs-compat/add/observable/never';\nimport 'rxjs-compat/add/observable/of';\nimport 'rxjs-compat/add/observable/onErrorResumeNext';\nimport 'rxjs-compat/add/observable/pairs';\nimport 'rxjs-compat/add/observable/range';\nimport 'rxjs-compat/add/observable/using';\nimport 'rxjs-compat/add/observable/throw';\nimport 'rxjs-compat/add/observable/timer';\nimport 'rxjs-compat/add/observable/zip';\nimport 'rxjs-compat/add/observable/dom/ajax';\nimport 'rxjs-compat/add/observable/dom/webSocket';\nimport 'rxjs-compat/add/operator/buffer';\nimport 'rxjs-compat/add/operator/bufferCount';\nimport 'rxjs-compat/add/operator/bufferTime';\nimport 'rxjs-compat/add/operator/bufferToggle';\nimport 'rxjs-compat/add/operator/bufferWhen';\nimport 'rxjs-compat/add/operator/catch';\nimport 'rxjs-compat/add/operator/combineAll';\nimport 'rxjs-compat/add/operator/combineLatest';\nimport 'rxjs-compat/add/operator/concat';\nimport 'rxjs-compat/add/operator/concatAll';\nimport 'rxjs-compat/add/operator/concatMap';\nimport 'rxjs-compat/add/operator/concatMapTo';\nimport 'rxjs-compat/add/operator/count';\nimport 'rxjs-compat/add/operator/dematerialize';\nimport 'rxjs-compat/add/operator/debounce';\nimport 'rxjs-compat/add/operator/debounceTime';\nimport 'rxjs-compat/add/operator/defaultIfEmpty';\nimport 'rxjs-compat/add/operator/delay';\nimport 'rxjs-compat/add/operator/delayWhen';\nimport 'rxjs-compat/add/operator/distinct';\nimport 'rxjs-compat/add/operator/distinctUntilChanged';\nimport 'rxjs-compat/add/operator/distinctUntilKeyChanged';\nimport 'rxjs-compat/add/operator/do';\nimport 'rxjs-compat/add/operator/exhaust';\nimport 'rxjs-compat/add/operator/exhaustMap';\nimport 'rxjs-compat/add/operator/expand';\nimport 'rxjs-compat/add/operator/elementAt';\nimport 'rxjs-compat/add/operator/filter';\nimport 'rxjs-compat/add/operator/finally';\nimport 'rxjs-compat/add/operator/find';\nimport 'rxjs-compat/add/operator/findIndex';\nimport 'rxjs-compat/add/operator/first';\nimport 'rxjs-compat/add/operator/groupBy';\nimport 'rxjs-compat/add/operator/ignoreElements';\nimport 'rxjs-compat/add/operator/isEmpty';\nimport 'rxjs-compat/add/operator/audit';\nimport 'rxjs-compat/add/operator/auditTime';\nimport 'rxjs-compat/add/operator/last';\nimport 'rxjs-compat/add/operator/let';\nimport 'rxjs-compat/add/operator/every';\nimport 'rxjs-compat/add/operator/map';\nimport 'rxjs-compat/add/operator/mapTo';\nimport 'rxjs-compat/add/operator/materialize';\nimport 'rxjs-compat/add/operator/max';\nimport 'rxjs-compat/add/operator/merge';\nimport 'rxjs-compat/add/operator/mergeAll';\nimport 'rxjs-compat/add/operator/mergeMap';\nimport 'rxjs-compat/add/operator/mergeMapTo';\nimport 'rxjs-compat/add/operator/mergeScan';\nimport 'rxjs-compat/add/operator/min';\nimport 'rxjs-compat/add/operator/multicast';\nimport 'rxjs-compat/add/operator/observeOn';\nimport 'rxjs-compat/add/operator/onErrorResumeNext';\nimport 'rxjs-compat/add/operator/pairwise';\nimport 'rxjs-compat/add/operator/partition';\nimport 'rxjs-compat/add/operator/pluck';\nimport 'rxjs-compat/add/operator/publish';\nimport 'rxjs-compat/add/operator/publishBehavior';\nimport 'rxjs-compat/add/operator/publishReplay';\nimport 'rxjs-compat/add/operator/publishLast';\nimport 'rxjs-compat/add/operator/race';\nimport 'rxjs-compat/add/operator/reduce';\nimport 'rxjs-compat/add/operator/repeat';\nimport 'rxjs-compat/add/operator/repeatWhen';\nimport 'rxjs-compat/add/operator/retry';\nimport 'rxjs-compat/add/operator/retryWhen';\nimport 'rxjs-compat/add/operator/sample';\nimport 'rxjs-compat/add/operator/sampleTime';\nimport 'rxjs-compat/add/operator/scan';\nimport 'rxjs-compat/add/operator/sequenceEqual';\nimport 'rxjs-compat/add/operator/share';\nimport 'rxjs-compat/add/operator/shareReplay';\nimport 'rxjs-compat/add/operator/single';\nimport 'rxjs-compat/add/operator/skip';\nimport 'rxjs-compat/add/operator/skipLast';\nimport 'rxjs-compat/add/operator/skipUntil';\nimport 'rxjs-compat/add/operator/skipWhile';\nimport 'rxjs-compat/add/operator/startWith';\nimport 'rxjs-compat/add/operator/subscribeOn';\nimport 'rxjs-compat/add/operator/switch';\nimport 'rxjs-compat/add/operator/switchMap';\nimport 'rxjs-compat/add/operator/switchMapTo';\nimport 'rxjs-compat/add/operator/take';\nimport 'rxjs-compat/add/operator/takeLast';\nimport 'rxjs-compat/add/operator/takeUntil';\nimport 'rxjs-compat/add/operator/takeWhile';\nimport 'rxjs-compat/add/operator/throttle';\nimport 'rxjs-compat/add/operator/throttleTime';\nimport 'rxjs-compat/add/operator/timeInterval';\nimport 'rxjs-compat/add/operator/timeout';\nimport 'rxjs-compat/add/operator/timeoutWith';\nimport 'rxjs-compat/add/operator/timestamp';\nimport 'rxjs-compat/add/operator/toArray';\nimport 'rxjs-compat/add/operator/toPromise';\nimport 'rxjs-compat/add/operator/window';\nimport 'rxjs-compat/add/operator/windowCount';\nimport 'rxjs-compat/add/operator/windowTime';\nimport 'rxjs-compat/add/operator/windowToggle';\nimport 'rxjs-compat/add/operator/windowWhen';\nimport 'rxjs-compat/add/operator/withLatestFrom';\nimport 'rxjs-compat/add/operator/zip';\nimport 'rxjs-compat/add/operator/zipAll';\nexport { Operator } from './Operator';\nexport { Observer } from './types';\nexport { Subscription } from './Subscription';\nexport { Subscriber } from './Subscriber';\nexport { AsyncSubject } from './AsyncSubject';\nexport { ReplaySubject } from './ReplaySubject';\nexport { BehaviorSubject } from './BehaviorSubject';\nexport { ConnectableObservable } from './observable/ConnectableObservable';\nexport { Notification } from './Notification';\nexport { EmptyError } from './util/EmptyError';\nexport { ArgumentOutOfRangeError } from './util/ArgumentOutOfRangeError';\nexport { ObjectUnsubscribedError } from './util/ObjectUnsubscribedError';\nexport { TimeoutError } from './util/TimeoutError';\nexport { UnsubscriptionError } from './util/UnsubscriptionError';\nexport { TimeInterval } from './operators/timeInterval';\nexport { Timestamp } from './operators/timestamp';\nexport { TestScheduler } from './testing/TestScheduler';\nexport { VirtualTimeScheduler } from './scheduler/VirtualTimeScheduler';\nexport { AjaxRequest, AjaxResponse, AjaxError, AjaxTimeoutError } from './observable/dom/AjaxObservable';\nexport { pipe } from './util/pipe';\nimport { AsapScheduler } from './scheduler/AsapScheduler';\nimport { AsyncScheduler } from './scheduler/AsyncScheduler';\nimport { QueueScheduler } from './scheduler/QueueScheduler';\nimport { AnimationFrameScheduler } from './scheduler/AnimationFrameScheduler';\nimport * as _operators from './operators/index';\nexport declare const operators: typeof _operators;\n/**\n * @typedef {Object} Rx.Scheduler\n * @property {SchedulerLike} asap Schedules on the micro task queue, which is the same\n * queue used for promises. Basically after the current job, but before the next job.\n * Use this for asynchronous conversions.\n * @property {SchedulerLike} queue Schedules on a queue in the current event frame\n * (trampoline scheduler). Use this for iteration operations.\n * @property {SchedulerLike} animationFrame Schedules work with `requestAnimationFrame`.\n * Use this for synchronizing with the platform's painting.\n * @property {SchedulerLike} async Schedules work with `setInterval`. Use this for\n * time-based operations.\n */\ndeclare let Scheduler: {\n    asap: AsapScheduler;\n    queue: QueueScheduler;\n    animationFrame: AnimationFrameScheduler;\n    async: AsyncScheduler;\n};\n/**\n * @typedef {Object} Rx.Symbol\n * @property {Symbol|string} rxSubscriber A symbol to use as a property name to\n * retrieve an \"Rx safe\" Observer from an object. \"Rx safety\" can be defined as\n * an object that has all of the traits of an Rx Subscriber, including the\n * ability to add and remove subscriptions to the subscription chain and\n * guarantees involving event triggering (can't \"next\" after unsubscription,\n * etc).\n * @property {Symbol|string} observable A symbol to use as a property name to\n * retrieve an Observable as defined by the [ECMAScript \"Observable\" spec](https://github.com/zenparsing/es-observable).\n * @property {Symbol|string} iterator The ES6 symbol to use as a property name\n * to retrieve an iterator from an object.\n */\ndeclare let Symbol: {\n    rxSubscriber: string | symbol;\n    observable: string | symbol;\n    iterator: symbol;\n};\nexport { Scheduler, Symbol };\n"
  },
  {
    "path": "node_modules/rxjs/internal/Scheduler.d.ts",
    "content": "import { Action } from './scheduler/Action';\nimport { Subscription } from './Subscription';\nimport { SchedulerLike, SchedulerAction } from './types';\n/**\n * An execution context and a data structure to order tasks and schedule their\n * execution. Provides a notion of (potentially virtual) time, through the\n * `now()` getter method.\n *\n * Each unit of work in a Scheduler is called an `Action`.\n *\n * ```ts\n * class Scheduler {\n *   now(): number;\n *   schedule(work, delay?, state?): Subscription;\n * }\n * ```\n *\n * @class Scheduler\n * @deprecated Scheduler is an internal implementation detail of RxJS, and\n * should not be used directly. Rather, create your own class and implement\n * {@link SchedulerLike}\n */\nexport declare class Scheduler implements SchedulerLike {\n    private SchedulerAction;\n    /**\n     * Note: the extra arrow function wrapper is to make testing by overriding\n     * Date.now easier.\n     * @nocollapse\n     */\n    static now: () => number;\n    constructor(SchedulerAction: typeof Action, now?: () => number);\n    /**\n     * A getter method that returns a number representing the current time\n     * (at the time this function was called) according to the scheduler's own\n     * internal clock.\n     * @return {number} A number that represents the current time. May or may not\n     * have a relation to wall-clock time. May or may not refer to a time unit\n     * (e.g. milliseconds).\n     */\n    now: () => number;\n    /**\n     * Schedules a function, `work`, for execution. May happen at some point in\n     * the future, according to the `delay` parameter, if specified. May be passed\n     * some context object, `state`, which will be passed to the `work` function.\n     *\n     * The given arguments will be processed an stored as an Action object in a\n     * queue of actions.\n     *\n     * @param {function(state: ?T): ?Subscription} work A function representing a\n     * task, or some unit of work to be executed by the Scheduler.\n     * @param {number} [delay] Time to wait before executing the work, where the\n     * time unit is implicit and defined by the Scheduler itself.\n     * @param {T} [state] Some contextual data that the `work` function uses when\n     * called by the Scheduler.\n     * @return {Subscription} A subscription in order to be able to unsubscribe\n     * the scheduled work.\n     */\n    schedule<T>(work: (this: SchedulerAction<T>, state?: T) => void, delay?: number, state?: T): Subscription;\n}\n"
  },
  {
    "path": "node_modules/rxjs/internal/scheduler/Action.d.ts",
    "content": "import { Scheduler } from '../Scheduler';\nimport { Subscription } from '../Subscription';\nimport { SchedulerAction } from '../types';\n/**\n * A unit of work to be executed in a `scheduler`. An action is typically\n * created from within a {@link SchedulerLike} and an RxJS user does not need to concern\n * themselves about creating and manipulating an Action.\n *\n * ```ts\n * class Action<T> extends Subscription {\n *   new (scheduler: Scheduler, work: (state?: T) => void);\n *   schedule(state?: T, delay: number = 0): Subscription;\n * }\n * ```\n *\n * @class Action<T>\n */\nexport declare class Action<T> extends Subscription {\n    constructor(scheduler: Scheduler, work: (this: SchedulerAction<T>, state?: T) => void);\n    /**\n     * Schedules this action on its parent {@link SchedulerLike} for execution. May be passed\n     * some context object, `state`. May happen at some point in the future,\n     * according to the `delay` parameter, if specified.\n     * @param {T} [state] Some contextual data that the `work` function uses when\n     * called by the Scheduler.\n     * @param {number} [delay] Time to wait before executing the work, where the\n     * time unit is implicit and defined by the Scheduler.\n     * @return {void}\n     */\n    schedule(state?: T, delay?: number): Subscription;\n}\n"
  },
  {
    "path": "node_modules/rxjs/internal/scheduler/animationFrame.d.ts",
    "content": "import { AnimationFrameScheduler } from './AnimationFrameScheduler';\n/**\n *\n * Animation Frame Scheduler\n *\n * <span class=\"informal\">Perform task when `window.requestAnimationFrame` would fire</span>\n *\n * When `animationFrame` scheduler is used with delay, it will fall back to {@link asyncScheduler} scheduler\n * behaviour.\n *\n * Without delay, `animationFrame` scheduler can be used to create smooth browser animations.\n * It makes sure scheduled task will happen just before next browser content repaint,\n * thus performing animations as efficiently as possible.\n *\n * ## Example\n * Schedule div height animation\n * ```javascript\n * const div = document.querySelector('.some-div');\n *\n * Rx.Scheduler.animationFrame.schedule(function(height) {\n *   div.style.height = height + \"px\";\n *\n *   this.schedule(height + 1);  // `this` references currently executing Action,\n *                               // which we reschedule with new state\n * }, 0, 0);\n *\n * // You will see .some-div element growing in height\n * ```\n *\n * @static true\n * @name animationFrame\n * @owner Scheduler\n */\nexport declare const animationFrame: AnimationFrameScheduler;\n"
  },
  {
    "path": "node_modules/rxjs/internal/scheduler/AnimationFrameAction.d.ts",
    "content": "import { AsyncAction } from './AsyncAction';\nimport { AnimationFrameScheduler } from './AnimationFrameScheduler';\nimport { SchedulerAction } from '../types';\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport declare class AnimationFrameAction<T> extends AsyncAction<T> {\n    protected scheduler: AnimationFrameScheduler;\n    protected work: (this: SchedulerAction<T>, state?: T) => void;\n    constructor(scheduler: AnimationFrameScheduler, work: (this: SchedulerAction<T>, state?: T) => void);\n    protected requestAsyncId(scheduler: AnimationFrameScheduler, id?: any, delay?: number): any;\n    protected recycleAsyncId(scheduler: AnimationFrameScheduler, id?: any, delay?: number): any;\n}\n"
  },
  {
    "path": "node_modules/rxjs/internal/scheduler/AnimationFrameScheduler.d.ts",
    "content": "import { AsyncAction } from './AsyncAction';\nimport { AsyncScheduler } from './AsyncScheduler';\nexport declare class AnimationFrameScheduler extends AsyncScheduler {\n    flush(action?: AsyncAction<any>): void;\n}\n"
  },
  {
    "path": "node_modules/rxjs/internal/scheduler/asap.d.ts",
    "content": "import { AsapScheduler } from './AsapScheduler';\n/**\n *\n * Asap Scheduler\n *\n * <span class=\"informal\">Perform task as fast as it can be performed asynchronously</span>\n *\n * `asap` scheduler behaves the same as {@link asyncScheduler} scheduler when you use it to delay task\n * in time. If however you set delay to `0`, `asap` will wait for current synchronously executing\n * code to end and then it will try to execute given task as fast as possible.\n *\n * `asap` scheduler will do its best to minimize time between end of currently executing code\n * and start of scheduled task. This makes it best candidate for performing so called \"deferring\".\n * Traditionally this was achieved by calling `setTimeout(deferredTask, 0)`, but that technique involves\n * some (although minimal) unwanted delay.\n *\n * Note that using `asap` scheduler does not necessarily mean that your task will be first to process\n * after currently executing code. In particular, if some task was also scheduled with `asap` before,\n * that task will execute first. That being said, if you need to schedule task asynchronously, but\n * as soon as possible, `asap` scheduler is your best bet.\n *\n * ## Example\n * Compare async and asap scheduler<\n * ```javascript\n * Rx.Scheduler.async.schedule(() => console.log('async')); // scheduling 'async' first...\n * Rx.Scheduler.asap.schedule(() => console.log('asap'));\n *\n * // Logs:\n * // \"asap\"\n * // \"async\"\n * // ... but 'asap' goes first!\n * ```\n * @static true\n * @name asap\n * @owner Scheduler\n */\nexport declare const asap: AsapScheduler;\n"
  },
  {
    "path": "node_modules/rxjs/internal/scheduler/AsapAction.d.ts",
    "content": "import { AsyncAction } from './AsyncAction';\nimport { AsapScheduler } from './AsapScheduler';\nimport { SchedulerAction } from '../types';\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport declare class AsapAction<T> extends AsyncAction<T> {\n    protected scheduler: AsapScheduler;\n    protected work: (this: SchedulerAction<T>, state?: T) => void;\n    constructor(scheduler: AsapScheduler, work: (this: SchedulerAction<T>, state?: T) => void);\n    protected requestAsyncId(scheduler: AsapScheduler, id?: any, delay?: number): any;\n    protected recycleAsyncId(scheduler: AsapScheduler, id?: any, delay?: number): any;\n}\n"
  },
  {
    "path": "node_modules/rxjs/internal/scheduler/AsapScheduler.d.ts",
    "content": "import { AsyncAction } from './AsyncAction';\nimport { AsyncScheduler } from './AsyncScheduler';\nexport declare class AsapScheduler extends AsyncScheduler {\n    flush(action?: AsyncAction<any>): void;\n}\n"
  },
  {
    "path": "node_modules/rxjs/internal/scheduler/async.d.ts",
    "content": "import { AsyncScheduler } from './AsyncScheduler';\n/**\n *\n * Async Scheduler\n *\n * <span class=\"informal\">Schedule task as if you used setTimeout(task, duration)</span>\n *\n * `async` scheduler schedules tasks asynchronously, by putting them on the JavaScript\n * event loop queue. It is best used to delay tasks in time or to schedule tasks repeating\n * in intervals.\n *\n * If you just want to \"defer\" task, that is to perform it right after currently\n * executing synchronous code ends (commonly achieved by `setTimeout(deferredTask, 0)`),\n * better choice will be the {@link asapScheduler} scheduler.\n *\n * ## Examples\n * Use async scheduler to delay task\n * ```javascript\n * const task = () => console.log('it works!');\n *\n * Rx.Scheduler.async.schedule(task, 2000);\n *\n * // After 2 seconds logs:\n * // \"it works!\"\n * ```\n *\n * Use async scheduler to repeat task in intervals\n * ```javascript\n * function task(state) {\n *   console.log(state);\n *   this.schedule(state + 1, 1000); // `this` references currently executing Action,\n *                                   // which we reschedule with new state and delay\n * }\n *\n * Rx.Scheduler.async.schedule(task, 3000, 0);\n *\n * // Logs:\n * // 0 after 3s\n * // 1 after 4s\n * // 2 after 5s\n * // 3 after 6s\n * ```\n *\n * @static true\n * @name async\n * @owner Scheduler\n */\nexport declare const async: AsyncScheduler;\n"
  },
  {
    "path": "node_modules/rxjs/internal/scheduler/AsyncAction.d.ts",
    "content": "import { Action } from './Action';\nimport { SchedulerAction } from '../types';\nimport { Subscription } from '../Subscription';\nimport { AsyncScheduler } from './AsyncScheduler';\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport declare class AsyncAction<T> extends Action<T> {\n    protected scheduler: AsyncScheduler;\n    protected work: (this: SchedulerAction<T>, state?: T) => void;\n    id: any;\n    state: T;\n    delay: number;\n    protected pending: boolean;\n    constructor(scheduler: AsyncScheduler, work: (this: SchedulerAction<T>, state?: T) => void);\n    schedule(state?: T, delay?: number): Subscription;\n    protected requestAsyncId(scheduler: AsyncScheduler, id?: any, delay?: number): any;\n    protected recycleAsyncId(scheduler: AsyncScheduler, id: any, delay?: number): any;\n    /**\n     * Immediately executes this action and the `work` it contains.\n     * @return {any}\n     */\n    execute(state: T, delay: number): any;\n    protected _execute(state: T, delay: number): any;\n    /** @deprecated This is an internal implementation detail, do not use. */\n    _unsubscribe(): void;\n}\n"
  },
  {
    "path": "node_modules/rxjs/internal/scheduler/AsyncScheduler.d.ts",
    "content": "import { Scheduler } from '../Scheduler';\nimport { Action } from './Action';\nimport { AsyncAction } from './AsyncAction';\nimport { SchedulerAction } from '../types';\nimport { Subscription } from '../Subscription';\nexport declare class AsyncScheduler extends Scheduler {\n    static delegate?: Scheduler;\n    actions: Array<AsyncAction<any>>;\n    /**\n     * A flag to indicate whether the Scheduler is currently executing a batch of\n     * queued actions.\n     * @type {boolean}\n     * @deprecated internal use only\n     */\n    active: boolean;\n    /**\n     * An internal ID used to track the latest asynchronous task such as those\n     * coming from `setTimeout`, `setInterval`, `requestAnimationFrame`, and\n     * others.\n     * @type {any}\n     * @deprecated internal use only\n     */\n    scheduled: any;\n    constructor(SchedulerAction: typeof Action, now?: () => number);\n    schedule<T>(work: (this: SchedulerAction<T>, state?: T) => void, delay?: number, state?: T): Subscription;\n    flush(action: AsyncAction<any>): void;\n}\n"
  },
  {
    "path": "node_modules/rxjs/internal/scheduler/queue.d.ts",
    "content": "import { QueueScheduler } from './QueueScheduler';\n/**\n *\n * Queue Scheduler\n *\n * <span class=\"informal\">Put every next task on a queue, instead of executing it immediately</span>\n *\n * `queue` scheduler, when used with delay, behaves the same as {@link asyncScheduler} scheduler.\n *\n * When used without delay, it schedules given task synchronously - executes it right when\n * it is scheduled. However when called recursively, that is when inside the scheduled task,\n * another task is scheduled with queue scheduler, instead of executing immediately as well,\n * that task will be put on a queue and wait for current one to finish.\n *\n * This means that when you execute task with `queue` scheduler, you are sure it will end\n * before any other task scheduled with that scheduler will start.\n *\n * ## Examples\n * Schedule recursively first, then do something\n * ```javascript\n * Rx.Scheduler.queue.schedule(() => {\n *   Rx.Scheduler.queue.schedule(() => console.log('second')); // will not happen now, but will be put on a queue\n *\n *   console.log('first');\n * });\n *\n * // Logs:\n * // \"first\"\n * // \"second\"\n * ```\n *\n * Reschedule itself recursively\n * ```javascript\n * Rx.Scheduler.queue.schedule(function(state) {\n *   if (state !== 0) {\n *     console.log('before', state);\n *     this.schedule(state - 1); // `this` references currently executing Action,\n *                               // which we reschedule with new state\n *     console.log('after', state);\n *   }\n * }, 0, 3);\n *\n * // In scheduler that runs recursively, you would expect:\n * // \"before\", 3\n * // \"before\", 2\n * // \"before\", 1\n * // \"after\", 1\n * // \"after\", 2\n * // \"after\", 3\n *\n * // But with queue it logs:\n * // \"before\", 3\n * // \"after\", 3\n * // \"before\", 2\n * // \"after\", 2\n * // \"before\", 1\n * // \"after\", 1\n * ```\n *\n * @static true\n * @name queue\n * @owner Scheduler\n */\nexport declare const queue: QueueScheduler;\n"
  },
  {
    "path": "node_modules/rxjs/internal/scheduler/QueueAction.d.ts",
    "content": "import { AsyncAction } from './AsyncAction';\nimport { Subscription } from '../Subscription';\nimport { QueueScheduler } from './QueueScheduler';\nimport { SchedulerAction } from '../types';\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport declare class QueueAction<T> extends AsyncAction<T> {\n    protected scheduler: QueueScheduler;\n    protected work: (this: SchedulerAction<T>, state?: T) => void;\n    constructor(scheduler: QueueScheduler, work: (this: SchedulerAction<T>, state?: T) => void);\n    schedule(state?: T, delay?: number): Subscription;\n    execute(state: T, delay: number): any;\n    protected requestAsyncId(scheduler: QueueScheduler, id?: any, delay?: number): any;\n}\n"
  },
  {
    "path": "node_modules/rxjs/internal/scheduler/QueueScheduler.d.ts",
    "content": "import { AsyncScheduler } from './AsyncScheduler';\nexport declare class QueueScheduler extends AsyncScheduler {\n}\n"
  },
  {
    "path": "node_modules/rxjs/internal/scheduler/VirtualTimeScheduler.d.ts",
    "content": "import { AsyncAction } from './AsyncAction';\nimport { Subscription } from '../Subscription';\nimport { AsyncScheduler } from './AsyncScheduler';\nimport { SchedulerAction } from '../types';\nexport declare class VirtualTimeScheduler extends AsyncScheduler {\n    maxFrames: number;\n    protected static frameTimeFactor: number;\n    frame: number;\n    index: number;\n    constructor(SchedulerAction?: typeof AsyncAction, maxFrames?: number);\n    /**\n     * Prompt the Scheduler to execute all of its queued actions, therefore\n     * clearing its queue.\n     * @return {void}\n     */\n    flush(): void;\n}\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @nodoc\n */\nexport declare class VirtualAction<T> extends AsyncAction<T> {\n    protected scheduler: VirtualTimeScheduler;\n    protected work: (this: SchedulerAction<T>, state?: T) => void;\n    protected index: number;\n    protected active: boolean;\n    constructor(scheduler: VirtualTimeScheduler, work: (this: SchedulerAction<T>, state?: T) => void, index?: number);\n    schedule(state?: T, delay?: number): Subscription;\n    protected requestAsyncId(scheduler: VirtualTimeScheduler, id?: any, delay?: number): any;\n    protected recycleAsyncId(scheduler: VirtualTimeScheduler, id?: any, delay?: number): any;\n    protected _execute(state: T, delay: number): any;\n    static sortActions<T>(a: VirtualAction<T>, b: VirtualAction<T>): 1 | -1 | 0;\n}\n"
  },
  {
    "path": "node_modules/rxjs/internal/Subject.d.ts",
    "content": "import { Operator } from './Operator';\nimport { Observable } from './Observable';\nimport { Subscriber } from './Subscriber';\nimport { Subscription } from './Subscription';\nimport { Observer, SubscriptionLike, TeardownLogic } from './types';\n/**\n * @class SubjectSubscriber<T>\n */\nexport declare class SubjectSubscriber<T> extends Subscriber<T> {\n    protected destination: Subject<T>;\n    constructor(destination: Subject<T>);\n}\n/**\n * A Subject is a special type of Observable that allows values to be\n * multicasted to many Observables. Subjects are like EventEmitters.\n *\n * Every Subject is an Observable and an Observer. You can subscribe to a\n * Subject, and you can call next to feed values as well as error and complete.\n *\n * @class Subject<T>\n */\nexport declare class Subject<T> extends Observable<T> implements SubscriptionLike {\n    observers: Observer<T>[];\n    closed: boolean;\n    isStopped: boolean;\n    hasError: boolean;\n    thrownError: any;\n    constructor();\n    /**@nocollapse */\n    static create: Function;\n    lift<R>(operator: Operator<T, R>): Observable<R>;\n    next(value?: T): void;\n    error(err: any): void;\n    complete(): void;\n    unsubscribe(): void;\n    /** @deprecated This is an internal implementation detail, do not use. */\n    _trySubscribe(subscriber: Subscriber<T>): TeardownLogic;\n    /** @deprecated This is an internal implementation detail, do not use. */\n    _subscribe(subscriber: Subscriber<T>): Subscription;\n    /**\n     * Creates a new Observable with this Subject as the source. You can do this\n     * to create customize Observer-side logic of the Subject and conceal it from\n     * code that uses the Observable.\n     * @return {Observable} Observable that the Subject casts to\n     */\n    asObservable(): Observable<T>;\n}\n/**\n * @class AnonymousSubject<T>\n */\nexport declare class AnonymousSubject<T> extends Subject<T> {\n    protected destination?: Observer<T>;\n    constructor(destination?: Observer<T>, source?: Observable<T>);\n    next(value: T): void;\n    error(err: any): void;\n    complete(): void;\n    /** @deprecated This is an internal implementation detail, do not use. */\n    _subscribe(subscriber: Subscriber<T>): Subscription;\n}\n"
  },
  {
    "path": "node_modules/rxjs/internal/SubjectSubscription.d.ts",
    "content": "import { Subject } from './Subject';\nimport { Observer } from './types';\nimport { Subscription } from './Subscription';\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport declare class SubjectSubscription<T> extends Subscription {\n    subject: Subject<T>;\n    subscriber: Observer<T>;\n    closed: boolean;\n    constructor(subject: Subject<T>, subscriber: Observer<T>);\n    unsubscribe(): void;\n}\n"
  },
  {
    "path": "node_modules/rxjs/internal/Subscriber.d.ts",
    "content": "import { Observer, PartialObserver } from './types';\nimport { Subscription } from './Subscription';\n/**\n * Implements the {@link Observer} interface and extends the\n * {@link Subscription} class. While the {@link Observer} is the public API for\n * consuming the values of an {@link Observable}, all Observers get converted to\n * a Subscriber, in order to provide Subscription-like capabilities such as\n * `unsubscribe`. Subscriber is a common type in RxJS, and crucial for\n * implementing operators, but it is rarely used as a public API.\n *\n * @class Subscriber<T>\n */\nexport declare class Subscriber<T> extends Subscription implements Observer<T> {\n    /**\n     * A static factory for a Subscriber, given a (potentially partial) definition\n     * of an Observer.\n     * @param {function(x: ?T): void} [next] The `next` callback of an Observer.\n     * @param {function(e: ?any): void} [error] The `error` callback of an\n     * Observer.\n     * @param {function(): void} [complete] The `complete` callback of an\n     * Observer.\n     * @return {Subscriber<T>} A Subscriber wrapping the (partially defined)\n     * Observer represented by the given arguments.\n     * @nocollapse\n     */\n    static create<T>(next?: (x?: T) => void, error?: (e?: any) => void, complete?: () => void): Subscriber<T>;\n    /** @internal */ syncErrorValue: any;\n    /** @internal */ syncErrorThrown: boolean;\n    /** @internal */ syncErrorThrowable: boolean;\n    protected isStopped: boolean;\n    protected destination: PartialObserver<any> | Subscriber<any>;\n    private _parentSubscription;\n    /**\n     * @param {Observer|function(value: T): void} [destinationOrNext] A partially\n     * defined Observer or a `next` callback function.\n     * @param {function(e: ?any): void} [error] The `error` callback of an\n     * Observer.\n     * @param {function(): void} [complete] The `complete` callback of an\n     * Observer.\n     */\n    constructor(destinationOrNext?: PartialObserver<any> | ((value: T) => void), error?: (e?: any) => void, complete?: () => void);\n    /**\n     * The {@link Observer} callback to receive notifications of type `next` from\n     * the Observable, with a value. The Observable may call this method 0 or more\n     * times.\n     * @param {T} [value] The `next` value.\n     * @return {void}\n     */\n    next(value?: T): void;\n    /**\n     * The {@link Observer} callback to receive notifications of type `error` from\n     * the Observable, with an attached `Error`. Notifies the Observer that\n     * the Observable has experienced an error condition.\n     * @param {any} [err] The `error` exception.\n     * @return {void}\n     */\n    error(err?: any): void;\n    /**\n     * The {@link Observer} callback to receive a valueless notification of type\n     * `complete` from the Observable. Notifies the Observer that the Observable\n     * has finished sending push-based notifications.\n     * @return {void}\n     */\n    complete(): void;\n    unsubscribe(): void;\n    protected _next(value: T): void;\n    protected _error(err: any): void;\n    protected _complete(): void;\n    /** @deprecated This is an internal implementation detail, do not use. */\n    _unsubscribeAndRecycle(): Subscriber<T>;\n}\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport declare class SafeSubscriber<T> extends Subscriber<T> {\n    private _parentSubscriber;\n    private _context;\n    constructor(_parentSubscriber: Subscriber<T>, observerOrNext?: PartialObserver<T> | ((value: T) => void), error?: (e?: any) => void, complete?: () => void);\n    next(value?: T): void;\n    error(err?: any): void;\n    complete(): void;\n    private __tryOrUnsub;\n    private __tryOrSetError;\n    /** @internal This is an internal implementation detail, do not use. */\n    _unsubscribe(): void;\n}\n"
  },
  {
    "path": "node_modules/rxjs/internal/Subscription.d.ts",
    "content": "import { SubscriptionLike, TeardownLogic } from './types';\n/**\n * Represents a disposable resource, such as the execution of an Observable. A\n * Subscription has one important method, `unsubscribe`, that takes no argument\n * and just disposes the resource held by the subscription.\n *\n * Additionally, subscriptions may be grouped together through the `add()`\n * method, which will attach a child Subscription to the current Subscription.\n * When a Subscription is unsubscribed, all its children (and its grandchildren)\n * will be unsubscribed as well.\n *\n * @class Subscription\n */\nexport declare class Subscription implements SubscriptionLike {\n    /** @nocollapse */\n    static EMPTY: Subscription;\n    /**\n     * A flag to indicate whether this Subscription has already been unsubscribed.\n     * @type {boolean}\n     */\n    closed: boolean;\n    /** @internal */\n    protected _parent: Subscription;\n    /** @internal */\n    protected _parents: Subscription[];\n    /** @internal */\n    private _subscriptions;\n    /**\n     * @param {function(): void} [unsubscribe] A function describing how to\n     * perform the disposal of resources when the `unsubscribe` method is called.\n     */\n    constructor(unsubscribe?: () => void);\n    /**\n     * Disposes the resources held by the subscription. May, for instance, cancel\n     * an ongoing Observable execution or cancel any other type of work that\n     * started when the Subscription was created.\n     * @return {void}\n     */\n    unsubscribe(): void;\n    /**\n     * Adds a tear down to be called during the unsubscribe() of this\n     * Subscription.\n     *\n     * If the tear down being added is a subscription that is already\n     * unsubscribed, is the same reference `add` is being called on, or is\n     * `Subscription.EMPTY`, it will not be added.\n     *\n     * If this subscription is already in an `closed` state, the passed\n     * tear down logic will be executed immediately.\n     *\n     * @param {TeardownLogic} teardown The additional logic to execute on\n     * teardown.\n     * @return {Subscription} Returns the Subscription used or created to be\n     * added to the inner subscriptions list. This Subscription can be used with\n     * `remove()` to remove the passed teardown logic from the inner subscriptions\n     * list.\n     */\n    add(teardown: TeardownLogic): Subscription;\n    /**\n     * Removes a Subscription from the internal list of subscriptions that will\n     * unsubscribe during the unsubscribe process of this Subscription.\n     * @param {Subscription} subscription The subscription to remove.\n     * @return {void}\n     */\n    remove(subscription: Subscription): void;\n    /** @internal */\n    private _addParent;\n}\n"
  },
  {
    "path": "node_modules/rxjs/internal/symbol/iterator.d.ts",
    "content": "export declare function getSymbolIterator(): symbol;\nexport declare const iterator: symbol;\n/**\n * @deprecated use {@link iterator} instead\n */\nexport declare const $$iterator: symbol;\n"
  },
  {
    "path": "node_modules/rxjs/internal/symbol/observable.d.ts",
    "content": "/** Symbol.observable addition */\ndeclare global {\n    interface SymbolConstructor {\n        readonly observable: symbol;\n    }\n}\n/** Symbol.observable or a string \"@@observable\". Used for interop */\nexport declare const observable: string | symbol;\n"
  },
  {
    "path": "node_modules/rxjs/internal/symbol/rxSubscriber.d.ts",
    "content": "/** @deprecated do not use, this is no longer checked by RxJS internals */\nexport declare const rxSubscriber: string | symbol;\n/**\n * @deprecated use rxSubscriber instead\n */\nexport declare const $$rxSubscriber: string | symbol;\n"
  },
  {
    "path": "node_modules/rxjs/internal/testing/ColdObservable.d.ts",
    "content": "import { Observable } from '../Observable';\nimport { Scheduler } from '../Scheduler';\nimport { TestMessage } from './TestMessage';\nimport { SubscriptionLog } from './SubscriptionLog';\nimport { SubscriptionLoggable } from './SubscriptionLoggable';\nimport { Subscriber } from '../Subscriber';\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport declare class ColdObservable<T> extends Observable<T> implements SubscriptionLoggable {\n    messages: TestMessage[];\n    subscriptions: SubscriptionLog[];\n    scheduler: Scheduler;\n    logSubscribedFrame: () => number;\n    logUnsubscribedFrame: (index: number) => void;\n    constructor(messages: TestMessage[], scheduler: Scheduler);\n    scheduleMessages(subscriber: Subscriber<any>): void;\n}\n"
  },
  {
    "path": "node_modules/rxjs/internal/testing/HotObservable.d.ts",
    "content": "import { Subject } from '../Subject';\nimport { Subscriber } from '../Subscriber';\nimport { Subscription } from '../Subscription';\nimport { Scheduler } from '../Scheduler';\nimport { TestMessage } from './TestMessage';\nimport { SubscriptionLog } from './SubscriptionLog';\nimport { SubscriptionLoggable } from './SubscriptionLoggable';\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport declare class HotObservable<T> extends Subject<T> implements SubscriptionLoggable {\n    messages: TestMessage[];\n    subscriptions: SubscriptionLog[];\n    scheduler: Scheduler;\n    logSubscribedFrame: () => number;\n    logUnsubscribedFrame: (index: number) => void;\n    constructor(messages: TestMessage[], scheduler: Scheduler);\n    /** @deprecated This is an internal implementation detail, do not use. */\n    _subscribe(subscriber: Subscriber<any>): Subscription;\n    setup(): void;\n}\n"
  },
  {
    "path": "node_modules/rxjs/internal/testing/SubscriptionLog.d.ts",
    "content": "export declare class SubscriptionLog {\n    subscribedFrame: number;\n    unsubscribedFrame: number;\n    constructor(subscribedFrame: number, unsubscribedFrame?: number);\n}\n"
  },
  {
    "path": "node_modules/rxjs/internal/testing/SubscriptionLoggable.d.ts",
    "content": "import { Scheduler } from '../Scheduler';\nimport { SubscriptionLog } from './SubscriptionLog';\nexport declare class SubscriptionLoggable {\n    subscriptions: SubscriptionLog[];\n    scheduler: Scheduler;\n    logSubscribedFrame(): number;\n    logUnsubscribedFrame(index: number): void;\n}\n"
  },
  {
    "path": "node_modules/rxjs/internal/testing/TestMessage.d.ts",
    "content": "import { Notification } from '../Notification';\nexport interface TestMessage {\n    frame: number;\n    notification: Notification<any>;\n    isGhost?: boolean;\n}\n"
  },
  {
    "path": "node_modules/rxjs/internal/testing/TestScheduler.d.ts",
    "content": "import { Observable } from '../Observable';\nimport { ColdObservable } from './ColdObservable';\nimport { HotObservable } from './HotObservable';\nimport { TestMessage } from './TestMessage';\nimport { SubscriptionLog } from './SubscriptionLog';\nimport { VirtualTimeScheduler } from '../scheduler/VirtualTimeScheduler';\nexport interface RunHelpers {\n    cold: typeof TestScheduler.prototype.createColdObservable;\n    hot: typeof TestScheduler.prototype.createHotObservable;\n    flush: typeof TestScheduler.prototype.flush;\n    expectObservable: typeof TestScheduler.prototype.expectObservable;\n    expectSubscriptions: typeof TestScheduler.prototype.expectSubscriptions;\n}\nexport declare type observableToBeFn = (marbles: string, values?: any, errorValue?: any) => void;\nexport declare type subscriptionLogsToBeFn = (marbles: string | string[]) => void;\nexport declare class TestScheduler extends VirtualTimeScheduler {\n    assertDeepEqual: (actual: any, expected: any) => boolean | void;\n    readonly hotObservables: HotObservable<any>[];\n    readonly coldObservables: ColdObservable<any>[];\n    private flushTests;\n    private runMode;\n    constructor(assertDeepEqual: (actual: any, expected: any) => boolean | void);\n    createTime(marbles: string): number;\n    /**\n     * @param marbles A diagram in the marble DSL. Letters map to keys in `values` if provided.\n     * @param values Values to use for the letters in `marbles`. If ommitted, the letters themselves are used.\n     * @param error The error to use for the `#` marble (if present).\n     */\n    createColdObservable<T = string>(marbles: string, values?: {\n        [marble: string]: T;\n    }, error?: any): ColdObservable<T>;\n    /**\n     * @param marbles A diagram in the marble DSL. Letters map to keys in `values` if provided.\n     * @param values Values to use for the letters in `marbles`. If ommitted, the letters themselves are used.\n     * @param error The error to use for the `#` marble (if present).\n     */\n    createHotObservable<T = string>(marbles: string, values?: {\n        [marble: string]: T;\n    }, error?: any): HotObservable<T>;\n    private materializeInnerObservable;\n    expectObservable(observable: Observable<any>, subscriptionMarbles?: string): ({\n        toBe: observableToBeFn;\n    });\n    expectSubscriptions(actualSubscriptionLogs: SubscriptionLog[]): ({\n        toBe: subscriptionLogsToBeFn;\n    });\n    flush(): void;\n    /** @nocollapse */\n    static parseMarblesAsSubscriptions(marbles: string, runMode?: boolean): SubscriptionLog;\n    /** @nocollapse */\n    static parseMarbles(marbles: string, values?: any, errorValue?: any, materializeInnerObservables?: boolean, runMode?: boolean): TestMessage[];\n    run<T>(callback: (helpers: RunHelpers) => T): T;\n}\n"
  },
  {
    "path": "node_modules/rxjs/internal/types.d.ts",
    "content": "import { Observable } from './Observable';\nimport { Subscription } from './Subscription';\n/** OPERATOR INTERFACES */\nexport interface UnaryFunction<T, R> {\n    (source: T): R;\n}\nexport interface OperatorFunction<T, R> extends UnaryFunction<Observable<T>, Observable<R>> {\n}\nexport declare type FactoryOrValue<T> = T | (() => T);\nexport interface MonoTypeOperatorFunction<T> extends OperatorFunction<T, T> {\n}\nexport interface Timestamp<T> {\n    value: T;\n    timestamp: number;\n}\nexport interface TimeInterval<T> {\n    value: T;\n    interval: number;\n}\n/** SUBSCRIPTION INTERFACES */\nexport interface Unsubscribable {\n    unsubscribe(): void;\n}\nexport declare type TeardownLogic = Unsubscribable | Function | void;\nexport interface SubscriptionLike extends Unsubscribable {\n    unsubscribe(): void;\n    readonly closed: boolean;\n}\nexport declare type SubscribableOrPromise<T> = Subscribable<T> | Subscribable<never> | PromiseLike<T> | InteropObservable<T>;\n/** OBSERVABLE INTERFACES */\nexport interface Subscribable<T> {\n    subscribe(observer?: PartialObserver<T>): Unsubscribable;\n    subscribe(next?: (value: T) => void, error?: (error: any) => void, complete?: () => void): Unsubscribable;\n}\nexport declare type ObservableInput<T> = SubscribableOrPromise<T> | ArrayLike<T> | Iterable<T>;\n/** @deprecated use {@link InteropObservable } */\nexport declare type ObservableLike<T> = InteropObservable<T>;\nexport declare type InteropObservable<T> = {\n    [Symbol.observable]: () => Subscribable<T>;\n};\n/** OBSERVER INTERFACES */\nexport interface NextObserver<T> {\n    closed?: boolean;\n    next: (value: T) => void;\n    error?: (err: any) => void;\n    complete?: () => void;\n}\nexport interface ErrorObserver<T> {\n    closed?: boolean;\n    next?: (value: T) => void;\n    error: (err: any) => void;\n    complete?: () => void;\n}\nexport interface CompletionObserver<T> {\n    closed?: boolean;\n    next?: (value: T) => void;\n    error?: (err: any) => void;\n    complete: () => void;\n}\nexport declare type PartialObserver<T> = NextObserver<T> | ErrorObserver<T> | CompletionObserver<T>;\nexport interface Observer<T> {\n    closed?: boolean;\n    next: (value: T) => void;\n    error: (err: any) => void;\n    complete: () => void;\n}\n/** SCHEDULER INTERFACES */\nexport interface SchedulerLike {\n    now(): number;\n    schedule<T>(work: (this: SchedulerAction<T>, state?: T) => void, delay?: number, state?: T): Subscription;\n}\nexport interface SchedulerAction<T> extends Subscription {\n    schedule(state?: T, delay?: number): Subscription;\n}\n"
  },
  {
    "path": "node_modules/rxjs/internal/util/applyMixins.d.ts",
    "content": "export declare function applyMixins(derivedCtor: any, baseCtors: any[]): void;\n"
  },
  {
    "path": "node_modules/rxjs/internal/util/ArgumentOutOfRangeError.d.ts",
    "content": "export interface ArgumentOutOfRangeError extends Error {\n}\nexport interface ArgumentOutOfRangeErrorCtor {\n    new (): ArgumentOutOfRangeError;\n}\n/**\n * An error thrown when an element was queried at a certain index of an\n * Observable, but no such index or position exists in that sequence.\n *\n * @see {@link elementAt}\n * @see {@link take}\n * @see {@link takeLast}\n *\n * @class ArgumentOutOfRangeError\n */\nexport declare const ArgumentOutOfRangeError: ArgumentOutOfRangeErrorCtor;\n"
  },
  {
    "path": "node_modules/rxjs/internal/util/canReportError.d.ts",
    "content": "import { Subscriber } from '../Subscriber';\nimport { Subject } from '../Subject';\n/**\n * Determines whether the ErrorObserver is closed or stopped or has a\n * destination that is closed or stopped - in which case errors will\n * need to be reported via a different mechanism.\n * @param observer the observer\n */\nexport declare function canReportError(observer: Subscriber<any> | Subject<any>): boolean;\n"
  },
  {
    "path": "node_modules/rxjs/internal/util/EmptyError.d.ts",
    "content": "export interface EmptyError extends Error {\n}\nexport interface EmptyErrorCtor {\n    new (): EmptyError;\n}\n/**\n * An error thrown when an Observable or a sequence was queried but has no\n * elements.\n *\n * @see {@link first}\n * @see {@link last}\n * @see {@link single}\n *\n * @class EmptyError\n */\nexport declare const EmptyError: EmptyErrorCtor;\n"
  },
  {
    "path": "node_modules/rxjs/internal/util/errorObject.d.ts",
    "content": "export declare const errorObject: any;\n"
  },
  {
    "path": "node_modules/rxjs/internal/util/hostReportError.d.ts",
    "content": "/**\n * Throws an error on another job so that it's picked up by the runtime's\n * uncaught error handling mechanism.\n * @param err the error to throw\n */\nexport declare function hostReportError(err: any): void;\n"
  },
  {
    "path": "node_modules/rxjs/internal/util/identity.d.ts",
    "content": "export declare function identity<T>(x: T): T;\n"
  },
  {
    "path": "node_modules/rxjs/internal/util/Immediate.d.ts",
    "content": "export declare const Immediate: {\n    setImmediate(cb: () => void): number;\n    clearImmediate(handle: number): void;\n};\n"
  },
  {
    "path": "node_modules/rxjs/internal/util/isArray.d.ts",
    "content": "export declare const isArray: (arg: any) => arg is any[];\n"
  },
  {
    "path": "node_modules/rxjs/internal/util/isArrayLike.d.ts",
    "content": "export declare const isArrayLike: <T>(x: any) => x is ArrayLike<T>;\n"
  },
  {
    "path": "node_modules/rxjs/internal/util/isDate.d.ts",
    "content": "export declare function isDate(value: any): value is Date;\n"
  },
  {
    "path": "node_modules/rxjs/internal/util/isFunction.d.ts",
    "content": "export declare function isFunction(x: any): x is Function;\n"
  },
  {
    "path": "node_modules/rxjs/internal/util/isInteropObservable.d.ts",
    "content": "import { InteropObservable } from '../types';\n/** Identifies an input as being Observable (but not necessary an Rx Observable) */\nexport declare function isInteropObservable(input: any): input is InteropObservable<any>;\n"
  },
  {
    "path": "node_modules/rxjs/internal/util/isIterable.d.ts",
    "content": "/** Identifies an input as being an Iterable */\nexport declare function isIterable(input: any): input is Iterable<any>;\n"
  },
  {
    "path": "node_modules/rxjs/internal/util/isNumeric.d.ts",
    "content": "export declare function isNumeric(val: any): val is number | string;\n"
  },
  {
    "path": "node_modules/rxjs/internal/util/isObject.d.ts",
    "content": "export declare function isObject(x: any): x is Object;\n"
  },
  {
    "path": "node_modules/rxjs/internal/util/isObservable.d.ts",
    "content": "import { Observable } from '../Observable';\n/**\n * Tests to see if the object is an RxJS {@link Observable}\n * @param obj the object to test\n */\nexport declare function isObservable<T>(obj: any): obj is Observable<T>;\n"
  },
  {
    "path": "node_modules/rxjs/internal/util/isPromise.d.ts",
    "content": "export declare function isPromise(value: any): value is PromiseLike<any>;\n"
  },
  {
    "path": "node_modules/rxjs/internal/util/isScheduler.d.ts",
    "content": "import { SchedulerLike } from '../types';\nexport declare function isScheduler(value: any): value is SchedulerLike;\n"
  },
  {
    "path": "node_modules/rxjs/internal/util/noop.d.ts",
    "content": "export declare function noop(): void;\n"
  },
  {
    "path": "node_modules/rxjs/internal/util/not.d.ts",
    "content": "export declare function not(pred: Function, thisArg: any): Function;\n"
  },
  {
    "path": "node_modules/rxjs/internal/util/ObjectUnsubscribedError.d.ts",
    "content": "export interface ObjectUnsubscribedError extends Error {\n}\nexport interface ObjectUnsubscribedErrorCtor {\n    new (): ObjectUnsubscribedError;\n}\n/**\n * An error thrown when an action is invalid because the object has been\n * unsubscribed.\n *\n * @see {@link Subject}\n * @see {@link BehaviorSubject}\n *\n * @class ObjectUnsubscribedError\n */\nexport declare const ObjectUnsubscribedError: ObjectUnsubscribedErrorCtor;\n"
  },
  {
    "path": "node_modules/rxjs/internal/util/pipe.d.ts",
    "content": "import { UnaryFunction } from '../types';\nexport declare function pipe<T>(): UnaryFunction<T, T>;\nexport declare function pipe<T, A>(fn1: UnaryFunction<T, A>): UnaryFunction<T, A>;\nexport declare function pipe<T, A, B>(fn1: UnaryFunction<T, A>, fn2: UnaryFunction<A, B>): UnaryFunction<T, B>;\nexport declare function pipe<T, A, B, C>(fn1: UnaryFunction<T, A>, fn2: UnaryFunction<A, B>, fn3: UnaryFunction<B, C>): UnaryFunction<T, C>;\nexport declare function pipe<T, A, B, C, D>(fn1: UnaryFunction<T, A>, fn2: UnaryFunction<A, B>, fn3: UnaryFunction<B, C>, fn4: UnaryFunction<C, D>): UnaryFunction<T, D>;\nexport declare function pipe<T, A, B, C, D, E>(fn1: UnaryFunction<T, A>, fn2: UnaryFunction<A, B>, fn3: UnaryFunction<B, C>, fn4: UnaryFunction<C, D>, fn5: UnaryFunction<D, E>): UnaryFunction<T, E>;\nexport declare function pipe<T, A, B, C, D, E, F>(fn1: UnaryFunction<T, A>, fn2: UnaryFunction<A, B>, fn3: UnaryFunction<B, C>, fn4: UnaryFunction<C, D>, fn5: UnaryFunction<D, E>, fn6: UnaryFunction<E, F>): UnaryFunction<T, F>;\nexport declare function pipe<T, A, B, C, D, E, F, G>(fn1: UnaryFunction<T, A>, fn2: UnaryFunction<A, B>, fn3: UnaryFunction<B, C>, fn4: UnaryFunction<C, D>, fn5: UnaryFunction<D, E>, fn6: UnaryFunction<E, F>, fn7: UnaryFunction<F, G>): UnaryFunction<T, G>;\nexport declare function pipe<T, A, B, C, D, E, F, G, H>(fn1: UnaryFunction<T, A>, fn2: UnaryFunction<A, B>, fn3: UnaryFunction<B, C>, fn4: UnaryFunction<C, D>, fn5: UnaryFunction<D, E>, fn6: UnaryFunction<E, F>, fn7: UnaryFunction<F, G>, fn8: UnaryFunction<G, H>): UnaryFunction<T, H>;\nexport declare function pipe<T, A, B, C, D, E, F, G, H, I>(fn1: UnaryFunction<T, A>, fn2: UnaryFunction<A, B>, fn3: UnaryFunction<B, C>, fn4: UnaryFunction<C, D>, fn5: UnaryFunction<D, E>, fn6: UnaryFunction<E, F>, fn7: UnaryFunction<F, G>, fn8: UnaryFunction<G, H>, fn9: UnaryFunction<H, I>): UnaryFunction<T, I>;\nexport declare function pipe<T, A, B, C, D, E, F, G, H, I>(fn1: UnaryFunction<T, A>, fn2: UnaryFunction<A, B>, fn3: UnaryFunction<B, C>, fn4: UnaryFunction<C, D>, fn5: UnaryFunction<D, E>, fn6: UnaryFunction<E, F>, fn7: UnaryFunction<F, G>, fn8: UnaryFunction<G, H>, fn9: UnaryFunction<H, I>, ...fns: UnaryFunction<any, any>[]): UnaryFunction<T, {}>;\n/** @internal */\nexport declare function pipeFromArray<T, R>(fns: Array<UnaryFunction<T, R>>): UnaryFunction<T, R>;\n"
  },
  {
    "path": "node_modules/rxjs/internal/util/root.d.ts",
    "content": "declare const _root: any;\nexport { _root as root };\n"
  },
  {
    "path": "node_modules/rxjs/internal/util/subscribeTo.d.ts",
    "content": "import { ObservableInput } from '../types';\nimport { Subscriber } from '../Subscriber';\nexport declare const subscribeTo: <T>(result: ObservableInput<T>) => (subscriber: Subscriber<{}>) => any;\n"
  },
  {
    "path": "node_modules/rxjs/internal/util/subscribeToArray.d.ts",
    "content": "import { Subscriber } from '../Subscriber';\n/**\n * Subscribes to an ArrayLike with a subscriber\n * @param array The array or array-like to subscribe to\n */\nexport declare const subscribeToArray: <T>(array: ArrayLike<T>) => (subscriber: Subscriber<T>) => void;\n"
  },
  {
    "path": "node_modules/rxjs/internal/util/subscribeToIterable.d.ts",
    "content": "import { Subscriber } from '../Subscriber';\nexport declare const subscribeToIterable: <T>(iterable: Iterable<T>) => (subscriber: Subscriber<T>) => Subscriber<T>;\n"
  },
  {
    "path": "node_modules/rxjs/internal/util/subscribeToObservable.d.ts",
    "content": "import { Subscriber } from '../Subscriber';\n/**\n * Subscribes to an object that implements Symbol.observable with the given\n * Subscriber.\n * @param obj An object that implements Symbol.observable\n */\nexport declare const subscribeToObservable: <T>(obj: any) => (subscriber: Subscriber<T>) => any;\n"
  },
  {
    "path": "node_modules/rxjs/internal/util/subscribeToPromise.d.ts",
    "content": "import { Subscriber } from '../Subscriber';\nexport declare const subscribeToPromise: <T>(promise: PromiseLike<T>) => (subscriber: Subscriber<T>) => Subscriber<T>;\n"
  },
  {
    "path": "node_modules/rxjs/internal/util/subscribeToResult.d.ts",
    "content": "import { Subscription } from '../Subscription';\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { Subscriber } from '../Subscriber';\nexport declare function subscribeToResult<T, R>(outerSubscriber: OuterSubscriber<T, R>, result: any, outerValue?: T, outerIndex?: number, destination?: Subscriber<any>): Subscription;\n"
  },
  {
    "path": "node_modules/rxjs/internal/util/TimeoutError.d.ts",
    "content": "export interface TimeoutError extends Error {\n}\nexport interface TimeoutErrorCtor {\n    new (): TimeoutError;\n}\n/**\n * An error thrown when duetime elapses.\n *\n * @see {@link timeout}\n *\n * @class TimeoutError\n */\nexport declare const TimeoutError: TimeoutErrorCtor;\n"
  },
  {
    "path": "node_modules/rxjs/internal/util/toSubscriber.d.ts",
    "content": "import { Subscriber } from '../Subscriber';\nimport { PartialObserver } from '../types';\nexport declare function toSubscriber<T>(nextOrObserver?: PartialObserver<T> | ((value: T) => void), error?: (error: any) => void, complete?: () => void): Subscriber<T>;\n"
  },
  {
    "path": "node_modules/rxjs/internal/util/tryCatch.d.ts",
    "content": "export declare function tryCatch<T extends Function>(fn: T): T;\n"
  },
  {
    "path": "node_modules/rxjs/internal/util/UnsubscriptionError.d.ts",
    "content": "export interface UnsubscriptionError extends Error {\n    readonly errors: any[];\n}\nexport interface UnsubscriptionErrorCtor {\n    new (errors: any[]): UnsubscriptionError;\n}\n/**\n * An error thrown when one or more errors have occurred during the\n * `unsubscribe` of a {@link Subscription}.\n */\nexport declare const UnsubscriptionError: UnsubscriptionErrorCtor;\n"
  },
  {
    "path": "node_modules/rxjs/node_modules/tslib/tslib.d.ts",
    "content": "/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\nexport declare function __extends(d: Function, b: Function): void;\r\nexport declare function __assign(t: any, ...sources: any[]): any;\r\nexport declare function __rest(t: any, propertyNames: (string | symbol)[]): any;\r\nexport declare function __decorate(decorators: Function[], target: any, key?: string | symbol, desc?: any): any;\r\nexport declare function __param(paramIndex: number, decorator: Function): Function;\r\nexport declare function __metadata(metadataKey: any, metadataValue: any): Function;\r\nexport declare function __awaiter(thisArg: any, _arguments: any, P: Function, generator: Function): any;\r\nexport declare function __generator(thisArg: any, body: Function): any;\r\nexport declare function __exportStar(m: any, exports: any): void;\r\nexport declare function __values(o: any): any;\r\nexport declare function __read(o: any, n?: number): any[];\r\nexport declare function __spread(...args: any[]): any[];\r\nexport declare function __await(v: any): any;\r\nexport declare function __asyncGenerator(thisArg: any, _arguments: any, generator: Function): any;\r\nexport declare function __asyncDelegator(o: any): any;\r\nexport declare function __asyncValues(o: any): any;\r\nexport declare function __makeTemplateObject(cooked: string[], raw: string[]): TemplateStringsArray;\r\nexport declare function __importStar<T>(mod: T): T;\r\nexport declare function __importDefault<T>(mod: T): T | { default: T };\r\n"
  },
  {
    "path": "node_modules/rxjs/Notification.d.ts",
    "content": "export * from 'rxjs-compat/Notification';\n"
  },
  {
    "path": "node_modules/rxjs/Observable.d.ts",
    "content": "export * from 'rxjs-compat/Observable';\n"
  },
  {
    "path": "node_modules/rxjs/observable/ArrayLikeObservable.d.ts",
    "content": "export * from 'rxjs-compat/observable/ArrayLikeObservable';\n"
  },
  {
    "path": "node_modules/rxjs/observable/ArrayObservable.d.ts",
    "content": "export * from 'rxjs-compat/observable/ArrayObservable';\n"
  },
  {
    "path": "node_modules/rxjs/observable/bindCallback.d.ts",
    "content": "export * from 'rxjs-compat/observable/bindCallback';\n"
  },
  {
    "path": "node_modules/rxjs/observable/bindNodeCallback.d.ts",
    "content": "export * from 'rxjs-compat/observable/bindNodeCallback';\n"
  },
  {
    "path": "node_modules/rxjs/observable/BoundCallbackObservable.d.ts",
    "content": "export * from 'rxjs-compat/observable/BoundCallbackObservable';\n"
  },
  {
    "path": "node_modules/rxjs/observable/BoundNodeCallbackObservable.d.ts",
    "content": "export * from 'rxjs-compat/observable/BoundNodeCallbackObservable';\n"
  },
  {
    "path": "node_modules/rxjs/observable/combineLatest.d.ts",
    "content": "export * from 'rxjs-compat/observable/combineLatest';\n"
  },
  {
    "path": "node_modules/rxjs/observable/concat.d.ts",
    "content": "export * from 'rxjs-compat/observable/concat';\n"
  },
  {
    "path": "node_modules/rxjs/observable/ConnectableObservable.d.ts",
    "content": "export * from 'rxjs-compat/observable/ConnectableObservable';\n"
  },
  {
    "path": "node_modules/rxjs/observable/defer.d.ts",
    "content": "export * from 'rxjs-compat/observable/defer';\n"
  },
  {
    "path": "node_modules/rxjs/observable/DeferObservable.d.ts",
    "content": "export * from 'rxjs-compat/observable/DeferObservable';\n"
  },
  {
    "path": "node_modules/rxjs/observable/dom/ajax.d.ts",
    "content": "export * from 'rxjs-compat/observable/dom/ajax';\n"
  },
  {
    "path": "node_modules/rxjs/observable/dom/AjaxObservable.d.ts",
    "content": "export * from 'rxjs-compat/observable/dom/AjaxObservable';\n"
  },
  {
    "path": "node_modules/rxjs/observable/dom/webSocket.d.ts",
    "content": "export * from 'rxjs-compat/observable/dom/webSocket';\n"
  },
  {
    "path": "node_modules/rxjs/observable/dom/WebSocketSubject.d.ts",
    "content": "export * from 'rxjs-compat/observable/dom/WebSocketSubject';\n"
  },
  {
    "path": "node_modules/rxjs/observable/empty.d.ts",
    "content": "export * from 'rxjs-compat/observable/empty';\n"
  },
  {
    "path": "node_modules/rxjs/observable/EmptyObservable.d.ts",
    "content": "export * from 'rxjs-compat/observable/EmptyObservable';\n"
  },
  {
    "path": "node_modules/rxjs/observable/ErrorObservable.d.ts",
    "content": "export * from 'rxjs-compat/observable/ErrorObservable';\n"
  },
  {
    "path": "node_modules/rxjs/observable/forkJoin.d.ts",
    "content": "export * from 'rxjs-compat/observable/forkJoin';\n"
  },
  {
    "path": "node_modules/rxjs/observable/ForkJoinObservable.d.ts",
    "content": "export * from 'rxjs-compat/observable/ForkJoinObservable';\n"
  },
  {
    "path": "node_modules/rxjs/observable/from.d.ts",
    "content": "export * from 'rxjs-compat/observable/from';\n"
  },
  {
    "path": "node_modules/rxjs/observable/fromArray.d.ts",
    "content": "export * from 'rxjs-compat/observable/fromArray';\n"
  },
  {
    "path": "node_modules/rxjs/observable/fromEvent.d.ts",
    "content": "export * from 'rxjs-compat/observable/fromEvent';\n"
  },
  {
    "path": "node_modules/rxjs/observable/FromEventObservable.d.ts",
    "content": "export * from 'rxjs-compat/observable/FromEventObservable';\n"
  },
  {
    "path": "node_modules/rxjs/observable/fromEventPattern.d.ts",
    "content": "export * from 'rxjs-compat/observable/fromEventPattern';\n"
  },
  {
    "path": "node_modules/rxjs/observable/FromEventPatternObservable.d.ts",
    "content": "export * from 'rxjs-compat/observable/FromEventPatternObservable';\n"
  },
  {
    "path": "node_modules/rxjs/observable/fromIterable.d.ts",
    "content": "export * from 'rxjs-compat/observable/fromIterable';\n"
  },
  {
    "path": "node_modules/rxjs/observable/FromObservable.d.ts",
    "content": "export * from 'rxjs-compat/observable/FromObservable';\n"
  },
  {
    "path": "node_modules/rxjs/observable/fromPromise.d.ts",
    "content": "export * from 'rxjs-compat/observable/fromPromise';\n"
  },
  {
    "path": "node_modules/rxjs/observable/generate.d.ts",
    "content": "export * from 'rxjs-compat/observable/generate';\n"
  },
  {
    "path": "node_modules/rxjs/observable/GenerateObservable.d.ts",
    "content": "export * from 'rxjs-compat/observable/GenerateObservable';\n"
  },
  {
    "path": "node_modules/rxjs/observable/if.d.ts",
    "content": "export * from 'rxjs-compat/observable/if';\n"
  },
  {
    "path": "node_modules/rxjs/observable/IfObservable.d.ts",
    "content": "export * from 'rxjs-compat/observable/IfObservable';\n"
  },
  {
    "path": "node_modules/rxjs/observable/interval.d.ts",
    "content": "export * from 'rxjs-compat/observable/interval';\n"
  },
  {
    "path": "node_modules/rxjs/observable/IntervalObservable.d.ts",
    "content": "export * from 'rxjs-compat/observable/IntervalObservable';\n"
  },
  {
    "path": "node_modules/rxjs/observable/IteratorObservable.d.ts",
    "content": "export * from 'rxjs-compat/observable/IteratorObservable';\n"
  },
  {
    "path": "node_modules/rxjs/observable/merge.d.ts",
    "content": "export * from 'rxjs-compat/observable/merge';\n"
  },
  {
    "path": "node_modules/rxjs/observable/never.d.ts",
    "content": "export * from 'rxjs-compat/observable/never';\n"
  },
  {
    "path": "node_modules/rxjs/observable/NeverObservable.d.ts",
    "content": "export * from 'rxjs-compat/observable/NeverObservable';\n"
  },
  {
    "path": "node_modules/rxjs/observable/of.d.ts",
    "content": "export * from 'rxjs-compat/observable/of';\n"
  },
  {
    "path": "node_modules/rxjs/observable/onErrorResumeNext.d.ts",
    "content": "export * from 'rxjs-compat/observable/onErrorResumeNext';\n"
  },
  {
    "path": "node_modules/rxjs/observable/pairs.d.ts",
    "content": "export * from 'rxjs-compat/observable/pairs';\n"
  },
  {
    "path": "node_modules/rxjs/observable/PairsObservable.d.ts",
    "content": "export * from 'rxjs-compat/observable/PairsObservable';\n"
  },
  {
    "path": "node_modules/rxjs/observable/PromiseObservable.d.ts",
    "content": "export * from 'rxjs-compat/observable/PromiseObservable';\n"
  },
  {
    "path": "node_modules/rxjs/observable/race.d.ts",
    "content": "export * from 'rxjs-compat/observable/race';\n"
  },
  {
    "path": "node_modules/rxjs/observable/range.d.ts",
    "content": "export * from 'rxjs-compat/observable/range';\n"
  },
  {
    "path": "node_modules/rxjs/observable/RangeObservable.d.ts",
    "content": "export * from 'rxjs-compat/observable/RangeObservable';\n"
  },
  {
    "path": "node_modules/rxjs/observable/ScalarObservable.d.ts",
    "content": "export * from 'rxjs-compat/observable/ScalarObservable';\n"
  },
  {
    "path": "node_modules/rxjs/observable/SubscribeOnObservable.d.ts",
    "content": "export * from 'rxjs-compat/observable/SubscribeOnObservable';\n"
  },
  {
    "path": "node_modules/rxjs/observable/throw.d.ts",
    "content": "export * from 'rxjs-compat/observable/throw';\n"
  },
  {
    "path": "node_modules/rxjs/observable/timer.d.ts",
    "content": "export * from 'rxjs-compat/observable/timer';\n"
  },
  {
    "path": "node_modules/rxjs/observable/TimerObservable.d.ts",
    "content": "export * from 'rxjs-compat/observable/TimerObservable';\n"
  },
  {
    "path": "node_modules/rxjs/observable/using.d.ts",
    "content": "export * from 'rxjs-compat/observable/using';\n"
  },
  {
    "path": "node_modules/rxjs/observable/UsingObservable.d.ts",
    "content": "export * from 'rxjs-compat/observable/UsingObservable';\n"
  },
  {
    "path": "node_modules/rxjs/observable/zip.d.ts",
    "content": "export * from 'rxjs-compat/observable/zip';\n"
  },
  {
    "path": "node_modules/rxjs/Observer.d.ts",
    "content": "export * from 'rxjs-compat/Observer';\n"
  },
  {
    "path": "node_modules/rxjs/Operator.d.ts",
    "content": "export * from 'rxjs-compat/Operator';\n"
  },
  {
    "path": "node_modules/rxjs/operator/audit.d.ts",
    "content": "export * from 'rxjs-compat/operator/audit';\n"
  },
  {
    "path": "node_modules/rxjs/operator/auditTime.d.ts",
    "content": "export * from 'rxjs-compat/operator/auditTime';\n"
  },
  {
    "path": "node_modules/rxjs/operator/buffer.d.ts",
    "content": "export * from 'rxjs-compat/operator/buffer';\n"
  },
  {
    "path": "node_modules/rxjs/operator/bufferCount.d.ts",
    "content": "export * from 'rxjs-compat/operator/bufferCount';\n"
  },
  {
    "path": "node_modules/rxjs/operator/bufferTime.d.ts",
    "content": "export * from 'rxjs-compat/operator/bufferTime';\n"
  },
  {
    "path": "node_modules/rxjs/operator/bufferToggle.d.ts",
    "content": "export * from 'rxjs-compat/operator/bufferToggle';\n"
  },
  {
    "path": "node_modules/rxjs/operator/bufferWhen.d.ts",
    "content": "export * from 'rxjs-compat/operator/bufferWhen';\n"
  },
  {
    "path": "node_modules/rxjs/operator/catch.d.ts",
    "content": "export * from 'rxjs-compat/operator/catch';\n"
  },
  {
    "path": "node_modules/rxjs/operator/combineAll.d.ts",
    "content": "export * from 'rxjs-compat/operator/combineAll';\n"
  },
  {
    "path": "node_modules/rxjs/operator/combineLatest.d.ts",
    "content": "export * from 'rxjs-compat/operator/combineLatest';\n"
  },
  {
    "path": "node_modules/rxjs/operator/concat.d.ts",
    "content": "export * from 'rxjs-compat/operator/concat';\n"
  },
  {
    "path": "node_modules/rxjs/operator/concatAll.d.ts",
    "content": "export * from 'rxjs-compat/operator/concatAll';\n"
  },
  {
    "path": "node_modules/rxjs/operator/concatMap.d.ts",
    "content": "export * from 'rxjs-compat/operator/concatMap';\n"
  },
  {
    "path": "node_modules/rxjs/operator/concatMapTo.d.ts",
    "content": "export * from 'rxjs-compat/operator/concatMapTo';\n"
  },
  {
    "path": "node_modules/rxjs/operator/count.d.ts",
    "content": "export * from 'rxjs-compat/operator/count';\n"
  },
  {
    "path": "node_modules/rxjs/operator/debounce.d.ts",
    "content": "export * from 'rxjs-compat/operator/debounce';\n"
  },
  {
    "path": "node_modules/rxjs/operator/debounceTime.d.ts",
    "content": "export * from 'rxjs-compat/operator/debounceTime';\n"
  },
  {
    "path": "node_modules/rxjs/operator/defaultIfEmpty.d.ts",
    "content": "export * from 'rxjs-compat/operator/defaultIfEmpty';\n"
  },
  {
    "path": "node_modules/rxjs/operator/delay.d.ts",
    "content": "export * from 'rxjs-compat/operator/delay';\n"
  },
  {
    "path": "node_modules/rxjs/operator/delayWhen.d.ts",
    "content": "export * from 'rxjs-compat/operator/delayWhen';\n"
  },
  {
    "path": "node_modules/rxjs/operator/dematerialize.d.ts",
    "content": "export * from 'rxjs-compat/operator/dematerialize';\n"
  },
  {
    "path": "node_modules/rxjs/operator/distinct.d.ts",
    "content": "export * from 'rxjs-compat/operator/distinct';\n"
  },
  {
    "path": "node_modules/rxjs/operator/distinctUntilChanged.d.ts",
    "content": "export * from 'rxjs-compat/operator/distinctUntilChanged';\n"
  },
  {
    "path": "node_modules/rxjs/operator/distinctUntilKeyChanged.d.ts",
    "content": "export * from 'rxjs-compat/operator/distinctUntilKeyChanged';\n"
  },
  {
    "path": "node_modules/rxjs/operator/do.d.ts",
    "content": "export * from 'rxjs-compat/operator/do';\n"
  },
  {
    "path": "node_modules/rxjs/operator/elementAt.d.ts",
    "content": "export * from 'rxjs-compat/operator/elementAt';\n"
  },
  {
    "path": "node_modules/rxjs/operator/every.d.ts",
    "content": "export * from 'rxjs-compat/operator/every';\n"
  },
  {
    "path": "node_modules/rxjs/operator/exhaust.d.ts",
    "content": "export * from 'rxjs-compat/operator/exhaust';\n"
  },
  {
    "path": "node_modules/rxjs/operator/exhaustMap.d.ts",
    "content": "export * from 'rxjs-compat/operator/exhaustMap';\n"
  },
  {
    "path": "node_modules/rxjs/operator/expand.d.ts",
    "content": "export * from 'rxjs-compat/operator/expand';\n"
  },
  {
    "path": "node_modules/rxjs/operator/filter.d.ts",
    "content": "export * from 'rxjs-compat/operator/filter';\n"
  },
  {
    "path": "node_modules/rxjs/operator/finally.d.ts",
    "content": "export * from 'rxjs-compat/operator/finally';\n"
  },
  {
    "path": "node_modules/rxjs/operator/find.d.ts",
    "content": "export * from 'rxjs-compat/operator/find';\n"
  },
  {
    "path": "node_modules/rxjs/operator/findIndex.d.ts",
    "content": "export * from 'rxjs-compat/operator/findIndex';\n"
  },
  {
    "path": "node_modules/rxjs/operator/first.d.ts",
    "content": "export * from 'rxjs-compat/operator/first';\n"
  },
  {
    "path": "node_modules/rxjs/operator/groupBy.d.ts",
    "content": "export * from 'rxjs-compat/operator/groupBy';\n"
  },
  {
    "path": "node_modules/rxjs/operator/ignoreElements.d.ts",
    "content": "export * from 'rxjs-compat/operator/ignoreElements';\n"
  },
  {
    "path": "node_modules/rxjs/operator/isEmpty.d.ts",
    "content": "export * from 'rxjs-compat/operator/isEmpty';\n"
  },
  {
    "path": "node_modules/rxjs/operator/last.d.ts",
    "content": "export * from 'rxjs-compat/operator/last';\n"
  },
  {
    "path": "node_modules/rxjs/operator/let.d.ts",
    "content": "export * from 'rxjs-compat/operator/let';\n"
  },
  {
    "path": "node_modules/rxjs/operator/map.d.ts",
    "content": "export * from 'rxjs-compat/operator/map';\n"
  },
  {
    "path": "node_modules/rxjs/operator/mapTo.d.ts",
    "content": "export * from 'rxjs-compat/operator/mapTo';\n"
  },
  {
    "path": "node_modules/rxjs/operator/materialize.d.ts",
    "content": "export * from 'rxjs-compat/operator/materialize';\n"
  },
  {
    "path": "node_modules/rxjs/operator/max.d.ts",
    "content": "export * from 'rxjs-compat/operator/max';\n"
  },
  {
    "path": "node_modules/rxjs/operator/merge.d.ts",
    "content": "export * from 'rxjs-compat/operator/merge';\n"
  },
  {
    "path": "node_modules/rxjs/operator/mergeAll.d.ts",
    "content": "export * from 'rxjs-compat/operator/mergeAll';\n"
  },
  {
    "path": "node_modules/rxjs/operator/mergeMap.d.ts",
    "content": "export * from 'rxjs-compat/operator/mergeMap';\n"
  },
  {
    "path": "node_modules/rxjs/operator/mergeMapTo.d.ts",
    "content": "export * from 'rxjs-compat/operator/mergeMapTo';\n"
  },
  {
    "path": "node_modules/rxjs/operator/mergeScan.d.ts",
    "content": "export * from 'rxjs-compat/operator/mergeScan';\n"
  },
  {
    "path": "node_modules/rxjs/operator/min.d.ts",
    "content": "export * from 'rxjs-compat/operator/min';\n"
  },
  {
    "path": "node_modules/rxjs/operator/multicast.d.ts",
    "content": "export * from 'rxjs-compat/operator/multicast';\n"
  },
  {
    "path": "node_modules/rxjs/operator/observeOn.d.ts",
    "content": "export * from 'rxjs-compat/operator/observeOn';\n"
  },
  {
    "path": "node_modules/rxjs/operator/onErrorResumeNext.d.ts",
    "content": "export * from 'rxjs-compat/operator/onErrorResumeNext';\n"
  },
  {
    "path": "node_modules/rxjs/operator/pairwise.d.ts",
    "content": "export * from 'rxjs-compat/operator/pairwise';\n"
  },
  {
    "path": "node_modules/rxjs/operator/partition.d.ts",
    "content": "export * from 'rxjs-compat/operator/partition';\n"
  },
  {
    "path": "node_modules/rxjs/operator/pluck.d.ts",
    "content": "export * from 'rxjs-compat/operator/pluck';\n"
  },
  {
    "path": "node_modules/rxjs/operator/publish.d.ts",
    "content": "export * from 'rxjs-compat/operator/publish';\n"
  },
  {
    "path": "node_modules/rxjs/operator/publishBehavior.d.ts",
    "content": "export * from 'rxjs-compat/operator/publishBehavior';\n"
  },
  {
    "path": "node_modules/rxjs/operator/publishLast.d.ts",
    "content": "export * from 'rxjs-compat/operator/publishLast';\n"
  },
  {
    "path": "node_modules/rxjs/operator/publishReplay.d.ts",
    "content": "export * from 'rxjs-compat/operator/publishReplay';\n"
  },
  {
    "path": "node_modules/rxjs/operator/race.d.ts",
    "content": "export * from 'rxjs-compat/operator/race';\n"
  },
  {
    "path": "node_modules/rxjs/operator/reduce.d.ts",
    "content": "export * from 'rxjs-compat/operator/reduce';\n"
  },
  {
    "path": "node_modules/rxjs/operator/repeat.d.ts",
    "content": "export * from 'rxjs-compat/operator/repeat';\n"
  },
  {
    "path": "node_modules/rxjs/operator/repeatWhen.d.ts",
    "content": "export * from 'rxjs-compat/operator/repeatWhen';\n"
  },
  {
    "path": "node_modules/rxjs/operator/retry.d.ts",
    "content": "export * from 'rxjs-compat/operator/retry';\n"
  },
  {
    "path": "node_modules/rxjs/operator/retryWhen.d.ts",
    "content": "export * from 'rxjs-compat/operator/retryWhen';\n"
  },
  {
    "path": "node_modules/rxjs/operator/sample.d.ts",
    "content": "export * from 'rxjs-compat/operator/sample';\n"
  },
  {
    "path": "node_modules/rxjs/operator/sampleTime.d.ts",
    "content": "export * from 'rxjs-compat/operator/sampleTime';\n"
  },
  {
    "path": "node_modules/rxjs/operator/scan.d.ts",
    "content": "export * from 'rxjs-compat/operator/scan';\n"
  },
  {
    "path": "node_modules/rxjs/operator/sequenceEqual.d.ts",
    "content": "export * from 'rxjs-compat/operator/sequenceEqual';\n"
  },
  {
    "path": "node_modules/rxjs/operator/share.d.ts",
    "content": "export * from 'rxjs-compat/operator/share';\n"
  },
  {
    "path": "node_modules/rxjs/operator/shareReplay.d.ts",
    "content": "export * from 'rxjs-compat/operator/shareReplay';\n"
  },
  {
    "path": "node_modules/rxjs/operator/single.d.ts",
    "content": "export * from 'rxjs-compat/operator/single';\n"
  },
  {
    "path": "node_modules/rxjs/operator/skip.d.ts",
    "content": "export * from 'rxjs-compat/operator/skip';\n"
  },
  {
    "path": "node_modules/rxjs/operator/skipLast.d.ts",
    "content": "export * from 'rxjs-compat/operator/skipLast';\n"
  },
  {
    "path": "node_modules/rxjs/operator/skipUntil.d.ts",
    "content": "export * from 'rxjs-compat/operator/skipUntil';\n"
  },
  {
    "path": "node_modules/rxjs/operator/skipWhile.d.ts",
    "content": "export * from 'rxjs-compat/operator/skipWhile';\n"
  },
  {
    "path": "node_modules/rxjs/operator/startWith.d.ts",
    "content": "export * from 'rxjs-compat/operator/startWith';\n"
  },
  {
    "path": "node_modules/rxjs/operator/subscribeOn.d.ts",
    "content": "export * from 'rxjs-compat/operator/subscribeOn';\n"
  },
  {
    "path": "node_modules/rxjs/operator/switch.d.ts",
    "content": "export * from 'rxjs-compat/operator/switch';\n"
  },
  {
    "path": "node_modules/rxjs/operator/switchMap.d.ts",
    "content": "export * from 'rxjs-compat/operator/switchMap';\n"
  },
  {
    "path": "node_modules/rxjs/operator/switchMapTo.d.ts",
    "content": "export * from 'rxjs-compat/operator/switchMapTo';\n"
  },
  {
    "path": "node_modules/rxjs/operator/take.d.ts",
    "content": "export * from 'rxjs-compat/operator/take';\n"
  },
  {
    "path": "node_modules/rxjs/operator/takeLast.d.ts",
    "content": "export * from 'rxjs-compat/operator/takeLast';\n"
  },
  {
    "path": "node_modules/rxjs/operator/takeUntil.d.ts",
    "content": "export * from 'rxjs-compat/operator/takeUntil';\n"
  },
  {
    "path": "node_modules/rxjs/operator/takeWhile.d.ts",
    "content": "export * from 'rxjs-compat/operator/takeWhile';\n"
  },
  {
    "path": "node_modules/rxjs/operator/throttle.d.ts",
    "content": "export * from 'rxjs-compat/operator/throttle';\n"
  },
  {
    "path": "node_modules/rxjs/operator/throttleTime.d.ts",
    "content": "export * from 'rxjs-compat/operator/throttleTime';\n"
  },
  {
    "path": "node_modules/rxjs/operator/timeInterval.d.ts",
    "content": "export * from 'rxjs-compat/operator/timeInterval';\n"
  },
  {
    "path": "node_modules/rxjs/operator/timeout.d.ts",
    "content": "export * from 'rxjs-compat/operator/timeout';\n"
  },
  {
    "path": "node_modules/rxjs/operator/timeoutWith.d.ts",
    "content": "export * from 'rxjs-compat/operator/timeoutWith';\n"
  },
  {
    "path": "node_modules/rxjs/operator/timestamp.d.ts",
    "content": "export * from 'rxjs-compat/operator/timestamp';\n"
  },
  {
    "path": "node_modules/rxjs/operator/toArray.d.ts",
    "content": "export * from 'rxjs-compat/operator/toArray';\n"
  },
  {
    "path": "node_modules/rxjs/operator/toPromise.d.ts",
    "content": "export * from 'rxjs-compat/operator/toPromise';\n"
  },
  {
    "path": "node_modules/rxjs/operator/window.d.ts",
    "content": "export * from 'rxjs-compat/operator/window';\n"
  },
  {
    "path": "node_modules/rxjs/operator/windowCount.d.ts",
    "content": "export * from 'rxjs-compat/operator/windowCount';\n"
  },
  {
    "path": "node_modules/rxjs/operator/windowTime.d.ts",
    "content": "export * from 'rxjs-compat/operator/windowTime';\n"
  },
  {
    "path": "node_modules/rxjs/operator/windowToggle.d.ts",
    "content": "export * from 'rxjs-compat/operator/windowToggle';\n"
  },
  {
    "path": "node_modules/rxjs/operator/windowWhen.d.ts",
    "content": "export * from 'rxjs-compat/operator/windowWhen';\n"
  },
  {
    "path": "node_modules/rxjs/operator/withLatestFrom.d.ts",
    "content": "export * from 'rxjs-compat/operator/withLatestFrom';\n"
  },
  {
    "path": "node_modules/rxjs/operator/zip.d.ts",
    "content": "export * from 'rxjs-compat/operator/zip';\n"
  },
  {
    "path": "node_modules/rxjs/operator/zipAll.d.ts",
    "content": "export * from 'rxjs-compat/operator/zipAll';\n"
  },
  {
    "path": "node_modules/rxjs/operators/audit.d.ts",
    "content": "export * from 'rxjs-compat/operators/audit';\n"
  },
  {
    "path": "node_modules/rxjs/operators/auditTime.d.ts",
    "content": "export * from 'rxjs-compat/operators/auditTime';\n"
  },
  {
    "path": "node_modules/rxjs/operators/buffer.d.ts",
    "content": "export * from 'rxjs-compat/operators/buffer';\n"
  },
  {
    "path": "node_modules/rxjs/operators/bufferCount.d.ts",
    "content": "export * from 'rxjs-compat/operators/bufferCount';\n"
  },
  {
    "path": "node_modules/rxjs/operators/bufferTime.d.ts",
    "content": "export * from 'rxjs-compat/operators/bufferTime';\n"
  },
  {
    "path": "node_modules/rxjs/operators/bufferToggle.d.ts",
    "content": "export * from 'rxjs-compat/operators/bufferToggle';\n"
  },
  {
    "path": "node_modules/rxjs/operators/bufferWhen.d.ts",
    "content": "export * from 'rxjs-compat/operators/bufferWhen';\n"
  },
  {
    "path": "node_modules/rxjs/operators/catchError.d.ts",
    "content": "export * from 'rxjs-compat/operators/catchError';\n"
  },
  {
    "path": "node_modules/rxjs/operators/combineAll.d.ts",
    "content": "export * from 'rxjs-compat/operators/combineAll';\n"
  },
  {
    "path": "node_modules/rxjs/operators/combineLatest.d.ts",
    "content": "export * from 'rxjs-compat/operators/combineLatest';\n"
  },
  {
    "path": "node_modules/rxjs/operators/concat.d.ts",
    "content": "export * from 'rxjs-compat/operators/concat';\n"
  },
  {
    "path": "node_modules/rxjs/operators/concatAll.d.ts",
    "content": "export * from 'rxjs-compat/operators/concatAll';\n"
  },
  {
    "path": "node_modules/rxjs/operators/concatMap.d.ts",
    "content": "export * from 'rxjs-compat/operators/concatMap';\n"
  },
  {
    "path": "node_modules/rxjs/operators/concatMapTo.d.ts",
    "content": "export * from 'rxjs-compat/operators/concatMapTo';\n"
  },
  {
    "path": "node_modules/rxjs/operators/count.d.ts",
    "content": "export * from 'rxjs-compat/operators/count';\n"
  },
  {
    "path": "node_modules/rxjs/operators/debounce.d.ts",
    "content": "export * from 'rxjs-compat/operators/debounce';\n"
  },
  {
    "path": "node_modules/rxjs/operators/debounceTime.d.ts",
    "content": "export * from 'rxjs-compat/operators/debounceTime';\n"
  },
  {
    "path": "node_modules/rxjs/operators/defaultIfEmpty.d.ts",
    "content": "export * from 'rxjs-compat/operators/defaultIfEmpty';\n"
  },
  {
    "path": "node_modules/rxjs/operators/delay.d.ts",
    "content": "export * from 'rxjs-compat/operators/delay';\n"
  },
  {
    "path": "node_modules/rxjs/operators/delayWhen.d.ts",
    "content": "export * from 'rxjs-compat/operators/delayWhen';\n"
  },
  {
    "path": "node_modules/rxjs/operators/dematerialize.d.ts",
    "content": "export * from 'rxjs-compat/operators/dematerialize';\n"
  },
  {
    "path": "node_modules/rxjs/operators/distinct.d.ts",
    "content": "export * from 'rxjs-compat/operators/distinct';\n"
  },
  {
    "path": "node_modules/rxjs/operators/distinctUntilChanged.d.ts",
    "content": "export * from 'rxjs-compat/operators/distinctUntilChanged';\n"
  },
  {
    "path": "node_modules/rxjs/operators/distinctUntilKeyChanged.d.ts",
    "content": "export * from 'rxjs-compat/operators/distinctUntilKeyChanged';\n"
  },
  {
    "path": "node_modules/rxjs/operators/elementAt.d.ts",
    "content": "export * from 'rxjs-compat/operators/elementAt';\n"
  },
  {
    "path": "node_modules/rxjs/operators/every.d.ts",
    "content": "export * from 'rxjs-compat/operators/every';\n"
  },
  {
    "path": "node_modules/rxjs/operators/exhaust.d.ts",
    "content": "export * from 'rxjs-compat/operators/exhaust';\n"
  },
  {
    "path": "node_modules/rxjs/operators/exhaustMap.d.ts",
    "content": "export * from 'rxjs-compat/operators/exhaustMap';\n"
  },
  {
    "path": "node_modules/rxjs/operators/expand.d.ts",
    "content": "export * from 'rxjs-compat/operators/expand';\n"
  },
  {
    "path": "node_modules/rxjs/operators/filter.d.ts",
    "content": "export * from 'rxjs-compat/operators/filter';\n"
  },
  {
    "path": "node_modules/rxjs/operators/finalize.d.ts",
    "content": "export * from 'rxjs-compat/operators/finalize';\n"
  },
  {
    "path": "node_modules/rxjs/operators/find.d.ts",
    "content": "export * from 'rxjs-compat/operators/find';\n"
  },
  {
    "path": "node_modules/rxjs/operators/findIndex.d.ts",
    "content": "export * from 'rxjs-compat/operators/findIndex';\n"
  },
  {
    "path": "node_modules/rxjs/operators/first.d.ts",
    "content": "export * from 'rxjs-compat/operators/first';\n"
  },
  {
    "path": "node_modules/rxjs/operators/groupBy.d.ts",
    "content": "export * from 'rxjs-compat/operators/groupBy';\n"
  },
  {
    "path": "node_modules/rxjs/operators/ignoreElements.d.ts",
    "content": "export * from 'rxjs-compat/operators/ignoreElements';\n"
  },
  {
    "path": "node_modules/rxjs/operators/index.d.ts",
    "content": "export { audit } from '../internal/operators/audit';\nexport { auditTime } from '../internal/operators/auditTime';\nexport { buffer } from '../internal/operators/buffer';\nexport { bufferCount } from '../internal/operators/bufferCount';\nexport { bufferTime } from '../internal/operators/bufferTime';\nexport { bufferToggle } from '../internal/operators/bufferToggle';\nexport { bufferWhen } from '../internal/operators/bufferWhen';\nexport { catchError } from '../internal/operators/catchError';\nexport { combineAll } from '../internal/operators/combineAll';\nexport { combineLatest } from '../internal/operators/combineLatest';\nexport { concat } from '../internal/operators/concat';\nexport { concatAll } from '../internal/operators/concatAll';\nexport { concatMap } from '../internal/operators/concatMap';\nexport { concatMapTo } from '../internal/operators/concatMapTo';\nexport { count } from '../internal/operators/count';\nexport { debounce } from '../internal/operators/debounce';\nexport { debounceTime } from '../internal/operators/debounceTime';\nexport { defaultIfEmpty } from '../internal/operators/defaultIfEmpty';\nexport { delay } from '../internal/operators/delay';\nexport { delayWhen } from '../internal/operators/delayWhen';\nexport { dematerialize } from '../internal/operators/dematerialize';\nexport { distinct } from '../internal/operators/distinct';\nexport { distinctUntilChanged } from '../internal/operators/distinctUntilChanged';\nexport { distinctUntilKeyChanged } from '../internal/operators/distinctUntilKeyChanged';\nexport { elementAt } from '../internal/operators/elementAt';\nexport { endWith } from '../internal/operators/endWith';\nexport { every } from '../internal/operators/every';\nexport { exhaust } from '../internal/operators/exhaust';\nexport { exhaustMap } from '../internal/operators/exhaustMap';\nexport { expand } from '../internal/operators/expand';\nexport { filter } from '../internal/operators/filter';\nexport { finalize } from '../internal/operators/finalize';\nexport { find } from '../internal/operators/find';\nexport { findIndex } from '../internal/operators/findIndex';\nexport { first } from '../internal/operators/first';\nexport { groupBy } from '../internal/operators/groupBy';\nexport { ignoreElements } from '../internal/operators/ignoreElements';\nexport { isEmpty } from '../internal/operators/isEmpty';\nexport { last } from '../internal/operators/last';\nexport { map } from '../internal/operators/map';\nexport { mapTo } from '../internal/operators/mapTo';\nexport { materialize } from '../internal/operators/materialize';\nexport { max } from '../internal/operators/max';\nexport { merge } from '../internal/operators/merge';\nexport { mergeAll } from '../internal/operators/mergeAll';\nexport { mergeMap } from '../internal/operators/mergeMap';\nexport { mergeMap as flatMap } from '../internal/operators/mergeMap';\nexport { mergeMapTo } from '../internal/operators/mergeMapTo';\nexport { mergeScan } from '../internal/operators/mergeScan';\nexport { min } from '../internal/operators/min';\nexport { multicast } from '../internal/operators/multicast';\nexport { observeOn } from '../internal/operators/observeOn';\nexport { onErrorResumeNext } from '../internal/operators/onErrorResumeNext';\nexport { pairwise } from '../internal/operators/pairwise';\nexport { partition } from '../internal/operators/partition';\nexport { pluck } from '../internal/operators/pluck';\nexport { publish } from '../internal/operators/publish';\nexport { publishBehavior } from '../internal/operators/publishBehavior';\nexport { publishLast } from '../internal/operators/publishLast';\nexport { publishReplay } from '../internal/operators/publishReplay';\nexport { race } from '../internal/operators/race';\nexport { reduce } from '../internal/operators/reduce';\nexport { repeat } from '../internal/operators/repeat';\nexport { repeatWhen } from '../internal/operators/repeatWhen';\nexport { retry } from '../internal/operators/retry';\nexport { retryWhen } from '../internal/operators/retryWhen';\nexport { refCount } from '../internal/operators/refCount';\nexport { sample } from '../internal/operators/sample';\nexport { sampleTime } from '../internal/operators/sampleTime';\nexport { scan } from '../internal/operators/scan';\nexport { sequenceEqual } from '../internal/operators/sequenceEqual';\nexport { share } from '../internal/operators/share';\nexport { shareReplay } from '../internal/operators/shareReplay';\nexport { single } from '../internal/operators/single';\nexport { skip } from '../internal/operators/skip';\nexport { skipLast } from '../internal/operators/skipLast';\nexport { skipUntil } from '../internal/operators/skipUntil';\nexport { skipWhile } from '../internal/operators/skipWhile';\nexport { startWith } from '../internal/operators/startWith';\nexport { subscribeOn } from '../internal/operators/subscribeOn';\nexport { switchAll } from '../internal/operators/switchAll';\nexport { switchMap } from '../internal/operators/switchMap';\nexport { switchMapTo } from '../internal/operators/switchMapTo';\nexport { take } from '../internal/operators/take';\nexport { takeLast } from '../internal/operators/takeLast';\nexport { takeUntil } from '../internal/operators/takeUntil';\nexport { takeWhile } from '../internal/operators/takeWhile';\nexport { tap } from '../internal/operators/tap';\nexport { throttle } from '../internal/operators/throttle';\nexport { throttleTime } from '../internal/operators/throttleTime';\nexport { throwIfEmpty } from '../internal/operators/throwIfEmpty';\nexport { timeInterval } from '../internal/operators/timeInterval';\nexport { timeout } from '../internal/operators/timeout';\nexport { timeoutWith } from '../internal/operators/timeoutWith';\nexport { timestamp } from '../internal/operators/timestamp';\nexport { toArray } from '../internal/operators/toArray';\nexport { window } from '../internal/operators/window';\nexport { windowCount } from '../internal/operators/windowCount';\nexport { windowTime } from '../internal/operators/windowTime';\nexport { windowToggle } from '../internal/operators/windowToggle';\nexport { windowWhen } from '../internal/operators/windowWhen';\nexport { withLatestFrom } from '../internal/operators/withLatestFrom';\nexport { zip } from '../internal/operators/zip';\nexport { zipAll } from '../internal/operators/zipAll';\n"
  },
  {
    "path": "node_modules/rxjs/operators/isEmpty.d.ts",
    "content": "export * from 'rxjs-compat/operators/isEmpty';\n"
  },
  {
    "path": "node_modules/rxjs/operators/last.d.ts",
    "content": "export * from 'rxjs-compat/operators/last';\n"
  },
  {
    "path": "node_modules/rxjs/operators/map.d.ts",
    "content": "export * from 'rxjs-compat/operators/map';\n"
  },
  {
    "path": "node_modules/rxjs/operators/mapTo.d.ts",
    "content": "export * from 'rxjs-compat/operators/mapTo';\n"
  },
  {
    "path": "node_modules/rxjs/operators/materialize.d.ts",
    "content": "export * from 'rxjs-compat/operators/materialize';\n"
  },
  {
    "path": "node_modules/rxjs/operators/max.d.ts",
    "content": "export * from 'rxjs-compat/operators/max';\n"
  },
  {
    "path": "node_modules/rxjs/operators/merge.d.ts",
    "content": "export * from 'rxjs-compat/operators/merge';\n"
  },
  {
    "path": "node_modules/rxjs/operators/mergeAll.d.ts",
    "content": "export * from 'rxjs-compat/operators/mergeAll';\n"
  },
  {
    "path": "node_modules/rxjs/operators/mergeMap.d.ts",
    "content": "export * from 'rxjs-compat/operators/mergeMap';\n"
  },
  {
    "path": "node_modules/rxjs/operators/mergeMapTo.d.ts",
    "content": "export * from 'rxjs-compat/operators/mergeMapTo';\n"
  },
  {
    "path": "node_modules/rxjs/operators/mergeScan.d.ts",
    "content": "export * from 'rxjs-compat/operators/mergeScan';\n"
  },
  {
    "path": "node_modules/rxjs/operators/min.d.ts",
    "content": "export * from 'rxjs-compat/operators/min';\n"
  },
  {
    "path": "node_modules/rxjs/operators/multicast.d.ts",
    "content": "export * from 'rxjs-compat/operators/multicast';\n"
  },
  {
    "path": "node_modules/rxjs/operators/observeOn.d.ts",
    "content": "export * from 'rxjs-compat/operators/observeOn';\n"
  },
  {
    "path": "node_modules/rxjs/operators/onErrorResumeNext.d.ts",
    "content": "export * from 'rxjs-compat/operators/onErrorResumeNext';\n"
  },
  {
    "path": "node_modules/rxjs/operators/pairwise.d.ts",
    "content": "export * from 'rxjs-compat/operators/pairwise';\n"
  },
  {
    "path": "node_modules/rxjs/operators/partition.d.ts",
    "content": "export * from 'rxjs-compat/operators/partition';\n"
  },
  {
    "path": "node_modules/rxjs/operators/pluck.d.ts",
    "content": "export * from 'rxjs-compat/operators/pluck';\n"
  },
  {
    "path": "node_modules/rxjs/operators/publish.d.ts",
    "content": "export * from 'rxjs-compat/operators/publish';\n"
  },
  {
    "path": "node_modules/rxjs/operators/publishBehavior.d.ts",
    "content": "export * from 'rxjs-compat/operators/publishBehavior';\n"
  },
  {
    "path": "node_modules/rxjs/operators/publishLast.d.ts",
    "content": "export * from 'rxjs-compat/operators/publishLast';\n"
  },
  {
    "path": "node_modules/rxjs/operators/publishReplay.d.ts",
    "content": "export * from 'rxjs-compat/operators/publishReplay';\n"
  },
  {
    "path": "node_modules/rxjs/operators/race.d.ts",
    "content": "export * from 'rxjs-compat/operators/race';\n"
  },
  {
    "path": "node_modules/rxjs/operators/reduce.d.ts",
    "content": "export * from 'rxjs-compat/operators/reduce';\n"
  },
  {
    "path": "node_modules/rxjs/operators/refCount.d.ts",
    "content": "export * from 'rxjs-compat/operators/refCount';\n"
  },
  {
    "path": "node_modules/rxjs/operators/repeat.d.ts",
    "content": "export * from 'rxjs-compat/operators/repeat';\n"
  },
  {
    "path": "node_modules/rxjs/operators/repeatWhen.d.ts",
    "content": "export * from 'rxjs-compat/operators/repeatWhen';\n"
  },
  {
    "path": "node_modules/rxjs/operators/retry.d.ts",
    "content": "export * from 'rxjs-compat/operators/retry';\n"
  },
  {
    "path": "node_modules/rxjs/operators/retryWhen.d.ts",
    "content": "export * from 'rxjs-compat/operators/retryWhen';\n"
  },
  {
    "path": "node_modules/rxjs/operators/sample.d.ts",
    "content": "export * from 'rxjs-compat/operators/sample';\n"
  },
  {
    "path": "node_modules/rxjs/operators/sampleTime.d.ts",
    "content": "export * from 'rxjs-compat/operators/sampleTime';\n"
  },
  {
    "path": "node_modules/rxjs/operators/scan.d.ts",
    "content": "export * from 'rxjs-compat/operators/scan';\n"
  },
  {
    "path": "node_modules/rxjs/operators/sequenceEqual.d.ts",
    "content": "export * from 'rxjs-compat/operators/sequenceEqual';\n"
  },
  {
    "path": "node_modules/rxjs/operators/share.d.ts",
    "content": "export * from 'rxjs-compat/operators/share';\n"
  },
  {
    "path": "node_modules/rxjs/operators/shareReplay.d.ts",
    "content": "export * from 'rxjs-compat/operators/shareReplay';\n"
  },
  {
    "path": "node_modules/rxjs/operators/single.d.ts",
    "content": "export * from 'rxjs-compat/operators/single';\n"
  },
  {
    "path": "node_modules/rxjs/operators/skip.d.ts",
    "content": "export * from 'rxjs-compat/operators/skip';\n"
  },
  {
    "path": "node_modules/rxjs/operators/skipLast.d.ts",
    "content": "export * from 'rxjs-compat/operators/skipLast';\n"
  },
  {
    "path": "node_modules/rxjs/operators/skipUntil.d.ts",
    "content": "export * from 'rxjs-compat/operators/skipUntil';\n"
  },
  {
    "path": "node_modules/rxjs/operators/skipWhile.d.ts",
    "content": "export * from 'rxjs-compat/operators/skipWhile';\n"
  },
  {
    "path": "node_modules/rxjs/operators/startWith.d.ts",
    "content": "export * from 'rxjs-compat/operators/startWith';\n"
  },
  {
    "path": "node_modules/rxjs/operators/subscribeOn.d.ts",
    "content": "export * from 'rxjs-compat/operators/subscribeOn';\n"
  },
  {
    "path": "node_modules/rxjs/operators/switchAll.d.ts",
    "content": "export * from 'rxjs-compat/operators/switchAll';\n"
  },
  {
    "path": "node_modules/rxjs/operators/switchMap.d.ts",
    "content": "export * from 'rxjs-compat/operators/switchMap';\n"
  },
  {
    "path": "node_modules/rxjs/operators/switchMapTo.d.ts",
    "content": "export * from 'rxjs-compat/operators/switchMapTo';\n"
  },
  {
    "path": "node_modules/rxjs/operators/take.d.ts",
    "content": "export * from 'rxjs-compat/operators/take';\n"
  },
  {
    "path": "node_modules/rxjs/operators/takeLast.d.ts",
    "content": "export * from 'rxjs-compat/operators/takeLast';\n"
  },
  {
    "path": "node_modules/rxjs/operators/takeUntil.d.ts",
    "content": "export * from 'rxjs-compat/operators/takeUntil';\n"
  },
  {
    "path": "node_modules/rxjs/operators/takeWhile.d.ts",
    "content": "export * from 'rxjs-compat/operators/takeWhile';\n"
  },
  {
    "path": "node_modules/rxjs/operators/tap.d.ts",
    "content": "export * from 'rxjs-compat/operators/tap';\n"
  },
  {
    "path": "node_modules/rxjs/operators/throttle.d.ts",
    "content": "export * from 'rxjs-compat/operators/throttle';\n"
  },
  {
    "path": "node_modules/rxjs/operators/throttleTime.d.ts",
    "content": "export * from 'rxjs-compat/operators/throttleTime';\n"
  },
  {
    "path": "node_modules/rxjs/operators/throwIfEmpty.d.ts",
    "content": "export * from 'rxjs-compat/operators/throwIfEmpty';\n"
  },
  {
    "path": "node_modules/rxjs/operators/timeInterval.d.ts",
    "content": "export * from 'rxjs-compat/operators/timeInterval';\n"
  },
  {
    "path": "node_modules/rxjs/operators/timeout.d.ts",
    "content": "export * from 'rxjs-compat/operators/timeout';\n"
  },
  {
    "path": "node_modules/rxjs/operators/timeoutWith.d.ts",
    "content": "export * from 'rxjs-compat/operators/timeoutWith';\n"
  },
  {
    "path": "node_modules/rxjs/operators/timestamp.d.ts",
    "content": "export * from 'rxjs-compat/operators/timestamp';\n"
  },
  {
    "path": "node_modules/rxjs/operators/toArray.d.ts",
    "content": "export * from 'rxjs-compat/operators/toArray';\n"
  },
  {
    "path": "node_modules/rxjs/operators/window.d.ts",
    "content": "export * from 'rxjs-compat/operators/window';\n"
  },
  {
    "path": "node_modules/rxjs/operators/windowCount.d.ts",
    "content": "export * from 'rxjs-compat/operators/windowCount';\n"
  },
  {
    "path": "node_modules/rxjs/operators/windowTime.d.ts",
    "content": "export * from 'rxjs-compat/operators/windowTime';\n"
  },
  {
    "path": "node_modules/rxjs/operators/windowToggle.d.ts",
    "content": "export * from 'rxjs-compat/operators/windowToggle';\n"
  },
  {
    "path": "node_modules/rxjs/operators/windowWhen.d.ts",
    "content": "export * from 'rxjs-compat/operators/windowWhen';\n"
  },
  {
    "path": "node_modules/rxjs/operators/withLatestFrom.d.ts",
    "content": "export * from 'rxjs-compat/operators/withLatestFrom';\n"
  },
  {
    "path": "node_modules/rxjs/operators/zip.d.ts",
    "content": "export * from 'rxjs-compat/operators/zip';\n"
  },
  {
    "path": "node_modules/rxjs/operators/zipAll.d.ts",
    "content": "export * from 'rxjs-compat/operators/zipAll';\n"
  },
  {
    "path": "node_modules/rxjs/OuterSubscriber.d.ts",
    "content": "export * from 'rxjs-compat/OuterSubscriber';\n"
  },
  {
    "path": "node_modules/rxjs/ReplaySubject.d.ts",
    "content": "export * from 'rxjs-compat/ReplaySubject';\n"
  },
  {
    "path": "node_modules/rxjs/Rx.d.ts",
    "content": "export * from 'rxjs-compat';\n"
  },
  {
    "path": "node_modules/rxjs/Scheduler.d.ts",
    "content": "export * from 'rxjs-compat/Scheduler';\n"
  },
  {
    "path": "node_modules/rxjs/scheduler/animationFrame.d.ts",
    "content": "export * from 'rxjs-compat/scheduler/animationFrame';\n"
  },
  {
    "path": "node_modules/rxjs/scheduler/asap.d.ts",
    "content": "export * from 'rxjs-compat/scheduler/asap';\n"
  },
  {
    "path": "node_modules/rxjs/scheduler/async.d.ts",
    "content": "export * from 'rxjs-compat/scheduler/async';\n"
  },
  {
    "path": "node_modules/rxjs/scheduler/queue.d.ts",
    "content": "export * from 'rxjs-compat/scheduler/queue';\n"
  },
  {
    "path": "node_modules/rxjs/Subject.d.ts",
    "content": "export * from 'rxjs-compat/Subject';\n"
  },
  {
    "path": "node_modules/rxjs/SubjectSubscription.d.ts",
    "content": "export * from 'rxjs-compat/SubjectSubscription';\n"
  },
  {
    "path": "node_modules/rxjs/Subscriber.d.ts",
    "content": "export * from 'rxjs-compat/Subscriber';\n"
  },
  {
    "path": "node_modules/rxjs/Subscription.d.ts",
    "content": "export * from 'rxjs-compat/Subscription';\n"
  },
  {
    "path": "node_modules/rxjs/symbol/iterator.d.ts",
    "content": "export * from 'rxjs-compat/symbol/iterator';\n"
  },
  {
    "path": "node_modules/rxjs/symbol/observable.d.ts",
    "content": "export * from 'rxjs-compat/symbol/observable';\n"
  },
  {
    "path": "node_modules/rxjs/symbol/rxSubscriber.d.ts",
    "content": "export * from 'rxjs-compat/symbol/rxSubscriber';\n"
  },
  {
    "path": "node_modules/rxjs/testing/index.d.ts",
    "content": "export { TestScheduler } from '../internal/testing/TestScheduler';\n"
  },
  {
    "path": "node_modules/rxjs/util/applyMixins.d.ts",
    "content": "export * from 'rxjs-compat/util/applyMixins';\n"
  },
  {
    "path": "node_modules/rxjs/util/ArgumentOutOfRangeError.d.ts",
    "content": "export * from 'rxjs-compat/util/ArgumentOutOfRangeError';\n"
  },
  {
    "path": "node_modules/rxjs/util/EmptyError.d.ts",
    "content": "export * from 'rxjs-compat/util/EmptyError';\n"
  },
  {
    "path": "node_modules/rxjs/util/errorObject.d.ts",
    "content": "export * from 'rxjs-compat/util/errorObject';\n"
  },
  {
    "path": "node_modules/rxjs/util/hostReportError.d.ts",
    "content": "export * from 'rxjs-compat/util/hostReportError';\n"
  },
  {
    "path": "node_modules/rxjs/util/identity.d.ts",
    "content": "export * from 'rxjs-compat/util/identity';\n"
  },
  {
    "path": "node_modules/rxjs/util/Immediate.d.ts",
    "content": "export * from 'rxjs-compat/util/Immediate';\n"
  },
  {
    "path": "node_modules/rxjs/util/isArray.d.ts",
    "content": "export * from 'rxjs-compat/util/isArray';\n"
  },
  {
    "path": "node_modules/rxjs/util/isArrayLike.d.ts",
    "content": "export * from 'rxjs-compat/util/isArrayLike';\n"
  },
  {
    "path": "node_modules/rxjs/util/isDate.d.ts",
    "content": "export * from 'rxjs-compat/util/isDate';\n"
  },
  {
    "path": "node_modules/rxjs/util/isFunction.d.ts",
    "content": "export * from 'rxjs-compat/util/isFunction';\n"
  },
  {
    "path": "node_modules/rxjs/util/isIterable.d.ts",
    "content": "export * from 'rxjs-compat/util/isIterable';\n"
  },
  {
    "path": "node_modules/rxjs/util/isNumeric.d.ts",
    "content": "export * from 'rxjs-compat/util/isNumeric';\n"
  },
  {
    "path": "node_modules/rxjs/util/isObject.d.ts",
    "content": "export * from 'rxjs-compat/util/isObject';\n"
  },
  {
    "path": "node_modules/rxjs/util/isObservable.d.ts",
    "content": "export * from 'rxjs-compat/util/isObservable';\n"
  },
  {
    "path": "node_modules/rxjs/util/isPromise.d.ts",
    "content": "export * from 'rxjs-compat/util/isPromise';\n"
  },
  {
    "path": "node_modules/rxjs/util/isScheduler.d.ts",
    "content": "export * from 'rxjs-compat/util/isScheduler';\n"
  },
  {
    "path": "node_modules/rxjs/util/noop.d.ts",
    "content": "export * from 'rxjs-compat/util/noop';\n"
  },
  {
    "path": "node_modules/rxjs/util/not.d.ts",
    "content": "export * from 'rxjs-compat/util/not';\n"
  },
  {
    "path": "node_modules/rxjs/util/ObjectUnsubscribedError.d.ts",
    "content": "export * from 'rxjs-compat/util/ObjectUnsubscribedError';\n"
  },
  {
    "path": "node_modules/rxjs/util/pipe.d.ts",
    "content": "export * from 'rxjs-compat/util/pipe';\n"
  },
  {
    "path": "node_modules/rxjs/util/root.d.ts",
    "content": "export * from 'rxjs-compat/util/root';\n"
  },
  {
    "path": "node_modules/rxjs/util/subscribeTo.d.ts",
    "content": "export * from 'rxjs-compat/util/subscribeTo';\n"
  },
  {
    "path": "node_modules/rxjs/util/subscribeToArray.d.ts",
    "content": "export * from 'rxjs-compat/util/subscribeToArray';\n"
  },
  {
    "path": "node_modules/rxjs/util/subscribeToIterable.d.ts",
    "content": "export * from 'rxjs-compat/util/subscribeToIterable';\n"
  },
  {
    "path": "node_modules/rxjs/util/subscribeToObservable.d.ts",
    "content": "export * from 'rxjs-compat/util/subscribeToObservable';\n"
  },
  {
    "path": "node_modules/rxjs/util/subscribeToPromise.d.ts",
    "content": "export * from 'rxjs-compat/util/subscribeToPromise';\n"
  },
  {
    "path": "node_modules/rxjs/util/subscribeToResult.d.ts",
    "content": "export * from 'rxjs-compat/util/subscribeToResult';\n"
  },
  {
    "path": "node_modules/rxjs/util/TimeoutError.d.ts",
    "content": "export * from 'rxjs-compat/util/TimeoutError';\n"
  },
  {
    "path": "node_modules/rxjs/util/toSubscriber.d.ts",
    "content": "export * from 'rxjs-compat/util/toSubscriber';\n"
  },
  {
    "path": "node_modules/rxjs/util/tryCatch.d.ts",
    "content": "export * from 'rxjs-compat/util/tryCatch';\n"
  },
  {
    "path": "node_modules/rxjs/util/UnsubscriptionError.d.ts",
    "content": "export * from 'rxjs-compat/util/UnsubscriptionError';\n"
  },
  {
    "path": "node_modules/rxjs/webSocket/index.d.ts",
    "content": "export { webSocket as webSocket } from '../internal/observable/dom/webSocket';\nexport { WebSocketSubject, WebSocketSubjectConfig } from '../internal/observable/dom/WebSocketSubject';\n"
  }
]